[
  {
    "Id": 1,
    "Date": "2015-10-27T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=PXl1We3Yr0I",
      "Id": "PXl1We3Yr0I",
      "StartDateTime": "2015-10-27T10:06:12.97-07:00",
      "EndDateTime": "2015-10-27T11:38:44-07:00",
      "Duration": 55510300000,
      "Title": ".NET Core Design Reviews: C# Interactive APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PXl1We3Yr0I/mqdefault.jpg"
    },
    "Title": "System.Net",
    "Items": [
      {
        "Id": 1,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 3895,
          "Title": "Revising System.Net.Sockets contract v4.1",
          "Author": "SidharthNabar",
          "CreatedAt": "2015-10-15T23:23:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15466",
          "Milestone": "1.0.0-rc1",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2015-10-27T00:00:00-07:00",
        "FeedbackId": "151577559",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/3895#issuecomment-151577559",
        "FeedbackMarkdown": "The PR for this issue is merged and the API review is completed. Hence closing this issue.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 2,
    "Date": "2015-12-04T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=nG-Af_TgYbI",
      "Id": "nG-Af_TgYbI",
      "StartDateTime": "2015-12-04T10:04:55.599-08:00",
      "EndDateTime": "2015-12-04T10:47:26-08:00",
      "Duration": 25504010000,
      "Title": ".NET Core Design Reviews: Backlog review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nG-Af_TgYbI/mqdefault.jpg"
    },
    "Title": "System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4636,
          "Title": "Missing several valuable members of System.Console in contract",
          "Author": "stephentoub",
          "CreatedAt": "2015-11-23T12:45:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15765",
          "Milestone": "1.0.0-rtm",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2015-12-04T00:00:00-08:00",
        "FeedbackId": "162039060",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4636#issuecomment-162039060",
        "FeedbackMarkdown": "Looks good, except for \u0060BufferWidth\u0060 and \u0060BufferHeight\u0060 because they are not meaningful on Linux; they basically have to return \u0060WindowWidth\u0060 and \u0060WindowHeight\u0060.\r\n\r\n@stephentoub, can you create a list of all the missing APIs in \u0060Console\u0060? We should probably add all except for the ones we don\u0027t want/can\u0027t support.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4708,
          "Title": "Add ValueTask to corefx",
          "Author": "benaadams",
          "CreatedAt": "2015-11-28T21:13:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15809",
          "Milestone": "1.0.0-rc2",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2015-12-04T00:00:00-08:00",
        "FeedbackId": "162042013",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4708#issuecomment-162042013",
        "FeedbackMarkdown": "No major concerns. We should agree, though, how we name types that provide a struct-based alternative to a class. Should this be a prefix or a suffix?\r\n- **Prefix**. Matches how must people read C# code, i.e. \u0060struct Foo\u0060, \u0060ValueFoo\u0060.\r\n- **Suffix**. Sorts better in IntelliSense, documentation, or any other case where APIs are sorted.\r\n\r\nThe best location seems to be \u0060System.Threading.Tasks\u0060. We need to check whether we can make this a partial fa\u00E7ade for .NET Framework.",
        "TimeCode": 6270000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 3,
    "Date": "2017-08-29T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=VppFZYG-9cA",
      "Id": "VppFZYG-9cA",
      "StartDateTime": "2017-08-29T10:09:41.581-07:00",
      "EndDateTime": "2017-08-29T12:03:24-07:00",
      "Duration": 68224190000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VppFZYG-9cA/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Process, System.Reflection, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14903,
          "Title": "Allow fire and forget CancellationTokenRegisteration.Dispose",
          "Author": "davidfowl",
          "CreatedAt": "2017-01-05T19:04:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19827",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14903#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16567,
          "Title": "Proposal: Update Type.GetMethod() overloads to simplify finding generic methods via reflection",
          "Author": "HaloFour",
          "CreatedAt": "2017-03-01T18:04:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20377",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325756004",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16567#issuecomment-325756004",
        "FeedbackMarkdown": "This\r\n\r\n\u0060\u0060\u0060C#\r\npublic static Type MakeGenericMethodParameterSignatureType(int position);\r\n\u0060\u0060\u0060\r\n\r\nshould be \r\n\r\n\u0060\u0060\u0060C#\r\npublic static Type MakeGenericMethodParameter(int position);\r\n\u0060\u0060\u0060\r\n\r\nWe should also rename \u0060genericArity\u0060 to \u0060genericParameterCount\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, Type[] types)\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers)\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);\r\nprotected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers) =\u003E throw new NotSupported;\r\n\u0060\u0060\u0060\r\n\r\nWe should also expose a query API that identifies the new positional generic method parameters. We propose to go with some more foundational concept that could equally apply to references to generic type parameters. In the spec above @AtsushiKan used the term signature type. So we settled on:\r\n\r\n\u0060\u0060\u0060C#\r\npublic virtual bool IsSignatureType =\u003E false;\r\n\u0060\u0060\u0060",
        "TimeCode": 7980000000,
        "Apis": [
          "M:.GetMethodImpl(string,int,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])",
          "P:.IsSignatureType"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17232,
          "Title": "Need api to determine if a type is \u0022byref-like.\u0022",
          "Author": "ghost",
          "CreatedAt": "2017-03-17T15:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20673",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325756873",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17232#issuecomment-325756873",
        "FeedbackMarkdown": "We should align this with the attribute we approved earlier, which is named \u0060IsByRefLikeAttribute\u0060. Since the proposal matches that, it\u0027s approved as proposed.",
        "TimeCode": 53140000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 22866,
          "Title": "Add a way to opt out of TargetInvocationException wrapping on late-bound invokes.",
          "Author": "kingces95",
          "CreatedAt": "2017-08-02T15:36:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23023",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325761139",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/22866#issuecomment-325761139",
        "FeedbackMarkdown": "Looks good, the only suggestion is to rename \u0060PassExceptions\u0060 to \u0060DoNotWrapExceptions\u0060. The rationale being that specifying \u0060~PassExceptions\u0060 could be read as catch-all.\r\n\r\n\u0060\u0060\u0060C#\r\nvar bf = BindingFlags.Public | BindingFlags.DoNotWrapExceptions;\r\n\u0060\u0060\u0060",
        "TimeCode": 55060000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 20497,
          "Title": "Add ProcessStartInfo.StandardInputEncoding property",
          "Author": "madelson",
          "CreatedAt": "2017-05-31T11:01:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22051",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325762992",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/20497#issuecomment-325762992",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 63550000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 4,
    "Date": "2017-10-03T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=m4BUM3nJZRw",
      "Id": "m4BUM3nJZRw",
      "StartDateTime": "2017-10-03T10:00:56.39-07:00",
      "EndDateTime": "2017-10-03T12:07:35-07:00",
      "Duration": 75986100000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/m4BUM3nJZRw/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Reflection, System.Runtime.CompilerServices, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12442,
          "Title": "Add QueueUserWorkItem for local threadpool queues",
          "Author": "benaadams",
          "CreatedAt": "2016-10-07T08:21:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18881",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12442#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23828,
          "Title": "Add CancellationTokenRegistration.Token property",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-06T17:18:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23461",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333935487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23828#issuecomment-333935487",
        "FeedbackMarkdown": "Approved as proposed.",
        "TimeCode": 21760000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23879,
          "Title": "Support casting ReadOnlyMemory\u003CT\u003E to Memory\u003CT\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-08T12:51:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23491",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333939600",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23879#issuecomment-333939600",
        "FeedbackMarkdown": "OK, it seems we should separate the discussion on the pinnable references. But the readonly casting looks reasonable. We should, however, choose a generic type name so that we can add the pinnable stuff later on. \u0060Buffers\u0060 seems like a good candidate:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class BuffersMarshal\r\n    {\r\n        public static bool TryGetArray\u003CT\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out ArraySegment\u003CT\u003E arraySegment);\r\n        public static Memory\u003CT\u003E AsMemory\u003CT\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51990000000,
        "Apis": [
          "M:BuffersMarshal.AsMemory\u003CT\u003E(ReadOnlyMemory\u003CT\u003E)",
          "M:BuffersMarshal.TryGetArray\u003CT\u003E(ReadOnlyMemory\u003CT\u003E,out ArraySegment\u003CT\u003E)",
          "T:BuffersMarshal"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23883,
          "Title": "Add IsGenericTypeParameter and IsGenericMethodParameter to System.Type",
          "Author": "ghost",
          "CreatedAt": "2017-09-08T14:38:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23493",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333940885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23883#issuecomment-333940885",
        "FeedbackMarkdown": "Looks good, but we don\u0027t understand why the properties have to be virtual. It seems they are in nature static. At the end you explain that but how would we eliminate the virtual method call?",
        "TimeCode": 60560000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23916,
          "Title": "S.R.CS.Unsafe and read-only references",
          "Author": "ektrah",
          "CreatedAt": "2017-09-09T14:31:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23504",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333942166",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23916#issuecomment-333942166",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 63260000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23974,
          "Title": "Add MemoryHandle.HasPointer",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-09-12T15:11:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23526",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333943725",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23974#issuecomment-333943725",
        "FeedbackMarkdown": "The member on \u0060MemoryHandle\u0060 is called \u0060PinnedPointer\u0060. We should align the name here, so \u0060HasPinnedPointer\u0060. It seems @KrzysztofCwalina is unsure whether the existing property is named correctly. He\u0027ll chase this up offline.",
        "TimeCode": 65860000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 5,
    "Date": "2017-10-10T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=b96co3sNzNI",
      "Id": "b96co3sNzNI",
      "StartDateTime": "2017-10-10T10:07:40.535-07:00",
      "EndDateTime": "2017-10-10T11:43:07-07:00",
      "Duration": 57264650000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b96co3sNzNI/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Process, System.IO, System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23862,
          "Title": "Productizing APIs for {ReadOnly}Memory\u003CT\u003E and friends",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-09-07T20:14:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335543258",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23862#issuecomment-335543258",
        "FeedbackMarkdown": "@ahsonkhan mentioned he\u0027s not ready for a review yet.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24039,
          "Title": "Proposal: Add protected {Unmanaged}MemoryStream.Read/WriteSpan method",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-14T16:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23553",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335544053",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24039#issuecomment-335544053",
        "FeedbackMarkdown": "@KrzysztofCwalina suggested to generalize this beyond these two types; @stephentoub said he has to think about to do this and whether it\u0027s even possible.",
        "TimeCode": 1450000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23592,
          "Title": "Add ProcessStartInfo.ArgumentList",
          "Author": "mklement0",
          "CreatedAt": "2017-08-27T20:08:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23347",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335552652",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23592#issuecomment-335552652",
        "FeedbackMarkdown": "The API looks good, and it\u0027s a good problem to solve. However, we don\u0027t like the idea that we have to roundtrip data between the two different representations because it means we have to both, parse and combine per operating system and get the semantics right. Instead, we\u0027d prefer a model like this:\r\n\r\n\u0060\u0060\u0060C#\r\npartial class ProcessStartInfo\r\n{\r\n    // Exists\r\n    string Arguments { get; set; }   \r\n\r\n    // new\r\n    IReadOnlyCollection\u003Cstring\u003E ArgumentList { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060Start\u0060 would verify that not both \u0060!string.IsNullOrEmpty(Arguments)\u0060 and \u0060ArgumentList.Count \u003E 1\u0060 are true, i.e. the caller may either use \u0060Arguments\u0060 or \u0060ArgumentList\u0060, but not both.\r\n\r\n[edit @danmosemsft changed Collection typo to IREadOnlyCollection]",
        "TimeCode": 2930000000,
        "Apis": [
          "P:ProcessStartInfo.ArgumentList",
          "P:ProcessStartInfo.Arguments",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Id": 4,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24115,
          "Title": "Proposal: Add Array.Sort\u003CT\u003E(T[], int, int, Comparison\u003CT\u003E) overload",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-18T14:27:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23587",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335553699",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24115#issuecomment-335553699",
        "FeedbackMarkdown": "Looks good to us, but we should probably add the same API to \u0060List\u003CT\u003E\u0060",
        "TimeCode": 21920000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24105,
          "Title": "Change ReadOnlySpan indexer to return ref readonly",
          "Author": "ektrah",
          "CreatedAt": "2017-09-17T17:33:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23582",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24105#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24210000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23874,
          "Title": "StreamWriter .ctor pooling overloads",
          "Author": "benaadams",
          "CreatedAt": "2017-09-08T03:51:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23486",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335568547",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23874#issuecomment-335568547",
        "FeedbackMarkdown": "Couple of thoughts:\r\n\r\n* It seems opting in wouldn\u0027t get huge wins for existing code because everyone has to change their code. At the same time, making it opt-out might be too breaking. The question is whether we can find a way to get 90% of the wins without requiring calling a new API while making it 90% safe (of course, on .NET Framework pooling would be quirked so that apps only get it when retargeting against the latest version).\r\n* We generally have to think about more aggressive buffer pooling\r\n* We\u0027d prefer the bool over the \u0060pool\u0060 because it allows us to change the implementation",
        "TimeCode": 24600000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 6,
    "Date": "2017-10-17T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=BEBq3__WfDc",
      "Id": "BEBq3__WfDc",
      "StartDateTime": "2017-10-17T10:07:23.564-07:00",
      "EndDateTime": "2017-10-17T12:03:46-07:00",
      "Duration": 69824360000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BEBq3__WfDc/mqdefault.jpg"
    },
    "Title": "Meta, System.Diagnostics, System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24426,
          "Title": "Rename MemoryHandle.PinnedPointer to Pointer",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-10-04T16:17:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23734",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337305000",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24426#issuecomment-337305000",
        "FeedbackMarkdown": "Looks good as proposed. Also, rename the constructor.\r\n\r\nAND NEXT TIME INCLUDE THE API REF.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14891,
          "Title": "SerialDisposable, CompositeDisposable, etc",
          "Author": "clairernovotny",
          "CreatedAt": "2017-01-05T15:34:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19822",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14891#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 10880000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24449,
          "Title": "Add DateTime.UnixEpoch and DateTimeOffset.UnixEpoch fields",
          "Author": "TylerBrinkley",
          "CreatedAt": "2017-10-05T16:46:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23747",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337315763",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24449#issuecomment-337315763",
        "FeedbackMarkdown": "Looks good as proposed. We may want to add the \u0060ToUnixXxx\u0060 and \u0060FromUnixXxx\u0060 to \u0060DateTime\u0060 as well though.",
        "TimeCode": 24230000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24694,
          "Title": "[ExcludeFromCodeCoverageAttribute] should be applicable to assemblies",
          "Author": "abatishchev",
          "CreatedAt": "2017-10-17T17:57:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23874",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24694#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 31070000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24568,
          "Title": "Add Base64 conversion APIs that support UTF-8 for Span\u003CT\u003E ",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-10-11T03:33:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23808",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337334707",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24568#issuecomment-337334707",
        "FeedbackMarkdown": "This needs more work. Raw notes:\r\n\r\n### Rough shape of API\r\n\r\n\u0060\u0060\u0060C#\r\n// System.Memory.dll\r\nnamespace System.Buffers.Text {\r\n    public static class Base64 {\r\n        public static OperationStatus EncodeToUtf8(ReadOnlySpan\u003Cbyte\u003E bytes, Span\u003Cbyte\u003E utf8, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static OperationStatus EncodeToUtf8InPlace(Span\u003Cbyte\u003E buffer, int bytesLength, out int written, bool isFinalBlock = true);\r\n        public static int GetMaxEncodedUtf8Length(int length);\r\n        public static OperationStatus DecodeFromUtf8(ReadOnlySpan\u003Cbyte\u003E utf8, Span\u003Cbyte\u003E bytes, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static OperationStatus DecodeFromUtf8InPlace(Span\u003Cbyte\u003E buffer, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static int GetMaxDecodedBytesLength(int length);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### isFinalBlock\r\n\r\nWe need it, using a more general term (as opposed to \u0060usePadding\u0060) avoids the caller having to understand the format/specification.\r\n\r\n### OperationStatus/TransformationStatus\r\n\r\nIt was brought up that we may not need the enum at all.\r\n\r\n@ahsonkhan /Levi: Look at the general pattern and decide whether the API is needed. In the past we concluded that the code becomes too convoluted and the conditions are easy to get wrong.\r\n\r\n### Length\r\n\r\nWe should not take the input, only the size. We should also not take the \u0060isFinalBlock\u0060. Basically, the contract is \u0022give an upper bound\u0022.",
        "TimeCode": 65460000000,
        "Apis": [
          "M:Base64.DecodeFromUtf8(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.DecodeFromUtf8InPlace(Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.EncodeToUtf8(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.EncodeToUtf8InPlace(Span\u003Cbyte\u003E,int,out int,bool)",
          "M:Base64.GetMaxDecodedBytesLength(int)",
          "M:Base64.GetMaxEncodedUtf8Length(int)",
          "T:Base64"
        ]
      }
    ]
  },
  {
    "Id": 7,
    "Date": "2017-10-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=OZnaGV2omvI",
      "Id": "OZnaGV2omvI",
      "StartDateTime": "2017-10-24T10:06:29.118-07:00",
      "EndDateTime": "2017-10-24T12:02:36-07:00",
      "Duration": 69668820000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/OZnaGV2omvI/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Memory, System.Net.Sockets, System.Numerics, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24555,
          "Title": "Add Microseconds and Nanoseconds to TimeStamp, DateTime, and DateTimeOffset",
          "Author": "ChristopherHaws",
          "CreatedAt": "2017-10-10T22:37:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23799",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339062792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24555#issuecomment-339062792",
        "FeedbackMarkdown": "Given the above concerns about overflow and precision, let\u0027s discuss a bit more on what would the right return type should be.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24442,
          "Title": "SocketTaskExtensions as instance methods",
          "Author": "stephentoub",
          "CreatedAt": "2017-10-05T02:58:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23741",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339063781",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24442#issuecomment-339063781",
        "FeedbackMarkdown": "Given that the methods are already instance methods on the implementation, it implementation wise there is no benefit of doing the move. The driving factor here would be if we wanted to expose for customers as instance methods, so, for example, they can derive from \u0060Socket\u0060 and override them. So we\u0027d go with Option 1.",
        "TimeCode": 660000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24115,
          "Title": "Proposal: Add Array.Sort\u003CT\u003E(T[], int, int, Comparison\u003CT\u003E) overload",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-18T14:27:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23587",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339064985",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24115#issuecomment-339064985",
        "FeedbackMarkdown": "Seems like it \uD83D\uDE22",
        "TimeCode": 3250000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24575,
          "Title": "Make BigInteger BigEndian-friendly",
          "Author": "bartonjs",
          "CreatedAt": "2017-10-11T15:31:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23812",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339072735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24575#issuecomment-339072735",
        "FeedbackMarkdown": "Looks good, minor comments:\r\n\r\n* We may want to swap the \u0060isBigEndian\u0060 and \u0060isUnsigned\u0060\r\n* It\u0027s a bit odd to have one type for signed and unsigned, but adding \u0060UBigInteger\u0060 seems like overkill",
        "TimeCode": 5710000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24840,
          "Title": "Add SpanExtensions.EndsWith",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-10-24T16:38:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23942",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339074798",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24840#issuecomment-339074798",
        "FeedbackMarkdown": "Seems reasonable. We should consider removing the \u0060Span\u003Cbyte\u003E\u0060 as we believe we can specialize the implementation without performance loss.",
        "TimeCode": 21280000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24839,
          "Title": "Add SpanExtensions.LastIndexOf",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-10-24T16:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23941",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339076860",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24839#issuecomment-339076860",
        "FeedbackMarkdown": "Looks good:\r\n\r\n* Why do we need the \u0060struct\u0060 constraint?\r\n* Can we just collapse the \u0060T\u0060 version and the \u0060byte\u0060 versions?\r\n* Why is there no \u0060LastIndexOfAny\u0060 version?",
        "TimeCode": 25530000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24607,
          "Title": "UTF8 Parsing and Formatting",
          "Author": "ghost",
          "CreatedAt": "2017-10-12T16:05:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23831",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339086989",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24607#issuecomment-339086989",
        "FeedbackMarkdown": "* \u0060ParsedFormat\u0060  -\u003E \u0060StandardFormat\u0060\r\n* \u0060ParsedFormat\u0060 should implement \u0060IEquatable\u003CParsedFormat\u003E\u0060\r\n* Follow @benaadams\u0027s proposal and drop the type names from methods on \u0060Utf8Parser\u0060\r\n* Rename the \u0060format\u0060 parameter on \u0060Utf8Parser\u0060 to \u0060standardFormat\u0060",
        "TimeCode": 29510000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24568,
          "Title": "Add Base64 conversion APIs that support UTF-8 for Span\u003CT\u003E ",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-10-11T03:33:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23808",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339096554",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24568#issuecomment-339096554",
        "FeedbackMarkdown": "Looks good as proposed. It seems @GrabYourPitchforks conceded that the enum is useful. We should, however, remove the \u0060dataLength\u0060 parameter from \u0060DecodeFromUtf8InPlace\u0060 -- it\u0027s not needed.",
        "TimeCode": 52010000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 8,
    "Date": "2017-10-31T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=bHwCPVNQLwo",
      "Id": "bHwCPVNQLwo",
      "StartDateTime": "2017-10-31T10:05:29.096-07:00",
      "EndDateTime": "2017-10-31T11:54:01-07:00",
      "Duration": 65119040000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bHwCPVNQLwo/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 22412,
          "Title": "Add TransformationStatus enum from corefxlab",
          "Author": "stephentoub",
          "CreatedAt": "2017-07-18T21:29:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22845",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocked",
              "BackgroundColor": "b60205",
              "Description": "Issue/PR is blocked on something - see comments",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340833769",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/22412#issuecomment-340833769",
        "FeedbackMarkdown": "This is now tracked as part of other work item.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23862,
          "Title": "Productizing APIs for {ReadOnly}Memory\u003CT\u003E and friends",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-09-07T20:14:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340845398",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23862#issuecomment-340845398",
        "FeedbackMarkdown": "We don\u0027t want to add the bulk methods. We believe it could become a performance trap and it invites having to keep \u0060Span\u003CT\u003E\u0060 and \u0060Memory\u003CT\u003E\u0060 in sync.\r\n\r\n\u0060\u0060\u0060C#\r\n// instance methods\r\npublic struct Memory\u003CT\u003E {\r\n  public void CopyTo(Memory\u003CT\u003E destination);\r\n  public bool TryCopyTo(Memory\u003CT\u003E destination);\r\n}\r\npublic struct ReadOnlyMemory\u003CT\u003E {\r\n  public void CopyTo(Memory\u003CT\u003E destination);\r\n  public bool TryCopyTo(Memory\u003CT\u003E destination);\r\n}\r\n// extension methods\r\n// Merge with SpanExtensions\r\npublic static class MemoryExtensions {\r\n  public static void CopyTo\u003CT\u003E(this T[] array, Memory\u003CT\u003E destination);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe should probably rename \u0060SpanExtensions\u0060 to \u0060MemoryExtensions\u0060.",
        "TimeCode": 3110000000,
        "Apis": [
          "M:Memory\u003CT\u003E.CopyTo(Memory\u003CT\u003E)",
          "M:Memory\u003CT\u003E.TryCopyTo(Memory\u003CT\u003E)",
          "M:MemoryExtensions.CopyTo\u003CT\u003E(this T[],Memory\u003CT\u003E)",
          "M:ReadOnlyMemory\u003CT\u003E.CopyTo(Memory\u003CT\u003E)",
          "M:ReadOnlyMemory\u003CT\u003E.TryCopyTo(Memory\u003CT\u003E)",
          "T:Memory\u003CT\u003E",
          "T:MemoryExtensions",
          "T:ReadOnlyMemory\u003CT\u003E"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24103,
          "Title": "Add Overlaps/Within extension methods for ReadOnlySpan\u003CT\u003E",
          "Author": "nietras",
          "CreatedAt": "2017-09-17T10:07:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23580",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340856211",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24103#issuecomment-340856211",
        "FeedbackMarkdown": "We seem to believe \u0060Overlaps\u0060 seems like a good addition (having both overloads), but it looks like \u0060Within\u0060 is redundant/not any faster. \r\n\r\n\u0060\u0060\u0060C#\r\npublic static class SpanExtensions\r\n{\r\n    public static bool Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E first, ReadOnlySpan\u003CT\u003E second);\r\n    public static bool Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E first, ReadOnlySpan\u003CT\u003E second,  out int elementOffset);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24700000000,
        "Apis": [
          "M:SpanExtensions.Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,out int)",
          "M:SpanExtensions.Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "T:SpanExtensions"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24296,
          "Title": "Memory and ReadOnlyMemory validation errors not matching",
          "Author": "Drawaes",
          "CreatedAt": "2017-09-28T03:41:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23670",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340868030",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24296#issuecomment-340868030",
        "FeedbackMarkdown": "We went back and forth, but it seems we\u0027re in agreement that these can be useful. We shouldn\u0027t expose static types \u0060Span\u0060 and \u0060Memory\u0060 in \u0060InteropServices\u0060. Instead, we should add them to the new [\u0060MemoryMarshal\u0060 type](https://github.com/dotnet/corefx/issues/23879#issuecomment-340861229).",
        "TimeCode": 45510000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 9,
    "Date": "2017-11-07T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=HnKmLJcEM74",
      "Id": "HnKmLJcEM74",
      "StartDateTime": "2017-11-07T10:11:30.709-08:00",
      "EndDateTime": "2017-11-07T12:06:50-08:00",
      "Duration": 69192910000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/HnKmLJcEM74/mqdefault.jpg"
    },
    "Title": "System.Data.SqlClient, System.Memory, System.Runtime.CompilerServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24946,
          "Title": "Expose RuntimeWrappedException constructor",
          "Author": "jkotas",
          "CreatedAt": "2017-10-30T02:10:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23991",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342573013",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24946#issuecomment-342573013",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24854,
          "Title": "Provide IEnumerable\u003CT\u003E support for Memory\u003CT\u003E",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-10-25T00:59:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23950",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342577441",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24854#issuecomment-342577441",
        "FeedbackMarkdown": "Looks good as proposed. \u0060MemoryExtensions\u0060 doesn\u0027t exist yet but \u0060SpanExtensions\u0060 will be renamed to it.",
        "TimeCode": 2520000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25085,
          "Title": "Add String support to ReadOnlyMemory\u003Cchar\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-11-06T19:26:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24064",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342585466",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25085#issuecomment-342585466",
        "FeedbackMarkdown": "Based on the discussion with @stephentoub we concluded that we should merge the two types:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class MemoryExtensions\r\n    {\r\n        // Existing class containing AsReadOnlySpan(this string)\r\n        public static ReadOnlyMemory\u003Cchar\u003E AsReadOnlyMemory(this string text);\r\n\r\n        // We already have ReadOnlyMemory\u003CT\u003E.TryGetArray(out ArraySegment\u003CT\u003E segment)\r\n        public static bool TryGetString(this ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string value, out int offset, out int count);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 11270000000,
        "Apis": [
          "M:MemoryExtensions.AsReadOnlyMemory(this string)",
          "M:MemoryExtensions.TryGetString(this ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "T:MemoryExtensions"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24839,
          "Title": "Add SpanExtensions.LastIndexOf",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-10-24T16:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23941",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342587703",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24839#issuecomment-342587703",
        "FeedbackMarkdown": "Looks good as proposed",
        "TimeCode": 28440000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 20903,
          "Title": "Additional API for DbProviderFactories in .NET Core",
          "Author": "divega",
          "CreatedAt": "2017-06-10T20:34:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22229",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data.SqlClient",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342605350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/20903#issuecomment-342605350",
        "FeedbackMarkdown": "Looks good with some minor tweaks:\r\n\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class DbProviderFactories\r\n{\r\n    // exiting members\r\n    \r\n    public static DbProviderFactory GetFactory(string providerInvariantName); \r\n    public static DbProviderFactory GetFactory(DataRow providerRow); \r\n    public static DbProviderFactory GetFactory(DbConnection connection); \r\n    public static DataTable GetFactoryClasses(); \r\n\r\n    // new members\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Registers a provider factory using the assembly qualified name of the factory and an \r\n    /// invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, string factoryTypeAssemblyQualifiedName);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Registers a provider factory using the provider factory type and an invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, Type factoryType);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Register a provider factory using the provider factory instance and \r\n    /// an invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, DbProviderFactory factory);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Returns the provider factory instance if one is registered for the given invariant name\r\n    /// \u003C/summary\u003E\r\n    public static bool TryGetFactory(string providerInvariantName, out DbProviderFactory factory);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Removes the provider factory registration for the given invariant name  \r\n    /// \u003C/summary\u003E\r\n    public static bool UnregisterFactory(string providerInvariantName);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Returns the invariant names for all the factories registered\r\n    /// \u003C/summary\u003E\r\n    public static IEnumerable\u003Cstring\u003E GetProviderInvariantNames();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32150000000,
        "Apis": [
          "M:DbProviderFactories.GetFactory(DataRow)",
          "M:DbProviderFactories.GetFactory(DbConnection)",
          "M:DbProviderFactories.GetFactory(string)",
          "M:DbProviderFactories.GetFactoryClasses()",
          "M:DbProviderFactories.GetProviderInvariantNames()",
          "M:DbProviderFactories.RegisterFactory(string,DbProviderFactory)",
          "M:DbProviderFactories.RegisterFactory(string,string)",
          "M:DbProviderFactories.RegisterFactory(string,Type)",
          "M:DbProviderFactories.TryGetFactory(string,out DbProviderFactory)",
          "M:DbProviderFactories.UnregisterFactory(string)",
          "T:DbProviderFactories"
        ]
      }
    ]
  },
  {
    "Id": 10,
    "Date": "2017-11-21T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=o5JFZtgaJLs",
      "Id": "o5JFZtgaJLs",
      "StartDateTime": "2017-11-21T10:16:08.038-08:00",
      "EndDateTime": "2017-11-21T11:47:37-08:00",
      "Duration": 54889620000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/o5JFZtgaJLs/mqdefault.jpg"
    },
    "Title": "Meta, System.Diagnostics, System.Memory, System.Net.Sockets, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23879,
          "Title": "Support casting ReadOnlyMemory\u003CT\u003E to Memory\u003CT\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-09-08T12:51:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23491",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346117097",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23879#issuecomment-346117097",
        "FeedbackMarkdown": "API review: Let\u0027s separate @jkotas\u0027s rename change into separate issue -- #25412.\r\nMarking as api-approved again.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25412,
          "Title": "Move (ReadOnly)Span.DangerousGetPinnableReference to MemoryMarshal",
          "Author": "karelz",
          "CreatedAt": "2017-11-21T18:30:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24207",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346119552",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25412#issuecomment-346119552",
        "FeedbackMarkdown": "Looks good as proposed. We should also remove the corresponding GetDangerousXxxx() instance methods.\r\n\r\n@jkotas why are they marked as in? Does it make a difference?",
        "TimeCode": 4980000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24694,
          "Title": "[ExcludeFromCodeCoverageAttribute] should be applicable to assemblies",
          "Author": "abatishchev",
          "CreatedAt": "2017-10-17T17:57:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23874",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346119984",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24694#issuecomment-346119984",
        "FeedbackMarkdown": "As long as we\u0027re working with the code coverage tool providers to make it\u0027s honored, I sounds good (and it seems we are).",
        "TimeCode": 10060000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25094,
          "Title": "Proposal: String.Contains(char)",
          "Author": "danmosemsft",
          "CreatedAt": "2017-11-07T05:29:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24068",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25094#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 11650000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 10981,
          "Title": "Expose UnixDomainSocket",
          "Author": "swernli",
          "CreatedAt": "2016-08-19T01:06:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18227",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-linux",
              "BackgroundColor": "fef2c0",
              "Description": "Linux OS (any supported distro)",
              "ForegroundColor": "black"
            },
            {
              "Name": "os-mac-os-x",
              "BackgroundColor": "fef2c0",
              "Description": "macOS aka OSX",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/10981#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 12490000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25337,
          "Title": "TryFormat with format strings as ReadOnlySpan\u003Cchar\u003E or string",
          "Author": "stephentoub",
          "CreatedAt": "2017-11-18T19:38:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24171",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346126703",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25337#issuecomment-346126703",
        "FeedbackMarkdown": "We seem to gravitate to (2) because it doesn\u0027t require an implicit conversion, but also doesn\u0027t prevent us from adding it in the future.\r\n\r\n@stephentoub has filed a separate issue to discuss (3) #25413.",
        "TimeCode": 15430000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25189,
          "Title": "\u0022ItemRef\u0022 - Ref element accessor for types that already have an indexer.",
          "Author": "VSadov",
          "CreatedAt": "2017-11-11T01:10:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24110",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346139011",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25189#issuecomment-346139011",
        "FeedbackMarkdown": "For data types like \u0060Stack\u003CT\u003E\u0060 and \u0060Queue\u003CT\u003E\u0060 the proposed name \u0060ItemRef\u0060 wouldn\u0027t work. Thus, this would be more like a pattern where the name depends on the concept you add a \u0060ref\u0060-returning method for:\r\n\r\n* Indexers -\u003E \u0060ItemRef()\u0060\r\n* \u0060Peek()\u0060 -\u003E \u0060PeekRef()\u0060",
        "TimeCode": 26170000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 11,
    "Date": "2017-11-28T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=9F_NsviGT0Y",
      "Id": "9F_NsviGT0Y",
      "StartDateTime": "2017-11-28T10:04:25.337-08:00",
      "EndDateTime": "2017-11-28T11:00:56-08:00",
      "Duration": 33906630000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9F_NsviGT0Y/mqdefault.jpg"
    },
    "Title": "System.IO, System.Runtime.Intrinsics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25535,
          "Title": "Add overload to Path.GetFullPath() to specify base path",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-11-28T02:05:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24262",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25535#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25539,
          "Title": "Need Span overloads for Path APIs",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-11-28T04:36:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24264",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25539#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 5580000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25536,
          "Title": "Need Span based path join API",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-11-28T02:17:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24263",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "347624492",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25536#issuecomment-347624492",
        "FeedbackMarkdown": "It seems weird to me to introduce a new API without deprecating the old API. However, deprecating the old API would be fairly invasive (high usage).\r\n\r\n1. Could we fix the behavior of \u0060Combine\u0060? We could quirk the behavior. @JeremyKuhne will take a look.\r\n2. It seems less ideal but more acceptable to me to introduce an overload of \u0060Combine\u0060 that takes \u0060Span\u0060 with the new behavior. People would opt-into the new behavior by converting to \u0060Span\u0060. Reason being we have a unified set of verbs.",
        "TimeCode": 7920000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25427,
          "Title": "Add PipeOptions.CurrentUserOnly option",
          "Author": "stephentoub",
          "CreatedAt": "2017-11-22T03:22:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24212",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25427#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 26420000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23519,
          "Title": "Add Scalar Intel hardware intrinsic functions",
          "Author": "tannergooding",
          "CreatedAt": "2017-08-24T15:55:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23315",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23519#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29560000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 12,
    "Date": "2017-12-05T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=BI3iXFT8H7E",
      "Id": "BI3iXFT8H7E",
      "StartDateTime": "2017-12-05T10:06:23.791-08:00",
      "EndDateTime": "2017-12-05T11:57:04-08:00",
      "Duration": 66402090000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BI3iXFT8H7E/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Collections, System.Memory, System.Runtime, System.Runtime.CompilerServices, System.Text.RegularExpressions",
    "Items": [
      {
        "Id": 1,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25303,
          "Title": "Regex should have a static TryParse() method",
          "Author": "udlose",
          "CreatedAt": "2017-11-16T23:58:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24159",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Text.RegularExpressions",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349394486",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25303#issuecomment-349394486",
        "FeedbackMarkdown": "We don\u0027t believe this API is very useful, because\r\n\r\n1. \u0060TryParse\u0060 is really about parsing user input in tight loops, which regex shouldn\u0027t be.\r\n2. Returning a \u0060bool\u0060 isn\u0027t very informative. Granted, our current \u0060ArgumentException\u0060 we expose information as a string, which is not machine readable, but that\u0027s probably the area we should be improving instead.\r\n3. Plumbing it through the current engine would be non-trival as we throw \u0060ArgumentException\u0060 left and right.\r\n\r\nWe already have plans to rewrite the regex engine; when we do, we should think about diagnostics.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12644,
          "Title": "Allow for ArrayPool\u003CT\u003E to create buffers with a different minimum length",
          "Author": "xoofx",
          "CreatedAt": "2016-10-14T11:20:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18959",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349398101",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12644#issuecomment-349398101",
        "FeedbackMarkdown": "The ordering is unfortunate. @KrzysztofCwalina mentioned that we might want to take more options in the future to customize how the sizes are spread inside the pool; this indicates that we probably shouldn\u0027t take more values as individual arguments but instead introduce a new class that holds the the options like this:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class ArrayPoolOptions\r\n{\r\n    public int MaxArrayLength { get; set; }\r\n    public int MaxArraysPerBucket { get; set; }\r\n    public int MinArrayLength { get; set; }\r\n}\r\n\r\npublic static class ArrayPool\u003CT\u003E\r\n{\r\n    public static ArrayPool\u003CT\u003E Create();\r\n    public static ArrayPool\u003CT\u003E Create(int maxArrayLength, int maxArraysPerBucket);\r\n    public static ArrayPool\u003CT\u003E Create(ArrayPoolOptions options);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n(this needs more design, but illustrates the point)",
        "TimeCode": 9440000000,
        "Apis": [
          "M:ArrayPool\u003CT\u003E.Create()",
          "M:ArrayPool\u003CT\u003E.Create(ArrayPoolOptions)",
          "M:ArrayPool\u003CT\u003E.Create(int,int)",
          "P:ArrayPoolOptions.MaxArrayLength",
          "P:ArrayPoolOptions.MaxArraysPerBucket",
          "P:ArrayPoolOptions.MinArrayLength",
          "T:ArrayPool\u003CT\u003E",
          "T:ArrayPoolOptions"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24445,
          "Title": "Add Dictionary\u003CTKey, TValue\u003E.Capacity to let you resize map after created",
          "Author": "davkean",
          "CreatedAt": "2017-10-05T08:16:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23744",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349406685",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24445#issuecomment-349406685",
        "FeedbackMarkdown": "Looks like the API needs more discussion.",
        "TimeCode": 17020000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23881,
          "Title": "ReadOnlySpan\u003CT\u003E.DangerousGetPinnableReference should return a readonly reference",
          "Author": "ektrah",
          "CreatedAt": "2017-09-08T13:50:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23492",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349408257",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23881#issuecomment-349408257",
        "FeedbackMarkdown": "We don\u0027t care super much; we see the value in promoting generally safe behavior so the API suggestion looks sensible to me. However, we lack expertise to judge whether this causes clutter (additional casting, like C\u002B\u002B const). So I\u0027d leave it to runtime/compiler folks to decided what to do here.",
        "TimeCode": 33810000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25229,
          "Title": "Change OwnedMemory Pin to take an optional integer offset",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-11-13T23:49:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24126",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25229#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 37500000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24072,
          "Title": "Span extension method to slice off of a string instance",
          "Author": "jnm2",
          "CreatedAt": "2017-09-15T14:44:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23569",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349412729",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24072#issuecomment-349412729",
        "FeedbackMarkdown": "That seems like a good suggestion, but we should do the same for arrays.",
        "TimeCode": 38830000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16878,
          "Title": "MemoryExtensions.SequenceCompare",
          "Author": "AronParker",
          "CreatedAt": "2017-03-08T23:42:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20525",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349414287",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16878#issuecomment-349414287",
        "FeedbackMarkdown": "We should change the name to \u0060SequenceCompareTo\u0060 (notice the \u0060To\u0060 at the end).\r\n\r\n\u0060\u0060\u0060csharp\r\nclass static SpanExtensions\r\n{\r\n    static int SequenceCompareTo(this ReadOnlySpan\u003Cbyte\u003E first, ReadOnlySpan\u003Cbyte\u003E second);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46500000000,
        "Apis": [
          "T:"
        ]
      },
      {
        "Id": 8,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14336,
          "Title": "String should implement IReadOnlyList\u003Cchar\u003E",
          "Author": "danmosemsft",
          "CreatedAt": "2016-12-08T22:47:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19609",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349415239",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14336#issuecomment-349415239",
        "FeedbackMarkdown": "String isn\u0027t (logically) a collection of chars, so giving a read-only view seems off. Considering how far we\u0027re with the new span based APIs, I\u0027m not convinced this interface is adding a ton of value for code that cares about performance (and code that doesn\u0027t has alternatives today).",
        "TimeCode": 47990000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24343,
          "Title": "Add SpanExtensions.AsVector",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-09-29T20:00:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23688",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349418624",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24343#issuecomment-349418624",
        "FeedbackMarkdown": "We should align it with the existing APIs, so I\u0027d rather make this a ctor on \u0060Vector\u003CT\u003E\u0060 itself:\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Numerics\r\n{\r\n    public struct Vector\u003CT\u003E\r\n    {\r\n        // Existing API\r\n        public Vector(T[] values);\r\n        // Proposed API\r\n        public Vector(Span\u003CT\u003E values);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52080000000,
        "Apis": [
          "M:Vector\u003CT\u003E.Vector(Span\u003CT\u003E)",
          "M:Vector\u003CT\u003E.Vector(T[])",
          "T:Vector\u003CT\u003E"
        ]
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24946,
          "Title": "Expose RuntimeWrappedException constructor",
          "Author": "jkotas",
          "CreatedAt": "2017-10-30T02:10:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23991",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24946#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 58880000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 13,
    "Date": "2017-12-19T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=IIKqOagRdWA",
      "Id": "IIKqOagRdWA",
      "StartDateTime": "2017-12-19T14:08:58.263-08:00",
      "EndDateTime": "2017-12-19T16:00:31-08:00",
      "Duration": 66927370000,
      "Title": ".NET Design Reviews Brotli",
      "ThumbnailUrl": "https://i.ytimg.com/vi/IIKqOagRdWA/mqdefault.jpg"
    },
    "Title": "System.IO.Compression",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25785,
          "Title": "Add Brotli Compression to CoreFX",
          "Author": "ianhays",
          "CreatedAt": "2017-12-07T23:19:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24389",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Compression",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2017-12-19T00:00:00-08:00",
        "FeedbackId": "352921246",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25785#issuecomment-352921246",
        "FeedbackMarkdown": "We reviewed the API and made some minor tweaks:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic partial class BrotliStream : Stream\r\n{\r\n    public BrotliStream(Stream stream, CompressionLevel compressionLevel);\r\n    public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);\r\n    public BrotliStream(Stream stream, CompressionMode mode);\r\n    public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);\r\n    public Stream BaseStream { get; }\r\n\r\n    // We don\u0027t think we need those for now. Not having aligns the type with DeflateStream/GzipStream\r\n    // public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int bufferSize);\r\n    // public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen, int bufferSize);\r\n\r\n    // Overrides omitted for clarity\r\n}\r\n// We discussed making these guys classes and derive from CFO ourselves instead of wrapping a SafeHandle\r\n// but we decided against it due to complexity and only minor savings (like when these are boxed)\r\npublic struct BrotliDecoder : IDisposable\r\n{\r\n    public OperationStatus Decompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesConsumed, out int bytesWritten);\r\n    public void Dispose();\r\n\r\n    public static bool TryDecompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n}\r\npublic struct BrotliEncoder : IDisposable\r\n{\r\n\tBrotliEncoder(int quality, int window);\r\n\r\n    public OperationStatus Compress(ReadOnlySpan\u003Cbyte\u003E source,\r\n    \t                            Span\u003Cbyte\u003E destination,\r\n    \t                            out int bytesConsumed,\r\n    \t                            out int bytesWritten,\r\n    \t                            bool isFinalBlock);\r\n    public OperationStatus Flush(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n    public void Dispose();\r\n\r\n    public static bool TryCompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n    public static bool TryCompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten, int quality, int window);\r\n    public static int GetMaxCompressedLength(int length);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BrotliDecoder.Decompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int)",
          "M:BrotliDecoder.Dispose()",
          "M:BrotliDecoder.TryDecompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:BrotliEncoder.BrotliEncoder(int,int)",
          "M:BrotliEncoder.Compress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:BrotliEncoder.Dispose()",
          "M:BrotliEncoder.Flush(Span\u003Cbyte\u003E,out int)",
          "M:BrotliEncoder.GetMaxCompressedLength(int)",
          "M:BrotliEncoder.TryCompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,int,int)",
          "M:BrotliEncoder.TryCompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:BrotliStream.BrotliStream(Stream,CompressionLevel,bool)",
          "M:BrotliStream.BrotliStream(Stream,CompressionLevel)",
          "M:BrotliStream.BrotliStream(Stream,CompressionMode,bool)",
          "M:BrotliStream.BrotliStream(Stream,CompressionMode)",
          "P:BrotliStream.BaseStream",
          "T:BrotliDecoder",
          "T:BrotliEncoder",
          "T:BrotliStream"
        ]
      }
    ]
  },
  {
    "Id": 14,
    "Date": "2018-01-02T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=dOpH6bUNbcw",
      "Id": "dOpH6bUNbcw",
      "StartDateTime": "2018-01-02T10:03:50.039-08:00",
      "EndDateTime": "2018-01-02T10:52:49-08:00",
      "Duration": 29389610000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dOpH6bUNbcw/mqdefault.jpg"
    },
    "Title": "System.Reflection, System.Runtime, System.Security, System.Xml",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25846,
          "Title": "Add StringBuilder.Equals(string) to efficiently compare a StringBuilder with a string.",
          "Author": "danmosemsft",
          "CreatedAt": "2017-12-11T23:48:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24418",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354837835",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25846#issuecomment-354837835",
        "FeedbackMarkdown": "It\u0027s a bit odd that the existing \u0060Equals(StringBuilder)\u0060 does an ordinal comparison -- that\u0027s inconsistent with how string comparisons work (defaults to current culture). Hence, it seems acceptable to have an \u0060Equals(string)\u0060 that is ordinal only too. Adding \u0060Equals(string, StringComparison)\u0060 would be doable too, but the only efficient one would be ordinal (all others likely have to enumerate char by char or even allocate), which might make the API a performance trap.\r\n\r\nConclusion: approved as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25671,
          "Title": "Add MemberInfo.IsCollectible \u0026 Assembly.IsCollectible",
          "Author": "JonHanna",
          "CreatedAt": "2017-12-04T04:13:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24330",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354839520",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25671#issuecomment-354839520",
        "FeedbackMarkdown": "Looks good as proposed; my only question is whether we need/should expose this on \u0060TypeInfo\u0060 as well?\r\n\r\n**Edit** Looks like \u0060TypeInfo\u0060 now inherits from \u0060Type\u0060 so we should be fine.",
        "TimeCode": 9540000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 1593,
          "Title": "XPathNodeIterator should implement IEnumerable\u003CXPathNavigator\u003E",
          "Author": "krwq",
          "CreatedAt": "2015-04-30T18:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14515",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Xml",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354841164",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/1593#issuecomment-354841164",
        "FeedbackMarkdown": "Implementing \u0060IE\u003CX\u003E\u0060 additionally would be fine, but this doesn\u0027t buy you anything for avoiding the cast in the \u0060foreach\u0060 scenario as the compiler will still call through the existing non-generic \u0060GetEnumerator()\u0060 method.\r\n\r\nAm I missing anything?",
        "TimeCode": 13820000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16493,
          "Title": "X509Certificate GetCertHash and GetCertHashString with SHA256",
          "Author": "logiclink",
          "CreatedAt": "2017-02-27T12:37:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20349",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354843685",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16493#issuecomment-354843685",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 19340000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 15,
    "Date": "2018-01-12T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=1t_a9fbB3jY",
      "Id": "1t_a9fbB3jY",
      "StartDateTime": "2018-01-12T13:06:19.158-08:00",
      "EndDateTime": "2018-01-12T15:39:05-08:00",
      "Duration": 91658420000,
      "Title": ".NET Design Review: Core Pipelines APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1t_a9fbB3jY/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25850,
          "Title": "Add MemoryExtension APIs to get parity with array APIs",
          "Author": "ahsonkhan",
          "CreatedAt": "2017-12-12T01:42:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24420",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "357358606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25850#issuecomment-357358606",
        "FeedbackMarkdown": "Let\u0027s only add \u0060Reverse\u0060 and not the rest. Reason being that delegate invocations could potentially become a perf trap; the have obvious 1 - 5 line replacements for the caller. \u0060Reverse\u0060 can be optimized and seems generally useful.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "357363944",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-357363944",
        "FeedbackMarkdown": "We don\u0027t think this is ready yet. @ahsonkhan, please redesign the APIs to avoid allocations by returning new spans. Instead, they should follow our \u0060TryXxx\u0060 pattern. But we have to keep in mind that many times folks will start with \u0060ReadOnlySpan\u003Cchar\u003E\u0060 from a \u0060string\u0060 where in-place isn\u0027t possible. It would help to have some sample code that shows how these APIs are used.",
        "TimeCode": 12280000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25846,
          "Title": "Add StringBuilder.Equals(string) to efficiently compare a StringBuilder with a string.",
          "Author": "danmosemsft",
          "CreatedAt": "2017-12-11T23:48:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24418",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25846#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 26310000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 16,
    "Date": "2018-01-16T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=rSVM5RmAhso",
      "Id": "rSVM5RmAhso",
      "StartDateTime": "2018-01-16T10:06:19.237-08:00",
      "EndDateTime": "2018-01-16T13:32:34-08:00",
      "Duration": 123747630000,
      "Title": ".NET Design Reviews GitHub Triage and MemoryPool",
      "ThumbnailUrl": "https://i.ytimg.com/vi/rSVM5RmAhso/mqdefault.jpg"
    },
    "Title": "System.Globalization, System.Memory, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26173,
          "Title": "char.GetUnicodeCategory(unicode scalar)",
          "Author": "ufcpp",
          "CreatedAt": "2018-01-05T03:14:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24581",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Globalization",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358057543",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26173#issuecomment-358057543",
        "FeedbackMarkdown": "Looks good but we should rename the parameter:\r\n\r\n\u0060\u0060\u0060csharp\r\n public static class CharUnicodeInfo\r\n {\r\n      public static UnicodeCategory GetUnicodeCategory(int codePoint);\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CharUnicodeInfo.GetUnicodeCategory(int)",
          "T:CharUnicodeInfo"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17135,
          "Title": "Helper class for dealing with native shared libraries and function pointers",
          "Author": "mellinoe",
          "CreatedAt": "2017-03-15T00:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20635",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358069191",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17135#issuecomment-358069191",
        "FeedbackMarkdown": "* \u0060IDisposable\u0060. We\u0027re concerned that by making this type \u0060IDisposable\u0060 we lead people down the path of disposing these instances over-aggressively (due to static code analysis rules), resulting in undefined behavior. However, we expect most people never having to unload the library. Thus, we believe it\u0027s more consistent with other concepts, such as \u0060AssemblyLoadContext\u0060, by calling it \u0060Unload\u0060.\r\n\r\n* \u0060throwOnError\u0060. Since failing seems to be the default here, we\u0027ve changed the APIs to follow the Try-pattern.\r\n\r\n* \u0060SearchDirectories\u0060. We\u0027ve removed \u0060SearchDirectories\u0060 as there seems to be no scenario where someone would need to probe that; most probing should be handled by calling \u0060TryOpen.\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\npublic sealed class NativeLibrary\r\n{\r\n    public static bool TryOpen(string name, DllImportSearchPath paths, out NativeLibrary result);\r\n\r\n    public IntPtr Handle { get; }\r\n    public bool TryGetSymbolAddress(string name, out IntPtr result);\r\n    public bool TryGetDelegate\u003CT\u003E(string name, out T result);\r\n    public void Unload();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10210000000,
        "Apis": [
          "M:NativeLibrary.TryGetDelegate\u003CT\u003E(string,out T)",
          "M:NativeLibrary.TryGetSymbolAddress(string,out IntPtr)",
          "M:NativeLibrary.TryOpen(string,DllImportSearchPath,out NativeLibrary)",
          "M:NativeLibrary.Unload()",
          "P:NativeLibrary.Handle",
          "T:NativeLibrary"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26357,
          "Title": "Add MemoryPool APIs",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2018-01-16T16:21:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24681",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358079441",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26357#issuecomment-358079441",
        "FeedbackMarkdown": "* **Minimum size**. The sentinel of \u0060int.MinValue\u0060 seems over the top, \u0060-1\u0060 seesm good enough. \u00601\u0060 would be too harsh, as the semantics we want is \u0022give me any buffer size that is convenient for the pool\u0022.\r\n\r\n* **Finalizer**. Don\u0027t define a finalizer. Otherwise, all derived types (even the fully managed ones) go into the finalizer queue.\r\n\r\n* **Default**. Renamed to \u0060Shared\u0060 to align with \u0060ArrayPool\u003CT\u003E\u0060.\r\n\r\n* **Dispose**. What should \u0060Dispose\u0060 do for the \u0060Shared\u0060 instance? It seems no-op is the best choice, otherwise everyone has to special case when folks.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic abstract class MemoryPool\u003CT\u003E : IDisposable\r\n{\r\n    public static MemoryPool\u003CT\u003E Shared { get; }\r\n\r\n    public abstract OwnedMemory\u003CT\u003E Rent(int minBufferSize=-1);\r\n    public abstract int MaxBufferSize { get; }\r\n\r\n    protected MemoryPool();\r\n    public void Dispose();\r\n    protected abstract void Dispose(bool disposing);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33790000000,
        "Apis": [
          "M:MemoryPool\u003CT\u003E.Dispose()",
          "M:MemoryPool\u003CT\u003E.Dispose(bool)",
          "M:MemoryPool\u003CT\u003E.MemoryPool()",
          "M:MemoryPool\u003CT\u003E.Rent(int)",
          "P:MemoryPool\u003CT\u003E.MaxBufferSize",
          "P:MemoryPool\u003CT\u003E.Shared",
          "T:MemoryPool\u003CT\u003E"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358087851",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-358087851",
        "FeedbackMarkdown": "\u0060\u0060\u0060c#\r\n// Approved, but needs to go somewhere else due to globalization\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    \r\n    public static bool Equals(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int Compare(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool Contains(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n\r\n    public static bool StartsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool EndsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E span);\r\n}\r\n\r\n// Needs more work\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    // APIs designed to avoid allocations:\r\n\r\n    public static bool Remove(this ReadOnlySpan\u003Cchar\u003E source, int startIndex, int count, Span\u003Cchar\u003E destination);\r\n    \r\n    public static bool Replace(this ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E oldValue, ReadOnlySpan\u003Cchar\u003E newValue, Span\u003Cchar\u003E destination, out int bytesWritten);\r\n    \r\n    // do we need bytesWritten? It should be source.Length on success\r\n    public static bool ToUpper(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToLower(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n}\r\n\r\n// We probably don\u0027t want these    \r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static bool PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination); \r\n    public static bool PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, char paddingChar, Span\u003Cchar\u003E destination);\r\n    public static bool PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static bool PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, char paddingChar, Span\u003Cchar\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54840000000,
        "Apis": [
          "M:MemoryExtensions.Compare(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Contains(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.EndsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Equals(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,char,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,char,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Remove(this ReadOnlySpan\u003Cchar\u003E,int,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Replace(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,out int)",
          "M:MemoryExtensions.StartsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.ToLower(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpper(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "Id": 17,
    "Date": "2018-01-19T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=Qcqn-yv1X0o",
      "Id": "Qcqn-yv1X0o",
      "StartDateTime": "2018-01-19T14:07:06.962-08:00",
      "EndDateTime": "2018-01-19T17:17:29-08:00",
      "Duration": 114220380000,
      "Title": ".NET Design Reviews Awaiter APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Qcqn-yv1X0o/mqdefault.jpg"
    },
    "Title": "System.Memory",
    "Items": [
      {
        "Id": 1,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26002,
          "Title": "Change OwnedMemory\u003CT\u003E to IOwnedMemory\u003CT\u003E",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2017-12-20T20:48:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24495",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359105642",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26002#issuecomment-359105642",
        "FeedbackMarkdown": "We decided against it. We cannot model read-only spans with this interface unless we\u0027re creating RW and RO interfaces for this.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26139,
          "Title": "Move Span.DangerousCreate to MemoryMarshal.Create",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2018-01-03T22:50:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24562",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359111438",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26139#issuecomment-359111438",
        "FeedbackMarkdown": "We should consider changing the second overload to be \u0060in\u0060. Otherwise, it looks good as proposed.",
        "TimeCode": 8150000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26368,
          "Title": "Move Span.NonPortableCast to MemoryMarshal and rename to Cast",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-01-16T22:18:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24689",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359109249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26368#issuecomment-359109249",
        "FeedbackMarkdown": "Looks good as proposed. We can add a more specialized API that handles the \u0060else\u0060 case if we we want to. Only difference from the proposal is to leave it on \u0060MemoryExtensions\u0060 as the API is now safe.\r\n\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System\r\n{\r\n    public static partial class MemoryExtensions\r\n    {\r\n        public static bool TryCast\u003CTFrom, TTo\u003E(this ReadOnlySpan\u003CTFrom\u003E source, out ReadOnlySpan\u003CTTo\u003E output) where TFrom : struct where TTo : struct;\r\n        public static bool TryCast\u003CTFrom, TTo\u003E(this Span\u003CTFrom\u003E source, out Span\u003CTTo\u003E output) where TFrom : struct where TTo : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe\u0027ll also leave the \u0060NonPortableCast\u0060 API but we\u0027ll move it \u0060MemoryMarshal\u0060. We need to make sure it\u0027s not an extension method, under which case we can rename it to just \u0060Cast\u0060.",
        "TimeCode": 22940000000,
        "Apis": [
          "M:MemoryExtensions.TryCast\u003CTFrom, TTo\u003E(this ReadOnlySpan\u003CTFrom\u003E,out ReadOnlySpan\u003CTTo\u003E)",
          "M:MemoryExtensions.TryCast\u003CTFrom, TTo\u003E(this Span\u003CTFrom\u003E,out Span\u003CTTo\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "Id": 18,
    "Date": "2018-01-23T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=m3Q6MENq17g",
      "Id": "m3Q6MENq17g",
      "StartDateTime": "2018-01-23T10:08:02.689-08:00",
      "EndDateTime": "2018-01-23T11:58:45-08:00",
      "Duration": 66423110000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/m3Q6MENq17g/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Net, System.Net.Http, System.Runtime.CompilerServices, System.ServiceModel.Syndication",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4382,
          "Title": "Update HttpStatusCode enum with updates",
          "Author": "mteper",
          "CreatedAt": "2015-11-06T18:28:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15650",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4382#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26201,
          "Title": "Add application/json to System.Net.Mime.MediaTypeNames.Application",
          "Author": "madelson",
          "CreatedAt": "2018-01-06T01:17:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24597",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26201#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 2670000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26451,
          "Title": "Unsafe API for comparing byrefs as pointers",
          "Author": "jkotas",
          "CreatedAt": "2018-01-19T17:36:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24729",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359887092",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26451#issuecomment-359887092",
        "FeedbackMarkdown": "We think these names align closer to the framework naming:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class Unsafe\r\n{\r\n    public static bool IsAddressLessThan\u003CT\u003E(ref T left, ref T right);\r\n    public static bool IsAddressGreaterThan\u003CT\u003E(ref T left, ref T right);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3830000000,
        "Apis": [
          "M:Unsafe.IsAddressGreaterThan\u003CT\u003E(ref T,ref T)",
          "M:Unsafe.IsAddressLessThan\u003CT\u003E(ref T,ref T)",
          "T:Unsafe"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25718,
          "Title": "New APIs for Accessing RSS Optional Elements",
          "Author": "shmao",
          "CreatedAt": "2017-12-05T17:59:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24348",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ServiceModel.Syndication",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359890337",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25718#issuecomment-359890337",
        "FeedbackMarkdown": "* \u0060TimeToLive\u0060 should throw when the \u0060TimeSpan\u0060 when the time span cannot be represented as an \u0060int\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.ServiceModel.Syndication\r\n{\r\n    public partial class SyndicationFeed\r\n    {\r\n        public SyndicationLink Documentation { get; set; }\r\n        public Collection\u003Cstring\u003E SkipDays { get; }\r\n        public Collection\u003Cint\u003E SkipHours { get; }\r\n        public SyndicationTextInput TextInput { get; set; }\r\n        public TimeSpan? TimeToLive { get; set; }\r\n    }\r\n    public partial class SyndicationTextInput\r\n    {\r\n        public string Description { get; set; }\r\n        public SyndicationLink Link { get; set; }\r\n        public string Name { get; set; }\r\n        public string Title { get; set; }\r\n        public SyndicationTextInput();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17330000000,
        "Apis": [
          "M:SyndicationTextInput.SyndicationTextInput()",
          "P:SyndicationFeed.Documentation",
          "P:SyndicationFeed.SkipDays",
          "P:SyndicationFeed.SkipHours",
          "P:SyndicationFeed.TextInput",
          "P:SyndicationFeed.TimeToLive",
          "P:SyndicationTextInput.Description",
          "P:SyndicationTextInput.Link",
          "P:SyndicationTextInput.Name",
          "P:SyndicationTextInput.Title",
          "T:SyndicationFeed",
          "T:SyndicationTextInput"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359906138",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-359906138",
        "FeedbackMarkdown": "* We can expose all these APIs from MemoryExtensions, even the ones that need globalization APIs as this just means we can\u0027t expose them (yet).\r\n* We\u0027ll not expose APIs that make \u0060StringComparison\u0060 or \u0060CultureInfo\u0060 implicit. We might get feedback, but we think forcing the developer to make a decision is less prone to errors than selecting a default.\r\n* We\u0027ve removed \u0060Replace\u0060 as we don\u0027t think the API interaction / pattern works out. It need more thought/design.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class MemoryExtensions\r\n{\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n\r\n    public static bool IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E span);\r\n\r\n    public static void Remove(this ReadOnlySpan\u003Cchar\u003E source, int startIndex, int count, Span\u003Cchar\u003E destination);    \r\n    public static void PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static void PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination, char paddingChar);\r\n    public static void PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static void PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination, char paddingChar);\r\n\r\n    // Those need access to globalization APIs. We\u0027ll also expose them from\r\n    // the .NET Framework OOB (slow span). They will try to extract the string\r\n    // from the underlying span (because slow span stores it) -- or -- allocate\r\n    // a new string. This avoids bifurcating the API surface.\r\n\r\n    public static bool Contains(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool EndsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool Equals(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool StartsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int CompareTo(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int IndexOf(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n\r\n    public static void ToLower(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination, CultureInfo culture);\r\n    public static void ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static void ToUpper(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination, CultureInfo culture);\r\n    public static void ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24440000000,
        "Apis": [
          "M:MemoryExtensions.CompareTo(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Contains(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.EndsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Equals(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IndexOf(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E,char)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E,char)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Remove(this ReadOnlySpan\u003Cchar\u003E,int,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.StartsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.ToLower(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,CultureInfo)",
          "M:MemoryExtensions.ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpper(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,CultureInfo)",
          "M:MemoryExtensions.ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "Id": 19,
    "Date": "2018-02-13T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=4hIcv01O3aQ",
      "Id": "4hIcv01O3aQ",
      "StartDateTime": "2018-02-13T10:08:00.752-08:00",
      "EndDateTime": "2018-02-13T12:08:59-08:00",
      "Duration": 72582480000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/4hIcv01O3aQ/mqdefault.jpg"
    },
    "Title": "System.IO, System.Memory, System.Reflection.Metadata, System.Runtime.InteropServices, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 10749,
          "Title": "Add time-constant equals and other utility methods to System.Security",
          "Author": "clintharrison",
          "CreatedAt": "2016-08-13T02:06:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18086",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365354366",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/10749#issuecomment-365354366",
        "FeedbackMarkdown": "Looks good as updated in [the last comment](https://github.com/dotnet/corefx/issues/10749#issuecomment-365027340).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17135,
          "Title": "Helper class for dealing with native shared libraries and function pointers",
          "Author": "mellinoe",
          "CreatedAt": "2017-03-15T00:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20635",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365365224",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17135#issuecomment-365365224",
        "FeedbackMarkdown": "@dotMorten \r\n\r\nThe \u0060name\u0060 argument for \u0060TryLoad\u0060 allows relative paths but behavior depends on the value of \u0060paths\u0060.",
        "TimeCode": 2900000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26935,
          "Title": "Add API for reading/writing PDB Checksum Debug Directory entry",
          "Author": "tmat",
          "CreatedAt": "2018-02-07T20:58:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24953",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection.Metadata",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365370670",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26935#issuecomment-365370670",
        "FeedbackMarkdown": "We just took a look. Looks good as proposed. Questions that came up:\r\n\r\n* Should the \u0060ImmtuableArray\u003Cbyte\u003E\u0060 be a \u0060ReadOnlySpan\u003Cbyte\u003E\u0060. We assumed the answer to be no, as S.R.M doesn\u0027t depend on span yet and you need to ship downlevel. Once you spannify S.R.M we can still add overloads.\r\n* \u0060IdStartOffset\u0060 are 32 bit enough? Assumption is yes, but hey :-)",
        "TimeCode": 24440000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26894,
          "Title": "Cleanup after removal of MemoryExtensions As* api.",
          "Author": "KrzysztofCwalina",
          "CreatedAt": "2018-02-06T16:53:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24938",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365381215",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26894#issuecomment-365381215",
        "FeedbackMarkdown": "Looks good as proposed. Regarding the open issues at the end:\r\n\r\n5. **Limit constructors to the longest (most flexible) overload.**. Makes sense, we want the .ctors to be largely plumbing. However, we don\u0027t want to lose perf due to excessive argument validation. We\u0027ll add overloads as needed for perf, but not usability.\r\n\r\n6. **Provide \u0060AsReadOnly()\u0060 methods on r/w/ slice types.**. We agreed to not adding these methods.\r\n\r\n7. **Skip \u0060ReadOnly\u0060 from conversion method names if the source type is already read-only. For example, string can be converted only to \u0060ReadOnlySpan\u003Cchar\u003E\u0060 and so the As\u003Cslice_type\u003E method should be called \u0060AsSpan\u0060, not \u0060AsReadOnlySpan\u0060**. Makes sense.",
        "TimeCode": 35930000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25875,
          "Title": "Add overloads to enumeration APIs that take FindOptions flags",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-12-12T23:21:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24431",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365383129",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25875#issuecomment-365383129",
        "FeedbackMarkdown": "Superseded by #25873",
        "TimeCode": 57560000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25873,
          "Title": "Add file enumeration extensibility points",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-12-12T23:11:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24429",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365388259",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25873#issuecomment-365388259",
        "FeedbackMarkdown": "Looks good. Comments:\r\n\r\n* \u0060MatchType\u0060, \u0060MatchCasing\u0060, \u0060EnumerationOptions\u0060 should live in \u0060System.IO\u0060. Please submit a proposal with the updated \u0060System.IO\u0060 APIs\r\n* \u0060EnumerationOptions.IgnoreInaccessible\u0060 should be \u0060true\u0060 by default\r\n* \u0060EnumerationOptions.AttributesToSkip\u0060 should include system and hidden files.",
        "TimeCode": 61440000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 20,
    "Date": "2018-02-20T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=9BC3Q1kgWAA",
      "Id": "9BC3Q1kgWAA",
      "StartDateTime": "2018-02-20T10:05:09.983-08:00",
      "EndDateTime": "2018-02-20T11:02:19-08:00",
      "Duration": 34290170000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9BC3Q1kgWAA/mqdefault.jpg"
    },
    "Title": "System.IO, System.Memory, System.Net",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27237,
          "Title": "Consider adding MemoryMarshal.GetOwner(ROM)",
          "Author": "benaadams",
          "CreatedAt": "2018-02-18T17:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25082",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "367072826",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27237#issuecomment-367072826",
        "FeedbackMarkdown": "We believe this API would slightly better and would be more consistent:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static bool TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out TOwner ownedMemory)\r\n           where TOwner: OwnedMemory\u003CT\u003E;\r\n        public static bool TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out TOwner ownedMemory, out int index, out int length)\r\n           where TOwner: OwnedMemory\u003CT\u003E;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MemoryMarshal.TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E,out TOwner,out int,out int)",
          "M:MemoryMarshal.TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E,out TOwner)",
          "T:MemoryMarshal"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26995,
          "Title": "Add DecompressionMethods.Brotli?",
          "Author": "stephentoub",
          "CreatedAt": "2018-02-09T13:16:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24986",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26995#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 15140000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25873,
          "Title": "Add file enumeration extensibility points",
          "Author": "JeremyKuhne",
          "CreatedAt": "2017-12-12T23:11:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24429",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "367082482",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25873#issuecomment-367082482",
        "FeedbackMarkdown": "We should probably rename \u0060MatchType.Dos\u0060 to \u0060MatchType.Win32\u0060. Otherwise, looks good as proposed.",
        "TimeCode": 22910000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 21,
    "Date": "2018-02-27T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=1pR7fDL0PBA",
      "Id": "1pR7fDL0PBA",
      "StartDateTime": "2018-02-27T10:06:34.794-08:00",
      "EndDateTime": "2018-02-27T12:04:59-08:00",
      "Duration": 71042060000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1pR7fDL0PBA/mqdefault.jpg"
    },
    "Title": "System.IO.Pipelines, System.Memory, System.Runtime, System.ServiceModel.Syndication, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27500,
          "Title": "Drop \u0060IMemoryList\u0060 and replace with abstract \u0060ReadOnlySequenceSegment\u0060",
          "Author": "benaadams",
          "CreatedAt": "2018-02-27T06:38:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25213",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27500#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27403,
          "Title": "Add GetPosition overload to ReadOnlySequence that only takes an int/long",
          "Author": "davidfowl",
          "CreatedAt": "2018-02-23T08:22:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25166",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368977923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27403#issuecomment-368977923",
        "FeedbackMarkdown": "We decided to go with @KrzysztofCwalina\u0027s proposal:\r\n\r\n\u0060\u0060\u0060c#\r\nvar position = sequence.GetPosition(100, sequence.Start);\r\n// and\r\nvar position = sequence.GetPosition(100);\r\n\u0060\u0060\u0060",
        "TimeCode": 9850000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27451,
          "Title": "Move Memory.TryGetXxx Extensions to MemoryMarshal.TryGetXxx",
          "Author": "benaadams",
          "CreatedAt": "2018-02-25T14:12:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25187",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368979558",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27451#issuecomment-368979558",
        "FeedbackMarkdown": "Argument makes sense, but we don\u0027t need the second one as the existing \u0060TryGetArray\u0060 covers that.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class MemoryMarshal\r\n{\r\n    public static bool TryGetString(ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string text, out int start, out int length);\r\n}\r\n\u0060\u0060\u0060\u0060\r\n\r\nBut we still need to remove these instance methods:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static partial class MemoryExtensions\r\n{\r\n    public static bool TryGetString(this ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string text, out int start, out int length);\r\n}\r\n\r\npublic static partial struct Memory\u003CT\u003E\r\n{\r\n    public bool TryGetArray(out ArraySegment\u003CT\u003E arraySegment)\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12880000000,
        "Apis": [
          "M:Memory\u003CT\u003E.TryGetArray(out ArraySegment\u003CT\u003E)",
          "M:MemoryExtensions.TryGetString(this ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "M:MemoryMarshal.TryGetString(ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "T:Memory\u003CT\u003E",
          "T:MemoryExtensions",
          "T:MemoryMarshal"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27464,
          "Title": "Change new QueueUserWorkItem method to use \u0060TState\u0060",
          "Author": "stephentoub",
          "CreatedAt": "2018-02-26T04:57:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25193",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27464#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 17150000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16767,
          "Title": "Expose Thread.GetCurrentProcessorId() as a public API",
          "Author": "danmosemsft",
          "CreatedAt": "2017-03-06T17:34:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368983869",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16767#issuecomment-368983869",
        "FeedbackMarkdown": "Makes but we believe it (1) should be a method and (2) live on \u0060Thread\u0060.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Threading\r\n{\r\n    public partial class Thread\r\n    {\r\n        public static int GetCurrentProcessorId();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17700000000,
        "Apis": [
          "M:Thread.GetCurrentProcessorId()",
          "T:Thread"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27329,
          "Title": "SocketsHttpHandler: Consider exposing setting for maximum response drain size",
          "Author": "geoffkizer",
          "CreatedAt": "2018-02-21T17:29:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25130",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27329#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24360000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24668,
          "Title": "New APIs in SyndicationFeedFormatter",
          "Author": "shmao",
          "CreatedAt": "2017-10-16T18:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23860",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ServiceModel.Syndication",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "369004374",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24668#issuecomment-369004374",
        "FeedbackMarkdown": "BTW: structs renamed to \u0060*Data\u0060, delegates are \u0060*Callback\u0060, args renamed to \u0060data\u0060.",
        "TimeCode": 64420000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 22,
    "Date": "2018-03-13T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=RsNFSBH3XX0",
      "Id": "RsNFSBH3XX0",
      "StartDateTime": "2018-03-13T10:04:05.32-07:00",
      "EndDateTime": "2018-03-13T11:01:27-07:00",
      "Duration": 34416800000,
      "Title": ".NET Design Reviews GitHub Triage and Span(of T) Consistency",
      "ThumbnailUrl": "https://i.ytimg.com/vi/RsNFSBH3XX0/mqdefault.jpg"
    },
    "Title": "System.Net, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12038,
          "Title": "Add support for RemoteCertificateValidationCallback with ClientWebSocket",
          "Author": "BravoTango86",
          "CreatedAt": "2016-09-24T18:42:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18696",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-03-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12038#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27417,
          "Title": "[System.Runtime.InteropServices] Introduce broader platform definitions. ",
          "Author": "migueldeicaza",
          "CreatedAt": "2018-02-23T20:31:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25172",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-03-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27417#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 6320000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 23,
    "Date": "2018-03-20T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=HvGnuR6zxfI",
      "Id": "HvGnuR6zxfI",
      "StartDateTime": "2018-03-20T10:04:54.246-07:00",
      "EndDateTime": "2018-03-20T12:02:48-07:00",
      "Duration": 70737540000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/HvGnuR6zxfI/mqdefault.jpg"
    },
    "Title": "System.IO",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27418,
          "Title": "Path Span APIs that write into a specified buffer",
          "Author": "JeremyKuhne",
          "CreatedAt": "2018-02-23T21:14:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25173",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-03-20T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27418#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 24,
    "Date": "2018-03-27T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=cwX05hKkp8s",
      "Id": "cwX05hKkp8s",
      "StartDateTime": "2018-03-27T10:10:49.214-07:00",
      "EndDateTime": "2018-03-27T10:57:46-07:00",
      "Duration": 28167860000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/cwX05hKkp8s/mqdefault.jpg"
    },
    "Title": "System.Net.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24553,
          "Title": "SNI API for SslStream",
          "Author": "Drawaes",
          "CreatedAt": "2017-10-10T21:13:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23797",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-03-27T00:00:00-07:00",
        "FeedbackId": "376614353",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24553#issuecomment-376614353",
        "FeedbackMarkdown": "@krwq, please make sure that deciding on the cert via a callback is viable, i.e. you don\u0027t have to pass a mapping of host name to cert up front on any of the platforms we support with .NET Core. Otherwise, the API shape won\u0027t work.\r\n\r\n\u003E When caller returns \u0060null\u0060 certificate we will throw \u0060AuthenticationException\u0060\r\n\r\nAlternative design would be that \u0060null\u0060 means use the default certificate (\u0060SslServerAuthenticationOptions.ServerCertificate\u0060). That might be more convenient without forcing the delegate to allocate a closure.\r\n\r\n@davidfowl @halter73, preferences?",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 25,
    "Date": "2018-04-10T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=FwqoZUlanYg",
      "Id": "FwqoZUlanYg",
      "StartDateTime": "2018-04-10T10:07:15.315-07:00",
      "EndDateTime": "2018-04-10T10:55:40-07:00",
      "Duration": 29046850000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/FwqoZUlanYg/mqdefault.jpg"
    },
    "Title": "System.Memory",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28959,
          "Title": "Remove SequenceMarshal.TryGetMemoryManager for ReadOnlySequence",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-04-10T02:19:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25825",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28959#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28954,
          "Title": "Make CreateFromPinnedArray visible and move it to MemoryMarshal",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-04-09T23:55:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25824",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28954#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 3000000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28751,
          "Title": "Remove .Length from MemoryManager\u003CT\u003E",
          "Author": "benaadams",
          "CreatedAt": "2018-04-03T03:40:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25728",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28751#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 8150000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28969,
          "Title": "Add GetPinnableReference back to Span and ReadOnlySpan",
          "Author": "benaadams",
          "CreatedAt": "2018-04-10T05:18:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25830",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "380190393",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28969#issuecomment-380190393",
        "FeedbackMarkdown": "* The API looks fine. It\u0027s a bit weird to have these APIs on \u0060Span\u003CT\u003E\u0060 and \u0060ReadOnlySpan\u003CT\u003E\u0060, it would be more consistent to have these APIs on \u0060MemoryMarshal\u0060. However, one could also argue that these API are are safe, as they return \u0060null\u0060 for empty spans, so callers will get a null reference rather than being able to get into corrupted states.\r\n\r\n* It\u0027s true that we mostly don\u0027t have extension methods there, but I don\u0027t see a reason why we wouldn\u0027t declare them as extension methods. However, the real issue is that moving them to \u0060MemoryMarshal\u0060 is that without the using, the feature wouldn\u0027t work. Yes, its not different from Linq, but it seems desirable to have these APIs just work.\r\n\r\nHence, we believe these should be instance methods on \u0060Span\u003CT\u003E\u0060 and \u0060ReadOnlySpan\u003CT\u003E\u0060. We\u0027d still mark the APIs as \u0060[EditorBrowsable(Never)]\u0060 as this API is plumbing only.",
        "TimeCode": 13650000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 26,
    "Date": "2018-04-17T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=8m4ijdz0CXw",
      "Id": "8m4ijdz0CXw",
      "StartDateTime": "2018-04-17T10:21:41.214-07:00",
      "EndDateTime": "2018-04-17T11:02:24-07:00",
      "Duration": 24427860000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8m4ijdz0CXw/mqdefault.jpg"
    },
    "Title": "System.Runtime.CompilerServices, System.Text.Encoding",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29026,
          "Title": "Expose \u0060System.Runtime.CompilerServices.SkipLocalsInitAttribute\u0060",
          "Author": "tannergooding",
          "CreatedAt": "2018-04-11T15:09:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25850",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-17T00:00:00-07:00",
        "FeedbackId": "382076991",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29026#issuecomment-382076991",
        "FeedbackMarkdown": "Questions:\r\n\r\n* Will there be a keyword in the language too or will developers use the attribute?\r\n* Presumably people will be able to define the attribute in their own code and get the same behavior?\r\n* Does it make sense to be applied to fields? Presumably no, because what matters is the constructor in case initializers are present?\r\n* Do you plan to support override behavior, i.e. apply to assembly/module/type to turn on/off and then override on the a per member basis?\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeUsage.All, Inherited = false)]\r\n    public sealed class SkipLocalsInitAttribute : Attribute\r\n    {\r\n        public SkipLocalsInitAttribute(bool isEnabled);\r\n        public bool IsEnabled { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SkipLocalsInitAttribute.SkipLocalsInitAttribute(bool)",
          "P:SkipLocalsInitAttribute.IsEnabled",
          "T:SkipLocalsInitAttribute"
        ]
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28944,
          "Title": "Add a GetEncodings method to System.Text.EncodingProvider to support enumerating available character encodings",
          "Author": "mklement0",
          "CreatedAt": "2018-04-09T20:59:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encoding",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-17T00:00:00-07:00",
        "FeedbackId": "382081100",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28944#issuecomment-382081100",
        "FeedbackMarkdown": "* \u0060EncodingProvider.GetEncodings()\u0060 should be \u0060IEnumerable\u003CEncodingInfo\u003E\u0060\r\n* \u0060EncodingProvider.GetEncodings()\u0060 should be virtual and return an empty list (instead of throwing). While this isn\u0027t correct it means that one provider that isn\u0027t updated doesn\u0027t spoil the enumeration for everyone else.\r\n* \u0060Encoding.GetEncodings()\u0060 should return all registered encodings across all providers and de-dupe them if necessary.",
        "TimeCode": 5930000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 27,
    "Date": "2018-04-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=E9X-kNjBtG8",
      "Id": "E9X-kNjBtG8",
      "StartDateTime": "2018-04-24T10:04:39.717-07:00",
      "EndDateTime": "2018-04-24T11:02:36-07:00",
      "Duration": 34762830000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/E9X-kNjBtG8/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Tracing, System.IO, System.Linq, System.Security, System.Text.RegularExpressions",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26406,
          "Title": "SignedCms extensibility to support external private keys",
          "Author": "clairernovotny",
          "CreatedAt": "2018-01-18T02:17:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24707",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384009048",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26406#issuecomment-384009048",
        "FeedbackMarkdown": "Looks good, any reason we wouldn\u0027t expose a matching property? @bartonjs suggested to use the name \u0060privateKey\u0060 instead of just \u0060key\u0060, which seems reasonable to me too.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29273,
          "Title": "Add FileSystem.Watcher.FilterList Property",
          "Author": "Anipik",
          "CreatedAt": "2018-04-22T21:03:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25967",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384014580",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29273#issuecomment-384014580",
        "FeedbackMarkdown": "Looks a good. A few points:\r\n\r\n* We should just use a plural form instead of the \u0060List\u0060 suffix, e.g. \u0060Filters\u0060.\r\n* The property shouldn\u0027t be settable as this avoids problems when the watcher needs to use a derived type in the implementation.\r\n* The existing API \u0060Filter\u0060 will return the first item in \u0060Filters\u0060. If set, it will clear \u0060Filters\u0060 and add the one item.\r\n* Adding a constructor that takes path and filters would be a source breaking change if people call it with a null value for the second argument (because we have an existing one that takes string). However, we could add a longer version that would also accept, say, the matcher type. But that would be a separate API review.",
        "TimeCode": 3100000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29207,
          "Title": "Public setter for System.Diagnostics.Activity.Current",
          "Author": "lmolkova",
          "CreatedAt": "2018-04-19T04:24:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25936",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29207#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13630000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24145,
          "Title": "Consider Span\u003Cchar\u003E overloads on Regex classes",
          "Author": "danmosemsft",
          "CreatedAt": "2017-09-19T16:40:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23602",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24145#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19790000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16011,
          "Title": "Proposal: New Zip LINQ Tuple Overload API",
          "Author": "jcouv",
          "CreatedAt": "2017-02-09T20:39:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20167",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Linq",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384022447",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16011#issuecomment-384022447",
        "FeedbackMarkdown": "\u2764\uFE0F",
        "TimeCode": 20470000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 28,
    "Date": "2018-05-22T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=-6wyH7K4L9g",
      "Id": "-6wyH7K4L9g",
      "StartDateTime": "2018-05-22T10:08:46.33-07:00",
      "EndDateTime": "2018-05-22T12:00:12-07:00",
      "Duration": 66856700000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/-6wyH7K4L9g/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Net, System.Net.Sockets, System.Runtime, System.Security, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29770,
          "Title": "Adding GetChunks which allow efficient scanning of a StringBuilder",
          "Author": "vancem",
          "CreatedAt": "2018-05-17T20:43:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26207",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391080101",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29770#issuecomment-391080101",
        "FeedbackMarkdown": "Looks good, only change is that we think we should collapse the two types:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass StringBuilder {\r\n        public ChunkEnumerator GetChunks();\r\n\r\n        public struct ChunkEnumerator\r\n        {\r\n            [EditorBrowsable(Never)] // Only here to make foreach work\r\n            public ChunkEnumerator GetEnumerator();\r\n            public bool MoveNext();\r\n            public ReadOnlyMemory\u003Cchar\u003E Current { get; }\r\n        }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n* Potentially we can add \u0060CurrentSpan\u0060 to make it cheaper to get the span\r\n* We could also in the future expose a \u0060CurrentSpanReadWrite\u0060 if we ever need a mutating version.",
        "TimeCode": 0,
        "Apis": [
          "M:StringBuilder.ChunkEnumerator.GetEnumerator()",
          "M:StringBuilder.ChunkEnumerator.MoveNext()",
          "M:StringBuilder.GetChunks()",
          "P:StringBuilder.ChunkEnumerator.Current",
          "T:StringBuilder",
          "T:StringBuilder.ChunkEnumerator"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29696,
          "Title": "Exception.HResult setter should be made public",
          "Author": "luqunl",
          "CreatedAt": "2018-05-14T18:36:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26163",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29696#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 22670000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29623,
          "Title": "Add SpinWait.SpinOnce overload to specify or disable the Sleep(1) threshold",
          "Author": "kouvel",
          "CreatedAt": "2018-05-10T01:27:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26132",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391085259",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29623#issuecomment-391085259",
        "FeedbackMarkdown": "* Looks good but we should shorten the name.\r\n* Are there any other thresholds that we need to expose?\r\n\r\n\u0060\u0060\u0060csharp\r\npublic struct SpinWait\r\n{\r\n    public void SpinOnce(int sleep1Threshold);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25560000000,
        "Apis": [
          "M:SpinWait.SpinOnce(int)",
          "T:SpinWait"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29327,
          "Title": "Enable EnvelopedCms to work with an external private key",
          "Author": "bartonjs",
          "CreatedAt": "2018-04-25T14:56:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25991",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391088582",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29327#issuecomment-391088582",
        "FeedbackMarkdown": "Looks good, after minor name change:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic partial class EnvelopedCms\r\n{\r\n     public void Decrypt(RecipientInfo recipientInfo, AsymmetricAlgorithm privateKey);\r\n}\r\n\r\npublic partial class SubjectIdentifier\r\n{\r\n     public bool MatchesCertificate(X509Certificate2 certificate);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32010000000,
        "Apis": [
          "M:EnvelopedCms.Decrypt(RecipientInfo,AsymmetricAlgorithm)",
          "M:SubjectIdentifier.MatchesCertificate(X509Certificate2)",
          "T:EnvelopedCms",
          "T:SubjectIdentifier"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29243,
          "Title": "Add DecompressionMethods.All?",
          "Author": "jnm2",
          "CreatedAt": "2018-04-20T20:01:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25950",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "BackgroundColor": "5319e7",
              "Description": "Issues picked for Hackathon",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391095592",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29243#issuecomment-391095592",
        "FeedbackMarkdown": "Seems reasonable.",
        "TimeCode": 38160000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25040,
          "Title": "Implement portable support for TCP_KEEPCNT, TCP_KEEPIDLE and TCP_KEEPINTVL socket options",
          "Author": "GoldenCrystal",
          "CreatedAt": "2017-11-03T12:53:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24041",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "BackgroundColor": "5319e7",
              "Description": "Issues picked for Hackathon",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391097721",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25040#issuecomment-391097721",
        "FeedbackMarkdown": "Looks good.\r\n\r\nCan we double check what happens if options are no-ops or are unsupported. Do we throw? If so, should the name of the option indicate that things might be unsupported or are no-ops?",
        "TimeCode": 51700000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26975,
          "Title": "[Cookie] CookieCollection should implement ICollection\u003CCookie\u003E",
          "Author": "geoffkizer",
          "CreatedAt": "2018-02-08T23:25:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24973",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "BackgroundColor": "5319e7",
              "Description": "Issues picked for Hackathon",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391098529",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26975#issuecomment-391098529",
        "FeedbackMarkdown": "Looks good but for consistency we should also implement \u0060IReadOnlyCollection\u003C\u003E\u0060.",
        "TimeCode": 54400000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28046,
          "Title": "Support struct Enumerator for ConcurrentDictionary",
          "Author": "stephentoub",
          "CreatedAt": "2018-03-14T04:08:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25448",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391102771",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28046#issuecomment-391102771",
        "FeedbackMarkdown": "The options listed here are all somewhat unfortunate (that is, they suck for various reasons :-)).\r\n\r\nOne compromise would be to add a new method called \u0060GetEnumerator2()\u0060 and change the compiler to support foreach-ing enumerators and code would like this:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar dict = new ConcurrentDictionary\u003Cstring, int\u003E();\r\n// add stuff\r\n\r\nforeach (var kv in dict.GetEnumerator2())\r\n{\r\n    Use(enumerator.Current);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe established patterns for struct-based alternative is \u0060ValueXxx\u0060, like \u0060ValueTuple\u0060 or \u0060ValueTask\u0060 but in this case \u0060value\u0060 might be a bad idea due to the generic parameter \u0060TValue\u0060.\r\n\r\n@jaredpar, are you still supportive of this change to the compiler?\r\n@stephentoub, are you OK with the resulting usage?",
        "TimeCode": 56680000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14334,
          "Title": "TypeInfo doesn\u0027t expose a parameterless constructor",
          "Author": "mellinoe",
          "CreatedAt": "2016-12-08T22:16:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19608",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391103797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14334#issuecomment-391103797",
        "FeedbackMarkdown": "Let\u0027s start doing this in .NET Core. This doesn\u0027t help the RefEmit case for .NET Standard, but we gonna start somewhere :-)",
        "TimeCode": 64720000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 29,
    "Date": "2018-05-29T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=ZHKLi8qWTCs",
      "Id": "ZHKLi8qWTCs",
      "StartDateTime": "2018-05-29T10:07:46.628-07:00",
      "EndDateTime": "2018-05-29T10:52:04-07:00",
      "Duration": 26573720000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ZHKLi8qWTCs/mqdefault.jpg"
    },
    "Title": "System.Net.Sockets, System.Runtime, System.Text.RegularExpressions",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28410,
          "Title": "Regex Match, Split and Matches should support RegexOptions.AnyNewLine as (?=\\r\\z|\\n\\z|\\r\\n\\z|\\z)",
          "Author": "jzabroski",
          "CreatedAt": "2018-03-23T15:39:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25598",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "392863409",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28410#issuecomment-392863409",
        "FeedbackMarkdown": "Looks good. A few comments:\r\n\r\n* We cannot use the proposed value of 128 because it\u0027s already taken (see \u0060#if DBG\u0060 in code)\r\n* The table looks wrong (Windows on Windows on the Current should work IMHO)\r\n* May be \u0060AcceptAllLineEndings\u0060?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23262,
          "Title": "GroupCollection should implement IReadOnlyDictionary interface to align with its Dictionary-Type Usage",
          "Author": "michael-hawker",
          "CreatedAt": "2017-08-15T20:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23186",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "BackgroundColor": "5319e7",
              "Description": "Issues picked for Hackathon",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "392866863",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23262#issuecomment-392866863",
        "FeedbackMarkdown": "Looks good.\r\n\r\n* We should also implement IDictionary\u003CK,V\u003E as the BCL exposes the notion of read-onlyness as a mode (\u0060IsReadOnly\u0060 returns true)\r\n* Given that we implemen \u0060IList\u003C\u003E\u0060, should we also implement \u0060IReadOnlyList\u003C\u003E\u0060?",
        "TimeCode": 6200000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29917,
          "Title": "Socket support for TCP_QUICKACK",
          "Author": "felipepessoto",
          "CreatedAt": "2018-05-25T13:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/798",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29917#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13000000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14334,
          "Title": "TypeInfo doesn\u0027t expose a parameterless constructor",
          "Author": "mellinoe",
          "CreatedAt": "2016-12-08T22:16:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19608",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14334#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16730000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 30,
    "Date": "2018-06-12T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=CcocbzCjCxM",
      "Id": "CcocbzCjCxM",
      "StartDateTime": "2018-06-12T10:09:04.232-07:00",
      "EndDateTime": "2018-06-12T12:04:14-07:00",
      "Duration": 69097680000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CcocbzCjCxM/mqdefault.jpg"
    },
    "Title": "System.Collections, System.ComponentModel, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30048,
          "Title": "Make it easy for large StringBuilders to be written to TextWriters without making a large string ",
          "Author": "vancem",
          "CreatedAt": "2018-06-01T15:57:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26347",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "tenet-performance",
              "BackgroundColor": "c2e0c6",
              "Description": "Performance related issue",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "396671773",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30048#issuecomment-396671773",
        "FeedbackMarkdown": "Looks good as proposed. A few minor suggestions:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass TextWriter {\r\n    public virtual void Write(StringBuilder value);\r\n    public virtual void WriteLine(StringBuilder value);\r\n    public virtual Task WriteAsync(StringBuilder value, CancelationToken cancellationToken=default);\r\n    public virtual Task WriteLineAsync(StringBuilder value, CancelationToken cancellationToken=default);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe should consider special casing \u0060Write(object)\u0060 to check for \u0060StringBuilder\u0060 to avoid going through \u0060StringBuilder.ToString()\u0060. Althought it seems we aren\u0027t special casing any other types but \u0060IFormattable\u0060 today.",
        "TimeCode": 0,
        "Apis": [
          "M:TextWriter.Write(StringBuilder)",
          "M:TextWriter.WriteAsync(StringBuilder,CancelationToken)",
          "M:TextWriter.WriteLine(StringBuilder)",
          "M:TextWriter.WriteLineAsync(StringBuilder,CancelationToken)",
          "T:TextWriter"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29979,
          "Title": "Allow Dictionary\u003CK,V\u003E.Remove during enumeration",
          "Author": "danmosemsft",
          "CreatedAt": "2018-05-30T16:27:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26314",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29979#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16760000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28594,
          "Title": "Proposal: new System.ComponentModel.VersionConverter class",
          "Author": "0xced",
          "CreatedAt": "2018-03-29T13:10:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25671",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ComponentModel",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "396690545",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28594#issuecomment-396690545",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 47690000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 31,
    "Date": "2018-06-26T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=PKQLZXybOUA",
      "Id": "PKQLZXybOUA",
      "StartDateTime": "2018-06-26T10:09:06.741-07:00",
      "EndDateTime": "2018-06-26T11:35:20-07:00",
      "Duration": 51732590000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PKQLZXybOUA/mqdefault.jpg"
    },
    "Title": "Meta, System.Collections, System.IO, System.Memory, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30649,
          "Title": "Add SpanExtensions.LastIndexOf StringComparison overload",
          "Author": "ViktorHofer",
          "CreatedAt": "2018-06-25T18:56:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26605",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30649#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30613,
          "Title": "API for interpretting Span\u003Cbyte\u003E as struct without copying",
          "Author": "jkotas",
          "CreatedAt": "2018-06-22T18:29:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26587",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400400504",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30613#issuecomment-400400504",
        "FeedbackMarkdown": "This API and scenarios make sense but we shouldn\u0027t use \u0060Struct\u0060 in the name. It seems to make more sense to align this with \u0060Unsafe.AsRef()\u0060, thus:\r\n\r\n\r\n\u0060\u0060\u0060csharp\r\nstatic class MemoryMarshal\r\n{\r\n    public static ref readonly T AsRef\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E span) where T : struct;\r\n    public static ref T AsRef(Span\u003Cbyte\u003E span) where T : struct;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 2490000000,
        "Apis": [
          "M:MemoryMarshal.AsRef(Span\u003Cbyte\u003E)",
          "M:MemoryMarshal.AsRef\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E)",
          "T:MemoryMarshal"
        ]
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29544,
          "Title": "Add Interlocked ops w/ explicit memoryOrder",
          "Author": "sdmaclea",
          "CreatedAt": "2018-05-07T18:28:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26092",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400405014",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29544#issuecomment-400405014",
        "FeedbackMarkdown": "Are we sure the enum members are sensibly named? The names do not make a lot of sense to us, but that might just domain knowledge. Also, @GrabYourPitchforks just noticed that \u0060Release\u0060 is being deprecated. Before approving I\u0027d like to get confirmation on the names.",
        "TimeCode": 16490000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27418,
          "Title": "Path Span APIs that write into a specified buffer",
          "Author": "JeremyKuhne",
          "CreatedAt": "2018-02-23T21:14:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25173",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400409299",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27418#issuecomment-400409299",
        "FeedbackMarkdown": "Let\u0027s remove \u0060 TryGetTempPath\u0060 but otherwise it looks good.",
        "TimeCode": 25030000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26948,
          "Title": "Need a method similar to S.R.CS.RuntimeHelpers.InitializeArray, but for spans",
          "Author": "VSadov",
          "CreatedAt": "2018-02-07T23:38:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24961",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400409742",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26948#issuecomment-400409742",
        "FeedbackMarkdown": "Alright, this is it:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass RuntimeHelpers\r\n{\r\n\tReadOnlySpan\u003CT\u003E CreateSpan\u003CT\u003E(RuntimeFieldHandle fldHandle);\t\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33110000000,
        "Apis": [
          "M:RuntimeHelpers.CreateSpan\u003CT\u003E(RuntimeFieldHandle)",
          "T:RuntimeHelpers"
        ]
      },
      {
        "Id": 6,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25189,
          "Title": "\u0022ItemRef\u0022 - Ref element accessor for types that already have an indexer.",
          "Author": "VSadov",
          "CreatedAt": "2017-11-11T01:10:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24110",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400418417",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25189#issuecomment-400418417",
        "FeedbackMarkdown": "This issue was about the naming convention (concept suffixing with \u0060Ref\u0060); it wasn\u0027t a particular set of members. It seems there are issues with the particular APIs being added (specifically \u0060List\u003CT\u003E\u0060 and \u0060Dictionary\u003CK,V\u003E\u0060.)\r\n\r\nPlease file API review requests for the specific members so we can review those (or alternatively update the issue description to have their signatures and reopen this one).",
        "TimeCode": 38690000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 50860000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 32,
    "Date": "2018-07-17T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=dCwHCg9TUvA",
      "Id": "dCwHCg9TUvA",
      "StartDateTime": "2018-07-17T10:15:29.824-07:00",
      "EndDateTime": "2018-07-17T11:56:49-07:00",
      "Duration": 60791760000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dCwHCg9TUvA/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Process, System.Globalization, System.IO.Compression, System.Memory, System.Runtime.InteropServices, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26234,
          "Title": "Expand Process.Kill to Optionally Kill a Process Tree",
          "Author": "bgribaudo",
          "CreatedAt": "2018-01-09T15:16:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24617",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405661428",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26234#issuecomment-405661428",
        "FeedbackMarkdown": "We don\u0027t see the value in an enum as it seems unlikely that we\u0027d do more than the two options. All examples we could come up with would likely result in more parameters. The usability of booleans on call sides have been solved in C# with named parameters.\r\n\r\nWe shouldn\u0027t make the parameter optional as there is no way this will ever be used by the compiler as we\u0027d still have the parameterless version (which cannot be removed as that would be a binary breaking change).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30873,
          "Title": "CSPRNG integers with ranges",
          "Author": "vcsjones",
          "CreatedAt": "2018-07-06T14:28:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26716",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405664452",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30873#issuecomment-405664452",
        "FeedbackMarkdown": "We discussed if we should add a \u0060float\u0060 or \u0060double\u0060 version because that would be consistent with \u0060Random\u0060 but that\u0027s because the underlying primitive there is a \u0060double\u0060 while \u0060RandomNumberGenerator\u0060\u0027s primitive is a random bits. We could add floating point version if someone ever cares.\r\n\r\nWe considered a parameterless overload \u0060GetInt32()\u0060 as this would allow \u0060int.MaxValue\u0060 to be part of the range but in practice there really isn\u0027t a scenario for it (and it can be down allocation free with the \u0060GetBytes()\u0060 method if ever needed).\r\n\r\nWe also considered \u0060GetInt64()\u0060 versions but given that these values are mostly used for indexing this seems equally over the top.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Security.Cryptography\r\n{\r\n  public abstract class RandomNumberGenerator\r\n  {\r\n    public static int GetInt32(int fromInclusive, int toExclusive);\r\n    public static int GetInt32(int toExclusive);\r\n  }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6490000000,
        "Apis": [
          "M:RandomNumberGenerator.GetInt32(int,int)",
          "M:RandomNumberGenerator.GetInt32(int)",
          "T:RandomNumberGenerator"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30677,
          "Title": "Add Public API Marshal.GetExceptionPointers ",
          "Author": "luqunl",
          "CreatedAt": "2018-06-26T20:32:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26620",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405668842",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30677#issuecomment-405668842",
        "FeedbackMarkdown": "Agree with @jkotas  -- we should just return \u0060null\u0060 as that\u0027s a valid answer even on Windows. Normally, if we cannot implement an API we\u0027d throw \u0060PlatformNotSupportedException\u0060 rather than \u0060NotSupportedException\u0060.\r\n\r\nLooks good as proposed.",
        "TimeCode": 12200000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30592,
          "Title": "Add MemoryExtensions.Trim methods for ReadOnlyMemory\u003Cchar\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2018-06-22T03:05:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26570",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30592#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20670000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30424,
          "Title": "Add better ZipFile extraction APIs",
          "Author": "ianhays",
          "CreatedAt": "2018-06-15T16:23:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1552",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-suggestion",
              "BackgroundColor": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Compression",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405676075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30424#issuecomment-405676075",
        "FeedbackMarkdown": "The scenario makes sense.\r\n\r\nThe idea with an option type looks good in principles, but we\u0027d probably want one for creation and one for extraction because not all options for both sides -- which seems overkill.\r\n\r\n@weshaggard had the idea of introducing the new method using default parameters so that we get away with fewer overloads.\r\n\r\n@ianhays, could you give that a shot?",
        "TimeCode": 21900000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28001,
          "Title": "Proposal: Add ReadOnlySpan\u003Cchar\u003E overloads to CompareInfo",
          "Author": "ViktorHofer",
          "CreatedAt": "2018-03-13T00:11:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25428",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Globalization",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405683985",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28001#issuecomment-405683985",
        "FeedbackMarkdown": "The scenario is reasonable.\r\n\r\n@GrabYourPitchforks brought up that we should also add an overload for \u0060GetHashCode()\u0060.\r\n\r\nIt\u0027s worth pointing out \u0060CompareInfo\u0060 can be derived from and the existing overloads are virtual. Presumably, these new APIs wouldn\u0027t normally delegate to them (because we want to avoid allocating a string in the first place), which now means that if a custom derivative exists and overrides the other methods, these methods would do the wrong thing.\r\n\r\nHowever, the type doesn\u0027t expose a public constructor so in practice nobody can derive from it. And it doesn\u0027t seem our implementation does either.\r\n\r\nOptions:\r\n\r\n1. **Ignore**. We make these methods non-virtual and don\u0027t delegate to the existing methods.\r\n\r\n2. **Handle**. We make these methods virtual and have the implementation do a type check. If the instance is \u0060CompareInfo\u0060 exactly, do the cheap thing. Otherwise, create strings and dispatch to the existing virtual methods. Implementers would have to override them to not pay the allocation cost.\r\n\r\nWe\u0027re leaning towards option (1) as we don\u0027t believe deriving from \u0060CompareInfo\u0060 to be a thing.",
        "TimeCode": 34630000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30207,
          "Title": "Add Bad\u00ED\u02BF Calendar to Globalization",
          "Author": "glittle",
          "CreatedAt": "2018-06-08T07:19:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26419",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Globalization",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405690297",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30207#issuecomment-405690297",
        "FeedbackMarkdown": "Thanks for the detailed proposal!\r\n\r\nThe cost for us to support a calendar can be high because we have to react if definitions or rules change. It seems neither Windows, nor macOS, nor ICU support this calendar natively.\r\n\r\nThankfully, the .NET globalization APIs are extensible so you\u0027ll be able to ship this calendar as a NuGet package. If it gets very popular, adding it to the platform seems reasonable. But considering that major vendors haven\u0027t added it, makes us believe it might not be popular enough to warrant us carrying the calendar -- and committing on keeping it up-to-date.\r\n\r\nFor now, I\u0027ll be closing this issue. Please feel free to reopen if you believe your package has become so popular that adding it the platform is sensible.",
        "TimeCode": 47380000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 33,
    "Date": "2018-07-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=vkOaqpdiF5U",
      "Id": "vkOaqpdiF5U",
      "StartDateTime": "2018-07-24T10:06:11.411-07:00",
      "EndDateTime": "2018-07-24T11:06:18-07:00",
      "Duration": 36065890000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/vkOaqpdiF5U/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Memory",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407484728",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-407484728",
        "FeedbackMarkdown": "Personally, I\u0027m fine with the first two bullet points but I don\u0027t understand the last. Could you elaborate? Reading the issue description it sounds like peeking could result in marking all data as \u0022preserve\u0022 which would block dequeues from removing data and thus could result in a state where enqueues would fail and the collection is stuck. Is copying not an option?\r\n\r\nThere are also some concerns about the second bullet point although I find this acceptable as callers have to opt-in.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26313,
          "Title": "Allow easier access to binary representation of blittable types",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-01-13T01:46:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24656",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407486861",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26313#issuecomment-407486861",
        "FeedbackMarkdown": "\u003E Isn\u0027t this equivalent to turning a \u0060ref T\u0060 into a \u0060Span\u003CT\u003E\u0060 followed by \u0060Cast\u003CT, byte\u003E\u0060? I thought turning a \u0060ref T\u0060 into a \u0060Span\u003CT\u003E\u0060 is not possible, even with fast span.\r\n\r\nRight. Thus we don\u0027t believe we need a dedicated API for this. Yet.",
        "TimeCode": 9400000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30527,
          "Title": "SocketsHttpHandler: Add MaxHttpVersion property",
          "Author": "geoffkizer",
          "CreatedAt": "2018-06-19T19:38:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26545",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407499225",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30527#issuecomment-407499225",
        "FeedbackMarkdown": "We\u0027ve talked with @davidsh about the proposed shape and it looks good.\r\n\r\nIf we find ourselves wanting to add this property to \u0060HttpMessageHandler\u0060 we can just physically move the property from \u0060SocketsHttpHandler\u0060 as that\u0027s binary/source compatible. We don\u0027t need the property to be virtual.\r\n\r\nFrom a usage standpoint, it seems more logical to put the property on the \u0060HttpClient\u0060 as that\u0027s what vast majority of users is going to do. @davidsh\u0027s argument is that API is part of the underlying pipe which is what the handler represents. There is another problem with that design in that consumers of \u0060HttpClient\u0060 can still construct an \u0060HttpRequestMessage\u0060 which wouldn\u0027t/can\u0027t honor the value from \u0060HttpClient\u0060.\r\n\r\n@bartonjs is proposing to expose \u0060HttpClient.DefaultHttpVersion\u0060 (instance property) that would control what the default value for \u0060HttpRequestMessage\u0060 objects will be that are constructed by \u0060HttpClient\u0060.\r\n\r\nAny objections to this?",
        "TimeCode": 13080000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 34,
    "Date": "2018-08-28T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=hLbCfJSPIaI",
      "Id": "hLbCfJSPIaI",
      "StartDateTime": "2018-08-28T10:08:02.086-07:00",
      "EndDateTime": "2018-08-28T12:12:04-07:00",
      "Duration": 74419140000,
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/hLbCfJSPIaI/mqdefault.jpg"
    },
    "Title": "System.Collections, System.IO, System.Memory, System.Numerics, System.Reflection, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27526,
          "Title": "Add MemoryExtensions.Contains",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-02-27T22:18:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25228",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27526#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31011,
          "Title": "Proposal: Trim/TrimStart/TrimEnd methods for Memory and Span with trim element",
          "Author": "schungx",
          "CreatedAt": "2018-07-12T08:17:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26785",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416678327",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31011#issuecomment-416678327",
        "FeedbackMarkdown": "We can probably cut the APIs that don\u0027t specify a element (because \u0060default(T)\u0060 doesn\u0027t seem reasonable) but it\u0027s still 6 APIs. We feel like we need a bit more justification to add these APIs.\r\n\r\n@schungx what are the scenarios where you needed this API?",
        "TimeCode": 16020000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31302,
          "Title": "Add span-based overloads of String.GetHashCode",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-07-24T04:35:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26924",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31302#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 23280000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31488,
          "Title": "Need one step API for creating files on Windows with security",
          "Author": "JeremyKuhne",
          "CreatedAt": "2018-07-30T17:49:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27021",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416680473",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31488#issuecomment-416680473",
        "FeedbackMarkdown": "@JeremyKuhne \r\n\r\nWhat would it look like if were to add them back where they were? How bad would the dependency be? These APIs show up a lot in porting.",
        "TimeCode": 24370000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31511,
          "Title": "File.Move(string,string, bool) overload",
          "Author": "mburbea",
          "CreatedAt": "2018-07-31T15:32:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27031",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416681677",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31511#issuecomment-416681677",
        "FeedbackMarkdown": "Makes sense. A few points:\r\n\r\n* We should probably add corresponding APIs to \u0060FileInfo\u0060 and \u0060DirectoryInfo\u0060.\r\n* Can this be implemented on Mac/Linux/Unix?",
        "TimeCode": 26780000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31614,
          "Title": "CustomAttributeData\u0027s AttributeType property should be virtual.",
          "Author": "ghost",
          "CreatedAt": "2018-08-06T17:22:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27071",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31614#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29030000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31787,
          "Title": "a new GC API for large array allocation",
          "Author": "Maoni0",
          "CreatedAt": "2018-08-15T21:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27146",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416688698",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31787#issuecomment-416688698",
        "FeedbackMarkdown": "* Should it just be \u0060AllocateArray\u0060? In the end, the developer controls the size.\r\n* What happens if the developer specifies gen-0 but wants to create a 50 MB array? Will the API fail or will it silently promote the object to, say, gen-1?\r\n* No clearing the memory is fine, but we want to make sure it shows up visibly on the call side (a plain \u0060false\u0060 isn\u0027t good enough). We\u0027d like this to be an overload, such a \u0060AllocateLargeArrayUninitialized\u0060? The other benefit of having an overload is that this could be constrained to only allow \u0060T\u0060s with no references (unmanaged constraint).\r\n* Is LOH the same as MaxGeneration? If not, how can a developer explicitly allocate on the LOH?",
        "TimeCode": 30560000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31798,
          "Title": "Expose the ability to create signature generic instance types.",
          "Author": "ghost",
          "CreatedAt": "2018-08-16T14:41:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27152",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31798#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 41760000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31902,
          "Title": "Expose additional MidpointRounding modes",
          "Author": "tannergooding",
          "CreatedAt": "2018-08-23T02:21:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27205",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31902#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 45580000000,
        "Apis": []
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31903,
          "Title": "Expose some additional Math and MathF operations",
          "Author": "tannergooding",
          "CreatedAt": "2018-08-23T02:50:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27206",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416696207",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31903#issuecomment-416696207",
        "FeedbackMarkdown": "Some minor feedback:\r\n\r\n* NextValue -\u003E BitIncrement\r\n* PreviousValue -\u003E BitDecrement\r\n* Copysign -\u003E CopySign",
        "TimeCode": 47760000000,
        "Apis": []
      },
      {
        "Id": 11,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31942,
          "Title": "Add string keyed dictionary ReadOnlySpan\u003Cchar\u003E lookup support",
          "Author": "TylerBrinkley",
          "CreatedAt": "2018-08-24T20:07:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27229",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416704108",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31942#issuecomment-416704108",
        "FeedbackMarkdown": "On the surface, the extension approach looks more appealing because it would allow the lookups to work against any instance of a dictionary (at least in principle, the current design only works if the dictionary was instantiated with a comparer that implements \u0060IStringEqualityComparer\u0060).\r\n\r\nHowever, this also complicates the implementation and might have performance implications if we have to expose more methods that only make sense when \u0060TKey\u0060 happens to be \u0060string\u0060. Also, one could argue that in the hot paths where people would be inclined to lookup with spans that they do in fact control their dictionary and whether they need to pass in the correct comparer or use a derived type of \u0060Dictionary\u003C,\u003E\u0060 doesn\u0027t matter.\r\n\r\nI totally buy the scenario, but adding a new collection type (even if derived from \u0060Dictionary\u003C,\u003E\u0060) feels heavy handed, but maybe I\u0027m overthinking this. Maybe just putting it in \u0060S.C.Specialized\u0060 is good enough.\r\n\r\nWhat do others think?",
        "TimeCode": 55400000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 35,
    "Date": "2018-09-25T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=nJleHEiiX14",
      "Id": "nJleHEiiX14",
      "StartDateTime": "2018-09-25T10:08:04.7-07:00",
      "EndDateTime": "2018-09-25T11:58:39-07:00",
      "Duration": 66343000000,
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nJleHEiiX14/mqdefault.jpg"
    },
    "Title": "System.Collections, System.IO, System.Memory, System.Net, System.Numerics, System.Runtime.CompilerServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26528,
          "Title": "Add \u0027split\u0027 support for ReadOnlySpan\u003Cchar\u003E similar to string",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-01-23T01:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/934",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "utf8-impact",
              "BackgroundColor": "eddf84",
              "Description": "Potentially impacts UTF-8 support in the runtime",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424438136",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26528#issuecomment-424438136",
        "FeedbackMarkdown": "We don\u0027t think we want these APIs:\r\n\r\n1. They allocate\r\n2. They aren\u0027t as convenient as \u0060String.Split\u0060\r\n\r\nIf you care about allocations, then you want a different API. And if you don\u0027t care about allocations, well, then you can just use \u0060String.Split\u0060.\r\n\r\nSo what API would we like to see? It could be a struct-based enumerator that allows the consumer to \u0060foreach\u0060 the individual spans without allocations. Alternatively (or additionally) we could have a method that allows the consumer to pass in a buffer with the locations, which, for the most part, could be \u0060stackalloc\u0060ated.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24550000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29258,
          "Title": "Capability APIs for runtime code generation",
          "Author": "morganbr",
          "CreatedAt": "2018-04-21T02:03:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25959",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424442400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29258#issuecomment-424442400",
        "FeedbackMarkdown": "This is related: https://github.com/dotnet/standard/issues/832\r\n\r\nI believe this feature needs a more comprehensive design. I\u0027ll follow-up.",
        "TimeCode": 27930000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30968,
          "Title": "Vector\u003CT\u003E should have a ctor that accepts ReadOnlySpan\u003CT\u003E",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-07-10T21:57:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26763",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424448085",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30968#issuecomment-424448085",
        "FeedbackMarkdown": "@GrabYourPitchforks also suggested these APIs:\r\n\r\n\u0060\u0060\u0060cs\r\npublic struct Vector\u003CT\u003E {\r\n    /* new ctor overload proposal */\r\n    public Vector(ReadOnlySpan\u003Cbyte\u003E values);\r\n   \r\n    /* new instance method proposals */\r\n    public void CopyTo(Span\u003Cbyte\u003E destination);\r\n    public bool TryCopyTo(Span\u003Cbyte\u003E destination);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would avoid consumers having to re-interpret case the spans. We don\u0027t know what happens when the \u0060Vector\u003CT\u003E\u0060 is instantiated with \u0060byte\u0060 though.  @GrabYourPitchforks, please take a look and file another item.",
        "TimeCode": 32290000000,
        "Apis": [
          "M:Vector\u003CT\u003E.CopyTo(Span\u003Cbyte\u003E)",
          "M:Vector\u003CT\u003E.TryCopyTo(Span\u003Cbyte\u003E)",
          "M:Vector\u003CT\u003E.Vector(ReadOnlySpan\u003Cbyte\u003E)",
          "T:Vector\u003CT\u003E"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31291,
          "Title": "Add IPEndPoint.Parse() \u0026 .TryParse()",
          "Author": "NickCraver",
          "CreatedAt": "2018-07-24T00:09:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26916",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424450665",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31291#issuecomment-424450665",
        "FeedbackMarkdown": "We should probably also expose this for \u0060DnsEndPoint\u0060, but that should be another issue. This one looks good as proposed.",
        "TimeCode": 41800000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31570,
          "Title": "Make internal directory separator helpers public",
          "Author": "cdmihai",
          "CreatedAt": "2018-08-02T23:59:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27053",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424461314",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31570#issuecomment-424461314",
        "FeedbackMarkdown": "The \u0060EndsIn*\u0060 methods seem problematic. The first ones seems fine but we should add support memory.\r\n\r\n\u0060\u0060\u0060c#\r\nnamespace System.IO\r\n{\r\n    public static class Path\r\n    {\r\n        public static string TrimEndingDirectorySeparator(string path);\r\n        public static ReadOnlySpan\u003Cchar\u003E TrimEndingDirectorySeparator(ReadOnlySpan\u003Cchar\u003E path);\r\n        public static ReadOnlyMemory\u003Cchar\u003E TrimEndingDirectorySeparator(ReadOnlyMemory\u003Cchar\u003E path);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46690000000,
        "Apis": [
          "M:Path.TrimEndingDirectorySeparator(ReadOnlyMemory\u003Cchar\u003E)",
          "M:Path.TrimEndingDirectorySeparator(ReadOnlySpan\u003Cchar\u003E)",
          "M:Path.TrimEndingDirectorySeparator(string)",
          "T:Path"
        ]
      }
    ]
  },
  {
    "Id": 36,
    "Date": "2018-12-11T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=6QOv4c1O6ME",
      "Id": "6QOv4c1O6ME",
      "StartDateTime": "2018-12-11T10:06:59.033-08:00",
      "EndDateTime": "2018-12-11T12:13:47-08:00",
      "Duration": 76079670000,
      "Title": ".NET Design Review: JSON DOM",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6QOv4c1O6ME/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33968,
          "Title": "Random-access document model for JSON (JsonDocument)",
          "Author": "bartonjs",
          "CreatedAt": "2018-12-11T00:17:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28132",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-11T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33968#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 37,
    "Date": "2018-12-18T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=iQMNIeVoAdY",
      "Id": "iQMNIeVoAdY",
      "StartDateTime": "2018-12-18T10:08:33.41-08:00",
      "EndDateTime": "2018-12-18T11:59:33-08:00",
      "Duration": 66595900000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/iQMNIeVoAdY/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32850,
          "Title": "API: Native Library Resolve Event",
          "Author": "swaroop-sridhar",
          "CreatedAt": "2018-10-16T21:10:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27647",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32850#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32015,
          "Title": "Native Library Loader API",
          "Author": "annaaniol",
          "CreatedAt": "2020-01-31T22:52:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27267",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448324606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32015#issuecomment-448324606",
        "FeedbackMarkdown": "This is the shape we agreed on:\r\n\r\n* We centrlized the APIs on a new type \u0060NativeLibrary\u0060 as opposed to \u0060Marshal\u0060 because it helps the developer using these APIs as it groups them better. \u0060Marshal\u0060 already has a ton of APIs.\r\n* We renamed \u0060RegisterDllImportResolver\u0060 to \u0060SetDllImportResolver\u0060. Register implies having an unregister and having a chain. \u0060Set\u0060 makes it clear there is a single value and \u0060null\u0060 will clear it.\r\n* We replaced the func of \u0060SetDllImportResolver\u0060 with a named delegate so that we can name the parameters.\r\n* Open item: we need to clarify whether the \u0060DllImportSearchPath?\u0060 argument to \u0060DllImportResolver\u0060 is different from any other existing enum value. If not, we should make it non-nullable.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public delegate IntPtr DllImportResolver(string libraryName,\r\n                                             Assembly assembly,\r\n                                             DllImportSearchPath? searchPath);\r\n\r\n    public static partial class NativeLibrary\r\n    {\r\n        // Typical or for dependencies which must be there or failure should happen.\r\n\r\n        public static IntPtr Load(string libraryPath);\r\n        public static IntPtr Load(string libraryName,\r\n                                  Assembly assembly,\r\n                                  DllImportSearchPath? searchPath);\r\n\r\n        // For fast probing scenarios:\r\n\r\n        public static bool TryLoad(string libraryPath,\r\n                                   out IntPtr handle);\r\n        public static bool TryLoad(string libraryName,\r\n                                   Assembly assembly,\r\n                                   DllImportSearchPath? searchPath,\r\n                                   out IntPtr handle);\r\n\r\n        public static void Free(IntPtr handle);\r\n\r\n        public static IntPtr GetExport(IntPtr handle, string name);\r\n        public static bool TryGetExport(IntPtr handle, string name, out IntPtr address);\r\n\r\n        public static bool SetDllImportResolver(Assembly assembly, DllImportResolver resolver);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 4760000000,
        "Apis": [
          "M:NativeLibrary.Free(IntPtr)",
          "M:NativeLibrary.GetExport(IntPtr,string)",
          "M:NativeLibrary.Load(string,Assembly,DllImportSearchPath?)",
          "M:NativeLibrary.Load(string)",
          "M:NativeLibrary.SetDllImportResolver(Assembly,DllImportResolver)",
          "M:NativeLibrary.TryGetExport(IntPtr,string,out IntPtr)",
          "M:NativeLibrary.TryLoad(string,Assembly,DllImportSearchPath?,out IntPtr)",
          "M:NativeLibrary.TryLoad(string,out IntPtr)",
          "T:DllImportResolver(string,Assembly,DllImportSearchPath?)",
          "T:NativeLibrary"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33284,
          "Title": "Proposal: MatchFailureException",
          "Author": "gafter",
          "CreatedAt": "2018-11-06T22:11:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27832",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448332714",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33284#issuecomment-448332714",
        "FeedbackMarkdown": "* There is a possibility for a breaking change: library author ships a library for 3.0 and then later downgrades to 2.0, which is is expected to be transparent to consumer. Now a different exception exception is thrown. Seems remote though.\r\n* We don\u0027t expect any user code to specifically handle this exception (outside of implicit catch-all style handlers). We should move this to \u0060System.Runtime.CompilerServices\u0060.\r\n* We should have a less generic name, for instance \u0060SwitchExpressionException\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Indicates that a switch expression that was non-exhaustive failed to match its input\r\n    /// at runtime, e.g. in the C# 8 expression \u003Ccode\u003E3 switch { 4 =\u003E 5 }\u003C/code\u003E.\r\n    /// The exception optionally contains an object representing the unmatched value.\r\n    /// \u003C/summary\u003E\r\n    [System.Runtime.InteropServices.ComVisible(true)]\r\n    [Serializable]\r\n    public sealed class SwitchExpressionException : InvalidOperationException\r\n    {\r\n        public SwitchExpressionException();\r\n        public SwitchExpressionException(object unmatchedValue);\r\n        public object UnmatchedValue { get; }\r\n        [System.Security.SecurityCritical]\r\n        public override void GetObjectData(SerializationInfo info, StreamingContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18250000000,
        "Apis": [
          "M:SwitchExpressionException.GetObjectData(SerializationInfo,StreamingContext)",
          "M:SwitchExpressionException.SwitchExpressionException()",
          "M:SwitchExpressionException.SwitchExpressionException(object)",
          "P:SwitchExpressionException.UnmatchedValue",
          "T:SwitchExpressionException"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33165,
          "Title": "Add API for resolving component dependencies",
          "Author": "vitek-karas",
          "CreatedAt": "2018-10-31T08:53:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27787",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448337807",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33165#issuecomment-448337807",
        "FeedbackMarkdown": "* Should we offer a resolver that represents the \u0022global\u0022 context? \u0060AssemblyLoadContext\u0060 kind of does that, but it doesn\u0027t talk in paths.\r\n* The term component seems a bit ill-defined. \u0060AssemblyDependencyResolver\u0060 seems to make sense, given that this type is for resolving dependencies of assemblies (managed or unamanged). The only caveat is that you need to pass the path to the assembly that has the corresponding \u0060\u003Cassembly\u003E.deps.json\u0060 file, i.e. the main assembly or the entry point of the plug-in.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Loader\r\n{\r\n    public sealed class AssemblyDependencyResolver\r\n    {\r\n        // Should this API exist?\r\n        // public static AssemblyDependencyResolver GlobalResolver { get; }\r\n\r\n        public AssemblyDependencyResolver(string assemblyPath);\r\n\r\n        public string ResolveAssemblyToPath(AssemblyName assemblyName);\r\n        public string ResolveUnmanagedDllToPath(string unmanagedDllName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32870000000,
        "Apis": [
          "M:AssemblyDependencyResolver.AssemblyDependencyResolver(string)",
          "M:AssemblyDependencyResolver.ResolveAssemblyToPath(AssemblyName)",
          "M:AssemblyDependencyResolver.ResolveUnmanagedDllToPath(string)",
          "T:AssemblyDependencyResolver"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 135,
          "Title": "Setting/Getting HighDpiMode in WinForms Core Apps",
          "Author": "KlausLoeffelmann",
          "CreatedAt": "2018-12-04T12:32:11+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/135",
          "Milestone": "3.0-Preview3",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448340808",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/135#issuecomment-448340808",
        "FeedbackMarkdown": "* It\u0027s a bit odd to use a method; one would expect a regular property setter.\r\n* However, after reading the text it seems that\u0027s because the method might ignore the value. Presumably the method returns \u0060false\u0060 in this case, as well as in your case (a)?\r\n* Thus, the shape looks good as proposed.",
        "TimeCode": 42760000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 218,
          "Title": "DataObject.SetAudio should be exposed with a new overload taking Span\u003Cbyte\u003E",
          "Author": "raffaeler",
          "CreatedAt": "2018-12-09T21:38:21+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/218",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "BackgroundColor": "5319e7",
              "Description": "(2) API is ready for formal API review; applied by the issue owner",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448343258",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/218#issuecomment-448343258",
        "FeedbackMarkdown": "We aren\u0027t experts on \u0060IDataObject\u0060 but what is the benefit of using \u0060Span\u003CT\u003E\u0060 here? The \u0060Stream\u0060 API allows you to slice the data already, and it seems the implementation pushes the state into the heap.\r\n\r\nFor this scenario \u0060Span\u003CT\u003E\u0060 doesn\u0027t make sense; at the very minimum it would need to be \u0060Memory\u003CT\u003E\u0060 (because \u0060Span\u003CT\u003E\u0060 cannot be stored on the heap). However, this seems to complicate the API surface more than it helps.\r\n\r\nIf slicing the array would be common, I suggest we instead add an overload that simply accepts two ints, or an \u0060ArraySegment\u003CT\u003E\u0060.",
        "TimeCode": 48580000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 38,
    "Date": "2019-01-08T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=e1nUhoqMJn8",
      "Id": "e1nUhoqMJn8",
      "StartDateTime": "2019-01-08T10:10:45.7-08:00",
      "EndDateTime": "2019-01-08T12:03:08-08:00",
      "Duration": 67423000000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/e1nUhoqMJn8/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32015,
          "Title": "Native Library Loader API",
          "Author": "annaaniol",
          "CreatedAt": "2020-01-31T22:52:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27267",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32015#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33909,
          "Title": "Proposal: IAsyncEnumerable\u003CT\u003E.WithCancellation extension method",
          "Author": "stephentoub",
          "CreatedAt": "2018-12-07T17:25:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28105",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33909#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13470000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 134,
          "Title": "PlaceholderText API addition to TextBox control",
          "Author": "stefanov-stefan",
          "CreatedAt": "2018-12-04T08:42:14+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/134",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "452412351",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/134#issuecomment-452412351",
        "FeedbackMarkdown": "Presumably \u0060PlaceholderText\u0060 will behave like \u0060Text\u0060 with respect to handling \u0060null\u0060 vs \u0060string.Empty\u0060?",
        "TimeCode": 24780000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34330,
          "Title": "string.Concat(ReadOnlySpan\u003Cchar\u003E, ...)",
          "Author": "stephentoub",
          "CreatedAt": "2019-01-03T14:56:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28310",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34330#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 27020000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 39,
    "Date": "2019-01-22T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=jjgr5xruXj4",
      "Id": "jjgr5xruXj4",
      "StartDateTime": "2019-01-22T10:10:01.124-08:00",
      "EndDateTime": "2019-01-22T11:12:13-08:00",
      "Duration": 37318760000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jjgr5xruXj4/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Text.Encoding, System.Threading.Channels, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32742,
          "Title": "Proposal: Add IAsyncEnumerable\u003CT\u003E support to System.Threading.Channels",
          "Author": "stephentoub",
          "CreatedAt": "2018-10-10T15:09:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27593",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Channels",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456511279",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32742#issuecomment-456511279",
        "FeedbackMarkdown": "We concluded that exposing it as a method is better as it\u0027s \u0022destructive\u0022, i.e. it drains the items. We settled on \u0060ReadAllAsync()\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33336,
          "Title": "Proposal: IAsyncDisposable.ConfigureAwait(bool continueOnCapturedContext)",
          "Author": "stephentoub",
          "CreatedAt": "2018-11-08T15:47:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27857",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33336#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13970000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 134,
          "Title": "PlaceholderText API addition to TextBox control",
          "Author": "stefanov-stefan",
          "CreatedAt": "2018-12-04T08:42:14+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/134",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456519247",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/134#issuecomment-456519247",
        "FeedbackMarkdown": ":shipit: #238",
        "TimeCode": 17830000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33717,
          "Title": "Allow recovering writable/heapable buffers from \u0022lower level\u0022 types.",
          "Author": "bartonjs",
          "CreatedAt": "2018-11-27T22:20:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28008",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456520584",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33717#issuecomment-456520584",
        "FeedbackMarkdown": "* \u0060Overlaps\u003CT\u003E()\u0060 with memories. We concluded we don\u0027t want these overloads. We generally want to poeple to go from memory to span; we also believe they are fast enough. If we ever need them for perf reasons, we can revisit this.\r\n\r\n* \u0060SliceTo\u0060. We\u0027re unsure whether this API will fix the usability issues of the \u0060Overlap\u003CT\u003E()\u0060 methods. For now, we don\u0027t think we want this API. However, we might want add a different API that will address these issues and makes working with spans when you need to compare bounds of other values (memories, other span, strings etc) based on how to two other spans relate to each other.",
        "TimeCode": 27260000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34683,
          "Title": "Add Rune creation API from UTF-16 surrogate pair",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-01-18T20:56:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28456",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encoding",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456524835",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34683#issuecomment-456524835",
        "FeedbackMarkdown": "Can we name this just \u0060TryCreate\u0060, given the overloads? It\u0027s clear from your signature that you\u0027re creating a rune from a surrogate pair.\r\n\r\nWe should also add the corresponding constructor.",
        "TimeCode": 31310000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 40,
    "Date": "2019-01-29T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=3KCS0GW6lUU",
      "Id": "3KCS0GW6lUU",
      "StartDateTime": "2019-01-29T10:08:02.266-08:00",
      "EndDateTime": "2019-01-29T11:52:28-08:00",
      "Duration": 62657340000,
      "Title": ".NET Design Review: GitHub Quick Review and DbDataReader Additions",
      "ThumbnailUrl": "https://i.ytimg.com/vi/3KCS0GW6lUU/mqdefault.jpg"
    },
    "Title": "System.Data, System.Reflection.Emit, System.Runtime, System.Runtime.InteropServices, System.Runtime.Intrinsics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32959,
          "Title": "System.Reflection.Emit.Label should implement IEquatable",
          "Author": "terrajobst",
          "CreatedAt": "2018-10-22T19:04:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27697",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection.Emit",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32959#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34124,
          "Title": "Exception to throw when interface dispatch is ambiguous",
          "Author": "MichalStrehovsky",
          "CreatedAt": "2018-12-17T14:08:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28221",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458653253",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34124#issuecomment-458653253",
        "FeedbackMarkdown": "Looks good. A few things:\r\n\r\n* We should have a parameterless constructor\r\n* We should add the serialization contructor\r\n* We should add the inner exception constructor\r\n* We should mark the exception serializable\r\n* We should seal the type",
        "TimeCode": 1700000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34902,
          "Title": "Consider moving several HWIntrinsic instance methods to be extension methods",
          "Author": "tannergooding",
          "CreatedAt": "2019-01-28T16:12:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28542",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34902#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13650000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34881,
          "Title": "Take another look at the \u0060COMISS\u0060 and \u0060UCOMISS\u0060 hardware intrinisics",
          "Author": "tannergooding",
          "CreatedAt": "2019-01-26T23:28:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28533",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458659597",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34881#issuecomment-458659597",
        "FeedbackMarkdown": "A derivative of @benaadams suggestion @tannergooding suggested (where \u0060Xxx\u0060 is \u0060Equals\u0060, \u0060LessThan\u0060 etc):\r\n\r\n* CompareOrderedScalarXxx\r\n* CompareUnorderdScalarXxx",
        "TimeCode": 17920000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33279,
          "Title": "SafeBuffer Span\u003CT\u003E methods",
          "Author": "vcsjones",
          "CreatedAt": "2018-11-06T18:56:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27831",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33279#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24320000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31595,
          "Title": "Add string overloads to DbDataReader.Get*()",
          "Author": "roji",
          "CreatedAt": "2018-08-04T05:41:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27059",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458677042",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31595#issuecomment-458677042",
        "FeedbackMarkdown": "We concluded that we want to leave these ones off for now. The reason being that ADO.NET really wants to expose a \u0060ValueTask\u003CT\u003E\u0060 as opposed to \u0060Task\u003CT\u003E\u0060 but we\u0027ll need to revisit how we\u0027d plumb this through:\r\n\r\n\u0060\u0060\u0060C#\r\npublic Task\u003CT\u003E GetFieldValueAsync\u003CT\u003E(string name); // Forwards to CancellationToken \r\npublic Task\u003CT\u003E GetFieldValueAsync\u003CT\u003E(string name, CancellationToken cancellationToken);\r\npublic Task\u003Cbool\u003E IsDBNullAsync(string name); // Forwards to CancellationToken \r\npublic Task\u003Cbool\u003E IsDBNullAsync(string name, CancellationToken cancellationToken);\r\n\u0060\u0060\u0060\r\n\r\nThis one is a mistake:\r\n\r\n\u0060\u0060\u0060C#\r\npublic int GetProviderSpecificValues(object[] values);\r\n\u0060\u0060\u0060\r\n\r\nWhich leaves us with this:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class DbDataReader\r\n{        \r\n    public bool GetBoolean(string name);\r\n    public byte GetByte(string name);\r\n    public long GetBytes(string name, long dataOffset, byte[] buffer, int bufferOffset, int length);\r\n    public char GetChar(string name);\r\n    public long GetChars(string name, long dataOffset, char[] buffer, int bufferOffset, int length);\r\n    public DbDataReader GetData(string name);\r\n    public string GetDataTypeName(string name);\r\n    public DateTime GetDateTime(string name);\r\n    public DateTime GetDbDataReader(string name);\r\n    public decimal GetDecimal(string name);\r\n    public double GetDouble(string name);\r\n    public Type GetFieldType(string name);\r\n    public T GetFieldValue\u003CT\u003E(string name);\r\n    public float GetFloat(string name);\r\n    public Guid GetGuid(string name);\r\n    public short GetInt16(string name);\r\n    public int GetInt32(string name);\r\n    public long GetInt64(string name);\r\n    public Type GetProviderSpecificFieldType(string name);\r\n    public object GetProviderSpecificValue(string name);\r\n    public Stream GetStream(string name);\r\n    public string GetString(string name);\r\n    public TextReader GetTextReader(string name);\r\n    public object GetValue(string name);\r\n    public bool IsDBNull(string name);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27620000000,
        "Apis": [
          "M:DbDataReader.GetBoolean(string)",
          "M:DbDataReader.GetByte(string)",
          "M:DbDataReader.GetBytes(string,long,byte[],int,int)",
          "M:DbDataReader.GetChar(string)",
          "M:DbDataReader.GetChars(string,long,char[],int,int)",
          "M:DbDataReader.GetData(string)",
          "M:DbDataReader.GetDataTypeName(string)",
          "M:DbDataReader.GetDateTime(string)",
          "M:DbDataReader.GetDbDataReader(string)",
          "M:DbDataReader.GetDecimal(string)",
          "M:DbDataReader.GetDouble(string)",
          "M:DbDataReader.GetFieldType(string)",
          "M:DbDataReader.GetFieldValue\u003CT\u003E(string)",
          "M:DbDataReader.GetFloat(string)",
          "M:DbDataReader.GetGuid(string)",
          "M:DbDataReader.GetInt16(string)",
          "M:DbDataReader.GetInt32(string)",
          "M:DbDataReader.GetInt64(string)",
          "M:DbDataReader.GetProviderSpecificFieldType(string)",
          "M:DbDataReader.GetProviderSpecificValue(string)",
          "M:DbDataReader.GetStream(string)",
          "M:DbDataReader.GetString(string)",
          "M:DbDataReader.GetTextReader(string)",
          "M:DbDataReader.GetValue(string)",
          "M:DbDataReader.IsDBNull(string)",
          "T:DbDataReader"
        ]
      }
    ]
  },
  {
    "Id": 41,
    "Date": "2019-02-05T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=jfJkaggdGws",
      "Id": "jfJkaggdGws",
      "StartDateTime": "2019-02-05T09:55:27.116-08:00",
      "EndDateTime": "2019-02-05T12:01:01-08:00",
      "Duration": 75338840000,
      "Title": ".NET Design Review: GitHub Quick Review and UTF8 APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jfJkaggdGws/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34768,
          "Title": "Expose line number and byte position in line as public properties on Utf8JsonReader",
          "Author": "ahsonkhan",
          "CreatedAt": "2019-01-23T05:40:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28482",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460749514",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34768#issuecomment-460749514",
        "FeedbackMarkdown": "This looks useful. We discussed whether we should expose this on the state as well so that consumers can use that information when invalid schema information was found (rather than when the reader detects invalid JSON).\r\n\r\nThe current design has the unfortunate behavior that the line/byte position represents where the next token will start reading. Note that this isn\u0027t even the start of next token (due to skipped whitespace). Since schema validation requires the token to be read, it\u0027s always at the end of the token, rather than at the beginning.\r\n\r\n@ahsonkhan please explore what the documentation for these APIs would say to explaint their behavior. We can then review wether that\u0027s something developers will be able to reason about.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34794,
          "Title": "Option to support trailing commas with JsonReader",
          "Author": "ahsonkhan",
          "CreatedAt": "2019-01-24T01:24:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28493",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34794#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20010000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34690,
          "Title": "Add (Try)GetDateTime(Offset) to Utf8JsonReader and JsonDocument",
          "Author": "ahsonkhan",
          "CreatedAt": "2019-01-19T01:35:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28459",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460761972",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34690#issuecomment-460761972",
        "FeedbackMarkdown": "Looks good.\r\n\r\nWe should consider applying the same principle from the writer to the reader: the writer differentiates between the underlying primitive and the convenience conversion (e.g. \u0060WriteString\u0060 that takes a \u0060DateTime\u0060). For example, instead of \u0060GetDateTime()\u0060 we\u0027d have \u0060GetStringAsDateTime\u0060. That also makes it clear where we expect the value to come from, e.g. \u0060GetNumberAsInt32\u0060 makes it clear we won\u0027t parse the \u0060int\u0060 from a \u0060string\u0060. And it makes the reader and the writer more consistent.",
        "TimeCode": 26780000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34094,
          "Title": "System.Text.Utf8Char data type to represent UTF-8 text data",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-12-14T07:38:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28204",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460774440",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34094#issuecomment-460774440",
        "FeedbackMarkdown": "* We need to decide if we want -- or need -- language support, including built-in conversions. If so, we can\u0027t ship user defined operators.\r\n* Should the API be in \u0060System.Text\u0060? We probably want to align this choice wherever we\u0027ll think we\u0027ll want to ship the UTF8 string type.\r\n* How should we name the type? We probably want to align this choice with the UTF8 string support and the language support.\r\n* Does this type need consideration for marshaling? We\u0027ll want to makes sure that the behavior we have in 3.0 we don\u0027t need to change later.\r\n\r\nIt seems as a next step we should have a meeting with the language folks.",
        "TimeCode": 40650000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34822,
          "Title": "Rune.DecodeFirstRune and friends",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-01-24T22:49:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28504",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460780898",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34822#issuecomment-460780898",
        "FeedbackMarkdown": "Looks good.\r\n\r\n* We\u0027ll have to make sure that the \u0060out\u0060 parameter \u0060charsConsumed\u0060 makes sense with the final name of \u0060Utf8Char\u0060. If it doesn\u0027t have \u0060char\u0060 in the name. Alternatively, we could decide to use something like \u0060consumedCount\u0060 that implies that it\u0027s number of elements, regardless of the type.\r\n\r\n\u0060\u0060\u0060C#\r\npublic static OperationStatus Decode(ReadOnlySpan\u003Cchar\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus Decode(ReadOnlySpan\u003CUtf8Char\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus DecodeFromEnd(ReadOnlySpan\u003Cchar\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus DecodeFromEnd(ReadOnlySpan\u003CUtf8Char\u003E source, out Rune result, out int charsConsumed);\r\n\u0060\u0060\u0060\r\n\r\n@KrzysztofCwalina, do you have an opinion on the name of the \u0060out\u0060 parameter?",
        "TimeCode": 61630000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 42,
    "Date": "2019-02-07T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=9TSP4awoHuI",
      "Id": "9TSP4awoHuI",
      "StartDateTime": "2019-02-07T10:06:38.252-08:00",
      "EndDateTime": "2019-02-07T11:39:57-08:00",
      "Duration": 55987480000,
      "Title": ".NET Design Review:  PipeReader and PipeWriter implementations over a Stream",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9TSP4awoHuI/mqdefault.jpg"
    },
    "Title": "System.IO.Pipelines",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27246,
          "Title": "PipeReader and PipeWriter implementations over a Stream",
          "Author": "davidfowl",
          "CreatedAt": "2018-02-19T05:13:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25087",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-07T00:00:00-08:00",
        "FeedbackId": "461567272",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27246#issuecomment-461567272",
        "FeedbackMarkdown": "Notes are here: https://github.com/dotnet/apireviews/pull/90",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 43,
    "Date": "2019-02-22T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=0ReXmy2bQvQ",
      "Id": "0ReXmy2bQvQ",
      "StartDateTime": "2019-02-22T10:11:23.946-08:00",
      "EndDateTime": "2019-02-22T11:02:17-08:00",
      "Duration": 30530540000,
      "Title": ".NET Design Review: UTF8 APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/0ReXmy2bQvQ/mqdefault.jpg"
    },
    "Title": "System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34826,
          "Title": "Complex Rune enumeration over spans of UTF-16 and UTF-8 text",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-01-25T00:19:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28507",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-22T00:00:00-08:00",
        "FeedbackId": "466507394",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34826#issuecomment-466507394",
        "FeedbackMarkdown": "* \u0060RunPosition\u0060\r\n    - We considered swapping \u0060rune\u0060 and \u0060startIndex\u0060 in the deconstruct method\r\n      to match Go, but decided against it because we also expose \u0060length\u0060 and\r\n      the order \u0060startIndex\u0060, \u0060rune\u0060, \u0060length\u0060 would be very weird.\r\n    - We should have a constructor that sets all four fields\r\n* \u0060Rune\u0060\r\n    - We should move the enumerate methods to \u0060RunePosition\u0060, which allows\r\n      making the names shorter\r\n\r\n        \u0060\u0060\u0060C#\r\n        public readonly struct RunPosition\r\n        {\r\n            public static Utf16Enumerator EnumerateUtf16(ReadOnlySpan\u003Cchar\u003E span);\r\n            public static Utf8Enumerator EnumerateUtf8(ReadOnlySpan\u003Cbyte\u003E span);\r\n\r\n            public ref struct Utf8Enumerator;\r\n            public ref struct Utf16Enumerator;\r\n        }\r\n        \u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:RunPosition.EnumerateUtf16(ReadOnlySpan\u003Cchar\u003E)",
          "M:RunPosition.EnumerateUtf8(ReadOnlySpan\u003Cbyte\u003E)",
          "T:RunPosition",
          "T:RunPosition.Utf16Enumerator",
          "T:RunPosition.Utf8Enumerator"
        ]
      }
    ]
  },
  {
    "Id": 44,
    "Date": "2019-02-26T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=qlj29o0R1rs",
      "Id": "qlj29o0R1rs",
      "StartDateTime": "2019-02-26T10:05:41.685-08:00",
      "EndDateTime": "2019-02-26T12:04:28-08:00",
      "Duration": 71263150000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/qlj29o0R1rs/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Runtime.CompilerServices, System.Runtime.Intrinsics, System.Security, System.Text.Encodings.Web",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33602,
          "Title": "Obsolete string.Copy(string) method",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-11-19T19:16:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27957",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467551787",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33602#issuecomment-467551787",
        "FeedbackMarkdown": "We should mark this obsolete in .NET Standard as well. I\u0027ll submit the PR for that.\r\n\r\n@GrabYourPitchforks are you on the hook for cleaning up any call sites in CoreFX?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35419,
          "Title": "Proposal: Expose existing BitOps methods",
          "Author": "grant-d",
          "CreatedAt": "2019-02-19T19:39:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28725",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467557134",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35419#issuecomment-467557134",
        "FeedbackMarkdown": "Having a separate type makes sense as the existing types don\u0027t make sense (\u0060Math\u0060, \u0060BitConverter\u0060). We shouldn\u0027t put it in the \u0060System\u0060 namespace though?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static partial class BitOperations\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7110000000,
        "Apis": [
          "T:BitOperations"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35508,
          "Title": "Consider removing Range.OffsetAndLength",
          "Author": "terrajobst",
          "CreatedAt": "2019-02-21T23:18:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28758",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35508#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 15910000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35560,
          "Title": "Remove some unnecessary HWIntrinsic API overloads",
          "Author": "tannergooding",
          "CreatedAt": "2019-02-25T16:22:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28781",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35560#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19060000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35530,
          "Title": "Add Rune.TryEncodeToUtf8Bytes",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-02-22T21:28:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28767",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467570023",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35530#issuecomment-467570023",
        "FeedbackMarkdown": "Looks good, minor suggestion from review:\r\n\r\n\u0060\u0060\u0060C#\r\nbool TryEncodeAsUtf8(...);\r\n\u0060\u0060\u0060\r\n\r\n@GrabYourPitchforks should we also add a non-\u0060Try\u0060 version that throws?",
        "TimeCode": 33420000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34366,
          "Title": "EnvelopedCms encryption with RSA padding modes",
          "Author": "vcsjones",
          "CreatedAt": "2019-01-04T19:30:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28322",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34366#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 36740000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34830,
          "Title": "UTF-8 web encoders",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-01-25T02:31:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28509",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encodings.Web",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467582155",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34830#issuecomment-467582155",
        "FeedbackMarkdown": "After giving it more thought, we\u0027d prefer the alternative proposal, meaning having a single class hierarchy for UTF16 and UTF8.\r\n\r\nThere are two ways to do the alternative:\r\n\r\n1. Completely additive, i.e. non-breaking.\r\n2. Redo the abstract members to make it sane (avoid \u0060char*\u0060 and encoding agnostic API pattern).\r\n\r\n@GrabYourPitchforks, please send me a mail with a write-up on the justification for the breaking change and I\u0027ll help you getting this approved by whoever is in charge for that :-)",
        "TimeCode": 41570000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34258,
          "Title": "Unsafe.Unbox should return \u0022ref readonly T\u0022, not \u0022ref T\u0022",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-12-27T15:43:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28278",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467591284",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34258#issuecomment-467591284",
        "FeedbackMarkdown": "It seems \u0060ref\u0060 is a closer match. There is nuance, and that is sufficiently addressed by the \u0060Unsafe\u0060 name plus proper documentation.\r\n\r\n@GrabYourPitchforks, could you file a doc bug / submit a PR?",
        "TimeCode": 55910000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 45,
    "Date": "2019-03-12T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=aaFcBs6cFqg",
      "Id": "aaFcBs6cFqg",
      "StartDateTime": "2019-03-12T10:10:28.639-07:00",
      "EndDateTime": "2019-03-12T12:20:04-07:00",
      "Duration": 77753610000,
      "Title": ".NET Design Review: Tensor",
      "ThumbnailUrl": "https://i.ytimg.com/vi/aaFcBs6cFqg/mqdefault.jpg"
    },
    "Title": "System.Collections",
    "Items": [
      {
        "Id": 1,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32987,
          "Title": "Add remove Range to sorted List",
          "Author": "hernot",
          "CreatedAt": "2018-10-23T19:13:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27713",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-12T00:00:00-07:00",
        "FeedbackId": "472132435",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32987#issuecomment-472132435",
        "FeedbackMarkdown": "@hernot could you please update the issue to include a formal api proposal? I think it makes sense to have this API but we need to include Rationale and Usage. Once you\u0027ve done that I can bring it over to API Review to get its approval and then implement it. \r\n\r\nHere is an example of an API Proposal: https://github.com/dotnet/corefx/issues/30953#issue-339950811",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 46,
    "Date": "2019-03-19T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=vHqgsQ23GRg",
      "Id": "vHqgsQ23GRg",
      "StartDateTime": "2019-03-19T10:03:00.909-07:00",
      "EndDateTime": "2019-03-19T12:03:58-07:00",
      "Duration": 72570910000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/vHqgsQ23GRg/mqdefault.jpg"
    },
    "Title": "System.Drawing, System.IO, System.Net.Security, System.Runtime, System.Text.Json, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31570,
          "Title": "Make internal directory separator helpers public",
          "Author": "cdmihai",
          "CreatedAt": "2018-08-02T23:59:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27053",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31570#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34252,
          "Title": "ColorConverter in System.ComponentModel.TypeConverters does not handle SystemColors",
          "Author": "DustinCampbell",
          "CreatedAt": "2018-12-26T23:34:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28272",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Drawing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34252#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 18750000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35145,
          "Title": "Rename Range to IndexRange",
          "Author": "YohDeadfall",
          "CreatedAt": "2019-02-07T09:27:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28637",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474491396",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35145#issuecomment-474491396",
        "FeedbackMarkdown": "We discussed this today but we feel it\u0027s too late to make this change now.",
        "TimeCode": 22980000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8173,
          "Title": "Simpler way to specify leaveOpen in StreamWriter constructor",
          "Author": "svick",
          "CreatedAt": "2016-04-29T16:53:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17157",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474495698",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8173#issuecomment-474495698",
        "FeedbackMarkdown": "Just realized that adding a bool would butt heads with \u0060StreamReader(Stream, bool)\u0060. Need to look at this a bit more to see if we can come up with a pattern that will work well across our readers/writers.",
        "TimeCode": 25680000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33295,
          "Title": "Implement Utf8JsonReader.Skip() with support for incomplete data",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-11-07T04:46:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27838",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474501111",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33295#issuecomment-474501111",
        "FeedbackMarkdown": "\u0060TrySkip()\u0060 is unfortunate because it\u0027s an unbounded buffering read; compared to calling \u0060Read()\u0060 which would throw data away as you go. That looks like a perf trap. But it\u0027s convenient so let\u0027s keep it.\r\n\r\nWe shouldn\u0027t do \u0060Skip()\u0060 because callers typically can\u0027t know whether it\u0027s the final block.\r\n\r\nThe \u0060TrySkipToDepth(int targetDepth)\u0060 API seems fine. Skipping is a weird term, but hey, that\u0027s the term everyone else is using so let\u0027s keep that.",
        "TimeCode": 28870000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35500,
          "Title": "Add APIs for some threading metrics",
          "Author": "kouvel",
          "CreatedAt": "2019-02-21T20:30:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28755",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474513603",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35500#issuecomment-474513603",
        "FeedbackMarkdown": "Looks good.\r\n\r\nThe only concern is about local vs. global. Unless there is a specific scenario needing the differentiation. If there isn\u0027t we should just expose the total.",
        "TimeCode": 36360000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34867,
          "Title": "Add SslStream.NegotiatedCipherSuite",
          "Author": "krwq",
          "CreatedAt": "2019-01-25T22:46:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28527",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474516862",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34867#issuecomment-474516862",
        "FeedbackMarkdown": "This does *NOT* look good, but it seems we have issues with adjacent numbers that we\u0027ll have to to separate by underscores. Given that this means this enum will never look \u0022.NET-ty\u0022, and that like five people in the world will care about this API, we might as well expose the IANA names.\r\n\r\nEvery time I\u0027ll be looking at this, I\u0027ll throw up in little my mouth, but hey. Approved.\r\n\r\nWe should make \u0060NegotiatedCipherSuite\u0060 nullable in cases we can\u0027t determine the TLS cipher. The API might also throw if it wasn\u0027t negotiated that.",
        "TimeCode": 49590000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 47,
    "Date": "2019-03-26T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=SNc-nABLZws",
      "Id": "SNc-nABLZws",
      "StartDateTime": "2019-03-26T11:08:12.558-07:00",
      "EndDateTime": "2019-03-26T11:51:51-07:00",
      "Duration": 26184420000,
      "Title": ".NET Design Review: AssemblyLoadContext improvements",
      "ThumbnailUrl": "https://i.ytimg.com/vi/SNc-nABLZws/mqdefault.jpg"
    },
    "Title": "System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36236,
          "Title": "API proposal AssemblyLoadContext.ActiveForContextSensitiveReflection",
          "Author": "sdmaclea",
          "CreatedAt": "2019-03-22T16:41:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29042",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-26T00:00:00-07:00",
        "FeedbackId": "476796579",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36236#issuecomment-476796579",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Loader\r\n{\r\n    public partial class AssemblyLoadContext\r\n    {\r\n        public static AssemblyLoadContext CurrentContextualReflectionContext { get; }\r\n\r\n        public ContextualReflectionScope EnterContextualReflection();\r\n        static public ContextualReflectionScope EnterContextualReflection(Assembly activating);\r\n\r\n        [EditorBrowsable(Never)]\r\n        public struct ContextualReflectionScope : IDisposable\r\n        {\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AssemblyLoadContext.EnterContextualReflection()",
          "M:AssemblyLoadContext.EnterContextualReflection(Assembly)",
          "P:AssemblyLoadContext.CurrentContextualReflectionContext",
          "T:AssemblyLoadContext",
          "T:AssemblyLoadContext.ContextualReflectionScope"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34791,
          "Title": "AssemblyLoadContext .NET Core 3.0 improvements",
          "Author": "sdmaclea",
          "CreatedAt": "2019-01-23T23:28:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28491",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2019-03-26T00:00:00-07:00",
        "FeedbackId": "476796715",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34791#issuecomment-476796715",
        "FeedbackMarkdown": "* Replace \u0060AssemblyLoadContext.Contexts\u0060 with \u0060AssemblyLoadContext.All\u0060 to make \u0060foreach\u0060 easier to read\r\n* Other than that, looks good as proposed",
        "TimeCode": 25760000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 48,
    "Date": "2019-03-28T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=_Uq0qG3KAzg",
      "Id": "_Uq0qG3KAzg",
      "StartDateTime": "2019-03-28T10:09:59.066-07:00",
      "EndDateTime": "2019-03-28T11:02:59-07:00",
      "Duration": 31799340000,
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_Uq0qG3KAzg/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36148,
          "Title": "Build a JsonDocument from an already positioned Utf8JsonReader",
          "Author": "bartonjs",
          "CreatedAt": "2019-03-19T15:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29008",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-28T00:00:00-07:00",
        "FeedbackId": "477696501",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36148#issuecomment-477696501",
        "FeedbackMarkdown": "We should have a consistent naming with the \u0060Parse\u0060 methods. We suggest to go with \u0060ParseValue\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class JsonDocument\r\n{\r\n    public static bool TryParseValue(ref Utf8JsonReader reader, out JsonDocument document);\r\n    public static JsonDocument ParseValue(ref Utf8JsonReader reader);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonDocument.ParseValue(ref Utf8JsonReader)",
          "M:JsonDocument.TryParseValue(ref Utf8JsonReader,out JsonDocument)",
          "T:JsonDocument"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36153,
          "Title": "Utf8JsonWriter and JsonElement, redux",
          "Author": "bartonjs",
          "CreatedAt": "2019-03-19T16:04:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29012",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-03-28T00:00:00-07:00",
        "FeedbackId": "477705735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36153#issuecomment-477705735",
        "FeedbackMarkdown": "Usability wise, this proposal seems less than ideal. Not sure I personal buy the layering argument, but if we feel strongly we should rename the method and swap the arguments:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial struct JsonElement\r\n{\r\n    public void WriteAsValue(ref Utf8JsonWriter writer);\r\n    public void WriteAsProperty(ReadOnlySpan\u003Cchar\u003E propertyName, ref Utf8JsonWriter writer);\r\n    public void WriteAsProperty(ReadOnlySpan\u003Cbyte\u003E utf8PropertyName, ref Utf8JsonWriter writer);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12900000000,
        "Apis": [
          "M:JsonElement.WriteAsProperty(ReadOnlySpan\u003Cbyte\u003E,ref Utf8JsonWriter)",
          "M:JsonElement.WriteAsProperty(ReadOnlySpan\u003Cchar\u003E,ref Utf8JsonWriter)",
          "M:JsonElement.WriteAsValue(ref Utf8JsonWriter)",
          "T:JsonElement"
        ]
      }
    ]
  },
  {
    "Id": 49,
    "Date": "2019-04-02T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=x5vbM3zB0_I",
      "Id": "x5vbM3zB0_I",
      "StartDateTime": "2019-04-02T10:03:59.732-07:00",
      "EndDateTime": "2019-04-02T12:02:26-07:00",
      "Duration": 71062680000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/x5vbM3zB0_I/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Tracing, System.IO, System.Net.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36129,
          "Title": "Evolving EventCounter API",
          "Author": "sywhang",
          "CreatedAt": "2019-03-18T21:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29001",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479128603",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36129#issuecomment-479128603",
        "FeedbackMarkdown": "* MetaData -\u003E \u0060Metadata\u0060\r\n* \u0060AddMetaData\u0060 to \u0060SetMetaData\r\n* Add a \u0060DiagnosticCounter\u0060 abstract base\r\n    - Have protected ctor that accepts the name and \u0060EventSource\u0060\r\n    - Add \u0060Name\u0060 get-only property\r\n    - Add \u0060EventSource\u0060 get-only property\r\n    - Add \u0060DisplayName\u0060 get/set property\r\n    - Add abstract \u0060SetMetadata(string key, string value) method\r\n    - All counters, including the existing \u0060EventCounter\u0060 should inherit from it\r\n* \u0060getMetricFunction\u0060 -\u003E \u0060metricProvider\u0060\r\n* \u0060getCountFunction\u0060 -\u003E \u0060totalValueProvider\u0060\r\n* We should consider using \u0060double\u0060 instead of \u0060float\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33809,
          "Title": "API: SSLStream Allow Configuration of CipherSuites",
          "Author": "krwq",
          "CreatedAt": "2018-12-04T01:32:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28048",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479132747",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33809#issuecomment-479132747",
        "FeedbackMarkdown": "Going through the builder feels odd; especially because it doesn\u0027t itself represent a collection. It seems more natural to do something like:\r\n\r\n\u0060\u0060\u0060C#\r\npublic sealed class CipherSuitesPolicy\r\n{\r\n    public CipherSuitesPolicy(IEnumerable\u003CTlsCipherSuite\u003E allowedCipherSuites);\r\n\r\n    public IEnumerable\u003CTlsCipherSuite\u003E AllowedCipherSuites { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIt was proposed to apply hide the \u0060AllowedCipherSuites\u0060 property from other types; we don\u0027t believe that\u0027s the way to give guidance. Rather, we should document the API, provide relevant guidance developers are likely searching for (e.g. \u0022How to properly configure SSL with TLS\u0022). We should also invest in an analyzer.",
        "TimeCode": 42580000000,
        "Apis": [
          "M:CipherSuitesPolicy.CipherSuitesPolicy(IEnumerable\u003CTlsCipherSuite\u003E)",
          "P:CipherSuitesPolicy.AllowedCipherSuites",
          "T:CipherSuitesPolicy"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8173,
          "Title": "Simpler way to specify leaveOpen in StreamWriter constructor",
          "Author": "svick",
          "CreatedAt": "2016-04-29T16:53:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17157",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479149933",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8173#issuecomment-479149933",
        "FeedbackMarkdown": "We\u0027d prefer the first option (i.e. default constructors), reason being:\r\n\r\n1. It works for all settings, including the ones that we can\u0027t change after construction\r\n2. We can apply it elsewhere, such as \u0060FileStream\u0060\r\n\r\nThe counter argument is that it might make it harder for folks to find bugs because we\u0027d now accept \u0060null\u0060, but that\u0027s already the case in the framework. Hopefully, non-nullable reference types can help with that.",
        "TimeCode": 50890000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 50,
    "Date": "2019-04-09T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=BgF2UKtQjWA",
      "Id": "BgF2UKtQjWA",
      "StartDateTime": "2019-04-09T10:05:40.561-07:00",
      "EndDateTime": "2019-04-09T11:31:50-07:00",
      "Duration": 51694390000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BgF2UKtQjWA/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Runtime.Intrinsics, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34631,
          "Title": "Making the info GC.GetMemoryInfo provides public",
          "Author": "Maoni0",
          "CreatedAt": "2019-01-16T21:27:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28439",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481358549",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34631#issuecomment-481358549",
        "FeedbackMarkdown": "Looks good! Comments from the review:\r\n\r\n* \u0060GCMemoryInfo\u0060 should be marked readonly\r\n* We should suffix all members with \u0060Bytes\u0060\r\n* We should normalzie all values into bytes\r\n* \u0060HighMemoryLoadThreshold\u0060 should return \u0060long\u0060 and be named \u0060HighMemoryLoadThresholdBytes\u0060\r\n* \u0060MemoryLoad\u0060 should return \u0060long\u0060 and be named \u0060MemoryLoadBytes\u0060\r\n* \u0060Fragmentation\u0060 should be \u0060FragmentedBytes\u0060\r\n* \u0060GetTotalAllocatedBytes()\u0060 should default the parameter to \u0060false\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35972,
          "Title": "Revisit Index/Range API requirements",
          "Author": "terrajobst",
          "CreatedAt": "2019-03-11T23:55:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28939",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35972#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 22350000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35768,
          "Title": "VPMOVZXBD and friends need pointer-based overloads",
          "Author": "saucecontrol",
          "CreatedAt": "2019-03-04T22:48:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28868",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35768#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29670000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34881,
          "Title": "Take another look at the \u0060COMISS\u0060 and \u0060UCOMISS\u0060 hardware intrinisics",
          "Author": "tannergooding",
          "CreatedAt": "2019-01-26T23:28:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28533",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481371966",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34881#issuecomment-481371966",
        "FeedbackMarkdown": "Works for us.",
        "TimeCode": 41450000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36152,
          "Title": "Clarity and control on a JsonDocument lifetime",
          "Author": "bartonjs",
          "CreatedAt": "2019-03-19T15:49:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29011",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481375975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36152#issuecomment-481375975",
        "FeedbackMarkdown": "Let\u0027s remove \u0060IsPersistable\u0060 for now and make \u0060Clone()\u0060 a no-op. This way, callers can always call \u0060Clone()\u0060 before storing it.",
        "TimeCode": 44230000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 51,
    "Date": "2019-04-16T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=M1Hc0qrL_Oo",
      "Id": "M1Hc0qrL_Oo",
      "StartDateTime": "2019-04-16T10:07:33.958-07:00",
      "EndDateTime": "2019-04-16T11:01:23-07:00",
      "Duration": 32290420000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/M1Hc0qrL_Oo/mqdefault.jpg"
    },
    "Title": "System.Data, System.Diagnostics.Tracing, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36351,
          "Title": "Json serializer support for a property name policy",
          "Author": "steveharter",
          "CreatedAt": "2019-03-25T23:26:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29063",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483773918",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36351#issuecomment-483773918",
        "FeedbackMarkdown": "* \u0060JsonNamePolicy\u0060 should have a protected constructor\r\n* For \u0060PropertyNameCaseInsensitive\u0060 we need to think about how we match names (comparisons and normalization aren\u0027t yielding the same results). @GrabYourPitchforks and @steveharter should chat.\r\n* The \u0060ConvertName()\u0060 method produces strings but that seems fine because they are going to be cached.\r\n* The code calling \u0060ConvertName()\u0060 should disallow \u0060null\u0060 values, but must accept empty strings. Likewise, \u0060ConvertName()\u0060 should be documented as  disallowing \u0060null\u0060 values but as accepting empty strings.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36129,
          "Title": "Evolving EventCounter API",
          "Author": "sywhang",
          "CreatedAt": "2019-03-18T21:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29001",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483778953",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36129#issuecomment-483778953",
        "FeedbackMarkdown": "The APIs were exposed via https://github.com/dotnet/coreclr/pull/23808 and all the changes discussed during the API review were implemented.",
        "TimeCode": 23310000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35012,
          "Title": "Add missing async methods in System.Data.Common and implement IAsyncDisposable",
          "Author": "roji",
          "CreatedAt": "2019-02-01T00:40:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28596",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483779404",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35012#issuecomment-483779404",
        "FeedbackMarkdown": "@roji @divega\r\n\r\n* What does it mean to cancel \u0060CancelAsync()\u0060? Also, how is calling \u0060CancelAsync()\u0060 different from cancelling the cancellation token that was passed to the operation that \u0060CancelAsync()\u0060 would cancel?\r\n* Is there a reason why \u0060CloseAsync()\u0060 returns \u0060ValueTask\u0060? It doesn\u0027t seem to on the perf critical path?\r\n* Should we really add \u0060DbDataReader.CloseAsync()\u0060 seems odd to add an API that is known to be not useful.",
        "TimeCode": 29110000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 52,
    "Date": "2019-04-23T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=5heMq4U2ek8",
      "Id": "5heMq4U2ek8",
      "StartDateTime": "2019-04-23T11:11:00.351-07:00",
      "EndDateTime": "2019-04-23T12:07:49-07:00",
      "Duration": 34086490000,
      "Title": ".NET Design Review: RESX",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5heMq4U2ek8/mqdefault.jpg"
    },
    "Title": "System.Resources",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37041,
          "Title": "System.Resources API additions for non-primitive objects",
          "Author": "ericstj",
          "CreatedAt": "2019-04-19T20:55:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29324",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Resources",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-23T00:00:00-07:00",
        "FeedbackId": "485934735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37041#issuecomment-485934735",
        "FeedbackMarkdown": "Looks good:\r\n\r\n* Seal the types and make the protected members private or remove them\r\n* \u0060closeAfterWrite\u0060 should be defaulted\r\n* Remove the \u0060TypeNameConverter\u0060, assuming MSBuild doens\u0027t need it",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 53,
    "Date": "2019-04-25T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=byHU4Ube7fg",
      "Id": "byHU4Ube7fg",
      "StartDateTime": "2019-04-25T11:02:15.48-07:00",
      "EndDateTime": "2019-04-25T12:00:29-07:00",
      "Duration": 34935200000,
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/byHU4Ube7fg/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33967,
          "Title": "Should Utf8JsonReader expose TokenStartIndex?",
          "Author": "bartonjs",
          "CreatedAt": "2018-12-10T22:25:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28131",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33967#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 54,
    "Date": "2019-04-30T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=jQjHzmAomLE",
      "Id": "jQjHzmAomLE",
      "StartDateTime": "2019-04-30T10:01:28.906-07:00",
      "EndDateTime": "2019-04-30T11:02:07-07:00",
      "Duration": 36380940000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jQjHzmAomLE/mqdefault.jpg"
    },
    "Title": "System.Net.Http, System.Net.Sockets",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36553,
          "Title": "Implement global proxy configuration for HttpClient",
          "Author": "davidsh",
          "CreatedAt": "2019-04-03T04:29:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29147",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36553#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37224,
          "Title": "Proposal: HttpClient.DefaultRequestVersion",
          "Author": "stephentoub",
          "CreatedAt": "2019-04-26T15:45:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29389",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37224#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20590000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35143,
          "Title": "add Netlink, Packet and Can to AddressFamily and ProtocolFamily enum",
          "Author": "wfurt",
          "CreatedAt": "2019-02-07T04:29:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28636",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "488053098",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35143#issuecomment-488053098",
        "FeedbackMarkdown": "We should rename \u0060Can\u0060 to \u0060ControllerAreaNetwork\u0060 to avoid confusion with it being a word in English. \u0060Packet\u0060 seems generic, but we can\u0027t think of a better, so it\u0027s fine.",
        "TimeCode": 28660000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 55,
    "Date": "2019-05-14T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=cP2E0gSe8is",
      "Id": "cP2E0gSe8is",
      "StartDateTime": "2019-05-14T10:08:24.891-07:00",
      "EndDateTime": "2019-05-14T11:11:06-07:00",
      "Duration": 37611090000,
      "Title": ".NET Design Review: System.Data",
      "ThumbnailUrl": "https://i.ytimg.com/vi/cP2E0gSe8is/mqdefault.jpg"
    },
    "Title": "System.Data",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35012,
          "Title": "Add missing async methods in System.Data.Common and implement IAsyncDisposable",
          "Author": "roji",
          "CreatedAt": "2019-02-01T00:40:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28596",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "492336595",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35012#issuecomment-492336595",
        "FeedbackMarkdown": "* To follow the existing pattern, \u0060BeginConnection\u0060 should be non-virtual and we should add a single BeginDbConnectionAsync that takes an isolation level\r\n* Consider for reach API whether you want \u0060Task\u003CT\u003E\u0060 or \u0060ValueTask\u003CT\u003E\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35564,
          "Title": "Add missing feature detection properties to DbProviderFactory",
          "Author": "roji",
          "CreatedAt": "2019-02-25T18:47:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28785",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35564#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 18750000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35135,
          "Title": "New System.Data.Common batching API",
          "Author": "roji",
          "CreatedAt": "2019-02-06T16:44:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28633",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "492347155",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35135#issuecomment-492347155",
        "FeedbackMarkdown": "* Have you considered making \u0060DbBatch\u0060 extend \u0060DbCommand\u0060?\r\n* \u0060IList\u003CDbBatchCommand\u003E\u0060 should probably be \u0060DbBatchCollection : Collection\u003CDbBatch\u003E\u0060\r\n* Validate this against multiple providers; shipping a new concept is best validated by having multiple implementations.",
        "TimeCode": 21710000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 56,
    "Date": "2019-05-21T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=zAhOxraBsi0",
      "Id": "zAhOxraBsi0",
      "StartDateTime": "2019-05-21T10:06:10.035-07:00",
      "EndDateTime": "2019-05-21T11:34:27-07:00",
      "Duration": 52969650000,
      "Title": ".NET Design Review: Nullable Annotation Attributes",
      "ThumbnailUrl": "https://i.ytimg.com/vi/zAhOxraBsi0/mqdefault.jpg"
    },
    "Title": "System.Diagnostics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37826,
          "Title": "Attributes for nullable annotations",
          "Author": "terrajobst",
          "CreatedAt": "2019-05-20T22:46:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29617",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-21T00:00:00-07:00",
        "FeedbackId": "494505569",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37826#issuecomment-494505569",
        "FeedbackMarkdown": "Summary:\r\n\r\n* We didn\u0027t want to put them in compiler services, because most APIs aren\u0027t meant to be used by developers.\r\n* \u0060NullableAttribute\u0060 (emitted by the compiler for question marks) will still go to compiler services.\r\n* We decided to go with the existing \u0060System.Diagnostics.CodeAnalysis\u0060 namespace\r\n* Since the new namespace is low in terms of types, we decided that we don\u0027t need a base type\r\n\r\nHere is the API shape we agreed on:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis \r\n{\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property)]\r\n    public sealed class AllowNullAttribute : Attribute\r\n    {    \t\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property)]\r\n    public sealed class DisallowNullAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue)]\r\n    public sealed class MaybeNullAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue)]\r\n    public sealed class NotNullAttribute : Attribute\r\n    {    \t\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class MaybeNullWhenAttribute : Attribute\r\n    {\r\n        public MaybeNullWhenAttribute(bool returnValue);\r\n        public bool ReturnValue { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class NotNullWhenAttribute : Attribute\r\n    {\r\n        public NotNullWhenAttribute(bool returnValue);\r\n        public bool ReturnValue { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue, AllowMultiple = true)]\r\n    public sealed class NotNullIfNotNullAttribute : Attribute\r\n    {\r\n        public NotNullIfNotNullAttribute(string parameterName);\r\n        public string ParameterName { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor)]\r\n    public sealed class DoesNotReturnAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class DoesNotReturnIfAttribute : Attribute\r\n    {\r\n        public DoesNotReturnIfAttribute(bool parameterValue);\r\n        public bool ParameterValue { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DoesNotReturnIfAttribute.DoesNotReturnIfAttribute(bool)",
          "M:MaybeNullWhenAttribute.MaybeNullWhenAttribute(bool)",
          "M:NotNullIfNotNullAttribute.NotNullIfNotNullAttribute(string)",
          "M:NotNullWhenAttribute.NotNullWhenAttribute(bool)",
          "P:DoesNotReturnIfAttribute.ParameterValue",
          "P:MaybeNullWhenAttribute.ReturnValue",
          "P:NotNullIfNotNullAttribute.ParameterName",
          "P:NotNullWhenAttribute.ReturnValue",
          "T:AllowNullAttribute",
          "T:DisallowNullAttribute",
          "T:DoesNotReturnAttribute",
          "T:DoesNotReturnIfAttribute",
          "T:MaybeNullAttribute",
          "T:MaybeNullWhenAttribute",
          "T:NotNullAttribute",
          "T:NotNullIfNotNullAttribute",
          "T:NotNullWhenAttribute"
        ]
      }
    ]
  },
  {
    "Id": 57,
    "Date": "2019-05-28T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=_VAq-ORjkqk",
      "Id": "_VAq-ORjkqk",
      "StartDateTime": "2019-05-28T09:57:26.748-07:00",
      "EndDateTime": "2019-05-28T11:01:22-07:00",
      "Duration": 38352520000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_VAq-ORjkqk/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Tracing, System.IO.Pipelines, System.Net.Security, System.Runtime, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35283,
          "Title": "SslStream.AuthenticateAsServer/ClientAsync methods should default CancellationToken to default(CancellationToken)",
          "Author": "geoffkizer",
          "CreatedAt": "2019-02-13T03:41:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28677",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496610570",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35283#issuecomment-496610570",
        "FeedbackMarkdown": "We should. Looks good.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35499,
          "Title": "Add Environment.LongTickCount",
          "Author": "geoffkizer",
          "CreatedAt": "2019-02-21T20:10:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28754",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496612786",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35499#issuecomment-496612786",
        "FeedbackMarkdown": "And we landed on:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class Environment\r\n{\r\n    public static long TickCount64 { get; }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16030000000,
        "Apis": [
          "P:Environment.TickCount64",
          "T:Environment"
        ]
      },
      {
        "Id": 3,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36741,
          "Title": "Consider moving RuntimeHelper.GetSubArray to Array",
          "Author": "terrajobst",
          "CreatedAt": "2019-04-09T18:08:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29218",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496613684",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36741#issuecomment-496613684",
        "FeedbackMarkdown": "Since we don\u0027t feel super strongly and the compiler would need to change, we\u0027re leaving it where it is.",
        "TimeCode": 19210000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37396,
          "Title": "Remove in and readonly ref from Activity apis",
          "Author": "benaadams",
          "CreatedAt": "2019-05-03T03:47:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29441",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496615275",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37396#issuecomment-496615275",
        "FeedbackMarkdown": "@tommcdon / @noahfalk / @sywhang are you OK with this? This change looks good to us.",
        "TimeCode": 20660000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37534,
          "Title": "Comparing Utf8JsonReader to default instance with the == operator",
          "Author": "ahsonkhan",
          "CreatedAt": "2019-05-09T05:00:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29488",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496618927",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37534#issuecomment-496618927",
        "FeedbackMarkdown": "We certainly don\u0027t want the comparison operators as they feel hard to define. \u0060IsDefault\u0060 feels OK \u0026 consistent, but we\u0027re unsure how much value this adds. Why can\u0027t the receive just read? Why is the validation necessary? Why is the \u0060Try\u0060-pattern not sufficient?\r\n\r\nFor now, we\u0027re deciding to not take the API. If you feel differently, please re-open and answer the above questions.",
        "TimeCode": 23270000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37701,
          "Title": "StreamPipeReader/Writer should allow to leave underlying stream opened",
          "Author": "azhmur",
          "CreatedAt": "2019-05-16T08:14:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29569",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496622595",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37701#issuecomment-496622595",
        "FeedbackMarkdown": "The API shape as outlined by @anurse\u0027s [comment](https://github.com/dotnet/corefx/issues/37701#issuecomment-495461474) looks good.\r\n\r\n@tannergooding has filed a separate bug for removing the explicit buffer sizes and instead use sentinels so we can change their values later.",
        "TimeCode": 29730000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 58,
    "Date": "2019-05-30T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=EVUtzNK3tdA",
      "Id": "EVUtzNK3tdA",
      "StartDateTime": "2019-05-30T10:03:48.916-07:00",
      "EndDateTime": "2019-05-30T11:02:39-07:00",
      "Duration": 35300840000,
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/EVUtzNK3tdA/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36974,
          "Title": "We should base64 encode byte[] when writing Json",
          "Author": "BrennanConroy",
          "CreatedAt": "2019-04-17T20:23:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29299",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497411886",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36974#issuecomment-497411886",
        "FeedbackMarkdown": "* \u0060Utf8JsonWriter.WriteAsBase64String()\u0060 -\u003E \u0060WriteBase64String()\u0060\r\n* \u0060Utf8JsonReader.GetBytes()\u0060 -\u003E \u0060GetBytesFromBase64()\u0060\r\n* \u0060Utf8JsonReader.TryGetBytes()\u0060 -\u003E \u0060TryGetBytesFromBase64()\u0060\r\n* \u0060JsonElement.GetBytes()\u0060 -\u003E \u0060GetBytesFromBase64()\u0060\r\n* \u0060JsonElement.TryGetBytes()\u0060 -\u003E \u0060TryGetBytesFromBase64()\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36714,
          "Title": "JsonSerializer writing into Utf8JsonWriter",
          "Author": "BrennanConroy",
          "CreatedAt": "2019-04-08T22:18:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29205",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497417558",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36714#issuecomment-497417558",
        "FeedbackMarkdown": "* We should make the \u0060stream, reader, writer\u0060-thingie the first argument as they are logically extension methods\r\n* \u0060ReadValue\u0060 makes sense\r\n* The \u0060As\u0060 infix notation feels odd. We should just call it \u0060WriteValue\u0060 and \u0060WriteProperty\u0060. We should also change them in \u0060JsonElement\u0060.\r\n* Adding \u0060WriteProperty(JsonEncodedText propertyName, Utf8JsonWriter writer)\u0060 makes sense.",
        "TimeCode": 13040000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36717,
          "Title": "JsonSerializer reading from Utf8JsonReader",
          "Author": "BrennanConroy",
          "CreatedAt": "2019-04-09T00:15:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29208",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497418459",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36717#issuecomment-497418459",
        "FeedbackMarkdown": "Approved because we approved the combined one #36714.",
        "TimeCode": 23550000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36125,
          "Title": "Utf8JsonReader\\Writer should support all primitive types",
          "Author": "steveharter",
          "CreatedAt": "2019-03-18T19:27:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29000",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497424987",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36125#issuecomment-497424987",
        "FeedbackMarkdown": "The \u0060char\u0060 one might be harder to define. We should get @JamesNK input on those. Basically two options:\r\n\r\n* **We can treat it as a number**. If the primary goal is to define serialization behavior, that might be OK. And given that we have to write UTF8 that might be more honest.\r\n\r\n* **Treat it as a single character string**. This would mean that we either throw for chars that we can\u0027t represent in UTF8 or write garbage.\r\n\r\nThe other ones seem fine.",
        "TimeCode": 24550000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 59,
    "Date": "2019-06-05T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=CJLCnj82kSA",
      "Id": "CJLCnj82kSA",
      "StartDateTime": "2019-06-05T14:06:52.234-07:00",
      "EndDateTime": "2019-06-05T15:55:05-07:00",
      "Duration": 64927660000,
      "Title": ".NET Design Review: Nullable Annotations",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CJLCnj82kSA/mqdefault.jpg"
    },
    "Title": "System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35993,
          "Title": "Add protected SecurityDescriptor to ObjectSecurity",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-03-12T18:25:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28948",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-05T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35993#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 60,
    "Date": "2019-06-11T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=XWSjh7qkHkg",
      "Id": "XWSjh7qkHkg",
      "StartDateTime": "2019-06-11T10:04:33.285-07:00",
      "EndDateTime": "2019-06-11T11:04:08-07:00",
      "Duration": 35747150000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/XWSjh7qkHkg/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Tracing, System.Runtime.CompilerServices, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36999,
          "Title": "Add a per Activity API to set the default ActivityIdFormat",
          "Author": "davidfowl",
          "CreatedAt": "2019-04-18T15:06:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29308",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500941214",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36999#issuecomment-500941214",
        "FeedbackMarkdown": "Personally, I\u0027d prefer this being a property but it seems folks on the thread have strong opinion that this should be method, which is also accetable.\r\n\r\nIf that\u0027s a method it should be called \u0060SetIdFormat\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\npublic void SetIdFormat(ActivityIdFormat idFormat);\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37510,
          "Title": "Add DisplayUnits property to EventCounter and friends",
          "Author": "sywhang",
          "CreatedAt": "2019-05-08T07:06:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29477",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500943921",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37510#issuecomment-500943921",
        "FeedbackMarkdown": "Looks like we\u0027re OK with this. The default return value would be \u0060string.Empty\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Tracing\r\n{\r\n    public partial abstract class DiagnosticCounter\r\n    {\r\n        public string DisplayUnits { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9740000000,
        "Apis": [
          "P:DiagnosticCounter.DisplayUnits",
          "T:DiagnosticCounter"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38422,
          "Title": "Add Timers.Count",
          "Author": "kouvel",
          "CreatedAt": "2019-06-10T21:23:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29840",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500951300",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38422#issuecomment-500951300",
        "FeedbackMarkdown": "After long discussion, we agreed on:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial class Timer\r\n    {\r\n        public static long ActiveCount { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13820000000,
        "Apis": [
          "P:Timer.ActiveCount",
          "T:Timer"
        ]
      },
      {
        "Id": 4,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36222,
          "Title": "Add NullableAttribute",
          "Author": "terrajobst",
          "CreatedAt": "2019-03-21T23:49:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29039",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500957428",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36222#issuecomment-500957428",
        "FeedbackMarkdown": "We decided to keep doing the code spit because\r\n\r\n1. Any code reasoning about the attribute has to assume that attribute is emitted, so you can\u0027t optimize the path.\r\n2. The size is small",
        "TimeCode": 25790000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 61,
    "Date": "2019-06-18T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=56yfsgHtJ1E",
      "Id": "56yfsgHtJ1E",
      "StartDateTime": "2019-06-18T10:03:01.494-07:00",
      "EndDateTime": "2019-06-18T12:02:12-07:00",
      "Duration": 71505060000,
      "Title": ".NET Design Review: Nullable Reflection APIs \u002B JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/56yfsgHtJ1E/mqdefault.jpg"
    },
    "Title": "System.Reflection, System.Security, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16364,
          "Title": "Allow X509Chain to replace the root trust list for a single call",
          "Author": "bartonjs",
          "CreatedAt": "2017-02-21T23:14:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20302",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503226830",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16364#issuecomment-503226830",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38087,
          "Title": "Expose top-level nullability information from reflection",
          "Author": "terrajobst",
          "CreatedAt": "2019-05-31T03:07:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29723",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503265497",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38087#issuecomment-503265497",
        "FeedbackMarkdown": "* Given that we don\u0027t have all the features in-place, we believe this feature doesn\u0027t make the cut for 3.0\r\n* What about the custom attributes, such as \u0060NullIfNotNullAttribute\u0060?\r\n* What about generic type parameters (e.g. for tuples)\r\n* Namespace choice: should this be in the \u0060System.Reflection\u0060 namespace or should this go into a nested namespace?\r\n* There is the general question whether MVC or EF should even handle nullable annotations.\r\n* How do we square making runtime decisions with being able to change annotations\r\n* We should consider generalizing the feature to handle \u0060dynamic\u0060 and tuple names.",
        "TimeCode": 4280000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36639,
          "Title": "Support for custom converters and OnXXX callbacks",
          "Author": "steveharter",
          "CreatedAt": "2019-04-05T20:47:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29177",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503265607",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36639#issuecomment-503265607",
        "FeedbackMarkdown": "Notes from toady:\r\n\r\n* \u0060JsonConverterAttribute\u0060: let\u0027s make \u0060CreateConverter\u0060 public\r\n* \u0060JsonConverter\u003CT\u003E.Read/Write\u0060: We shouldn\u0027t catch specific types, instead, we should catch exceptions whose \u0060Source\u0060 indicate that it originates from the reader/writer. The reader/writer only marks exception types that it expects the serializer to catch, for example, it would not mark argument exception because those should go unhandled. We should, however, still special case \u0060JsonException\u0060 so that implementers of JSON converters don\u0027t have to set the source.\r\n* \u0060JsonConverterAttribute\u0060 we should add \u0060protected JsonConverterAttribute()\u0060 constructor that can be used by derived types.",
        "TimeCode": 66040000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 62,
    "Date": "2019-06-25T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=1k-niYNMo4w",
      "Id": "1k-niYNMo4w",
      "StartDateTime": "2019-06-25T15:05:49.167-07:00",
      "EndDateTime": "2019-06-25T16:56:19-07:00",
      "Duration": 66298330000,
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1k-niYNMo4w/mqdefault.jpg"
    },
    "Title": "System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38821,
          "Title": "Proposal: Add hard limit to MemoryInfo API",
          "Author": "andy-ms",
          "CreatedAt": "2019-06-24T16:49:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29998",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-06-25T00:00:00-07:00",
        "FeedbackId": "505662309",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38821#issuecomment-505662309",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 63,
    "Date": "2019-07-02T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=SdNdvSN_OHY",
      "Id": "SdNdvSN_OHY",
      "StartDateTime": "2019-07-02T10:10:18.945-07:00",
      "EndDateTime": "2019-07-02T10:37:07-07:00",
      "Duration": 16080550000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/SdNdvSN_OHY/mqdefault.jpg"
    },
    "Title": "System.IO.Pipelines, System.Runtime.Intrinsics, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39037,
          "Title": "Add WriteTo convenience APIs on JsonDocument and JsonProperty",
          "Author": "ahsonkhan",
          "CreatedAt": "2019-06-28T19:05:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30084",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507769350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39037#issuecomment-507769350",
        "FeedbackMarkdown": "We liked option Part A) \u002B Part B) 2, i.e. a single \u0060WriteTo(writer)\u0060 on all three elements.\r\n\r\n\u003E Can we instead add Write methods to \u0060Utf8JsonWriter\u0060?\r\n\r\nWe don\u0027t want this for layering reasons, i.e. the DOM knows about the writer, but the writer shouldn\u0027t know about the DOM.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37984,
          "Title": "PipeOptions, StreamPipeReaderOptions, and StreamPipeWriterOptions should not hardcode default sizes.",
          "Author": "tannergooding",
          "CreatedAt": "2019-05-28T17:56:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29680",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507774253",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37984#issuecomment-507774253",
        "FeedbackMarkdown": "That makes sense. We should make the same change across\r\n\r\n* \u0060PipeOptions\u0060 constructor\r\n* \u0060StreamPipeReaderOptions\u0060 constructor\r\n* \u0060StreamPipeWriterOptions\u0060 constructor\r\n\r\nAfter construction, the properties should reflect the actual default. In other words, we should only change the literal of the parameter itself to \u0060-1\u0060.\r\n\r\n@bartonjs brought up the question if we should expose something like \u0060Buffer.DefaultBufferSize\u0060 that is \u0060-1\u0060. We believe that\u0027s overkill. Also, many of the BCL construct that accept buffer sizes currently don\u0027t accept negative values. We could change that, but this would be a sizable work item and we\u0027re in the wrong part in the cycle to do that.",
        "TimeCode": 5770000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507770664",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-507770664",
        "FeedbackMarkdown": "@davidfowl the method is abstract. Does that mean we\u0027ll make it virtual and a no-nop? Also, what does deprecation mean to you, marking in Obsolete? What\u0027s the message gonna say?",
        "TimeCode": 13710000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37199,
          "Title": "Change how the Arm intrinsics are exposed",
          "Author": "tannergooding",
          "CreatedAt": "2019-04-25T21:25:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29376",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm32",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507775790",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37199#issuecomment-507775790",
        "FeedbackMarkdown": "This was reviewed and approved over e-mail. I\u0027ve started the work on changing the surface area to match this here: https://github.com/dotnet/coreclr/pull/25508, but it won\u0027t get merged until after dotnet/master begins targeting .NET 5.",
        "TimeCode": 14200000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 64,
    "Date": "2019-07-09T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=EERe5C9qty0",
      "Id": "EERe5C9qty0",
      "StartDateTime": "2019-07-09T10:08:18.332-07:00",
      "EndDateTime": "2019-07-09T12:06:27-07:00",
      "Duration": 70886680000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/EERe5C9qty0/mqdefault.jpg"
    },
    "Title": "Microsoft.Win32, System.Configuration, System.IO.Pipelines, System.ServiceProcess, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39241,
          "Title": "Add async versions of PipeReader and PipeWriter completion",
          "Author": "davidfowl",
          "CreatedAt": "2019-07-05T22:27:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30162",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39241#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509732308",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-509732308",
        "FeedbackMarkdown": "Decision:\r\n\r\n* Make the implementation virtual.\r\n* Make the implementation a no-op\r\n* Mark the API as \u0060[Obsolete]\u0060\r\n* Apply the same to \u0060PipeWriter.OnWriterCompleted\u0060\r\n\r\n@davidfowl, what should the message be for \u0060PipeReader.OnReaderCompleted\u0060 and \u0060PipeWriter.OnWriterCompleted\u0060?",
        "TimeCode": 6420000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37984,
          "Title": "PipeOptions, StreamPipeReaderOptions, and StreamPipeWriterOptions should not hardcode default sizes.",
          "Author": "tannergooding",
          "CreatedAt": "2019-05-28T17:56:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29680",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509735688",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37984#issuecomment-509735688",
        "FeedbackMarkdown": "Conclusion:\r\n\r\n* Nullable would have been nice, but we can\u0027t change the type for some of the APIs (because they shipped) and we prefer consistency, so we\u0027re going with the sentinel value of \u0060-1\u0060.",
        "TimeCode": 10060000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39307,
          "Title": "Make JsonConverterFactory.CreateConverter public.",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-07-09T00:04:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30190",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509740229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39307#issuecomment-509740229",
        "FeedbackMarkdown": "* Making the API public makes sense.\r\n* However, it seems if the scenario is composition, we should pass in the \u0060JsonSerializerOptions\u0060 so that someone implementing a converter for a generic type, can ask the options for getting a converter for its type arguments.\r\n     - The same logic would also apply to \u0060CanConvert()\u0060, however, it seems the design seems to be that the answer can be deferred.\r\n     - In fact, it seems \u0060GetConverter()\u0060 could too because the logic can be deferred to \u0060JsonConverter\u003CT\u003E.Read\u0060 and \u0060JsonConverter\u003CT\u003E.Write\u0060\r\n     - If that\u0027s the case the API can be approved.\r\n\r\n@JeremyKuhne please take a look.",
        "TimeCode": 15930000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39308,
          "Title": "Make Microsoft.Win32.SystemEvents static",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-07-09T00:11:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30191",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Microsoft.Win32",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509744182",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39308#issuecomment-509744182",
        "FeedbackMarkdown": "(You can use this issue for any class where all public APIs are static, all constructors are private, and the type is sealed)",
        "TimeCode": 24970000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36897,
          "Title": "Add AppContext.ApplicationConfig",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-04-15T20:04:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29271",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Configuration",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509749369",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36897#issuecomment-509749369",
        "FeedbackMarkdown": "Conclusion\r\n\r\n* Exposing the API on \u0060AppDomainSetup\u0060 is fine, but we shouldn\u0027t expose the property on \u0060AppContext\u0060\r\n* We may want to expose the backing store for .NET Core\u0027s \u0060runtimeconfig.json\u0060 (and that should go on \u0060AppContext\u0060) but it would point to a different file, obviously.",
        "TimeCode": 29180000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36842,
          "Title": "ServiceBase.IsRunningInWindowsService",
          "Author": "davidfowl",
          "CreatedAt": "2019-04-13T15:31:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29252",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ServiceProcess",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36842#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 39590000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 65,
    "Date": "2019-07-16T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=JdaQ2RP2tqM",
      "Id": "JdaQ2RP2tqM",
      "StartDateTime": "2019-07-16T10:03:28.805-07:00",
      "EndDateTime": "2019-07-16T12:01:59-07:00",
      "Duration": 71101950000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/JdaQ2RP2tqM/mqdefault.jpg"
    },
    "Title": "System.IO.Pipelines, System.Numerics, System.Runtime, System.Text.Encodings.Web",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39523,
          "Title": "Add Encode(ReadOnlySpan\u003Cchar\u003E) method to TextEncoder for performance",
          "Author": "steveharter",
          "CreatedAt": "2019-07-16T05:59:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30274",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encodings.Web",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39523#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 6490000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35434,
          "Title": "(System.Numerics) Cross Product for Vector2 and Vector4",
          "Author": "danmosemsft",
          "CreatedAt": "2019-02-20T01:42:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28731",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "511933825",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35434#issuecomment-511933825",
        "FeedbackMarkdown": "Generally this seems like a reasonable API. The only sticking point is that it seems undefined and only DirectX exposes this operation for \u0060Vector2\u0060 and \u0060Vector4\u0060. This may be odd, but doesn\u0027t seem to be a blocker to us.",
        "TimeCode": 19350000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17745,
          "Title": "Add StringBuilder(Char)",
          "Author": "iSazonov",
          "CreatedAt": "2017-03-31T18:49:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20848",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "511942559",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17745#issuecomment-511942559",
        "FeedbackMarkdown": "So after discussion we think it\u0027s not worth it. It\u0027s been 20 years and this isn\u0027t a widespread enough problem.",
        "TimeCode": 53190000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 66,
    "Date": "2019-08-20T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=dfzXrQCINHM",
      "Id": "dfzXrQCINHM",
      "StartDateTime": "2019-08-20T11:01:58.518-07:00",
      "EndDateTime": "2019-08-20T12:18:34-07:00",
      "Duration": 45954820000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dfzXrQCINHM/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Memory, System.Net.Sockets, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 9680,
          "Title": "Add a Socket.Listen() overload",
          "Author": "GSPP",
          "CreatedAt": "2016-06-25T15:58:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17708",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523130997",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/9680#issuecomment-523130997",
        "FeedbackMarkdown": "Makes sense.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19408,
          "Title": "Add ImmutableInterlocked.Update for ImmutableArray",
          "Author": "sharwell",
          "CreatedAt": "2017-05-05T17:47:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21534",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523140923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19408#issuecomment-523140923",
        "FeedbackMarkdown": "We should make sure that the new overloads don\u0027t cause ambiguities but recompiling CoreFx will probably be sufficient.",
        "TimeCode": 3450000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19416,
          "Title": "Add support for getting current stack into Exception",
          "Author": "stephentoub",
          "CreatedAt": "2017-05-05T22:13:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21539",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523144443",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19416#issuecomment-523144443",
        "FeedbackMarkdown": "Based on the scenario, it seems \u0060SetCurrentStackTrace\u0060 would more sense; if we ever need an append, we can add an overload with a Boolean. @stephentoub suggested to make it fail for exceptions with existing stack traces.",
        "TimeCode": 18110000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26528,
          "Title": "Add \u0027split\u0027 support for ReadOnlySpan\u003Cchar\u003E similar to string",
          "Author": "ahsonkhan",
          "CreatedAt": "2018-01-23T01:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/934",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "utf8-impact",
              "BackgroundColor": "eddf84",
              "Description": "Potentially impacts UTF-8 support in the runtime",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523152939",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26528#issuecomment-523152939",
        "FeedbackMarkdown": "Based on the conversation, we believe we would prefer something more scoped:\r\n\r\n\u0060\u0060\u0060C#\r\npartial class MemoryExtensions\r\n{\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span, char separator);\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span, string separator);\r\n\r\n    // This API seems possible, but we can defer until we see scenarios\r\n    // public static SpanSplitEnumerator\u003Cchar\u003E SplitAny(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E separators);\r\n\r\n    // This API seems possible, but we should defer until we see scenarios. It wouldn\u0027t be good make this work for UTF8, for example.\r\n    // public static SpanSplitEnumerator\u003CT\u003E Split\u003CT\u003E(this ReadOnlySpan\u003CT\u003E span, T separator);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe enumerator returns ranges so you cans split a memory via this API and use the span to slice the memory and to unify span and read-only spans. It\u0027s unclear whether we need different enumerator types for different \u0060Split\u0060 behaviors, but we don\u0027t expect people to exchange those, which is why they are currently proposed to be nested types too.",
        "TimeCode": 23950000000,
        "Apis": [
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E,string)",
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "Id": 67,
    "Date": "2019-08-27T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=maDBdlZfCGA",
      "Id": "maDBdlZfCGA",
      "StartDateTime": "2019-08-27T11:00:30.756-07:00",
      "EndDateTime": "2019-08-27T12:10:42-07:00",
      "Duration": 42112440000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/maDBdlZfCGA/mqdefault.jpg"
    },
    "Title": "System.IO, System.Linq.Expressions, System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26772,
          "Title": "Expression support for ref and readonly ref types",
          "Author": "JonHanna",
          "CreatedAt": "2018-02-02T00:53:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24884",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Linq.Expressions",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocked",
              "BackgroundColor": "b60205",
              "Description": "Issue/PR is blocked on something - see comments",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525417923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26772#issuecomment-525417923",
        "FeedbackMarkdown": "There is a general item on the compiler team to figure out how expression trees are going to be evolved (and if).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28379,
          "Title": "Add a ValueStringBuilder",
          "Author": "JeremyKuhne",
          "CreatedAt": "2018-03-22T21:28:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25587",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocked",
              "BackgroundColor": "b60205",
              "Description": "Issue/PR is blocked on something - see comments",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525424732",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28379#issuecomment-525424732",
        "FeedbackMarkdown": "We believe that without a feature that forces consumers to pass value types by reference (either language feature or in-box analyzer) this will cause unreliable applications due to corruption of the array pool when accidental copies are being made.\r\n\r\n@JeremyKuhne do you want to drive that discussion with @jaredpar?",
        "TimeCode": 3440000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30701,
          "Title": "Add Path.RemoveRelativeSegments Api",
          "Author": "Anipik",
          "CreatedAt": "2018-06-27T18:37:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2162",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525429074",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30701#issuecomment-525429074",
        "FeedbackMarkdown": "@Anipik you mentioned you don\u0027t want to use \u0060GetFullPath()\u0060 because you want to preserve the relativeness. What\u0027s the scenario for this API then? Functionally, it seems \u0060GetFullPath()\u0060 or keeping the path with the dots seems both OK.",
        "TimeCode": 14480000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19814,
          "Title": "Proposal: List\u003CT\u003E.AsSpan()",
          "Author": "benaadams",
          "CreatedAt": "2017-05-16T02:52:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21727",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525432693",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19814#issuecomment-525432693",
        "FeedbackMarkdown": "Let\u0027s start with no :)",
        "TimeCode": 20960000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 68,
    "Date": "2019-09-10T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=Vf-Gj0h8Uws",
      "Id": "Vf-Gj0h8Uws",
      "StartDateTime": "2019-09-10T10:07:57.521-07:00",
      "EndDateTime": "2019-09-10T11:56:39-07:00",
      "Duration": 65214790000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Vf-Gj0h8Uws/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40962,
          "Title": "Review System.Buffers.SequenceReader\u003CT\u003E proposals",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-09-10T02:04:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30807",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530060857",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857",
        "FeedbackMarkdown": "* We should rename the \u0060skip\u0060 parameters to \u0060offset\u0060\r\n    - We don\u0027t use \u0060skip\u0060 anywhere else and it kind of implies a side effect\r\n    - \u0060offset\u0060 implies relative to *something* and for a reader it makes to be relative to current position\r\n* We should the \u0060count\u0060 parameter to \u0060length\u0060\r\n* We should remove the overloads of TryPeek that take two arguments and whose first argument is \u0060count\u0060 -- because it conflicts \u0060TryPeek(int skip, out T value)\u0060\r\n* Arguments referring to position and lengths should be typed as \u0060long\u0060\r\n* We should add \u0060readonly\u0060 annotations\r\n* It\u0027s sad that \u0060TryPeek()\u0060 that returns a span might have to allocate if the span crosses buffers but there is no way around that.\r\n* FDG: we need to consider what we do for out parameters where the out type is the same as the input type as that allows you modify the \u0060this\u0060 while it\u0027s running (ask Levi for details).\r\n* \u0060public void SetPosition(SequencePosition position);\u0060 needs more work as there are a lot of concerns (like O(n) complexity).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Optimized API to position the reader at the end of the sequence (much faster than what users can write)\r\n        public void AdvanceToEnd();\r\n\r\n        // Pairs with existing Span\u003CT\u003E UnreadSpan;\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence { get; }\r\n\r\n        // Overloads for TryRead that allow reading out a given count rather than to some delimiter (as with existing\r\n        // API span out will slice if it can or allocate and copy if it has to).\r\n        public bool TryRead(int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public bool TryRead(long length, out ReadOnlySequence\u003CT\u003E value);\r\n\r\n        // Peeking out T, while skipping. This is more performant than users can write (avoids rewinding).\r\n        public readonly bool TryPeek(long offset, out T value);\r\n\r\n        // Equivalent \u0022Peek\u0022 versions. They need a offset as peeking doesn\u0027t advance the reader and rewinding is super expensive.\r\n        public readonly bool TryPeek(long offset, int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public readonly bool TryPeek(long offset, long length, out ReadOnlySequence\u003CT\u003E value);\r\n \r\n        // Pairs with existing TryCopyTo(Span\u003CT\u003E destination), which does not advance the reader (neither does this)\r\n        public readonly bool TryCopyTo(long offset, Span\u003CT\u003E destination);\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.AdvanceToEnd()",
          "M:SequenceReader\u003CT\u003E.TryCopyTo(long,Span\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,int,out ReadOnlySpan\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,long,out ReadOnlySequence\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,out T)",
          "M:SequenceReader\u003CT\u003E.TryRead(int,out ReadOnlySpan\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryRead(long,out ReadOnlySequence\u003CT\u003E)",
          "P:SequenceReader\u003CT\u003E.UnreadSequence",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40843,
          "Title": "SequenceReader\u003CT\u003E.AdvanceTo(SequencePosition)",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-05T18:16:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30770",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530066043",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40843#issuecomment-530066043",
        "FeedbackMarkdown": "This was reviewed in #40962.  Concerns about [performance and usability](https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857) pretty much as described so putting back to \u0022needs work\u0022.",
        "TimeCode": 45190000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8126,
          "Title": "Allow custom format strings for boolean values",
          "Author": "martingbrown",
          "CreatedAt": "2016-04-27T17:42:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17141",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530066335",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8126#issuecomment-530066335",
        "FeedbackMarkdown": "Honestly, while I agree with that being useful, it\u0027s trivial for people to define helper methods:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static string ToState(this bool value, string trueValue, string falseValue)\r\n    =\u003E value ? trueValue : falseValue;\r\npublic static string ToState(this bool? value, string trueValue, string falseValue, string nullValue)\r\n    =\u003E value is null ? nullValue : value.Value ? trueValue : nullValue;\r\n\u0060\u0060\u0060\r\n\r\nFor \u0060bool\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\nstring.Format($\u0022The kettle is {kettle.ToState(\u0022on\u0022, \u0022off\u0022)}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nFor \u0060bool?\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\nstring.Format($\u0022The kettle is {kettle.ToState(\u0022on\u0022, \u0022off\u0022, \u0022Unknown\u0022)}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nUsing the formatting APIs seems way too complex for this case.",
        "TimeCode": 51490000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37156,
          "Title": "Proposal: SequenceReader\u003CT\u003E.ReadToEnd / AdvanceToEnd",
          "Author": "GoldenCrystal",
          "CreatedAt": "2019-04-24T21:29:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29360",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530067301",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37156#issuecomment-530067301",
        "FeedbackMarkdown": "This was approved in #40962 as:\r\n\r\n\u0060\u0060\u0060 C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Optimized API to position the reader at the end of the sequence (much faster than what users can write)\r\n        public void AdvanceToEnd();\r\n\r\n        // Pairs with existing Span\u003CT\u003E UnreadSpan;\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHere are the rough implementations:\r\n\r\n\u0060\u0060\u0060 C#\r\n        /// \u003Csummary\u003E\r\n        /// The unread portion of the \u003Csee cref=\u0022Sequence\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence\r\n        {\r\n            get =\u003E Sequence.Slice(Position);\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n\r\n\u0060\u0060\u0060 C#\r\n        public void AdvanceToEnd()\r\n        {\r\n            if (_moreData)\r\n            {\r\n                Consumed = Length;\r\n                CurrentSpan = default;\r\n                CurrentSpanIndex = 0;\r\n                _currentPosition = Sequence.End;\r\n                _moreData = false;\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nMarking as up-for-grabs to fully implement/test.",
        "TimeCode": 53960000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.AdvanceToEnd()",
          "P:.UnreadSequence",
          "P:SequenceReader\u003CT\u003E.UnreadSequence",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40870,
          "Title": "SequenceReader\u003CT\u003E.TryRead overloads to read a specified number of elements",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-06T05:30:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30778",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530068389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40870#issuecomment-530068389",
        "FeedbackMarkdown": "Approved: https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857\r\n\r\n\u0060\u0060\u0060 C#\r\n        public bool TryRead(int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public bool TryRead(long length, out ReadOnlySequence\u003CT\u003E value);\r\n\u0060\u0060\u0060",
        "TimeCode": 55580000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40845,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads for look ahead",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-05T18:21:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30771",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530069306",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40845#issuecomment-530069306",
        "FeedbackMarkdown": "Approved: #40962 (comment):\r\n\r\n\u0060\u0060\u0060 C#\r\n        public readonly bool TryPeek(long offset, out T value);\r\n\u0060\u0060\u0060",
        "TimeCode": 57020000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40871,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads to read a specified number of elements from any position",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-06T05:33:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30779",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530070064",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40871#issuecomment-530070064",
        "FeedbackMarkdown": "Approved: #40962 (comment):\r\n\r\n\u0060\u0060\u0060 C#\r\n        // Equivalent \u0022Peek\u0022 versions. They need a offset as peeking doesn\u0027t advance the reader and rewinding is super expensive.\r\n        public readonly bool TryPeek(long offset, int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public readonly bool TryPeek(long offset, long length, out ReadOnlySequence\u003CT\u003E value);\r\n \r\n        // Pairs with existing TryCopyTo(Span\u003CT\u003E destination), which does not advance the reader (neither does this)\r\n        public readonly bool TryCopyTo(long offset, Span\u003CT\u003E destination);\r\n\u0060\u0060\u0060",
        "TimeCode": 58490000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 69,
    "Date": "2019-09-17T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=6Kd92ScY3gM",
      "Id": "6Kd92ScY3gM",
      "StartDateTime": "2019-09-17T11:10:28.876-07:00",
      "EndDateTime": "2019-09-17T12:13:38-07:00",
      "Duration": 37891240000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6Kd92ScY3gM/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Security, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39564,
          "Title": "Add UnderScoreCase support for System.Text.Json",
          "Author": "hez2010",
          "CreatedAt": "2019-07-17T05:17:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/782",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532341171",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39564#issuecomment-532341171",
        "FeedbackMarkdown": "Makes sense. We also considered others (such as kebap casing) but it seems we should defer that until someone actually needs that.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41002,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532349735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41002#issuecomment-532349735",
        "FeedbackMarkdown": "We seem to lean towards not having \u0060Ignore\u0060 -- it results in payloads that nobody can reason about. The right fix for those scenarios to modify the C# types to exclude back pointers from serialization.\r\n\r\nWe\u0027d like to see more detailed spec for the behavior, specifically error cases.",
        "TimeCode": 5790000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40558,
          "Title": "HashAlgorithmName.FromOid",
          "Author": "vcsjones",
          "CreatedAt": "2019-08-24T16:02:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30671",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40558#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19480000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24770,
          "Title": "Add RemoveIfValue to ConcurrentDictionary",
          "Author": "CornedBee",
          "CreatedAt": "2017-10-20T09:05:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23909",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532361229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24770#issuecomment-532361229",
        "FeedbackMarkdown": "If we\u0027re adding it, it should be \u0060TryRemove(KV\u003CK, V\u003E)\u0060.",
        "TimeCode": 27490000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 70,
    "Date": "2019-09-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=8M5rFkINsus",
      "Id": "8M5rFkINsus",
      "StartDateTime": "2019-09-24T11:10:08.464-07:00",
      "EndDateTime": "2019-09-24T12:10:33-07:00",
      "Duration": 36245360000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8M5rFkINsus/mqdefault.jpg"
    },
    "Title": "System.Collections, System.IO, System.Reflection",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27453,
          "Title": "Add a Generic version of GetValues to Enum (probably GetName/GetNames)",
          "Author": "andreigit",
          "CreatedAt": "2018-02-25T17:06:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2364",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534690642",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27453#issuecomment-534690642",
        "FeedbackMarkdown": "I stand corrected, we believe we\u0027d prefer this API shape:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial abstract class Enum\r\n    {\r\n        public static TEnum[] GetValues\u003CTEnum\u003E() where TEnum : struct, Enum;\r\n        public static string GetName\u003CTEnum\u003E(TEnum value) where TEnum : struct, Enum;\r\n        public static string[] GetNames\u003CTEnum\u003E() where TEnum : struct, Enum;     \r\n        public static bool IsDefined\u003CTEnum\u003E(TEnum value) where TEnum : struct, Enum;       \r\n        public static bool HasFlag\u003CTEnum\u003E(TEnum value, TEnum test) where TEnum : struct, Enum;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Enum.GetName\u003CTEnum\u003E(TEnum)",
          "M:Enum.GetNames\u003CTEnum\u003E()",
          "M:Enum.GetValues\u003CTEnum\u003E()",
          "M:Enum.HasFlag\u003CTEnum\u003E(TEnum,TEnum)",
          "M:Enum.IsDefined\u003CTEnum\u003E(TEnum)",
          "T:Enum"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30701,
          "Title": "Add Path.RemoveRelativeSegments Api",
          "Author": "Anipik",
          "CreatedAt": "2018-06-27T18:37:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2162",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534695882",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30701#issuecomment-534695882",
        "FeedbackMarkdown": "Alright, here is the shape we\u0027d like to see:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class Path\r\n    {\r\n        public static string RemoveRedundantSegments(string path);\r\n        public static string RemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E path);\r\n        public static bool TryRemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E path, Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14520000000,
        "Apis": [
          "M:Path.RemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E)",
          "M:Path.RemoveRedundantSegments(string)",
          "M:Path.TryRemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,out int)",
          "T:Path"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31597,
          "Title": "Add List\u003CT\u003E AsSpan to CollectionsMarshal",
          "Author": "benaadams",
          "CreatedAt": "2018-08-04T14:02:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27061",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534703891",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31597#issuecomment-534703891",
        "FeedbackMarkdown": "Approved shape:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial static class CollectionsMarshal\r\n    {\r\n        public static Span\u003CT\u003E AsSpan(List\u003CT\u003E list);\r\n        public static ReadOnlySpan\u003CT\u003E AsReadOnlySpan(List\u003CT\u003E list);\r\n\r\n        // We don\u0027t want this one:\r\n        // public Memory\u003CT\u003E AsMemory(List\u003CT\u003E list);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22430000000,
        "Apis": [
          "M:CollectionsMarshal.AsReadOnlySpan(List\u003CT\u003E)",
          "M:CollectionsMarshal.AsSpan(List\u003CT\u003E)",
          "T:CollectionsMarshal"
        ]
      }
    ]
  },
  {
    "Id": 71,
    "Date": "2019-10-01T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=b-Hz_CBobfU",
      "Id": "b-Hz_CBobfU",
      "StartDateTime": "2019-10-01T10:10:24.661-07:00",
      "EndDateTime": "2019-10-01T12:05:42-07:00",
      "Duration": 69173390000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b-Hz_CBobfU/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Collections, System.Drawing, System.Globalization, System.Memory, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41166,
          "Title": "Add Encoding/Decoding APIs for new System.Buffer types",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-18T05:00:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30882",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537141144",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41166#issuecomment-537141144",
        "FeedbackMarkdown": "* The signatures makes sense\r\n* Should also add \r\n    \u0060\u0060\u0060C#\r\n    public static long GetByteCount(this Encoding encoding, in ReadOnlySequence\u003Cchar\u003E chars);\r\n    public static long GetCharCount(this Encoding encoding, in ReadOnlySequence\u003Cbyte\u003E bytes);\r\n    \u0060\u0060\u0060\r\n* Making this an extension seems slightly sad; is this the point where we should consider movign \u0060ReadOnlySequence\u003CT\u003E\u0060, \u0060IBfferWriter\u003CT\u003E\u0060 into corlib? Can anybody think of scenarios where we\u0027d like those types down?\r\n* @GrabYourPitchforks filed #41474 to make these instance methods should we move the types down",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41326,
          "Title": "Add Encoder/Decoder for new System.Buffer types",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-25T20:32:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30957",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537150026",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41326#issuecomment-537150026",
        "FeedbackMarkdown": "* Should these be \u0060OperationStatus\u0060 APIs? We decided not to, because we modeled these overloads after the existing APIs.\r\n* We considered replacing the outed sequence position with an \u0060int\u0060, but slicing with a position is simpler and more performant (because O(1)).\r\n* We should rename \u0060bytesUsedPosition\u0060 to just \u0060position\u0060\r\n* Same as #41166: if we move \u0060ReadOnlySequence\u003CT\u003E\u0060 and \u0060IBufferWriter\u003CT\u003E\u0060 to corlib, we should make those instance methods.",
        "TimeCode": 9180000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31597,
          "Title": "Add List\u003CT\u003E AsSpan to CollectionsMarshal",
          "Author": "benaadams",
          "CreatedAt": "2018-08-04T14:02:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27061",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537151655",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31597#issuecomment-537151655",
        "FeedbackMarkdown": "We decided to not increment the version, which is why we removed the \u0060AsReadOnlySpan()\u0060 overload.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial static class CollectionsMarshal\r\n    {\r\n        public static Span\u003CT\u003E AsSpan(List\u003CT\u003E? list);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21570000000,
        "Apis": [
          "M:CollectionsMarshal.AsSpan(List\u003CT\u003E?)",
          "T:CollectionsMarshal"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31787,
          "Title": "a new GC API for large array allocation",
          "Author": "Maoni0",
          "CreatedAt": "2018-08-15T21:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27146",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537157276",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31787#issuecomment-537157276",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class GC\r\n    {\r\n        public static T[] AllocateArray\u003CT\u003E(int length, int generation=-1, bool pinned=false, int alignment=-1);\r\n        public static T[] AllocateUninitializedArray\u003CT\u003E(int length, int generation=-1, bool pinned=false, int alignment=-1);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23760000000,
        "Apis": [
          "M:GC.AllocateArray\u003CT\u003E(int,int,bool,int)",
          "M:GC.AllocateUninitializedArray\u003CT\u003E(int,int,bool,int)",
          "T:GC"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31807,
          "Title": "long ReadOnlySequence\u003CT\u003E.GetPosition(SequencePosition)",
          "Author": "AArnott",
          "CreatedAt": "2018-08-16T18:56:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27158",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537160854",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31807#issuecomment-537160854",
        "FeedbackMarkdown": "Given that the nomenclature uses \u0060offset\u0060 for \u0060long\u0060-based absolute values and \u0060position\u0060 for a \u0060SequencePosition\u0060 value, we should be using \u0060GetOffset()\u0060. This also solves some overload issue that only @tannergooding understands \uD83D\uDE04 \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct ReadOnlySequence\u003CT\u003E\r\n    {\r\n       public long GetOffset(SequencePosition position);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31780000000,
        "Apis": [
          "M:ReadOnlySequence\u003CT\u003E.GetOffset(SequencePosition)",
          "T:ReadOnlySequence\u003CT\u003E"
        ]
      },
      {
        "Id": 6,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31820,
          "Title": "Color should implement FromHsl methods",
          "Author": "AraHaan",
          "CreatedAt": "2018-08-16T23:57:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27164",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Drawing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537164275",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31820#issuecomment-537164275",
        "FeedbackMarkdown": "* It [sounds like](https://stackoverflow.com/questions/15668623/hsb-vs-hsl-vs-hsv) HSL is different from HSB.\r\n* Given that your sample code uses \u0060GetBrightness()\u0060 as the input to \u0060FromHsl\u0060, is it possible that you really meant \u0060FromHsb()\u0060?",
        "TimeCode": 37180000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32201,
          "Title": "Extend CultureInfo.GetCultureInfo and new CultureInfo to optionally accept predefined cultures only",
          "Author": "mklement0",
          "CreatedAt": "2018-09-10T20:53:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27352",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Globalization",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537177127",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32201#issuecomment-537177127",
        "FeedbackMarkdown": "After some debate we settled on this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial class CultureInfo\r\n    {\r\n        public static CultureInfo GetCulture(string name, bool prefinedOnly);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis API would throw for invalid names as well as names that weren\u0027t system provided when \u0060predefinedOnly\u0060 is \u0060true\u0060.",
        "TimeCode": 42150000000,
        "Apis": [
          "M:CultureInfo.GetCulture(string,bool)",
          "T:CultureInfo"
        ]
      },
      {
        "Id": 8,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32987,
          "Title": "Add remove Range to sorted List",
          "Author": "hernot",
          "CreatedAt": "2018-10-23T19:13:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27713",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537183526",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32987#issuecomment-537183526",
        "FeedbackMarkdown": "The generic sorted list doesn\u0027t allow indexing by \u0060int\u0060, however, it does expose a \u0060RemoveAt\u0060 method. But we\u0027d have to make sure this plays nicely for cases where custom compares are used that, for example, take into consideration the number of elements and use different sorting.\r\n\r\nRight now, we\u0027re not convinced the usability and minor performance gains are motivating enough. Feel free to push back though and provide more arguments :-)",
        "TimeCode": 59900000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 72,
    "Date": "2019-10-10T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=7KTxd_41Lus",
      "Id": "7KTxd_41Lus",
      "StartDateTime": "2019-10-10T13:07:01.117-07:00",
      "EndDateTime": "2019-10-10T14:16:41-07:00",
      "Duration": 41798830000,
      "Title": ".NET Design Review: .NET Core 3.1",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7KTxd_41Lus/mqdefault.jpg"
    },
    "Title": "System.IO, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41614,
          "Title": "Add file and directory creation methods that take an ACL",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-10-07T21:22:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31095",
          "Milestone": "3.1",
          "Labels": [
            {
              "Name": "Security",
              "BackgroundColor": "b60205",
              "Description": null,
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540773661",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41614#issuecomment-540773661",
        "FeedbackMarkdown": "We considered adding the APIs back to the relevant types (i.e. as constructors). While this would be preferred from a porting/backwards compabitility case, it would mean we\u0027d have to pull-in a large amount of ACL / Windows security into \u0060System.Private.Corelib\u0060.\r\n\r\nWe think these APIs are weird and shouldn\u0027t be exposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class FileSystemAclExtensions\r\n    {\r\n        public static FileStream CreateFile(\r\n            this FileSecurity fileSecurity,\r\n            string path,\r\n            FileMode mode,\r\n            FileSystemRights rights,\r\n            FileShare share,\r\n            int bufferSize,\r\n            FileOptions options);\r\n\r\n        public static DirectoryInfo CreateDirectory(\r\n            this DirectorySecurity directorySecurity\r\n            string path);\r\n    }\r\n }\r\n\u0060\u0060\u0060\r\n\r\nThese APIs look fine (assuming they match the existing instance methods of .NET Framework in terms of naming and order):\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class FileSystemAclExtensions\r\n    {\r\n        // Add\r\n        public static FileStream Create(\r\n            this FileInfo fileInfo,\r\n            FileMode mode,\r\n            FileSystemRights rights,\r\n            FileShare share,\r\n            int bufferSize,\r\n            FileOptions options,\r\n            FileSecurity fileSecurity);\r\n\r\n        public static void Create(\r\n            this DirectoryInfo directoryInfo,\r\n            DirectorySecurity directorySecurity);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:FileSystemAclExtensions.Create(this DirectoryInfo,DirectorySecurity)",
          "M:FileSystemAclExtensions.Create(this FileInfo,FileMode,FileSystemRights,FileShare,int,FileOptions,FileSecurity)",
          "M:FileSystemAclExtensions.CreateDirectory(this DirectorySecurity,string)",
          "M:FileSystemAclExtensions.CreateFile(this FileSecurity,string,FileMode,FileSystemRights,FileShare,int,FileOptions)",
          "T:FileSystemAclExtensions"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41654,
          "Title": "Port \u0060MemoryMappedFileSecurity\u0060 and add extensions for \u0060MemoryMappedFile\u0060",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-10-08T21:21:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/941",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540781324",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41654#issuecomment-540781324",
        "FeedbackMarkdown": "We should introduce a new static type in the same assembly as \u0060FileSystemAclExtensions\u0060. The pattern we settled on was suffixing the type with \u0060Acl\u0060.\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.MemoryMappedFiles\r\n{\r\n    public static class MemoryMappedFileAcl\r\n    {\r\n        public static MemoryMappedFile CreateFromFile(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            FileStream fileStream,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            HandleInheritability inheritability,\r\n            bool leaveOpen);\r\n\r\n        public static MemoryMappedFile CreateNew(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            MemoryMappedFileOptions options,\r\n            HandleInheritability inheritability);\r\n\r\n        public static MemoryMappedFile CreateOrOpenMappedFile(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            MemoryMappedFileOptions options,\r\n            HandleInheritability inheritability);\r\n\r\n        // Those are fine as extensions:\r\n\r\n        public static MemoryMappedFileSecurity GetAccessControl(\r\n            this MemoryMappedFile memoryMappedFile);\r\n\r\n        public static void SetAccessControl(\r\n            this MemoryMappedFile memoryMappedFile,\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10470000000,
        "Apis": [
          "M:MemoryMappedFileAcl.CreateFromFile(MemoryMappedFileSecurity,FileStream,string,long,MemoryMappedFileAccess,HandleInheritability,bool)",
          "M:MemoryMappedFileAcl.CreateNew(MemoryMappedFileSecurity,string,long,MemoryMappedFileAccess,MemoryMappedFileOptions,HandleInheritability)",
          "M:MemoryMappedFileAcl.CreateOrOpenMappedFile(MemoryMappedFileSecurity,string,long,MemoryMappedFileAccess,MemoryMappedFileOptions,HandleInheritability)",
          "M:MemoryMappedFileAcl.GetAccessControl(this MemoryMappedFile)",
          "M:MemoryMappedFileAcl.SetAccessControl(this MemoryMappedFile,MemoryMappedFileSecurity)",
          "T:MemoryMappedFileAcl"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41657,
          "Title": "Add pipe creation extension methods that take an ACL",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-10-08T21:52:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31112",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "Security",
              "BackgroundColor": "b60205",
              "Description": null,
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540786760",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41657#issuecomment-540786760",
        "FeedbackMarkdown": "We should not make them extension methods. We should follow the other pattern and create new static types suffixed with \u0060Acl\u0060:\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipes\r\n{\r\n    public static class AnonymousPipeServerStreamAcl\r\n    {\r\n        public AnonymousPipeServerStream Create(\r\n            PipeSecurity pipeSecurity\r\n            PipeDirection direction,\r\n            HandleInheritability inheritability,\r\n            int bufferSize);\r\n    }\r\n\r\n    public static class NamedPipeServerStreamAcl\r\n    {\r\n        public NamedPipeServerStream Create(\r\n            PipeSecurity pipeSecurity\r\n            string pipeName,\r\n            PipeDirection direction,\r\n            int maxNumberOfServerInstances,\r\n            PipeTransmissionMode transmissionMode,\r\n            PipeOptions options,\r\n            int inBufferSize,\r\n            int outBufferSize,\r\n            HandleInheritability inheritability = HandleInheritability.None,\r\n            PipeAccessRights additionalAccessRights = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19120000000,
        "Apis": [
          "M:AnonymousPipeServerStreamAcl.Create(PipeSecurity,PipeDirection,HandleInheritability,int)",
          "M:NamedPipeServerStreamAcl.Create(PipeSecurity,string,PipeDirection,int,PipeTransmissionMode,PipeOptions,int,int,HandleInheritability,PipeAccessRights)",
          "T:AnonymousPipeServerStreamAcl",
          "T:NamedPipeServerStreamAcl"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41662,
          "Title": "Add Mutex, Semaphore, and EventWaitHandle creation extension methods that take an ACL",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-10-08T22:22:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31114",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "Security",
              "BackgroundColor": "b60205",
              "Description": null,
              "ForegroundColor": "white"
            },
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540790209",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41662#issuecomment-540790209",
        "FeedbackMarkdown": "We should not make them extension methods. We should follow the other pattern and create new static types suffixed with \u0060Acl\u0060:\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static class EventWaitHandleAcl\r\n    {   \r\n        public static EventWaitHandle Create(\r\n            EventWaitHandleSecurity eventSecurity\r\n            bool initialState,\r\n            EventResetMode mode,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n\r\n    public static class MutexAcl\r\n    {   \r\n        public static Mutex Create(\r\n            MutexSecurity mutexSecurity,\r\n            bool initiallyOwned,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n\r\n    public static class SemaphoreAcl\r\n    {   \r\n        public static Semaphore Create(\r\n            SemaphoreSecurity semaphoreSecurity,\r\n            int initialCount,\r\n            int maximumCount,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25060000000,
        "Apis": [
          "M:EventWaitHandleAcl.Create(EventWaitHandleSecurity,bool,EventResetMode,string,out bool)",
          "M:MutexAcl.Create(MutexSecurity,bool,string,out bool)",
          "M:SemaphoreAcl.Create(SemaphoreSecurity,int,int,string,out bool)",
          "T:EventWaitHandleAcl",
          "T:MutexAcl",
          "T:SemaphoreAcl"
        ]
      }
    ]
  },
  {
    "Id": 73,
    "Date": "2019-10-22T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=VQuFvX2k-HA",
      "Id": "VQuFvX2k-HA",
      "StartDateTime": "2019-10-22T10:13:04.646-07:00",
      "EndDateTime": "2019-10-22T11:59:51-07:00",
      "Duration": 64063540000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VQuFvX2k-HA/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Net, System.Net.Http, System.Numerics, System.Reflection, System.Runtime.CompilerServices, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40740,
          "Title": "Attribute for minimal runtime impact during an unmanaged call",
          "Author": "AaronRobinsonMSFT",
          "CreatedAt": "2019-09-01T22:26:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30741",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545076797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40740#issuecomment-545076797",
        "FeedbackMarkdown": "* Would probably make sense on \u0060DllImportAttribute\u0060 but this attribute is specially encoded in metadata, so we can\u0027t easily do that\r\n* We believe this can\u0027t be internal and library authors will likely want this\r\n* This concept should work function pointers, however, it\u0027s unclear how this can be expressed. There is currently no way to express this.\r\n* The more generic API names (\u0060TrivialUnmanagedMethodAttribute\u0060, \u0060LimitedUnmanagedMethodAttribute\u0060) seem problematic because we\u0027re probably not likely to turn more runtime optimizations on when a method is attributed as *trivial*, which makes specific naming like this more useful.\r\n* We should probably make this attribute work for \u0060UnmanagedFunctionPointerAttribute\u0060 which names we should include \u0060Delegate\u0060 in the attribute targets.\r\n\t- @AaronRobinsonMSFT please confirm whether this feature will work for the existing umanaged function pointer delegates.\r\n* How would this feature work with function pointers?\r\n\t- @333fred @jaredpar what are you thoughts on this?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38585,
          "Title": "Provide an \u0060Unsafe.SkipInit\u0060 method to allow bypassing definite assignment rules.",
          "Author": "tannergooding",
          "CreatedAt": "2019-06-16T14:42:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29905",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545079783",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38585#issuecomment-545079783",
        "FeedbackMarkdown": "Looks good as proposed, ~~but we should constrain the \u0060T\u0060 to be unamanged.~~\r\n\r\nAfter discussion with @jkotas we concluded that we don\u0027t want *any* constraint. The JIT will do the right thing. Not even the \u0060struct\u0060 constraint should be there.\r\n\r\n\u0060\u0060\u0060C#\r\npublic static partial class Unsafe\r\n{\r\n    public static void SkipInit\u003CT\u003E(out T value);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20540000000,
        "Apis": [
          "M:Unsafe.SkipInit\u003CT\u003E(out T)",
          "T:Unsafe"
        ]
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41784,
          "Title": "Make Type implement IEquatable\u003CType\u003E",
          "Author": "TylerBrinkley",
          "CreatedAt": "2019-10-15T13:21:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31171",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545080947",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41784#issuecomment-545080947",
        "FeedbackMarkdown": "What about other types in the \u0060MemberInfo\u0060 hierarchy?\r\n\r\n@steveharter what are you thoughts?",
        "TimeCode": 24870000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41695,
          "Title": "Mark Assembly.CodeBase as obsolete",
          "Author": "terrajobst",
          "CreatedAt": "2019-10-09T23:56:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31127",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Reflection",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545084027",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41695#issuecomment-545084027",
        "FeedbackMarkdown": "Looks good. We should also mark it as \u0060[EditorBrowsable(Never)]\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection\r\n{\r\n    public partial class Assembly\r\n    {\r\n        [Obsolete(\u0022Use Location instead.\u0022)]\r\n        public virtual string CodeBase { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26580000000,
        "Apis": [
          "P:Assembly.CodeBase",
          "T:Assembly"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 9071,
          "Title": "Add HttpContent.SerializeToStreamAsync overload with cancellation",
          "Author": "stephentoub",
          "CreatedAt": "2016-06-02T17:40:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17492",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545093260",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/9071#issuecomment-545093260",
        "FeedbackMarkdown": "~~We should consider making the existing one non-abstract so that new types inheriting it don\u0027t have to overide the *bad* one. We obviously can\u0027t call each other because if a person didn\u0027t override either method, we shouldn\u0027t crash with a stack overflow.~~\r\n\r\n**Edit** We changed our mind. We\u0027ll leave it abstract and implementers should override both. We should think about a *soft abstract* attribute where an analyzer could warn people if they inherited but didn\u0027t override.\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpContent\r\n{\r\n    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken token);\r\n    protected abstract Task SerializeToStreamAsync(Stream stream, TransportContext context);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31270000000,
        "Apis": [
          "M:HttpContent.SerializeToStreamAsync(Stream,TransportContext,CancellationToken)",
          "M:HttpContent.SerializeToStreamAsync(Stream,TransportContext)",
          "T:HttpContent"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24475,
          "Title": "Proposal: SmtpClient.SendMailAsync overload with cancellation",
          "Author": "jnm2",
          "CreatedAt": "2017-10-06T13:39:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23756",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545097103",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24475#issuecomment-545097103",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Mail\r\n{\r\n    public partial class SmtpClient\r\n    {\r\n        public Task SendMailAsync(MailMessage message, CancellationToken cancellationToken);\r\n        public Task SendMailAsync(string from, string recipients, string subject, string body, CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45020000000,
        "Apis": [
          "M:SmtpClient.SendMailAsync(MailMessage,CancellationToken)",
          "M:SmtpClient.SendMailAsync(string,string,string,string,CancellationToken)",
          "T:SmtpClient"
        ]
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25295,
          "Title": "TryParse for email addresses ",
          "Author": "Grauenwolf",
          "CreatedAt": "2017-11-16T17:50:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/907",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545099733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25295#issuecomment-545099733",
        "FeedbackMarkdown": "* If we were to expose the \u0060TryParse\u0060 ones, we should also define corresponding static \u0060Parse\u0060 methods.\r\n* The bigger question is whether we\u0027d recommend \u0060MailAddress\u0060 at all. The [data annotations implementation for \u0060IsValid\u0060](https://source.dot.net/#System.ComponentModel.Annotations/System/ComponentModel/DataAnnotations/EmailAddressAttribute.cs,1dcffef3eace5290,references) is much simpler, probably because email addresses are complex and in practice most validators reject rare, but valid email addreses.",
        "TimeCode": 51160000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36379,
          "Title": "Provide a zero-cost mechanism for going between System.Numerics.Vector and System.Runtime.Intrinsics.Vector types",
          "Author": "tannergooding",
          "CreatedAt": "2019-03-26T21:25:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/952",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545102767",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36379#issuecomment-545102767",
        "FeedbackMarkdown": "Can we move \u0060Vector2\u0060, \u0060Vector3\u0060, \u0060Vector4\u0060 to corlib? It seems weird to add one more dumping ground for extension methods. Another benefit is that we\u0027d end up with all intrinsically understood types to be corlib then.",
        "TimeCode": 55190000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29780,
          "Title": "Add new overloads with ReadOnlySpan to System.Net.NetworkInformation.PhysicalAddress ",
          "Author": "iSazonov",
          "CreatedAt": "2018-05-18T06:39:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545105286",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29780#issuecomment-545105286",
        "FeedbackMarkdown": "We should also have \u0060string\u0060-based \u0060TryParse\u0060 method. We should also name the \u0060out\u0060 parameter \u0060value\u0060. Other than that, looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.NetworkInformation\r\n{\r\n    public class PhysicalAddress\r\n    {\r\n        public static bool TryParse(string address, out PhysicalAddress value);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E address, out PhysicalAddress value);\r\n        public static PhysicalAddress Parse(ReadOnlySpan\u003Cchar\u003E address);\r\n        // Existing\r\n        // public static PhysicalAddress Parse(string address);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59510000000,
        "Apis": [
          "M:PhysicalAddress.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:PhysicalAddress.TryParse(ReadOnlySpan\u003Cchar\u003E,out PhysicalAddress)",
          "M:PhysicalAddress.TryParse(string,out PhysicalAddress)",
          "T:PhysicalAddress"
        ]
      }
    ]
  },
  {
    "Id": 74,
    "Date": "2019-11-12T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=6NLJ1csBw14",
      "Id": "6NLJ1csBw14",
      "StartDateTime": "2019-11-12T10:05:42.319-08:00",
      "EndDateTime": "2019-11-12T12:00:36-08:00",
      "Duration": 68936810000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6NLJ1csBw14/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Net.Http, System.Runtime, System.Security, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29660,
          "Title": "HMAC-based Extract-and-Expand Key Derivation Function (HKDF)",
          "Author": "cocowalla",
          "CreatedAt": "2018-05-11T14:45:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26147",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553037689",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29660#issuecomment-553037689",
        "FeedbackMarkdown": "* ~~\u0060Expand\u0060. We should align the optionality of the \u0060info\u0060 parameter between the span version and the byte array version.~~\r\n    - This might cause ambiguity. We decided that optionality is omitted from the span versions\r\n    - However, we should align the order to \u0060outputLength\u0060 and \u0060output\u0060. We should swap \u0060output\u0060 and \u0060info\u0060 in the span-based version.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public static class HKDF\r\n    {\r\n        public static byte[] Extract(HashAlgorithmName hashAlgorithmName, byte[] ikm, byte[] salt = null);\r\n        public static int Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E ikm, ReadOnlySpan\u003Cbyte\u003E salt, Span\u003Cbyte\u003E prk);\r\n\r\n        public static byte[] Expand(HashAlgorithmName hashAlgorithmName, byte[] prk, int outputLength, byte[] info = null);\r\n        public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E prk, Span\u003Cbyte\u003E output, ReadOnlySpan\u003Cbyte\u003E info);\r\n\r\n        public static byte[] DeriveKey(HashAlgorithmName hashAlgorithmName, byte[] ikm, int outputLength, byte[] salt = null, byte[] info = null);\r\n        public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E ikm, Span\u003Cbyte\u003E output, ReadOnlySpan\u003Cbyte\u003E salt, ReadOnlySpan\u003Cbyte\u003E info);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HKDF.DeriveKey(HashAlgorithmName,byte[],int,byte[],byte[])",
          "M:HKDF.DeriveKey(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HKDF.Expand(HashAlgorithmName,byte[],int,byte[])",
          "M:HKDF.Expand(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HKDF.Extract(HashAlgorithmName,byte[],byte[])",
          "M:HKDF.Extract(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "T:HKDF"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32615,
          "Title": "Add cancellation overloads on HttpClient and HttpContent",
          "Author": "baal2000",
          "CreatedAt": "2018-10-04T14:38:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/916",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553050411",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32615#issuecomment-553050411",
        "FeedbackMarkdown": "* Looks good, but optionality is pointless because the overload without the token already exists\r\n* Name of methods on \u0060HttpContent\u0060 should be \u0060ReadAsXxx\u0060\r\n* Return types needs fixing up\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpClient\r\n{\r\n    // New APIs\r\n\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    public Task\u003CStream\u003E GetStreamAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003CStream\u003E GetStreamAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    public Task\u003Cstring\u003E GetStringAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003Cstring\u003E GetStringAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    // Existing APIs\r\n\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(string requestUri);\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(Uri requestUri);\r\n\r\n    public Task\u003CStream\u003E GetStreamAsync(string requestUri);\r\n    public Task\u003CStream\u003E GetStreamAsync(Uri requestUri);\r\n\r\n    public Task\u003Cstring\u003E GetStringAsync(string requestUri);\r\n    public Task\u003Cstring\u003E GetStringAsync(Uri requestUri);\r\n}\r\n\r\npartial class HttpContent\r\n{\r\n    // New APIs\r\n\r\n    public Task\u003Cbyte[]\u003E ReadAsByteArrayAsync(CancellationToken cancellationToken);\r\n    public Task\u003CStream\u003E ReadAsStreamAsync(CancellationToken cancellationToken);\r\n    public Task\u003Cstring\u003E ReadAsStringAsync(CancellationToken cancellationToken);\r\n\r\n    // Existing APIs\r\n\r\n    public Task\u003Cbyte[]\u003E ReadAsByteArrayAsync();\r\n    public Task\u003CStream\u003E ReadAsStreamAsync();\r\n    public Task\u003Cstring\u003E ReadAsStringAsync();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14240000000,
        "Apis": [
          "M:HttpClient.GetByteArrayAsync(string,CancellationToken)",
          "M:HttpClient.GetByteArrayAsync(string)",
          "M:HttpClient.GetByteArrayAsync(Uri,CancellationToken)",
          "M:HttpClient.GetByteArrayAsync(Uri)",
          "M:HttpClient.GetStreamAsync(string,CancellationToken)",
          "M:HttpClient.GetStreamAsync(string)",
          "M:HttpClient.GetStreamAsync(Uri,CancellationToken)",
          "M:HttpClient.GetStreamAsync(Uri)",
          "M:HttpClient.GetStringAsync(string,CancellationToken)",
          "M:HttpClient.GetStringAsync(string)",
          "M:HttpClient.GetStringAsync(Uri,CancellationToken)",
          "M:HttpClient.GetStringAsync(Uri)",
          "M:HttpContent.ReadAsByteArrayAsync()",
          "M:HttpContent.ReadAsByteArrayAsync(CancellationToken)",
          "M:HttpContent.ReadAsStreamAsync()",
          "M:HttpContent.ReadAsStreamAsync(CancellationToken)",
          "M:HttpContent.ReadAsStringAsync()",
          "M:HttpContent.ReadAsStringAsync(CancellationToken)",
          "T:HttpClient",
          "T:HttpContent"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33006,
          "Title": "Add List\u003CT\u003E.CopyTo(Span\u003CT\u003E) overloads",
          "Author": "eerhardt",
          "CreatedAt": "2018-10-24T16:19:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27721",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553078596",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33006#issuecomment-553078596",
        "FeedbackMarkdown": "Wow, that took quoit a bit \uD83D\uDE04 \r\n\r\n* Makes sense. We should just make sure that \u0060List\u003CT\u003E.CopyTo(someInt, someArray, anotherInt)\u0060 doesn\u0027t magically bind to the span version.\r\n    - While not a breaking having the third parameter having different behavior is bad (\u0060arrayIndex\u0060 vs. \u0060count\u0060)\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class List\u003CT\u003E\r\n{\r\n    // public void CopyTo(int index, T[] array, int arrayIndex, int count);\r\n    // public void CopyTo(T[] array, int arrayIndex);\r\n    // public void CopyTo(T[] array);\r\n\r\n    public void CopyTo(Span\u003CT\u003E destination);\r\n    public void CopyTo(int sourceIndex, int count, Span\u003CT\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24290000000,
        "Apis": [
          "M:List\u003CT\u003E.CopyTo(int,int,Span\u003CT\u003E)",
          "M:List\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "T:List\u003CT\u003E"
        ]
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33543,
          "Title": "Expose the match length when using String.IndexOf in culture specific mode",
          "Author": "GSPP",
          "CreatedAt": "2018-11-16T13:03:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27935",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553082487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33543#issuecomment-553082487",
        "FeedbackMarkdown": "@GrabYourPitchforks mentioned that he\u0027s planning on addressing this issue in UTF8 string. He\u0027s thinking of exposing something like \u0060TryFind\u0060 that outputs a \u0060Range\u0060. We should make sure the work aligns.",
        "TimeCode": 53490000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33701,
          "Title": "Proposal: Hide Thread.VolatileRead and Thread.VolatileWrite",
          "Author": "carlreinke",
          "CreatedAt": "2018-11-27T06:01:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27997",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            },
            {
              "Name": "code-fixer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553086736",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33701#issuecomment-553086736",
        "FeedbackMarkdown": "* This seems like a good candidate for a code fixer that replaces the call site.\r\n* Usage of these APIs is low.\r\n* We should consider this API in our plan for obsoletion.\r\n* Hiding these APIs seems fine.",
        "TimeCode": 58410000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36068,
          "Title": "ComputeHash Async required",
          "Author": "mgardi85",
          "CreatedAt": "2019-03-15T04:23:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28978",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553088815",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36068#issuecomment-553088815",
        "FeedbackMarkdown": "* Makes sense. We shouldn\u0027t make the API virtual though because it just does an async read and then forwards to the existing sync API\r\n* Without \u0060virtual\u0060, we don\u0027t need \u0060HashCoreAsync\u0060\r\n\r\n\r\n\u0060\u0060\u0060C#\r\npublic class HashAlgorithm\r\n{\r\n    public Task\u003Cbyte[]\u003E ComputeHashAsync(Stream inputStream, CancellationToken cancellationToken = default);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64910000000,
        "Apis": [
          "M:HashAlgorithm.ComputeHashAsync(Stream,CancellationToken)",
          "T:HashAlgorithm"
        ]
      }
    ]
  },
  {
    "Id": 75,
    "Date": "2019-11-26T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=b509D73mmGc",
      "Id": "b509D73mmGc",
      "StartDateTime": "2019-11-26T10:06:54.661-08:00",
      "EndDateTime": "2019-11-26T12:03:51-08:00",
      "Duration": 70163390000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b509D73mmGc/mqdefault.jpg"
    },
    "Title": "System.Net.Sockets, System.Runtime.Intrinsics, System.Security, System.Threading.Channels",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24977,
          "Title": "Add asynchronous overload of WindowsIdentity.RunImpersonated ",
          "Author": "Tratcher",
          "CreatedAt": "2017-10-31T18:37:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24009",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558756052",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24977#issuecomment-558756052",
        "FeedbackMarkdown": "* These APIs can be simply implemented over the existing one, thanks for generics.\r\n* However, it\u0027s not obvious that is in fact supported. Adding explicit overload that are named with the \u0060Async\u0060 suffix would make sense\r\n* We considered adding a cancellation token, but given callers likely have to allocate a closure anyway, this doesn\u0027t save anything and impersonation is already expensive.\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Security.Principal\r\n{\r\n    public partial class WindowsIdentity\r\n    {\r\n        public static Task\u003CT\u003E RunImpersonatedAsync\u003CT\u003E(SafeAccessTokenHandle safeAccessTokenHandle, Func\u003CTask\u003CT\u003E\u003E func)\r\n            =\u003E RunImpersonated(safeAccessTokenHandle, func);\r\n\r\n        public static Task RunImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle, Func\u003CTask\u003E func)\r\n            =\u003E RunImpersonated(safeAccessTokenHandle, func);    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:WindowsIdentity.RunImpersonatedAsync(SafeAccessTokenHandle,Func\u003CTask\u003E)",
          "M:WindowsIdentity.RunImpersonatedAsync\u003CT\u003E(SafeAccessTokenHandle,Func\u003CTask\u003CT\u003E\u003E)",
          "T:WindowsIdentity"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27643,
          "Title": "Consider Socket.OSSupportsUnixDomainSockets property",
          "Author": "stephentoub",
          "CreatedAt": "2018-03-02T04:15:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/863",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558760298",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27643#issuecomment-558760298",
        "FeedbackMarkdown": "* Some version of Windows 10 supports Unix domain sockets; having a capability API to check this without having to know the exact OS version\r\n* Only concern is that there are more capability APIs we might have to expose in the future. It\u0027s debatable whether a Boolean properties on this type are the correct pattern, but it seems consistent with prior art and domain sockets are reasonably common.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        public static bool OSSupportsUnixDomainSockets { get; }\r\n        // Existing APIs\r\n        // public static bool OSSupportsIPv4 { get; }\r\n        // public static bool OSSupportsIPv6 { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7500000000,
        "Apis": [
          "P:Socket.OSSupportsUnixDomainSockets",
          "T:Socket"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30852,
          "Title": "System.Threading.Channels : Expose Channel.EstimatedCount",
          "Author": "mgravell",
          "CreatedAt": "2018-07-05T21:08:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26706",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Channels",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558762980",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30852#issuecomment-558762980",
        "FeedbackMarkdown": "* We considered naming the property with \u0060EstimatedCount\u0060 but that seems overkill because you never get an exact count unless you freeze the world, but that\u0027s the nature of concurrent APIs.\r\n* We can\u0027t make the API abstract, but most of us believe that the API guideline is to use the Tester-Doer pattern (capability API \u002B API).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Channels\r\n{\r\n    public abstract partial class ChannelReader\u003CT\u003E\r\n    {\r\n        public virtual bool CanCount =\u003E false;\r\n        public virtual int Count { get; }\r\n    }\r\n    public abstract partial class ChannelWriter\u003CT\u003E\r\n    {\r\n        public virtual bool CanCount =\u003E false;\r\n        public virtual int Count { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14160000000,
        "Apis": [
          "P:ChannelReader\u003CT\u003E.CanCount",
          "P:ChannelReader\u003CT\u003E.Count",
          "P:ChannelWriter\u003CT\u003E.CanCount",
          "P:ChannelWriter\u003CT\u003E.Count",
          "T:ChannelReader\u003CT\u003E",
          "T:ChannelWriter\u003CT\u003E"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 42684,
          "Title": "Support Rfc3279 signature format for DSA and EcDSA",
          "Author": "krwq",
          "CreatedAt": "2019-11-22T21:34:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31548",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558782564",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/42684#issuecomment-558782564",
        "FeedbackMarkdown": "* The APIs cannot be resumed, thus no \u0060OperationStatus\u0060 or \u0060bytesConsumed\u0060 outputs\r\n* The naming is slightly different between \u0060DSA\u0060 and \u0060ECDsa\u0060 but this mirrors existing conventions\r\n* \u0060out\u0060 should go last\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Security.Cryptography\r\n{\r\n    public enum DSASignatureFormat\r\n    {\r\n        IeeeP1363FixedFieldConcatenation,\r\n        Rfc3279DerSequence\r\n    }\r\n\r\n    public abstract partial class DSA : AsymmetricAlgorithm\r\n    {\r\n        public byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool TrySignData(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignDataCore(ReadOnlySpan\u003Cbyte\u003E data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n\r\n        public byte[] CreateSignature(byte[] rgbHash, DSASignatureFormat signatureFormat);\r\n        public bool TryCreateSignature(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] CreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TryCreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifySignature(byte[] rgbHash, byte[] rgbSignature, DSASignatureFormat signatureFormat);\r\n        public bool VerifySignature(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifySignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n\r\n        public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);\r\n    }\r\n\r\n    public abstract partial class ECDsa : AsymmetricAlgorithm\r\n    {\r\n        public byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool TrySignData(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignDataCore(ReadOnlySpan\u003Cbyte\u003E data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n\r\n        public byte[] SignHash(byte[] hash, DSASignatureFormat signatureFormat);\r\n        public bool TrySignHash(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignHashCore(ReadOnlySpan\u003Cbyte\u003E hash, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignHashCore(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyHash(byte[] hash, byte[] signature, DSASignatureFormat signatureFormat);\r\n        public bool VerifyHash(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyHashCore(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n\r\n        public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 36740000000,
        "Apis": [
          "F:DSASignatureFormat.IeeeP1363FixedFieldConcatenation",
          "F:DSASignatureFormat.Rfc3279DerSequence",
          "M:DSA.CreateSignature(byte[],DSASignatureFormat)",
          "M:DSA.CreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:DSA.GetMaxSignatureSize(DSASignatureFormat)",
          "M:DSA.SignData(byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignData(byte[],int,int,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignData(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignDataCore(ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignDataCore(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.TryCreateSignature(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:DSA.TryCreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:DSA.TrySignData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:DSA.TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:DSA.VerifyData(byte[],byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(byte[],int,int,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(Stream,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyDataCore(Stream,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifySignature(byte[],byte[],DSASignatureFormat)",
          "M:DSA.VerifySignature(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:DSA.VerifySignatureCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.GetMaxSignatureSize(DSASignatureFormat)",
          "M:ECDsa.SignData(byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignData(byte[],int,int,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignData(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignDataCore(ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignDataCore(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignHash(byte[],DSASignatureFormat)",
          "M:ECDsa.SignHashCore(ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.TrySignData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignHashCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:ECDsa.VerifyData(byte[],byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(byte[],int,int,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(Stream,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyDataCore(Stream,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyHash(byte[],byte[],DSASignatureFormat)",
          "M:ECDsa.VerifyHash(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.VerifyHashCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "T:DSA",
          "T:DSASignatureFormat",
          "T:ECDsa"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33566,
          "Title": "Consider exposing a HWIntrinsic that allows efficient loading, regardless of encoding.",
          "Author": "tannergooding",
          "CreatedAt": "2018-11-17T17:45:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/954",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "untriaged",
              "BackgroundColor": "fbca04",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558793376",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33566#issuecomment-558793376",
        "FeedbackMarkdown": "* \u0060LoadAlignedVector128Unsafe\u0060 will throw an \u0060AccessViolationException\u0060 when optimizations are disabled when the data isn\u0027t aligned. When optimizations are on, it depends on the hardware. On newer hardware, the access will work but be slower. Older hardware will AV.\r\n* We should include the word \u0060Aligned\u0060 in the API\r\n* In general, \u0060Unsafe\u0060 should be a prefix, rather than a suffix (to make sure it pops) but to be consistent with other APIs we\u0027ll go with a suffix here.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public partial abstract class Sse\r\n    {\r\n        // New APIs:\r\n        public unsafe Vector128\u003Cfloat\u003E LoadAlignedVector128Unsafe(float* address);\r\n\r\n        // Existing APIs:\r\n        // public unsafe Vector128\u003Cfloat\u003E LoadVector128(float* address);\r\n        // public unsafe Vector128\u003Cfloat\u003E LoadAlignedVector128(float* address);\r\n    }\r\n\r\n    public partial abstract class Sse2\r\n    {\r\n        // New APIs:\r\n        public unsafe Vector128\u003Cdouble\u003E LoadAlignedVector128Unsafe(double* address);\r\n        public unsafe Vector128\u003Cbyte\u003E LoadAlignedVector128Unsafe(byte* address);\r\n        public unsafe Vector128\u003Csbyte\u003E LoadAlignedVector128Unsafe(sbyte* address);\r\n        public unsafe Vector128\u003Cshort\u003E LoadAlignedVector128Unsafe(short* address);\r\n        public unsafe Vector128\u003Cushort\u003E LoadAlignedVector128Unsafe(ushort* address);\r\n        public unsafe Vector128\u003Cint\u003E LoadAlignedVector128Unsafe(int* address);\r\n        public unsafe Vector128\u003Cuint\u003E LoadAlignedVector128Unsafe(uint* address);\r\n        public unsafe Vector128\u003Clong\u003E LoadAlignedVector128Unsafe(long* address);\r\n        public unsafe Vector128\u003Culong\u003E LoadAlignedVector128Unsafe(ulong* address);\r\n\r\n        // Existing APIs:\r\n        // public unsafe Vector128\u003Cdouble\u003E LoadVector128(double* address);\r\n        // public unsafe Vector128\u003Cbyte\u003E LoadVector128(byte* address);\r\n        // public unsafe Vector128\u003Csbyte\u003E LoadVector128(sbyte* address);\r\n        // public unsafe Vector128\u003Cshort\u003E LoadVector128(short* address);\r\n        // public unsafe Vector128\u003Cushort\u003E LoadVector128(ushort* address);\r\n        // public unsafe Vector128\u003Cint\u003E LoadVector128(int* address);\r\n        // public unsafe Vector128\u003Cuint\u003E LoadVector128(uint* address);\r\n        // public unsafe Vector128\u003Clong\u003E LoadVector128(long* address);\r\n        // public unsafe Vector128\u003Culong\u003E LoadVector128(ulong* address);\r\n        //\r\n        // public unsafe Vector128\u003Cdouble\u003E LoadAlignedVector128(double* address);\r\n        // public unsafe Vector128\u003Cbyte\u003E LoadAlignedVector128(byte* address);\r\n        // public unsafe Vector128\u003Csbyte\u003E LoadAlignedVector128(sbyte* address);\r\n        // public unsafe Vector128\u003Cshort\u003E LoadAlignedVector128(short* address);\r\n        // public unsafe Vector128\u003Cushort\u003E LoadAlignedVector128(ushort* address);\r\n        // public unsafe Vector128\u003Cint\u003E LoadAlignedVector128(int* address);\r\n        // public unsafe Vector128\u003Cuint\u003E LoadAlignedVector128(uint* address);\r\n        // public unsafe Vector128\u003Clong\u003E LoadAlignedVector128(long* address);\r\n        // public unsafe Vector128\u003Culong\u003E LoadAlignedVector128(ulong* address);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48660000000,
        "Apis": [
          "M:Sse.LoadAlignedVector128Unsafe(float*)",
          "M:Sse2.LoadAlignedVector128Unsafe(byte*)",
          "M:Sse2.LoadAlignedVector128Unsafe(double*)",
          "M:Sse2.LoadAlignedVector128Unsafe(int*)",
          "M:Sse2.LoadAlignedVector128Unsafe(long*)",
          "M:Sse2.LoadAlignedVector128Unsafe(sbyte*)",
          "M:Sse2.LoadAlignedVector128Unsafe(short*)",
          "M:Sse2.LoadAlignedVector128Unsafe(uint*)",
          "M:Sse2.LoadAlignedVector128Unsafe(ulong*)",
          "M:Sse2.LoadAlignedVector128Unsafe(ushort*)",
          "T:Sse",
          "T:Sse2"
        ]
      }
    ]
  },
  {
    "Id": 76,
    "Date": "2019-12-10T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=zTzY7iL34Hg",
      "Id": "zTzY7iL34Hg",
      "StartDateTime": "2019-12-10T10:05:25.574-08:00",
      "EndDateTime": "2019-12-10T11:59:02-08:00",
      "Duration": 68164260000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/zTzY7iL34Hg/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Diagnostics.Process, System.IO, System.Memory, System.Net.Http, System.Net.Sockets, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 576,
          "Title": "More cancellation overloads for HttpContent",
          "Author": "MihaZupan",
          "CreatedAt": "2019-12-05T17:36:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/576",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564164757",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/576#issuecomment-564164757",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpContent\r\n{\r\n    protected virtual Task\u003CStream\u003E CreateContentReadStreamAsync(); // Exists\r\n    protected virtual Task\u003CStream\u003E CreateContentReadStreamAsync(CancellationToken cancellationToken);\r\n\r\n    public Task CopyToAsync(Stream stream); // Exists\r\n    public Task CopyToAsync(Stream stream, TransportContext context); // Exists\r\n    public Task CopyToAsync(Stream stream, CancellationToken cancellationToken);\r\n    public Task CopyToAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpContent.CopyToAsync(Stream,CancellationToken)",
          "M:HttpContent.CopyToAsync(Stream,TransportContext,CancellationToken)",
          "M:HttpContent.CopyToAsync(Stream,TransportContext)",
          "M:HttpContent.CopyToAsync(Stream)",
          "M:HttpContent.CreateContentReadStreamAsync()",
          "M:HttpContent.CreateContentReadStreamAsync(CancellationToken)",
          "T:HttpContent"
        ]
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33791,
          "Title": "Option to allow HttpClient to follow HTTPS -\u003E HTTP redirects",
          "Author": "martin-heralecky",
          "CreatedAt": "2018-12-01T22:05:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28039",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564169859",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33791#issuecomment-564169859",
        "FeedbackMarkdown": "This needs work:\r\n\r\n* It\u0027s a dangerous API; the name seems OK, although we normally use the \u0060Unsafe\u0060 prefix.\r\n* We wonder whether instead of simple bool this should be callback that takes at least the URL or even the request message and return true whether it should be redirected or not.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler\r\n    {\r\n        public bool DangerousAllowHttpsToHttpRedirection { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8450000000,
        "Apis": [
          "P:SocketsHttpHandler.DangerousAllowHttpsToHttpRedirection",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34019,
          "Title": "Add ImmutableHashSet\u003CT\u003E.Builder.TryGetValue",
          "Author": "GeorgeAlexandria",
          "CreatedAt": "2018-12-12T13:08:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28160",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564172216",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34019#issuecomment-564172216",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\nHowever, we should review the API surface of all immutable types and make sure that the API surface of the builder is logically equivalent.\r\n\r\n@GeorgeAlexandria / @safern would one of you be willing to do that?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Immutable\r\n{\r\n    public partial class ImmutableHashSet\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        {\r\n            public bool TryGetValue(T equalValue, out T actualValue);\r\n        }\r\n    }\r\n\r\n    public partial class ImmutableSortedSet\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        {\r\n            public bool TryGetValue(T equalValue, out T actualValue);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15520000000,
        "Apis": [
          "M:ImmutableHashSet\u003CT\u003E.Builder.TryGetValue(T,out T)",
          "M:ImmutableSortedSet\u003CT\u003E.Builder.TryGetValue(T,out T)",
          "T:ImmutableHashSet\u003CT\u003E",
          "T:ImmutableHashSet\u003CT\u003E.Builder",
          "T:ImmutableSortedSet\u003CT\u003E",
          "T:ImmutableSortedSet\u003CT\u003E.Builder"
        ]
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34144,
          "Title": "Create APIs to deal with processing ASCII text (as bytes)",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-12-18T18:15:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28230",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564176989",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34144#issuecomment-564176989",
        "FeedbackMarkdown": "Looks good but needs work:\r\n\r\n* We didn\u0027t like the name \u0060AsciiUtility\u0060\r\n* We felt the type should be in \u0060System.Buffers.Text\u0060 as that\u0027s the home for low-level span-based APIs for specific encodings\r\n* We should add other operations, such as:\r\n    - \u0060GetHashCode\u0060\r\n    - \u0060Compare\u0060\r\n    - ...\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Text\r\n{\r\n   public static class Ascii\r\n   {\r\n      public static bool EqualsOrdinalIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n      public static int ToLowerInvariant(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n      public static int ToUpperInvariant(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n      public static void ToLowerInvariantInPlace(Span\u003Cbyte\u003E buffer);\r\n      public static void ToUpperInvariantInPlace(Span\u003Cbyte\u003E buffer);\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19020000000,
        "Apis": [
          "M:Ascii.EqualsOrdinalIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInvariant(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInvariantInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInvariant(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInvariantInPlace(Span\u003Cbyte\u003E)",
          "T:Ascii"
        ]
      },
      {
        "Id": 5,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34619,
          "Title": "Proposal: Add an atomic ToArray \u002B Clear method to ConcurrentDictionary\u003CTKey, TValue\u003E",
          "Author": "smourier",
          "CreatedAt": "2019-01-16T10:27:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28434",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564182556",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34619#issuecomment-564182556",
        "FeedbackMarkdown": "Maybe we don\u0027t understand the scenario but as stated it doesn\u0027t make sense to us:\r\n\r\n1. In order to be safe, dispose needs to stop any party that adds to the dictionary\r\n2. Once that\u0027s done, you can just drain the dictionary\r\n\r\n@stephentoub, any other thoughts?",
        "TimeCode": 26160000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34689,
          "Title": "WaitForExitAsync for System.Diagnostics.Process",
          "Author": "MattKotsenas",
          "CreatedAt": "2019-01-19T00:23:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28458",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564185885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34689#issuecomment-564185885",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Process\r\n    {\r\n        public Task WaitForExitAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34170000000,
        "Apis": [
          "M:Process.WaitForExitAsync(CancellationToken)",
          "T:Process"
        ]
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35400,
          "Title": "Implement IBufferWrite\u003Cbyte\u003E on MemoryStream",
          "Author": "davidfowl",
          "CreatedAt": "2019-02-18T23:07:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28719",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564205625",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35400#issuecomment-564205625",
        "FeedbackMarkdown": "A couple of questions:\r\n\r\n* Why do you need it on \u0060MemoryStream\u0060? Why is \u0060ArrayBufferWriter\u003Cbyte\u003E\u0060 not sufficient for your scenarios?\r\n* Do you actually need an \u0060IBufferWriter\u003Cbyte\u003E\u0060 that is also a stream?\r\n* Any objection to us creating an allocation-free method on a stream type that returns an \u0060IBufferWriter\u003Cbyte\u003E\u0060?",
        "TimeCode": 39260000000,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35410,
          "Title": "Change NetworkStream.Socket property from protected to public",
          "Author": "stephentoub",
          "CreatedAt": "2019-02-19T14:51:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28723",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564210981",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35410#issuecomment-564210981",
        "FeedbackMarkdown": "Seems fine. The only question is: @scalablecory mentioned that we might want to use \u0060NetworkStream\u0060 for non-socket based streams, e.g. QUIC. What would happen then?\r\n\r\n\u003E \u0060Socket\u0060 property is protected, but not virtual, which means we should be able to just change its visibility.\r\n\r\nThat\u0027s correct and we\u0027ve done this in the past.",
        "TimeCode": 49140000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35791,
          "Title": "Add Single and Double overloads to BinaryPrimitives",
          "Author": "eerhardt",
          "CreatedAt": "2019-03-05T16:57:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2365",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564214440",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35791#issuecomment-564214440",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* Should we also add these methods for parity?\r\n    - \u0060ReverseEndianness(float)\u0060\r\n    - \u0060ReverseEndianness(double)\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Binary\r\n{\r\n    public static class BinaryPrimitives\r\n    {\r\n        public static float ReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static float ReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static double ReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static double ReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n\r\n        public static bool TryReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out float value);\r\n        public static bool TryReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out float value);\r\n        public static bool TryReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out double value);\r\n        public static bool TryReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out double value);\r\n\r\n        public static bool TryWriteSingleBigEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static bool TryWriteSingleLittleEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static bool TryWriteDoubleBigEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n        public static bool TryWriteDoubleLittleEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n\r\n        public static void WriteSingleBigEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static void WriteSingleLittleEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static void WriteDoubleBigEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n        public static void WriteDoubleLittleEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 56400000000,
        "Apis": [
          "M:BinaryPrimitives.ReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.TryReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E,out double)",
          "M:BinaryPrimitives.TryReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out double)",
          "M:BinaryPrimitives.TryReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E,out float)",
          "M:BinaryPrimitives.TryReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out float)",
          "M:BinaryPrimitives.TryWriteDoubleBigEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.TryWriteSingleBigEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.TryWriteSingleLittleEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.WriteDoubleBigEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.WriteDoubleLittleEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.WriteSingleBigEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.WriteSingleLittleEndian(System.Span\u003Cbyte\u003E,float)",
          "T:BinaryPrimitives"
        ]
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35861,
          "Title": "add Span overloads for Socket datagram functions",
          "Author": "wfurt",
          "CreatedAt": "2019-03-07T18:09:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/938",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564217357",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35861#issuecomment-564217357",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* However, should we stop adding async methods as extension and just make them proper public instance methods?\r\n* In fact we may want to hide the entire \u0060SocketTaskExtensions\u0060 because it was only used as a bridge pack for .NET Framework.\r\n* Remaining: we should have overloads for the method that take \u0060IList\u003CArraySegment\u003Cbyte\u003E\u003E\u0060 because they are more efficient.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // Open question: consider defaulting SocketFlags to SocketFlags.None to reduce API space? Might challenge IntelliSense.\r\n\r\n    public partial class Socket : IDisposable\r\n    {\r\n        // existing: public int SendTo(byte[] buffer, EndPoint remoteEP);\r\n        public int SendTo(ReadOnlySpan\u003Cbyte\u003E buffer, EndPoint remoteEP);\r\n\r\n        // existing: public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n        public int SendTo(ReadOnlySpan\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n\r\n        // existing: public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP);\r\n        public int ReceiveFrom(Span\u003Cbyte\u003E buffer, ref EndPoint remoteEP);\r\n\r\n        // existing: public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP);\r\n        public int ReceiveFrom(Span\u003Cbyte\u003E buffer, SocketFlags socketFlags, ref EndPoint remoteEP);\r\n    }\r\n\r\n    public static class SocketTaskExtensions\r\n    {\r\n        // existing: public static Task\u003Cint\u003E SendToAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n        public static ValueTask\u003Cint\u003E SendToAsync(this Socket socket, ReadOnlyMemory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003Cint\u003E SendToAsync(this Socket socket, ReadOnlyMemory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\r\n        // existing: public static Task\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public static ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\r\n        // existing: public static Task\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public static ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61300000000,
        "Apis": [
          "M:Socket.ReceiveFrom(Span\u003Cbyte\u003E,ref EndPoint)",
          "M:Socket.ReceiveFrom(Span\u003Cbyte\u003E,SocketFlags,ref EndPoint)",
          "M:Socket.SendTo(ReadOnlySpan\u003Cbyte\u003E,EndPoint)",
          "M:Socket.SendTo(ReadOnlySpan\u003Cbyte\u003E,SocketFlags,EndPoint)",
          "M:SocketTaskExtensions.ReceiveFromAsync(this Socket,Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveFromAsync(this Socket,Memory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveMessageFromAsync(this Socket,Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveMessageFromAsync(this Socket,Memory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.SendToAsync(this Socket,ReadOnlyMemory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.SendToAsync(this Socket,ReadOnlyMemory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "T:Socket",
          "T:SocketTaskExtensions"
        ]
      }
    ]
  },
  {
    "Id": 77,
    "Date": "2019-12-17T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=VRTCAkk7wKU",
      "Id": "VRTCAkk7wKU",
      "StartDateTime": "2019-12-17T10:05:54.825-08:00",
      "EndDateTime": "2019-12-17T12:05:32-08:00",
      "Duration": 71771750000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VRTCAkk7wKU/mqdefault.jpg"
    },
    "Title": "System.IO.Compression, System.Runtime.InteropServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36133,
          "Title": "MemoryMarshal.GetRawArrayData",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-03-18T23:39:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29003",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-17T00:00:00-08:00",
        "FeedbackId": "566723424",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36133#issuecomment-566723424",
        "FeedbackMarkdown": "We considered this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        public static ref T GetRawArrayRef\u003CT\u003E(ref T source);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nbut we\u0027d prefer this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static ref T GetReference\u003CT\u003E(T[] array);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n(Please not that\u0027s OK because the existing \u0060GetReference\u003CT\u003E()\u0060 method don\u0027t bind for arrays due to an ambiguous match, so the caller had to add a cast.)",
        "TimeCode": 0,
        "Apis": [
          "M:MemoryMarshal.GetReference\u003CT\u003E(T[])",
          "M:Unsafe.GetRawArrayRef\u003CT\u003E(ref T)",
          "T:MemoryMarshal",
          "T:Unsafe"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36348,
          "Title": "API request : CompressionLevel.Highest",
          "Author": "ericstj",
          "CreatedAt": "2019-03-25T21:05:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1549",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Compression",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2019-12-17T00:00:00-08:00",
        "FeedbackId": "566725990",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36348#issuecomment-566725990",
        "FeedbackMarkdown": "* We prefer \u0060SmallestSize\u0060 to make it more clear what the API does (\u0060Highest\u0060 or \u0060Best\u0060 seem ambiguous with \u0060Optimal\u0060).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Compression\r\n{\r\n    public partial enum CompressionLevel\r\n    {\r\n        SmallestSize\r\n\r\n        // Existing:\r\n        // Fastest,\r\n        // NoCompression,\r\n        // Optimal\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 65490000000,
        "Apis": [
          "F:CompressionLevel.SmallestSize",
          "T:CompressionLevel"
        ]
      }
    ]
  },
  {
    "Id": 78,
    "Date": "2020-01-07T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=lSB-ACeetRo",
      "Id": "lSB-ACeetRo",
      "StartDateTime": "2020-01-07T10:04:00-08:00",
      "EndDateTime": "2020-01-07T12:01:31-08:00",
      "Duration": 70510000000,
      "Title": ".NET Design Reviews: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/lSB-ACeetRo/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Diagnostics, System.Net, System.Net.Sockets, System.Numerics, System.Runtime.InteropServices, System.Security, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36925,
          "Title": "Expose Math.MaxNumber and Math.MinNumber functions that don\u0027t propagate NaN",
          "Author": "tannergooding",
          "CreatedAt": "2019-04-16T16:15:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29279",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571721383",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36925#issuecomment-571721383",
        "FeedbackMarkdown": "* Should we have a wider discussion about putting future APIs on the primitive\r\n  types (\u0060double\u0060, \u0060half\u0060, etc.) instead of the \u0060Math\u0060 / \u0060MathF\u0060 / \u0060MathH\u0060\r\n  classes? Otherwise there\u0027s likely to be an explosion of \u0060Math*\u0060 types and APIs\r\n  on those types.\r\n* If we decide that putting these APIs on the primitive types isn\u0027t worthwhile\r\n  then the proposal as stated here seems viable. There was some discussion on\r\n  whether we should keep the \u0060Number\u0060 name and whether those APIs would be\r\n  discoverable enough, but: (a) these names match what IEEE uses; and (b) it\u0027s\r\n  ok if users keep using the old APIs instead of the new APIs for the majority\r\n  of use cases.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 939,
          "Title": "Add address family specific name resolution to Dns",
          "Author": "scalablecory",
          "CreatedAt": "2019-10-22T21:20:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/939",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571705400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/939#issuecomment-571705400",
        "FeedbackMarkdown": "* Do we have some kind of guarantee that the supported OSes have a \u0022return\r\n  synchronously if you have the relevant data already cached\u0022 behavior? If so,\r\n  then it would make sense for these APIs to return \u0060ValueTask\u003CT\u003E\u0060. Without that\r\n  underlying OS support then we should keep these as \u0060Task\u003CT\u003E\u0060. It also helps\r\n  usability if callers want to maintain their own cache of returned values so\r\n  that they don\u0027t have to rely on the OS\u0027s underlying cache.\r\n* Aside from this, marking _approved_.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 861,
          "Title": "Happy Eyeballs support in Socket.ConnectAsync",
          "Author": "scalablecory",
          "CreatedAt": "2019-10-15T08:16:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/861",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571712410",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/861#issuecomment-571712410",
        "FeedbackMarkdown": "* Take the new parameter and move it to the end of the parameter list of the new\r\n  overload.\r\n* Remove \u0060[Flags]\u0060 from the enum. We can add it later if necessary as long as we\r\n  only have 1 legal value on the enum right now.\r\n* Rename the zero value to _Default_.\r\n* Consider renaming the enum to \u0060ConnectionAlgorithm\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37220,
          "Title": "Add HashSet.AsReadOnly",
          "Author": "vanillajonathan",
          "CreatedAt": "2019-04-26T13:13:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29387",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571732291",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37220#issuecomment-571732291",
        "FeedbackMarkdown": "* What are you actually trying to do here?\r\n* \u0060HashSet\u003CT\u003E\u0060 already implements \u0060IReadOnlyCollection\u003CT\u003E\u0060, so you can cast it\r\n  directly: \u0060IReadOnlyCollection\u003CT\u003E collection = myHashSet;\u0060.\r\n* If you want to create a \u0060ReadOnlyCollection\u003CT\u003E\u0060, it\u0027s one line:\r\n  \u0060ReadOnlyCollection\u003CT\u003E collection = new\r\n  ReadOnlyCollection\u003CT\u003E(myHashSet.ToArray());\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37149,
          "Title": "Proposal: Extension method to get value or default with creation function for Dictionary",
          "Author": "datvm",
          "CreatedAt": "2019-04-24T16:46:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29358",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571729598",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37149#issuecomment-571729598",
        "FeedbackMarkdown": "* This would be a compile-time breaking change because there would be an\r\n  overload resolution conflict if the \u0060null\u0060 literal is provided as the last\r\n  parameter to the extension method.\r\n* Please modify the proposal and reopen if you still have a strong desire \u002B\r\n  justification for this and there\u0027s a solution to working around the breaking\r\n  change.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37748,
          "Title": "One-shot PEM reader",
          "Author": "owlstead",
          "CreatedAt": "2019-05-17T14:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29588",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571743250",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37748#issuecomment-571743250",
        "FeedbackMarkdown": "* Change _dataSize_ and _labelSize_ to have _*Length_ suffixes instead.\r\n * In \u0060TryWrite\u0060, move the _destination_ parameter toward the end of the\r\n   parameter list.\r\n * Rename struct\u0027s _Base64_ property to _Base64Data_. Rename _EncodedByteSize_\r\n   to _DecodedByteSize_.\r\n * Remove the base64-decoding helper method from the ref struct. Callers can use\r\n   the \u0060Convert\u0060 class instead.\r\n * Consider using a normal struct instead of a ref struct and use _Range_\r\n   properties instead of _ROS_ properties. If we do this, then we can get away\r\n   with not _out_ing a \u0060Range\u0060 from the \u0060Find\u0060 method, and instead just put\r\n   _Range location_ on the struct itself.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36133,
          "Title": "MemoryMarshal.GetRawArrayData",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-03-18T23:39:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29003",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571725298",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36133#issuecomment-571725298",
        "FeedbackMarkdown": "* Rename to \u0060GetArrayDataRef\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36652,
          "Title": "\u0060ExcludeFromCodeCoverageAttribute(string reason)\u0060",
          "Author": "hughbe",
          "CreatedAt": "2019-04-06T10:27:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29185",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571726362",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36652#issuecomment-571726362",
        "FeedbackMarkdown": "* Don\u0027t add the new ctor. Instead add a get\u002Bset property \u0060string? Justification\u0060. This mirrors the \u0060SuppressMessageAttribute\u0060 design.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39555,
          "Title": "Expose CancellationTokenSource.CreateLinkedTokenSource(CancellationToken)",
          "Author": "stephentoub",
          "CreatedAt": "2019-07-16T22:24:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30286",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571746847",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39555#issuecomment-571746847",
        "FeedbackMarkdown": "* We discussed whether this would be necessary if we had a \u0060params ROS\u003CT\u003E\u0060\r\n  overload. But there\u0027s not even 100% consensus that we want to add that\r\n  overload, and the proposal in this issue has merit on its own regardless.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 79,
    "Date": "2020-01-14T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=dJLmN6u98Z4",
      "Id": "dJLmN6u98Z4",
      "StartDateTime": "2020-01-14T10:04:00-08:00",
      "EndDateTime": "2020-01-14T11:57:44-08:00",
      "Duration": 68240000000,
      "Title": ".NET Design Reviews: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dJLmN6u98Z4/mqdefault.jpg"
    },
    "Title": "System.Collections, System.IO, System.Runtime, System.Runtime.CompilerServices, System.Runtime.Intrinsics, System.Security, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 941,
          "Title": "Port \u0060MemoryMappedFileSecurity\u0060 and add extensions for \u0060MemoryMappedFile\u0060",
          "Author": "JeremyKuhne",
          "CreatedAt": "2019-10-08T21:21:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/941",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574306474",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/941#issuecomment-574306474",
        "FeedbackMarkdown": "* We need to know a little more about the scenario. In particular, is the only\r\n  reason the \u0060FileStream\u0060 is accepted in the ctor is so that there\u0027s something\r\n  to dispose at the end of the operation? Can we instead dispose the\r\n  \u0060FileStream\u0060 and the memmapped handle at the same time through some clever ref\r\n  counting mechanism?\r\n* See if there\u0027s perhaps a way to enable this scenario without exposing this\r\n  particular ctor.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40693,
          "Title": "Add TimeSpan.Infinite",
          "Author": "terrajobst",
          "CreatedAt": "2019-08-29T23:42:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30723",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574308350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40693#issuecomment-574308350",
        "FeedbackMarkdown": "This sentinel value would only be special-cased by specific APIs, and in some\r\ncontexts -1 is a perfectly valid value for \u0060TimeSpan\u0060 parameters. This really\r\nshould be a doc issue demonstrating correct use of the existing \u0060Timeout\u0060 API\r\nrather than a public API being added to \u0060TimeSpan\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40504,
          "Title": "[System.Runtime.Intrinsics] API suggestion: Introduce an intrinsic all bits set field to Vector intrinsic types",
          "Author": "john-h-k",
          "CreatedAt": "2019-08-22T14:26:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30659",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574310177",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40504#issuecomment-574310177",
        "FeedbackMarkdown": "* \u0060AllBitsSet\u0060 seems like a decent name given the scenario.\r\n* Also rename the internal member \u0060Vector\u003CT\u003E.AllOnes\u0060 at the same time so that\r\n  if it does become public in the future we have consistent naming already.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41131,
          "Title": "ExecutionContext.Run\u003CTContext\u003E overloads",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-16T04:27:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30867",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574312085",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41131#issuecomment-574312085",
        "FeedbackMarkdown": "Please match parameter names for the new overloads to parameter names for the existing overloads.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41487,
          "Title": "StringSplitOptions.TrimEntries",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-10-02T01:29:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31038",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574317661",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41487#issuecomment-574317661",
        "FeedbackMarkdown": "See if there\u0027s any usage of \u0060Split\u0060 followed by \u0060TrimStart\u0060 and \u0060TrimEnd\u0060 as\r\nopposed to just \u0060Trim\u0060. That\u0027ll inform us on whether these enum values being\r\nadded are sufficient for common use cases.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41783,
          "Title": "Unsafe.NullRef, IsNullRef",
          "Author": "jkotas",
          "CreatedAt": "2019-10-15T13:09:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31170",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574325067",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41783#issuecomment-574325067",
        "FeedbackMarkdown": "This really should be \u0060in\u0060 from a purity perspective, but should sit down with\r\nlanguage folks to figure out exactly what pitfalls might exist and whether the\r\nlanguage itself could be evolved to address any concerns. I\u0027ll punt this back to\r\nmyself.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 42372,
          "Title": "One-shot AES CBC and ECB",
          "Author": "vcsjones",
          "CreatedAt": "2019-11-04T20:57:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2406",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574334307",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/42372#issuecomment-574334307",
        "FeedbackMarkdown": "* CBC padding mode should default to PKCS7, ECB padding modes should be\r\n  non-default (require explicit value at call site). For all methods, move\r\n  non-_out_ parameters before _out_ parameters.\r\n* @bartonjs - please document whether the newly introduced virtual members would\r\n  ever mutate the underlying instance (changing block mode or padding mode) or\r\n  throw.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 8,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38395,
          "Title": "Ctor of sorted collection classes should support IReadOnlyDictionary or IEnumerable",
          "Author": "craigwardman",
          "CreatedAt": "2019-06-10T11:19:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29829",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574338733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38395#issuecomment-574338733",
        "FeedbackMarkdown": "We can\u0027t add the desired ctor because it would conflict with the\r\n\u0060.ctor(IDictionary\u003CTKey, TValue\u003E, ...)\u0060 ctor and would be a compile-time\r\nbreaking change. We might be able to get away with using one of the existing\r\nctors and instead adding a method \u0060AddRange(IEnumerable\u003CKeyValuePair\u003CTKey,\r\nTValue\u003E\u003E)\u0060, so the call site would look like:\r\n\r\n\u0060\u0060\u0060C#\r\nIReadOnlyDictionary\u003CTKey, TValue\u003E myDict = GetDictionary();\r\nvar sortedDictionary = new SortedDictionary\u003CTKey, TValue\u003E(comparer);\r\nsortedDictionary.AddRange(myDict);\r\n\u0060\u0060\u0060\r\n\r\nPerhaps a ctor that takes a capacity would also benefit here, that way the\r\ninstance is already sized appropriately for the data that will be added to it.\r\n\r\nWould this proposed API be sufficient for your scenarios?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1210,
          "Title": "ObjectDisposedException missing constructor with all: objectName, message, innerException",
          "Author": "dmitriyse",
          "CreatedAt": "2019-12-29T23:04:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1210",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574342594",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1210#issuecomment-574342594",
        "FeedbackMarkdown": "* Per @scalablecory\u0027s comments, what\u0027s the scenario for this? Why not match the\r\n  existing constructors in your own subclassed type?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 836,
          "Title": "Mark Value and HasValue of System.Nullable\u003CT\u003E as readonly",
          "Author": "bernd5",
          "CreatedAt": "2019-12-13T15:09:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/836",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574346202",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/836#issuecomment-574346202",
        "FeedbackMarkdown": "* It looks like the Roslyn compiler already special-cases this, so perf is\r\n  already in a good way. But we should probably do this anyway for non-Roslyn\r\n  compiler scenarios, and so that the API surface matches the expectation.\r\n* Approved for these APIs specifically:\r\n    - \u0060get_Value\u0060\r\n    - \u0060get_HasValue\u0060\r\n    - \u0060GetValueOrDefault\u0060 (both overloads)",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "Id": 80,
    "Date": "2020-01-28T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=keHv3W-2-Q4",
      "Id": "keHv3W-2-Q4",
      "StartDateTime": "2020-01-28T10:28:16.778-08:00",
      "EndDateTime": "2020-01-28T11:07:32-08:00",
      "Duration": 23552220000,
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/keHv3W-2-Q4/mqdefault.jpg"
    },
    "Title": "System.IO, System.Net.Http",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 7864,
          "Title": "Add StringContent ctor providing tighter control over charset",
          "Author": "guardrex",
          "CreatedAt": "2016-04-19T16:57:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17036",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-28T00:00:00-08:00",
        "FeedbackId": "579398933",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/7864#issuecomment-579398933",
        "FeedbackMarkdown": "We believe the correct API is this:\r\n\r\n\u0060\u0060\u0060C#\r\npublic StringContent(string content, MediaTypeHeaderValue mediaType)\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 15708,
          "Title": "Is there a function to copy directories?",
          "Author": "akcorp2003",
          "CreatedAt": "2017-02-02T00:55:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20078",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-01-28T00:00:00-08:00",
        "FeedbackId": "579405459",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/15708#issuecomment-579405459",
        "FeedbackMarkdown": "We generally have avoided IO APIs with complex policy (such as, cancellation, error handling, recovery, permissions etc). The API shape would work, but we\u0027re concerned about the complexity in implementation and don\u0027t think it\u0027s worth it.",
        "TimeCode": 14370000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 81,
    "Date": "2020-02-04T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=nD5kZ2aXjdM",
      "Id": "nD5kZ2aXjdM",
      "StartDateTime": "2020-02-04T10:08:00.906-08:00",
      "EndDateTime": "2020-02-04T12:01:03-08:00",
      "Duration": 67820940000,
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nD5kZ2aXjdM/mqdefault.jpg"
    },
    "Title": "System.IO, System.Runtime, System.Security, System.Text.Encoding, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30260,
          "Title": "Add an API to perform streaming transcoding",
          "Author": "pranavkm",
          "CreatedAt": "2019-07-15T16:46:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30260",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encoding",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582050875",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30260#issuecomment-582050875",
        "FeedbackMarkdown": "* We\u0027ll likely need this ourselves for the \u0060HttpClient\u0060 extension methods for JSON, so putting it in the BCL seems more reasonable than an ASP.NET/networking specific helper\r\n* Instead of exposing a concrete type, we\u0027d prefer a factory because we\u0027ll likely want to have dedicated implementations for specific encodings in order to speed things up.\r\n* Putting the factory on \u0060Encoding\u0060 seems most sensible because that\u0027s the array based helpers are too\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class Encoding\r\n    {\r\n        public static Stream CreateTranscodingStream(Stream innerStream, Encoding innerStreamEncoding, Encoding outerStreamEncoding, bool leaveOpen = false);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Encoding.CreateTranscodingStream(Stream,Encoding,Encoding,bool)",
          "T:Encoding"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20234,
          "Title": "SetCreationTime, SetLastAccessTime, SetLastWriteTime Should not open a new stream to obtain a SafeFileHandle",
          "Author": "TrabacchinLuigi",
          "CreatedAt": "2017-02-15T15:06:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20234",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582053400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20234#issuecomment-582053400",
        "FeedbackMarkdown": "* The scenario makes sense, but defining them as extension methods on \u0060SafeFileHandle\u0060 seems odd\r\n* It seems more logical to define them as overloads to the \u0060string\u0060 based APIs on \u0060File\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n        public static DateTime GetCreationTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastAccessTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastWriteTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle);\r\n\r\n        public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime);\r\n        public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creatinTimeUtc);\r\n        public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime);\r\n        public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc);\r\n        public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime);\r\n        public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc);\r\n\r\n        // Seems we should be adding support for these too.\r\n        // If we can\u0027t make it work, dropping is fine.\r\n        public static FileAttributes GetAttributes(SafeFileHandle fileHandle);\r\n        public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14140000000,
        "Apis": [
          "M:File.GetAttributes(SafeFileHandle)",
          "M:File.GetCreationTime(SafeFileHandle)",
          "M:File.GetCreationTimeUtc(SafeFileHandle)",
          "M:File.GetLastAccessTime(SafeFileHandle)",
          "M:File.GetLastAccessTimeUtc(SafeFileHandle)",
          "M:File.GetLastWriteTime(SafeFileHandle)",
          "M:File.GetLastWriteTimeUtc(SafeFileHandle)",
          "M:File.SetAttributes(SafeFileHandle,FileAttributes)",
          "M:File.SetCreationTime(SafeFileHandle,DateTime)",
          "M:File.SetCreationTimeUtc(SafeFileHandle,DateTime)",
          "M:File.SetLastAccessTime(SafeFileHandle,DateTime)",
          "M:File.SetLastAccessTimeUtc(SafeFileHandle,DateTime)",
          "M:File.SetLastWriteTime(SafeFileHandle,DateTime)",
          "M:File.SetLastWriteTimeUtc(SafeFileHandle,DateTime)",
          "T:File"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 23819,
          "Title": "Add bit manipulation methods to Interlocked class",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2017-10-12T00:33:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582059179",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/23819#issuecomment-582059179",
        "FeedbackMarkdown": "* Makes sense, the naming \u0060location1\u0060 matches the existing methods\r\n* We\u0027ll review support for unsigned in a separate issue (#24694)\r\n* @GrabYourPitchforks will file a separate issue for test and clear/reset\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        public static int And(ref int location1, int value);\r\n        public static long And(ref long location1, long value);\r\n        public static int Or(ref int location1, int value);\r\n        public static long Or(ref long location1, long value);\r\n        public static int Xor(ref int location1, int value);\r\n        public static long Xor(ref long location1, long value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17780000000,
        "Apis": [
          "M:Interlocked.And(ref int,int)",
          "M:Interlocked.And(ref long,long)",
          "M:Interlocked.Or(ref int,int)",
          "M:Interlocked.Or(ref long,long)",
          "M:Interlocked.Xor(ref int,int)",
          "M:Interlocked.Xor(ref long,long)",
          "T:Interlocked"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24694,
          "Title": "Interlocked.CompareExchange missing for uint, ulong and (if possible) general structs.",
          "Author": "jkotas",
          "CreatedAt": "2018-01-17T01:20:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24694",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582063204",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24694#issuecomment-582063204",
        "FeedbackMarkdown": "* Makes sense, we added unsigned for the APIs approved in #23819\r\n* Let\u0027s ignore the generic struct here; this should be a separate proposal\r\n* We should probably add \u0060Interlocked\u0060 support for \u0060nint\u0060 and \u0060nuint\u0060 support on Interlocked. @tannergooding, could you file a tracking item for this?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        // New proposed APIs, pretty much a carbon copy of the above but unsigned\r\n        // All of these would be marked [CLSCompliant(false)]\r\n\r\n        public static uint Add(ref uint location1, uint value);\r\n        public static ulong Add(ref ulong location1, ulong value);\r\n        public static uint CompareExchange(ref uint location1, uint value, uint comparand);\r\n        public static ulong CompareExchange(ref ulong location1, ulong value, ulong comparand);\r\n        public static UIntPtr CompareExchange(ref UIntPtr location1, UIntPtr value, UIntPtr comparand);\r\n        public static uint Decrement(ref uint location);\r\n        public static ulong Decrement(ref ulong location);\r\n        public static uint Exchange(ref uint location1, uint value);\r\n        public static ulong Exchange(ref ulong location1, ulong value);\r\n        public static UIntPtr Exchange(ref UIntPtr location1, UIntPtr value);\r\n        public static uint Increment(ref uint location);\r\n        public static ulong Increment(ref ulong location);\r\n        public static ulong Read(ref ulong location);\r\n\r\n        // Since these were approved in #23819 we should add them:\r\n        // All of these would be marked [CLSCompliant(false)]\r\n\r\n        public static int And(ref uint location1, uint value);\r\n        public static long And(ref ulong location1, ulong value);\r\n        public static int Or(ref uint location1, uint value);\r\n        public static long Or(ref ulong location1, ulong value);\r\n        public static int Xor(ref uint location1, uint value);\r\n        public static long Xor(ref ulong location1, ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25840000000,
        "Apis": [
          "M:Interlocked.Add(ref uint,uint)",
          "M:Interlocked.Add(ref ulong,ulong)",
          "M:Interlocked.And(ref uint,uint)",
          "M:Interlocked.And(ref ulong,ulong)",
          "M:Interlocked.CompareExchange(ref uint,uint,uint)",
          "M:Interlocked.CompareExchange(ref UIntPtr,UIntPtr,UIntPtr)",
          "M:Interlocked.CompareExchange(ref ulong,ulong,ulong)",
          "M:Interlocked.Decrement(ref uint)",
          "M:Interlocked.Decrement(ref ulong)",
          "M:Interlocked.Exchange(ref uint,uint)",
          "M:Interlocked.Exchange(ref UIntPtr,UIntPtr)",
          "M:Interlocked.Exchange(ref ulong,ulong)",
          "M:Interlocked.Increment(ref uint)",
          "M:Interlocked.Increment(ref ulong)",
          "M:Interlocked.Or(ref uint,uint)",
          "M:Interlocked.Or(ref ulong,ulong)",
          "M:Interlocked.Read(ref ulong)",
          "M:Interlocked.Xor(ref uint,uint)",
          "M:Interlocked.Xor(ref ulong,ulong)",
          "T:Interlocked"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29588,
          "Title": "One-shot PEM reader",
          "Author": "owlstead",
          "CreatedAt": "2019-05-17T14:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29588",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582069797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29588#issuecomment-582069797",
        "FeedbackMarkdown": "* The constructor on \u0060PemFields\u0060 isn\u0027t public to avoid having to validate well-formedness\r\n* Should \u0060PemFields\u0060 implement IEquatable\u003CPemFields\u003E\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public static class PemEncoding\r\n    {\r\n        public static bool TryFind(ReadOnlySpan\u003Cchar\u003E pemData, out PemFields fields);\r\n        public static PemFields Find(ReadOnlySpan\u003Cchar\u003E pemData);\r\n\r\n        public static int GetEncodedSize(int labelLength, int dataLength);\r\n        public static bool TryWrite(ReadOnlySpan\u003Cchar\u003E label, ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cchar\u003E destination, out int charsWritten);\r\n        public static char[] Write(ReadOnlySpan\u003Cchar\u003E label, ReadOnlySpan\u003Cbyte\u003E data);\r\n    }\r\n\r\n    public readonly struct PemFields\r\n    {\r\n        public Range Location { get; }\r\n        public Range Label { get; }\r\n        public Range Base64Data { get; }\r\n        public int DecodedDataLength { get; }\r\n    }\r\n }\r\n \u0060\u0060\u0060",
        "TimeCode": 31310000000,
        "Apis": [
          "M:PemEncoding.Find(ReadOnlySpan\u003Cchar\u003E)",
          "M:PemEncoding.GetEncodedSize(int,int)",
          "M:PemEncoding.TryFind(ReadOnlySpan\u003Cchar\u003E,out PemFields)",
          "M:PemEncoding.TryWrite(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cchar\u003E,out int)",
          "M:PemEncoding.Write(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "P:PemFields.Base64Data",
          "P:PemFields.DecodedDataLength",
          "P:PemFields.Label",
          "P:PemFields.Location",
          "T:PemEncoding",
          "T:PemFields"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24473,
          "Title": "Mark Write7BitEncodedInt and Read7BitEncodedInt as public",
          "Author": "vermorel",
          "CreatedAt": "2017-12-15T19:45:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24473",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582076029",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24473#issuecomment-582076029",
        "FeedbackMarkdown": "* We should reuse the existing methods, which are protected (since the method isn\u0027t virtual, making it public isn\u0027t a breaking change).\r\n* We don\u0027t want to add \u0060BigInteger\u0060 support because reader/writer has no support for \u0060BigInteger\u0060. This should be a separate proposal.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class BinaryReader\r\n    {\r\n        public int Read7BitEncodedInt();\r\n        public long Read7BitEncodedInt64();\r\n    }\r\n    public class BinaryWriter\r\n    {\r\n        public int Write7BitEncodedInt(int value);\r\n        public int Write7BitEncodedInt64(long value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40510000000,
        "Apis": [
          "M:BinaryReader.Read7BitEncodedInt()",
          "M:BinaryReader.Read7BitEncodedInt64()",
          "M:BinaryWriter.Write7BitEncodedInt(int)",
          "M:BinaryWriter.Write7BitEncodedInt64(long)",
          "T:BinaryReader",
          "T:BinaryWriter"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27683,
          "Title": "Easy reference equality comparer API",
          "Author": "jnm2",
          "CreatedAt": "2018-10-20T18:51:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27683",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582080375",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27683#issuecomment-582080375",
        "FeedbackMarkdown": "* Let\u0027s put it in \u0060System.Collections.Generic\u0060 (because \u0060System.Collections\u0060 doesn\u0027t have a \u0060EqualityComparer\u0060 anyway).\r\n* We don\u0027t want to put it on \u0060EqualityComparer\u003CT\u003E\u0060 because it wouldn\u0027t vary by \u0060T\u0060\r\n* Based on Internet search, it seems most folks calls their implementation \u0060ReferenceEqualityComparer\u0060. We considered introducing a non-generic \u0060EqualityComparer\u0060 with a property \u0060ReferenceEquality\u0060 that felt odd. Also, having a dedicated sealed type allows implementations to check whether it\u0027s the special reference equality comparer. The field would have to guarantee that it\u0027s the same instance, which we might not want.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public sealed class ReferenceEqualityComparer : IEqualityComparer, IEqualityComparer\u003Cobject\u003E\r\n    {\r\n        private ReferenceEqualityComparer();\r\n        public static ReferenceEqualityComparer Instance { get; }\r\n\r\n        // Plus inherited members from IEqualityComparer, IEqualityComparer\u003Cobject\u003E\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49350000000,
        "Apis": [
          "M:ReferenceEqualityComparer.ReferenceEqualityComparer()",
          "P:ReferenceEqualityComparer.Instance",
          "T:ReferenceEqualityComparer"
        ]
      }
    ]
  },
  {
    "Id": 82,
    "Date": "2020-02-11T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=kGIsqCyWqa0",
      "Id": "kGIsqCyWqa0",
      "StartDateTime": "2020-02-11T10:11:53.104-08:00",
      "EndDateTime": "2020-02-11T12:03:15-08:00",
      "Duration": 66818960000,
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/kGIsqCyWqa0/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Net.Http, System.Runtime, System.Security, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 911,
          "Title": "Proposal: HttpRequestException w/ Status Code",
          "Author": "yaakov-h",
          "CreatedAt": "2018-01-20T11:25:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/911",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584780389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/911#issuecomment-584780389",
        "FeedbackMarkdown": "* Looks good\r\n* At the minimum we\u0027ll need to remove the nullable annotation fromt he first constructor, otherwise passing null as the second argument would be a source breaking change\r\n* However, we concluded we can just remove it.\r\n\r\n\u0060\u0060\u0060C#\r\npublic class HttpRequestException : Exception\r\n{\r\n    // Existing:\r\n    // public HttpRequestException(string message);\r\n    // public HttpRequestException(string message, Exception inner);\r\n\r\n    public HttpRequestException(string message, Exception inner, HttpStatusCode? statusCode);\r\n    public HttpStatusCode? StatusCode { get; }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpRequestException.HttpRequestException(string,Exception,HttpStatusCode?)",
          "P:HttpRequestException.StatusCode",
          "T:HttpRequestException"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2043,
          "Title": "Make System.Security.Cryptography.Oid write-once (initializable read-only)",
          "Author": "bartonjs",
          "CreatedAt": "2020-01-22T21:45:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2043",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "breaking-change",
              "BackgroundColor": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease.",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584786046",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2043#issuecomment-584786046",
        "FeedbackMarkdown": "* Looks good. It\u0027s a runtime breaking change but we believe the value is high and the risk is low (enough)\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class Oid\r\n{\r\n    public string Value\r\n    {\r\n        get =\u003E _value;\r\n        set\r\n        {\r\n            if (_value != null \u0026\u0026 !_value.Equals(value))\r\n                throw new PlatformNotSupportedException(...);\r\n\r\n            _value = value;\r\n        }\r\n    }\r\n\r\n    public string FriendlyName\r\n    {\r\n        get =\u003E _friendlyName ??= LookupFriendlyName(_value);\r\n        set\r\n        {\r\n            if (_friendlyName != null \u0026\u0026 !_friendlyName.Equals(value))\r\n                throw new PlatformNotSupportedException(...);\r\n\r\n            _friendlyName = value;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7300000000,
        "Apis": [
          "P:Oid.FriendlyName",
          "P:Oid.Value",
          "T:Oid"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27935,
          "Title": "Expose the match length when using String.IndexOf in culture specific mode",
          "Author": "GSPP",
          "CreatedAt": "2018-11-16T13:03:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27935",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584799296",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27935#issuecomment-584799296",
        "FeedbackMarkdown": "* We shoulnd\u0027t invent new names for \u0060IndexOf\u0060 and \u0060LastIndexOf\u0060\r\n* While our guidance says we should be adding \u0060string\u0060-based version of the new range returning APIs, we don\u0027t believe they are common enough to be warranted. We can add them later if necessary.\r\n* Given the programming model for \u0060IndexOf\u0060, we decided against using the \u0060Try\u0060-pattern.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial class CompareInfo\r\n    {\r\n        public bool IsPrefix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E prefix, CompareOptions options, out Range match);\r\n        public bool IsSuffix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E suffix, CompareOptions options, out Range match);\r\n        public int IndexOf(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E value, CompareOptions options, out int matchLength);\r\n        public int LastIndexOf(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E value, CompareOptions options, out int matchLength);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14720000000,
        "Apis": [
          "M:CompareInfo.IndexOf(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out int)",
          "M:CompareInfo.IsPrefix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out Range)",
          "M:CompareInfo.IsSuffix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out Range)",
          "M:CompareInfo.LastIndexOf(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out int)",
          "T:CompareInfo"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1968,
          "Title": "Incremental Hash, allowing to continue to hash",
          "Author": "Drawaes",
          "CreatedAt": "2020-01-21T16:57:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1968",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584806878",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1968#issuecomment-584806878",
        "FeedbackMarkdown": "* There don\u0027t seem to be any scenarios for \u0060DuplicateHash\u0060, so let\u0027s remove it for now. If we were to do it, we should probably name it \u0060Clone\u0060 though.\r\n* Rest looks good as proposed.\r\n* We should add a \u0060HashSizeInBytes\u0060 property so that callers don\u0027t have to call \u0060TryGetCurrentHash\u0060 in a loop\r\n* While we\u0027re at it, we should also add overloads for the new \u0060TryGetCurrentHash\u0060 and the existing \u0060TryGetHashAndReset\u0060 to return the length instead of returning a \u0060bool\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class IncrementalHash\r\n    {\r\n        public bool TryGetCurrentHash(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetCurrentHash(Span\u003Cbyte\u003E destination);\r\n        // public bool TryGetHashAndReset(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetHashAndReset(Span\u003Cbyte\u003E destination);\r\n        public byte[] GetCurrentHash();\r\n        public int HashLengthInBytes { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32270000000,
        "Apis": [
          "M:IncrementalHash.GetCurrentHash()",
          "M:IncrementalHash.GetCurrentHash(Span\u003Cbyte\u003E)",
          "M:IncrementalHash.GetHashAndReset(Span\u003Cbyte\u003E)",
          "M:IncrementalHash.TryGetCurrentHash(Span\u003Cbyte\u003E,out int)",
          "P:IncrementalHash.HashLengthInBytes",
          "T:IncrementalHash"
        ]
      },
      {
        "Id": 5,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1946,
          "Title": "Async parallel foreach",
          "Author": "tomesendam",
          "CreatedAt": "2018-12-24T10:18:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1946",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1946#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 42850000000,
        "Apis": []
      },
      {
        "Id": 6,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29222,
          "Title": "BinaryPrimitives.ToLittleEndian / FromLittleEndian",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-04-09T22:00:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29222",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584820663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29222#issuecomment-584820663",
        "FeedbackMarkdown": "We need a more compelling reason. Sorry Levi :-)",
        "TimeCode": 49630000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 83,
    "Date": "2020-02-20T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=DWt2Dh5L-C0",
      "Id": "DWt2Dh5L-C0",
      "StartDateTime": "2020-02-20T10:04:49.344-08:00",
      "EndDateTime": "2020-02-20T12:00:07-08:00",
      "Duration": 69176560000,
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/DWt2Dh5L-C0/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Drawing, System.Linq.Parallel, System.Net.Sockets, System.Numerics, System.Runtime, System.Runtime.Intrinsics, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 921,
          "Title": "Add CancellationToken overloads to Socket.ConnectAsync and Socket.AcceptAsync",
          "Author": "tmds",
          "CreatedAt": "2019-04-23T15:10:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/921",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589234342",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/921#issuecomment-589234342",
        "FeedbackMarkdown": "* We should file an issue to cover the remaining APIs \u0060ReceiveAsync\u0060, \u0060ReceiveFromAsync\u0060, \u0060ReceiveMessageFromAsync\u0060, \u0060SendToAsync (@scalablecory)\r\n* Otherwise looks good\r\n\r\n\u0060\u0060\u0060C#\r\nclass SocketTaskExtensions\r\n{\r\n   public static ValueTask ConnectAsync (this Socket socket, EndPoint remoteEP, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, IPAddress address, int port, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, IPAddress[] addresses, int port, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, string host, int port, CancellationToken cancellationToken);\r\n   public static ValueTask\u003CSocket\u003E AcceptAsync (this Socket socket, CancellationToken cancellationToken);\r\n   public static ValueTask\u003CSocket\u003E AcceptAsync (this Socket socket, Socket acceptSocket, CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public static Task ConnectAsync (this Socket socket, EndPoint remoteEP);\r\n   // public static Task ConnectAsync (this Socket socket, IPAddress address, int port);\r\n   // public static Task ConnectAsync (this Socket socket, IPAddress[] addresses, int port);\r\n   // public static Task ConnectAsync (this Socket socket, string host, int port);\r\n   // public static Task\u003CSocket\u003E AcceptAsync (this Socket socket);\r\n   // public static Task\u003CSocket\u003E AcceptAsync (this Socket socket, Socket acceptSocket);\r\n}\r\n\r\nclass Socket\r\n{\r\n   public static void CancelAcceptAsync(SocketAsyncEventArgs e);\r\n\r\n   // existing methods:\r\n   // public bool AcceptAsync (SocketAsyncEventArgs e);\r\n   // public bool ConnectAsync (SocketAsyncEventArgs e);\r\n   // public static void CancelConnectAsync (SocketAsyncEventArgs e);\r\n}\r\n\r\nclass TcpClient\r\n{\r\n   public ValueTask ConnectAsync (string host, int port, CancellationToken cancellationToken);\r\n   public ValueTask ConnectAsync (IPAddress address, int port, CancellationToken cancellationToken);\r\n   public ValueTask ConnectAsync (IPAddress[] addresses, int port, CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public Task ConnectAsync (string host, int port);\r\n   // public Task ConnectAsync (IPAddress address, int port);\r\n   // public Task ConnectAsync (IPAddress[] addresses, int port);\r\n}\r\n\r\nclass TcpListener\r\n{\r\n   public ValueTask\u003CSocket\u003E AcceptSocketAsync (CancellationToken cancellationToken);\r\n   public ValueTask\u003CTcpClient\u003E AcceptTcpClientAsync (CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public Task\u003CSocket\u003E AcceptSocketAsync ();\r\n   // public Task\u003CTcpClient\u003E AcceptTcpClientAsync ();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Socket.CancelAcceptAsync(SocketAsyncEventArgs)",
          "M:SocketTaskExtensions.AcceptAsync(this Socket,CancellationToken)",
          "M:SocketTaskExtensions.AcceptAsync(this Socket,Socket,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,IPAddress,int,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,IPAddress[],int,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,string,int,CancellationToken)",
          "M:TcpClient.ConnectAsync(IPAddress,int,CancellationToken)",
          "M:TcpClient.ConnectAsync(IPAddress[],int,CancellationToken)",
          "M:TcpClient.ConnectAsync(string,int,CancellationToken)",
          "M:TcpListener.AcceptSocketAsync(CancellationToken)",
          "M:TcpListener.AcceptTcpClientAsync(CancellationToken)",
          "T:Socket",
          "T:SocketTaskExtensions",
          "T:TcpClient",
          "T:TcpListener"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 865,
          "Title": "API Socket.SetRawSocketOption",
          "Author": "benaadams",
          "CreatedAt": "2019-04-23T17:21:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/865",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589239349",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/865#issuecomment-589239349",
        "FeedbackMarkdown": "* We considered making it \u0060TryGetRawSocketOption\u0060 but we can\u0027t think of a case where the size of the option would change/is not known.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class Socket\r\n{\r\n    // existing: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);\r\n    public void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan\u003Cbyte\u003E optionValue);\r\n\r\n    // existing: public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);\r\n    public int GetRawSocketOption(int optionLevel, int optionName, Span\u003Cbyte\u003E optionValue);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6670000000,
        "Apis": [
          "M:Socket.GetRawSocketOption(int,int,Span\u003Cbyte\u003E)",
          "M:Socket.SetRawSocketOption(int,int,ReadOnlySpan\u003Cbyte\u003E)",
          "T:Socket"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30543,
          "Title": "Update Encoder, EncoderParameterValueType to match GDI\u002B",
          "Author": "qmfrederik",
          "CreatedAt": "2019-08-09T12:51:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30543",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Drawing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589242229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30543#issuecomment-589242229",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing.Imaging\r\n{\r\n    public sealed partial class Encoder\r\n    {\r\n        // Existing:\r\n        // public static readonly Encoder ChrominanceTable;\r\n        // public static readonly Encoder ColorDepth;\r\n        // public static readonly Encoder Compression;\r\n        // public static readonly Encoder LuminanceTable;\r\n        // public static readonly Encoder Quality;\r\n        // public static readonly Encoder RenderMethod;\r\n        // public static readonly Encoder SaveFlag;\r\n        // public static readonly Encoder ScanMethod;\r\n        // public static readonly Encoder Transformation;\r\n        // public static readonly Encoder Version;\r\n        public static readonly Encoder ColorSpace;\r\n        public static readonly Encoder ImageItems;\r\n        public static readonly Encoder SaveAsCmyk;\r\n    }\r\n\r\n    public enum EncoderParameterValueType\r\n    {\r\n        // Existing:\r\n        // ValueTypeByte = 1,\r\n        // ValueTypeAscii = 2,\r\n        // ValueTypeShort = 3,\r\n        // ValueTypeLong = 4,\r\n        // ValueTypeRational = 5,\r\n        // ValueTypeLongRange = 6,\r\n        // ValueTypeUndefined = 7,\r\n        // ValueTypeRationalRange = 8,\r\n        ValueTypePointer = 9,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13420000000,
        "Apis": [
          "F:Encoder.ColorSpace",
          "F:Encoder.ImageItems",
          "F:Encoder.SaveAsCmyk",
          "F:EncoderParameterValueType.ValueTypePointer",
          "T:Encoder",
          "T:EncoderParameterValueType"
        ]
      },
      {
        "Id": 4,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30652,
          "Title": "Add ParallelOptions constructor with MaxDegreeOfParallelism parameter",
          "Author": "SnakyBeaky",
          "CreatedAt": "2019-08-22T10:16:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30652",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Linq.Parallel",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589246889",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30652#issuecomment-589246889",
        "FeedbackMarkdown": "* After more discussion, it seems we prefer the current state because it\u0027s less ambiguous.",
        "TimeCode": 17520000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30778,
          "Title": "SequenceReader\u003CT\u003E.TryRead overloads to read a specified number of elements",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-06T05:30:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30778",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589257975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30778#issuecomment-589257975",
        "FeedbackMarkdown": "* The first API will have to allocate when \u0060count\u0060 causes spanning blocks in the sequence. The bigger the \u0060count\u0060, the more likely it is to cross such a boundary. This could be changed to allow the caller to pass in a pre-allocated span or we could change the semantics to only succeed if the data is available contiguously. This API will need more design.\r\n* The second overload is fine but we should change the name to \u0060TryReadExact\u0060 to make it clear that returning less or more is both not possible.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial ref struct SequenceReader\u003CT\u003E\r\n{\r\n    bool TryReadExact(int count, out ReadOnlySequence\u003CT\u003E value);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27910000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.TryReadExact(int,out ReadOnlySequence\u003CT\u003E)",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Id": 6,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30779,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads to read a specified number of elements from any position",
          "Author": "davidfowl",
          "CreatedAt": "2019-09-06T05:33:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30779",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589267066",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30779#issuecomment-589267066",
        "FeedbackMarkdown": "* The two \u0060TryPeek\u0060 APIs that out a span need more work because they silently allocate. Either allow for the caller to pass in a pre-allocated span or make it clear in the name that it will only return true if the data is in contiguous memory.\r\n* The \u0060TryPeek\u0060 overloads involving sequences look fine, except that \u0060count\u0060 changes position due to \u0060skip\u0060. We should either remove the one that doesn\u0027t take \u0060skip\u0060 (callers would have to pass in \u00600\u0060) or we should change order of \u0060skip\u0060 which might be weird.\r\n* \u0060TryCopyTo\u0060 seems fine as proposed, but it seems we might want to change it based on what we do for \u0060TryPeek\u0060.\r\n\r\n@davidfowl looks like we should meet and discuss this.",
        "TimeCode": 39230000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30800,
          "Title": "Add generic overloads for MethodInfo.CreateDelegate",
          "Author": "YairHalberstadt",
          "CreatedAt": "2019-09-09T12:28:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30800",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589273550",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30800#issuecomment-589273550",
        "FeedbackMarkdown": "* We discussed dropping the generic constraint (because it makes the new API less useful to code that is generic and not constrained, because the constraint is recent).\r\n* We\u0027ll keep it for now and will drop it if we see issues with the constraint.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MethodInfo\r\n{\r\n    // Current\r\n    public virtual Delegate CreateDelegate(Type delegateType);\r\n    public virtual Delegate CreateDelegate(Type delegateType, object target);\r\n\r\n    // New\r\n    public T CreateDelegate\u003CT\u003E() where T : Delegate =\u003E (T)CreateDelegate(typeof(T));\r\n    public T CreateDelegate\u003CT\u003E(object? target) where T : Delegate =\u003E (T)CreateDelegate(typeof(T), target);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50780000000,
        "Apis": [
          "M:MethodInfo.CreateDelegate(Type,object)",
          "M:MethodInfo.CreateDelegate(Type)",
          "M:MethodInfo.CreateDelegate\u003CT\u003E()",
          "M:MethodInfo.CreateDelegate\u003CT\u003E(object?)",
          "T:MethodInfo"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30862,
          "Title": "Add TaskCompletionSource.SetCanceled(CancellationToken)",
          "Author": "Frassle",
          "CreatedAt": "2019-09-15T09:28:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30862",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589274248",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30862#issuecomment-589274248",
        "FeedbackMarkdown": "* Looks good as proposed and follows the guidelines for \u0060Try\u0060-APIs\r\n\r\n\u0060\u0060\u0060C#\r\npublic class TaskCompletionSource\u003CTResult\u003E\r\n{\r\n    ...\r\n    public void SetCanceled(CancellationToken cancellationToken);\r\n    ...\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59790000000,
        "Apis": [
          "M:TaskCompletionSource\u003CTResult\u003E.SetCanceled(CancellationToken)",
          "T:TaskCompletionSource\u003CTResult\u003E"
        ]
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31179,
          "Title": "Sse2.StoreScalar(int*)",
          "Author": "saucecontrol",
          "CreatedAt": "2019-10-16T06:14:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31179",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589275674",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31179#issuecomment-589275674",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Sse2 : Sse\r\n    {\r\n        public static unsafe void StoreScalar(int* address, Vector128\u003Cint\u003E source);\r\n        public static unsafe void StoreScalar(uint* address, Vector128\u003Cuint\u003E source);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 60720000000,
        "Apis": [
          "M:Sse2.StoreScalar(int*,Vector128\u003Cint\u003E)",
          "M:Sse2.StoreScalar(uint*,Vector128\u003Cuint\u003E)",
          "T:Sse2"
        ]
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31184,
          "Title": "API: long Math.BigMul(long, long, out long)",
          "Author": "benaadams",
          "CreatedAt": "2019-10-16T11:23:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31184",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589278166",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31184#issuecomment-589278166",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Math\r\n    {\r\n        public ulong BigMul(ulong a, ulong b, out ulong low);\r\n        public long BigMul(long a, long b, out long low);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62740000000,
        "Apis": [
          "M:Math.BigMul(long,long,out long)",
          "M:Math.BigMul(ulong,ulong,out ulong)",
          "T:Math"
        ]
      },
      {
        "Id": 11,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31193,
          "Title": "Avx.CompareXXX convenience methods for float/double",
          "Author": "saucecontrol",
          "CreatedAt": "2019-10-16T23:38:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31193",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589280411",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31193#issuecomment-589280411",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Avx : Sse42\r\n    {\r\n        public static Vector256\u003Cfloat\u003E CompareEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareGreaterThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareGreaterThan(Vector256\u003Cdouble\u003E left,  Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareGreaterThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareGreaterThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareLessThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareLessThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareLessThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareLessThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotGreaterThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotGreaterThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotGreaterThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotGreaterThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotLessThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotLessThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotLessThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotLessThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        // The justification for these is questionable as the equivalent FloatComparisonMode is obvious.\r\n        public static Vector256\u003Cfloat\u003E CompareOrdered(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareOrdered(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareUnordered(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareUnordered(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 66050000000,
        "Apis": [
          "M:Avx.CompareEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareGreaterThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareGreaterThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareGreaterThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareGreaterThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareLessThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareLessThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareLessThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareLessThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotGreaterThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotGreaterThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotGreaterThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotGreaterThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotLessThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotLessThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotLessThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotLessThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareOrdered(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareOrdered(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareUnordered(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareUnordered(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "T:Avx"
        ]
      }
    ]
  },
  {
    "Id": 84,
    "Date": "2020-03-03T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=3qXvVF9n0kQ",
      "Id": "3qXvVF9n0kQ",
      "StartDateTime": "2020-03-03T10:04:12.136-08:00",
      "EndDateTime": "2020-03-03T12:30:12-08:00",
      "Duration": 87598640000,
      "Title": ".NET Design Review: ARM Intrinsics",
      "ThumbnailUrl": "https://i.ytimg.com/vi/3qXvVF9n0kQ/mqdefault.jpg"
    },
    "Title": "Interop-coreclr, System.Runtime, System.Runtime.Intrinsics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31324,
          "Title": "API Proposal : Arm Shift and Permute intrinsics",
          "Author": "TamarChristinaArm",
          "CreatedAt": "2019-10-28T17:21:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31324",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594124186",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31324#issuecomment-594124186",
        "FeedbackMarkdown": "* Confirm that \u0060ShiftLeftLogicalAndInsert\u0060 under \u0060ArmBase\u0060 should move under \u0060AdvSimd\u0060, but is it 32 bit or 64 bit?\r\n* Some of instructions are destructive on ARM32 and non-destructive on ARM64. Should we split these up into a 32-bit version with a different shape?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class ArmBase\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// vslid_n_[su]64\r\n        ///\r\n        /// A64: SLI\r\n        /// A32: VSLI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Clong\u003E  ShiftLeftLogicalAndInsertScalar(Vector64\u003Clong\u003E  left, Vector64\u003Clong\u003E  right, byte shift);\r\n        public static Vector64\u003Culong\u003E ShiftLeftLogicalAndInsertScalar(Vector64\u003Culong\u003E left, Vector64\u003Culong\u003E right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vsrid_n_[su]64\r\n        ///\r\n        /// A64: SRI\r\n        /// A32: VSRI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Clong\u003E  ShiftRightLogicalAndInsertScalar(Vector64\u003Clong\u003E  left, Vector64\u003Clong\u003E  right, byte shift);\r\n        public static Vector64\u003Culong\u003E ShiftRightLogicalAndInsertScalar(Vector64\u003Culong\u003E left, Vector64\u003Culong\u003E right, byte shift);\r\n    }\r\n    public partial class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// vsli[q]_n_[su][8,16,32,64]\r\n        //\r\n        /// A64: SLI\r\n        /// A32: VSLI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Cbyte\u003E   ShiftLeftLogicalAndInsert(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector64\u003Cushort\u003E ShiftLeftLogicalAndInsert(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right, byte shift);\r\n        public static Vector64\u003Cuint\u003E   ShiftLeftLogicalAndInsert(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right, byte shift);\r\n        public static Vector64\u003Csbyte\u003E  ShiftLeftLogicalAndInsert(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector64\u003Cshort\u003E  ShiftLeftLogicalAndInsert(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte shift);\r\n        public static Vector64\u003Cint\u003E    ShiftLeftLogicalAndInsert(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte shift);\r\n\r\n        public static Vector128\u003Cbyte\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector128\u003Cushort\u003E ShiftLeftLogicalAndInsert(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right, byte shift);\r\n        public static Vector128\u003Cuint\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right, byte shift);\r\n        public static Vector128\u003Culong\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right, byte shift);\r\n        public static Vector128\u003Csbyte\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector128\u003Cshort\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right, byte shift);\r\n        public static Vector128\u003Cint\u003E    ShiftLeftLogicalAndInsert(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right, byte shift);\r\n        public static Vector128\u003Clong\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vsri[q]_n_[su][8,16,32,64]\r\n        ///\r\n        /// A64: SRI\r\n        /// A32: VSRI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Cbyte\u003E   ShiftRightAndInsert(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector64\u003Cushort\u003E ShiftRightAndInsert(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right, byte shift);\r\n        public static Vector64\u003Cuint\u003E   ShiftRightAndInsert(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right, byte shift);\r\n        public static Vector64\u003Csbyte\u003E  ShiftRightAndInsert(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector64\u003Cshort\u003E  ShiftRightAndInsert(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte shift);\r\n        public static Vector64\u003Cint\u003E    ShiftRightAndInsert(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte shift);\r\n\r\n        public static Vector128\u003Cbyte\u003E   ShiftRightAndInsert(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector128\u003Cushort\u003E ShiftRightAndInsert(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right, byte shift);\r\n        public static Vector128\u003Cuint\u003E   ShiftRightAndInsert(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right, byte shift);\r\n        public static Vector128\u003Culong\u003E  ShiftRightAndInsert(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right, byte shift);\r\n        public static Vector128\u003Csbyte\u003E  ShiftRightAndInsert(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector128\u003Cshort\u003E  ShiftRightAndInsert(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right, byte shift);\r\n        public static Vector128\u003Cint\u003E    ShiftRightAndInsert(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right, byte shift);\r\n        public static Vector128\u003Clong\u003E   ShiftRightAndInsert(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vmovn_[su][16,32,64]\r\n        ///\r\n        /// A64: XTN\r\n        /// A32: VMOVN\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Csbyte\u003E  ExtractAndNarrowLow(Vector128\u003Cshort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E  ExtractAndNarrowLow(Vector128\u003Cint\u003E    value);\r\n        public static Vector64\u003Cint\u003E    ExtractAndNarrowLow(Vector128\u003Clong\u003E   value);\r\n        public static Vector64\u003Cbyte\u003E   ExtractAndNarrowLow(Vector128\u003Cushort\u003E value);\r\n        public static Vector64\u003Cushort\u003E ExtractAndNarrowLow(Vector128\u003Cuint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E   ExtractAndNarrowLow(Vector128\u003Culong\u003E  value);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vmovn_high_[su][16,32,64]\r\n        //\r\n        /// A64: XTN2\r\n        /// A32: VMOVN\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Csbyte\u003E  ExtractAndNarrowHigh(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  value);\r\n        public static Vector128\u003Cshort\u003E  ExtractAndNarrowHigh(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    value);\r\n        public static Vector128\u003Cint\u003E    ExtractAndNarrowHigh(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractAndNarrowHigh(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractAndNarrowHigh(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractAndNarrowHigh(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  value);\r\n\r\n        public partial class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// vtrn1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: UZP1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  UnzipEven(Vector64\u003Csbyte\u003E  lower, Vector64\u003Csbyte\u003E  upper);\r\n            public static Vector64\u003Cshort\u003E  UnzipEven(Vector64\u003Cshort\u003E  lower, Vector64\u003Cshort\u003E  upper);\r\n            public static Vector64\u003Cint\u003E    UnzipEven(Vector64\u003Cint\u003E    lower, Vector64\u003Cint\u003E    upper);\r\n            public static Vector64\u003Cbyte\u003E   UnzipEven(Vector64\u003Cbyte\u003E   lower, Vector64\u003Cbyte\u003E   upper);\r\n            public static Vector64\u003Cushort\u003E UnzipEven(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper);\r\n            public static Vector64\u003Cuint\u003E   UnzipEven(Vector64\u003Cuint\u003E   lower, Vector64\u003Cuint\u003E   upper);\r\n            public static Vector64\u003Cfloat\u003E  UnzipEven(Vector64\u003Cfloat\u003E  lower, Vector64\u003Cfloat\u003E  upper);\r\n\r\n            public static Vector128\u003Csbyte\u003E  UnzipEven(Vector128\u003Csbyte\u003E  lower, Vector128\u003Csbyte\u003E  upper);\r\n            public static Vector128\u003Cshort\u003E  UnzipEven(Vector128\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E  upper);\r\n            public static Vector128\u003Cint\u003E    UnzipEven(Vector128\u003Cint\u003E    lower, Vector128\u003Cint\u003E    upper);\r\n            public static Vector128\u003Clong\u003E   UnzipEven(Vector128\u003Clong\u003E   lower, Vector128\u003Clong\u003E   upper);\r\n            public static Vector128\u003Cbyte\u003E   UnzipEven(Vector128\u003Cbyte\u003E   lower, Vector128\u003Cbyte\u003E   upper);\r\n            public static Vector128\u003Cushort\u003E UnzipEven(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper);\r\n            public static Vector128\u003Cuint\u003E   UnzipEven(Vector128\u003Cuint\u003E   lower, Vector128\u003Cuint\u003E   upper);\r\n            public static Vector128\u003Culong\u003E  UnzipEven(Vector128\u003Culong\u003E  lower, Vector128\u003Culong\u003E  upper);\r\n            public static Vector128\u003Cfloat\u003E  UnzipEven(Vector128\u003Cfloat\u003E  lower, Vector128\u003Cfloat\u003E  upper);\r\n            public static Vector128\u003Cdouble\u003E UnzipEven(Vector128\u003Cdouble\u003E lower, Vector128\u003Cdouble\u003E upper);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: UZP2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  UnzipOdd(Vector64\u003Csbyte\u003E  lower, Vector64\u003Csbyte\u003E  upper);\r\n            public static Vector64\u003Cshort\u003E  UnzipOdd(Vector64\u003Cshort\u003E  lower, Vector64\u003Cshort\u003E  upper);\r\n            public static Vector64\u003Cint\u003E    UnzipOdd(Vector64\u003Cint\u003E    lower, Vector64\u003Cint\u003E    upper);\r\n            public static Vector64\u003Cbyte\u003E   UnzipOdd(Vector64\u003Cbyte\u003E   lower, Vector64\u003Cbyte\u003E   upper);\r\n            public static Vector64\u003Cushort\u003E UnzipOdd(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper);\r\n            public static Vector64\u003Cuint\u003E   UnzipOdd(Vector64\u003Cuint\u003E   lower, Vector64\u003Cuint\u003E   upper);\r\n            public static Vector64\u003Cfloat\u003E  UnzipOdd(Vector64\u003Cfloat\u003E  lower, Vector64\u003Cfloat\u003E  upper);\r\n\r\n            public static Vector128\u003Csbyte\u003E  UnzipOdd(Vector128\u003Csbyte\u003E  lower, Vector128\u003Csbyte\u003E  upper);\r\n            public static Vector128\u003Cshort\u003E  UnzipOdd(Vector128\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E  upper);\r\n            public static Vector128\u003Cint\u003E    UnzipOdd(Vector128\u003Cint\u003E    lower, Vector128\u003Cint\u003E    upper);\r\n            public static Vector128\u003Clong\u003E   UnzipOdd(Vector128\u003Clong\u003E   lower, Vector128\u003Clong\u003E   upper);\r\n            public static Vector128\u003Cbyte\u003E   UnzipOdd(Vector128\u003Cbyte\u003E   lower, Vector128\u003Cbyte\u003E   upper);\r\n            public static Vector128\u003Cushort\u003E UnzipOdd(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper);\r\n            public static Vector128\u003Cuint\u003E   UnzipOdd(Vector128\u003Cuint\u003E   lower, Vector128\u003Cuint\u003E   upper);\r\n            public static Vector128\u003Culong\u003E  UnzipOdd(Vector128\u003Culong\u003E  lower, Vector128\u003Culong\u003E  upper);\r\n            public static Vector128\u003Cfloat\u003E  UnzipOdd(Vector128\u003Cfloat\u003E  lower, Vector128\u003Cfloat\u003E  upper);\r\n            public static Vector128\u003Cdouble\u003E UnzipOdd(Vector128\u003Cdouble\u003E lower, Vector128\u003Cdouble\u003E upper);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vzip1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: ZIP1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  ZipLow(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  ZipLow(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    ZipLow(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   ZipLow(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E ZipLow(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   ZipLow(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  ZipLow(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  ZipLow(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  ZipLow(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    ZipLow(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   ZipLow(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   ZipLow(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E ZipLow(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   ZipLow(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  ZipLow(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  ZipLow(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E ZipLow(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vzip2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: ZIP2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  ZipHigh(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  ZipHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    ZipHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   ZipHigh(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E ZipHigh(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   ZipHigh(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  ZipHigh(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  ZipHigh(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  ZipHigh(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    ZipHigh(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   ZipHigh(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   ZipHigh(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E ZipHigh(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   ZipHigh(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  ZipHigh(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  ZipHigh(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E ZipHigh(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: TRN1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  TransposeEven(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  TransposeEven(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    TransposeEven(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   TransposeEven(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E TransposeEven(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   TransposeEven(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  TransposeEven(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  TransposeEven(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  TransposeEven(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    TransposeEven(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   TransposeEven(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   TransposeEven(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E TransposeEven(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   TransposeEven(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  TransposeEven(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  TransposeEven(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E TransposeEven(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: TRN2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  TransposeOdd(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  TransposeOdd(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    TransposeOdd(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   TransposeOdd(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E TransposeOdd(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   TransposeOdd(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  TransposeOdd(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  TransposeOdd(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  TransposeOdd(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    TransposeOdd(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   TransposeOdd(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   TransposeOdd(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E TransposeOdd(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   TransposeOdd(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  TransposeOdd(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  TransposeOdd(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E TransposeOdd(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:ArmBase.ShiftLeftLogicalAndInsertScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:ArmBase.ShiftLeftLogicalAndInsertScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:ArmBase.ShiftRightLogicalAndInsertScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:ArmBase.ShiftRightLogicalAndInsertScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64",
          "T:ArmBase"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33089,
          "Title": "Extend ObsoleteAttribute",
          "Author": "terrajobst",
          "CreatedAt": "2020-03-03T01:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33089",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33089#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 48790000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 32462,
          "Title": "NativeCallableAttribute should be a public API",
          "Author": "AaronRobinsonMSFT",
          "CreatedAt": "2020-02-18T01:41:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/32462",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Interop-coreclr",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594132248",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/32462#issuecomment-594132248",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We modelled it off of \u0060DllImportAttribute\u0060, which is why it\u0027s named \u0060EntryPoint\u0060 and those are fields.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed class NativeCallableAttribute : Attribute\r\n    {\r\n        public NativeCallableAttribute();\r\n\r\n        public CallingConvention CallingConvention;\r\n        public string? EntryPoint;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52610000000,
        "Apis": [
          "F:NativeCallableAttribute.CallingConvention",
          "F:NativeCallableAttribute.EntryPoint",
          "M:NativeCallableAttribute.NativeCallableAttribute()",
          "T:NativeCallableAttribute"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1845,
          "Title": "Low level API support for RCW and CCW management",
          "Author": "AaronRobinsonMSFT",
          "CreatedAt": "2020-01-17T02:01:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1845",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Interop-coreclr",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594151682",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1845#issuecomment-594151682",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should align the naming \u0060Vtable\u0060 vs. \u0060vftbl\u0060\r\n* Some comments are out sync\r\n* The design should be validated by people who are wrapping COM objects\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58970000000,
        "Apis": [
          "F:ComWrappers.ComInterfaceDispatch.vftbl",
          "F:ComWrappers.ComInterfaceEntry.IID",
          "F:ComWrappers.ComInterfaceEntry.Vtable",
          "F:CreateComInterfaceFlags.CallerDefinedIUnknown",
          "F:CreateComInterfaceFlags.None",
          "F:CreateComInterfaceFlags.TrackerSupport",
          "F:CreateObjectFlags.None",
          "F:CreateObjectFlags.TrackerObject",
          "F:CreateObjectFlags.UniqueInstance",
          "M:ComWrappers.ComInterfaceDispatch.GetInstance\u003CT\u003E(ComInterfaceDispatch*)",
          "M:ComWrappers.ComputeVtables(object,CreateComInterfaceFlags,out int)",
          "M:ComWrappers.CreateObject(IntPtr,CreateObjectFlags)",
          "M:ComWrappers.GetIUnknownImpl(out IntPtr,out IntPtr,out IntPtr)",
          "M:ComWrappers.GetOrCreateComInterfaceForObject(object,CreateComInterfaceFlags)",
          "M:ComWrappers.GetOrCreateObjectForComInstance(IntPtr,CreateObjectFlags,object?)",
          "M:ComWrappers.RegisterAsGlobalInstance()",
          "M:ComWrappers.ReleaseObjects(IEnumerable)",
          "M:RuntimeHelpers.AllocateTypeAssociatedMemory(Type,int)",
          "T:ComWrappers",
          "T:ComWrappers.ComInterfaceDispatch",
          "T:ComWrappers.ComInterfaceEntry",
          "T:CreateComInterfaceFlags",
          "T:CreateObjectFlags",
          "T:RuntimeHelpers"
        ]
      }
    ]
  },
  {
    "Id": 85,
    "Date": "2020-03-05T00:00:00-08:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=gwXkFHKPKok",
      "Id": "gwXkFHKPKok",
      "StartDateTime": "2020-03-05T14:06:28.999-08:00",
      "EndDateTime": "2020-03-05T15:30:01-08:00",
      "Duration": 50120010000,
      "Title": ".NET Design Review: WinForms Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/gwXkFHKPKok/mqdefault.jpg"
    },
    "Title": "GitHub Quick Reviews",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2858,
          "Title": "Proposal to expose FileDialog.ClientGuid",
          "Author": "jnm2",
          "CreatedAt": "2020-02-15T17:01:34+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2858",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595474869",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2858#issuecomment-595474869",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class FileDialog\r\n    {\r\n        public System.Guid? ClientGuid { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:FileDialog.ClientGuid",
          "T:FileDialog"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2656,
          "Title": "Add support for tasks to ListViewGroup",
          "Author": "hughbe",
          "CreatedAt": "2020-01-07T12:03:39+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2656",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "tenet-OS-compat",
              "BackgroundColor": "c2e0c6",
              "Description": "Compatibility with OS features",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595478125",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2656#issuecomment-595478125",
        "FeedbackMarkdown": "* Let\u0027s stop creating new delegates for the basic event pattern and just use \u0060EventHandler\u003CT\u003E\u0060\r\n* Is \u0060GroupLink\u0060 the best name for the concept? Or is it some kind of index? If so, the name should reflect that.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public class GroupLinkClickEventArgs : EventArgs\r\n    {\r\n        public GroupLinkClickEventArgs(int groupLink);\r\n        public int GroupLink { get; }\r\n    }\r\n    public partial class ListView\r\n    {\r\n        public event EventHandler\u003CGroupLinkClickEventArgs\u003E GroupLinkClick;\r\n        protected void OnGroupLinkClick(GroupEventArgs e);\r\n    }\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Task { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6010000000,
        "Apis": [
          "M:GroupLinkClickEventArgs.GroupLinkClickEventArgs(int)",
          "M:ListView.OnGroupLinkClick(GroupEventArgs)",
          "P:GroupLinkClickEventArgs.GroupLink",
          "P:ListViewGroup.Task",
          "T:GroupLinkClickEventArgs",
          "T:ListView",
          "T:ListViewGroup"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2655,
          "Title": "Add support for subtitles in ListViewGroup",
          "Author": "hughbe",
          "CreatedAt": "2020-01-07T11:58:51+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2655",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "design-discussion",
              "BackgroundColor": "f7b7ee",
              "Description": "Ongoing discussion about design without consensus",
              "ForegroundColor": "black"
            },
            {
              "Name": "tenet-OS-compat",
              "BackgroundColor": "c2e0c6",
              "Description": "Compatibility with OS features",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595479361",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2655#issuecomment-595479361",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Subtitle { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 11530000000,
        "Apis": [
          "P:ListViewGroup.Subtitle",
          "T:ListViewGroup"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2653,
          "Title": "Add support for footers to ListViewGroup",
          "Author": "hughbe",
          "CreatedAt": "2020-01-07T10:50:31+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2653",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "tenet-OS-compat",
              "BackgroundColor": "c2e0c6",
              "Description": "Compatibility with OS features",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595480175",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2653#issuecomment-595480175",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Footer { get; set; }\r\n        public HorizontalAlignment FooterAlignment { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13600000000,
        "Apis": [
          "P:ListViewGroup.Footer",
          "P:ListViewGroup.FooterAlignment",
          "T:ListViewGroup"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2627,
          "Title": "Discussion/proposal: add more LVCOLUMN ComCtl 6.0 features",
          "Author": "hughbe",
          "CreatedAt": "2020-01-04T21:18:42+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2627",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "tenet-OS-compat",
              "BackgroundColor": "c2e0c6",
              "Description": "Compatibility with OS features",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595483352",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2627#issuecomment-595483352",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We think the individual booleans seems easier than the flags, given that it\u0027s a single use\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ColumnHeader\r\n    {\r\n        public int MinimumWidth { get; set; }\r\n        public bool FixedWidth { get; set; }\r\n        public bool SplitButton { get; set; }\r\n    }\r\n    public class ColumnDropDownClickEventArgs : ColumnClickEventArgs\r\n    {\r\n        public ColumnDropDownClickEventArgs(int column, Point screenLocation);\r\n        public Point ScreenLocation { get; set; }\r\n    }\r\n    public partial class ListView\r\n    {\r\n        public event EventHandler\u003CColumnDropDownClickEventArgs\u003E ColumnDropDownClicked;\r\n        protected void OnColumnDropDownClicked(ColumnDropDownClickEventArgs e);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14710000000,
        "Apis": [
          "M:ColumnDropDownClickEventArgs.ColumnDropDownClickEventArgs(int,Point)",
          "M:ListView.OnColumnDropDownClicked(ColumnDropDownClickEventArgs)",
          "P:ColumnDropDownClickEventArgs.ScreenLocation",
          "P:ColumnHeader.FixedWidth",
          "P:ColumnHeader.MinimumWidth",
          "P:ColumnHeader.SplitButton",
          "T:ColumnDropDownClickEventArgs",
          "T:ColumnHeader",
          "T:ListView"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2642,
          "Title": "Proposal: add SelectionStart and SelectionEnd to TrackBar",
          "Author": "hughbe",
          "CreatedAt": "2020-01-06T16:41:29+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2642",
          "Milestone": "5.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "design-discussion",
              "BackgroundColor": "f7b7ee",
              "Description": "Ongoing discussion about design without consensus",
              "ForegroundColor": "black"
            },
            {
              "Name": "tenet-OS-compat",
              "BackgroundColor": "c2e0c6",
              "Description": "Compatibility with OS features",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595486672",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2642#issuecomment-595486672",
        "FeedbackMarkdown": "* We should probably follow \u0060TextBoxBase\u0060 and use \u0060SelectionStart\u0060 and \u0060SelectionLength\u0060, because that avoids ordering issues and the need for sentinel values. @RussKie, it would be good to check what the throw behavior is for \u0060TextBoxBase\u0060.\r\n* We considered making it method like \u0060SetSelection(int start, int length)\u0060 but that would mean you can\u0027t set the selection using the designer, which feels odd\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class TrackBar\r\n    {\r\n        public bool ShowSelectionRange { get; set; }\r\n        public int SelectionStart { get; set; }\r\n        public int SelectionLength { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n@hughbe What the other properties you show in your UI? Like \u0060ShowThumb\u0060 and \u0060ThumbWidth\u0060?",
        "TimeCode": 20520000000,
        "Apis": [
          "P:TrackBar.SelectionLength",
          "P:TrackBar.SelectionStart",
          "P:TrackBar.ShowSelectionRange",
          "T:TrackBar"
        ]
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2788,
          "Title": "Add Bold Property to TreeNode",
          "Author": "jmairboeck",
          "CreatedAt": "2020-01-30T11:13:18+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2788",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "200dff",
              "Description": "(3) API needs work before it is approved, it is NOT ready for implementation; applied by repo owners",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595496212",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2788#issuecomment-595496212",
        "FeedbackMarkdown": "* We prefer \u0060IsBold\u0060 is nicer than \u0060Bold\u0060\r\n* Assuming \u0060IsBold\u0060 is independent of the \u0060NodeFont\u0060 we like it.\r\n* If there is a weird relationship between \u0060IsBold\u0060 and \u0060NodeFont\u0060, e.g. when setting \u0060IsBold\u0060 modifies the \u0060NodeFont\u0060, then we don\u0027t like it because it creates referential integrity issues where setting a boolean in one place suddenly causes the node to use a different font when the font was meant to be shared across multiple nodes. We should investigate that before we approve the API.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class TreeNode\r\n    {\r\n        public bool IsBold { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27450000000,
        "Apis": [
          "P:TreeNode.IsBold",
          "T:TreeNode"
        ]
      }
    ]
  },
  {
    "Id": 86,
    "Date": "2020-03-17T00:00:00-07:00",
    "Video": null,
    "Title": "System.Runtime.Intrinsics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 32512,
          "Title": "ARM additional arithmetic intrinsics",
          "Author": "tannergooding",
          "CreatedAt": "2020-02-18T22:46:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/32512",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-17T00:00:00-07:00",
        "FeedbackId": "600227857",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/32512#issuecomment-600227857",
        "FeedbackMarkdown": "* Looks good\r\n* We made some substantial changing in order of words\r\n* ~~\u0060AbsoluteDifferenceAdd\u0060 in #24794 should take \u0060Vector128\u003CT\u003E\u0060 rather than \u0060Vector64\u003CT\u003E\u0060~~\r\n    - Actually it\u0027s correct\r\n* The \u0060Halving\u0060 methods are fused, so we should prefix them with \u0060Fused\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class AdvSimd\r\n    {\r\n        public Vector64\u003Cbyte\u003E   AddLowerReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  AddLowerReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  AddLowerReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E AddLowerReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    AddLowerReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   AddLowerReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003Cbyte\u003E   AddLowerRoundedReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  AddLowerRoundedReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  AddLowerRoundedReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E AddLowerRoundedReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    AddLowerRoundedReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   AddLowerRoundedReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003CT\u003E  FusedAddHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedAddHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  FusedAddRoundedHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedAddRoundedHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  AddSaturate(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E AddSaturate(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003Cbyte\u003E   SubtractLowerReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  SubtractLowerReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  SubtractLowerReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E SubtractLowerReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    SubtractLowerReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   SubtractLowerReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003Cbyte\u003E   SubtractLowerRoundedReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  SubtractLowerRoundedReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  SubtractLowerRoundedReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E SubtractLowerRoundedReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    SubtractLowerRoundedReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   SubtractLowerRoundedReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003CT\u003E  FusedSubtractHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedSubtractHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  SubtractSaturate(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E SubtractSaturate(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public partial class Arm64\r\n        {\r\n            public Vector128\u003Cbyte\u003E   AddUpperReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  AddUpperReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  AddUpperReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E AddUpperReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    AddUpperReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   AddUpperReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector128\u003Cbyte\u003E   AddUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  AddUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  AddUpperRoundedReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E AddUpperRoundedReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    AddUpperRoundedReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   AddUpperRoundedReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector64\u003CT\u003E AddSaturateScalar(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n            public Vector128\u003Cbyte\u003E   SubtractUpperReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  SubtractUpperReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  SubtractUpperReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E SubtractUpperReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    SubtractUpperReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   SubtractUpperReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector128\u003Cbyte\u003E   SubtractUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  SubtractUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  SubtractUpperRoundedReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E SubtractUpperRoundedReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    SubtractUpperRoundedReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   SubtractUpperRoundedReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector64\u003CT\u003E SubtractSaturateScalar(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddPairwiseWidening(Vector64\u003Csbyte\u003E  value);\r\n            public static Vector128\u003Cushort\u003E AddPairwiseWidening(Vector64\u003Cbyte\u003E   value);\r\n            public static Vector128\u003Cint\u003E    AddPairwiseWidening(Vector64\u003Cshort\u003E  value);\r\n            public static Vector128\u003Cuint\u003E   AddPairwiseWidening(Vector64\u003Cushort\u003E value);\r\n            public static Vector128\u003Clong\u003E   AddPairwiseWidening(Vector64\u003Cint\u003E    value);\r\n            public static Vector128\u003Culong\u003E  AddPairwiseWidening(Vector64\u003Cuint\u003E   value);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddPairwiseWideningAndAdd(Vector128\u003Cshort\u003E  addend, Vector64\u003Csbyte\u003E  value);\r\n            public static Vector128\u003Cushort\u003E AddPairwiseWideningAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   value);\r\n            public static Vector128\u003Cint\u003E    AddPairwiseWideningAndAdd(Vector128\u003Cint\u003E    addend, Vector64\u003Cshort\u003E  value);\r\n            public static Vector128\u003Cuint\u003E   AddPairwiseWideningAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E value);\r\n            public static Vector128\u003Clong\u003E   AddPairwiseWideningAndAdd(Vector128\u003Clong\u003E   addend, Vector64\u003Cint\u003E    value);\r\n            public static Vector128\u003Culong\u003E  AddPairwiseWideningAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   value);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLower(Vector128\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLower(Vector128\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLower(Vector128\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLower(Vector128\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLower(Vector128\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLower(Vector128\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningLower(Vector128\u003Cshort\u003E   left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningLower(Vector128\u003Cushort\u003E  left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningLower(Vector128\u003Cint\u003E     left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningLower(Vector128\u003Cuint\u003E    left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningLower(Vector128\u003Clong\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningLower(Vector128\u003Culong\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningUpper(Vector128\u003Clong\u003E   left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningUpper(Vector128\u003Culong\u003E  left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningLower(Vector128\u003Cshort\u003E   left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningLower(Vector128\u003Cushort\u003E  left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningLower(Vector128\u003Cint\u003E     left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningLower(Vector128\u003Cuint\u003E    left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningLower(Vector128\u003Clong\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningLower(Vector128\u003Culong\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningUpper(Vector128\u003Clong\u003E   left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningUpper(Vector128\u003Culong\u003E  left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLowerAndAdd(Vector128\u003Cshort\u003E  addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLowerAndAdd(Vector128\u003Cint\u003E    addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLowerAndAdd(Vector128\u003Clong\u003E   addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpperAndAdd(Vector128\u003Cshort\u003E  addend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpperAndAdd(Vector128\u003Cint\u003E    addend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpperAndAdd(Vector128\u003Clong\u003E   addend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLowerAndSubtract(Vector128\u003Cshort\u003E  minuend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLowerAndSubtract(Vector128\u003Cushort\u003E minuend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLowerAndSubtract(Vector128\u003Cint\u003E    minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLowerAndSubtract(Vector128\u003Cuint\u003E   minuend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLowerAndSubtract(Vector128\u003Clong\u003E   minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLowerAndSubtract(Vector128\u003Culong\u003E  minuend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpperAndSubtract(Vector128\u003Cshort\u003E  minuend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpperAndSubtract(Vector128\u003Cushort\u003E minuend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpperAndSubtract(Vector128\u003Cint\u003E    minuend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpperAndSubtract(Vector128\u003Cuint\u003E   minuend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpperAndSubtract(Vector128\u003Clong\u003E   minuend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpperAndSubtract(Vector128\u003Culong\u003E  minuend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.AddSaturate(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.AddSaturate(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddSaturateScalar(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractSaturateScalar(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.FusedAddHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedAddHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.FusedAddRoundedHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedAddRoundedHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.FusedSubtractHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedSubtractHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1277,
          "Title": "API Proposal : Arm TableVectorLookup and TableVectorExtension intrinsics",
          "Author": "TamarChristinaArm",
          "CreatedAt": "2020-01-03T17:34:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1277",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-17T00:00:00-07:00",
        "FeedbackId": "600244479",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1277#issuecomment-600244479",
        "FeedbackMarkdown": "* We should consider using a custom type rather than a tuple to repesent lists, because we can expose more operations later. It also means people can\u0027t do things like taking the address of the tuple field. However, the nice thing about using tuples is language syntax. But we can probably get the same benefits if we were to define implicit conversion between the two. We can also a \u0060Deconstruct\u0060 directly on the custom type, allowing for tuple-style deconstructing into locals.\r\n* We don\u0027t think we\u0027re ready for the overloads that take multiple lists with more than value for .NET 5, due to necessary JIT implementation work\r\n* We approved the \u0060Arm32\u0060 version but commented them out b/c we won\u0027t be shipping them in .NET 5\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class AdvSimd\r\n    {\r\n        public static Vector64\u003Cbyte\u003E  VectorTableLookup(Vector128\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        public static Vector64\u003Csbyte\u003E VectorTableLookup(Vector128\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n\r\n        public static Vector64\u003Cbyte\u003E  VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector128\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        public static Vector64\u003Csbyte\u003E VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector128\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n\r\n        // public partial class Arm32\r\n        // {\r\n        //    public static Vector64\u003Cbyte\u003E  VectorTableLookup(Vector64\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        //    public static Vector64\u003Csbyte\u003E VectorTableLookup(Vector64\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n        //\r\n        //    public static Vector64\u003Cbyte\u003E  VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector64\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E byteIndexes);\r\n        //    public static Vector64\u003Csbyte\u003E VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector64\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n        // }\r\n\r\n        public partial class Arm64\r\n        {\r\n           public static Vector128\u003Cbyte\u003E  VectorTableLookup(Vector128\u003Cbyte\u003E  table, Vector128\u003Cbyte\u003E byteIndexes);\r\n           public static Vector128\u003Csbyte\u003E VectorTableLookup(Vector128\u003Csbyte\u003E table, Vector128\u003Csbyte\u003E byteIndexes);\r\n\r\n           public static Vector128\u003Cbyte\u003E  VectorTableLookupExtension(Vector128\u003Cbyte\u003E defaultValues, Vector128\u003Cbyte\u003E  table, Vector128\u003Cbyte\u003E  byteIndexes);\r\n           public static Vector128\u003Csbyte\u003E VectorTableLookupExtension(Vector128\u003Cbyte\u003E defaultValues, Vector128\u003Csbyte\u003E table, Vector128\u003Csbyte\u003E byteIndexes);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.VectorTableLookup(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookup(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookupExtension(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookupExtension(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.VectorTableLookup(Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.VectorTableLookup(Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.VectorTableLookupExtension(Vector64\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.VectorTableLookupExtension(Vector64\u003Cbyte\u003E,Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      }
    ]
  },
  {
    "Id": 87,
    "Date": "2020-03-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=IcE-wGQC_eM",
      "Id": "IcE-wGQC_eM",
      "StartDateTime": "2020-03-24T10:03:58.488-07:00",
      "EndDateTime": "2020-03-24T12:34:33-07:00",
      "Duration": 90345120000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/IcE-wGQC_eM/mqdefault.jpg"
    },
    "Title": "System.Memory, System.Net.Http, System.Runtime, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 987,
          "Title": "HTTP version selection",
          "Author": "scalablecory",
          "CreatedAt": "2019-12-17T19:00:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/987",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603384663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/987#issuecomment-603384663",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - We may want to change \u0060HttpVersionPolicy.RequestXxx\u0060 to \u0060HttpVersionPolicy.RequestedXxx\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class HttpClient\r\n    {\r\n        // Exists today - will be interpreted as Min or Max based on new API below.\r\n        // Version DefaultVersion { get; set; }\r\n        public HttpVersionPolicy DefaultVersionPolicy { get; set; } = HttpVersionPolicy.RequestVersionOrLower;\r\n    }\r\n\r\n    public partial class HttpRequestMessage\r\n    {\r\n        // Exists today - will be interpreted as Min or Max based on new API below.\r\n        // Version Version { get; set; }\r\n        public HttpVersionPolicy VersionPolicy { get; set; } = HttpVersionPolicy.RequestVersionOrLower;\r\n    }\r\n\r\n    public enum HttpVersionPolicy\r\n    {\r\n        RequestVersionOrLower,\r\n        RequestVersionOrHigher,\r\n        RequestVersionExact\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:HttpVersionPolicy.RequestVersionExact",
          "F:HttpVersionPolicy.RequestVersionOrHigher",
          "F:HttpVersionPolicy.RequestVersionOrLower",
          "P:HttpClient.DefaultVersionPolicy",
          "P:HttpRequestMessage.VersionPolicy",
          "T:HttpClient",
          "T:HttpRequestMessage",
          "T:HttpVersionPolicy"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28230,
          "Title": "Create APIs to deal with processing ASCII text (as bytes)",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2018-12-18T18:15:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28230",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603439786",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28230#issuecomment-603439786",
        "FeedbackMarkdown": "* \u0060Equals\u0060 ignores non-ASCII characters. Should it return \u0060false\u0060 or even throw?\r\n* \u0060IndexOf\u0060 et. al. should return \u0060-1\u0060 if the \u0022needle\u0022 contains non-ASCII characters; it\u0027s acceptable to return a successful match if the \u0022needle\u0022 is found in the \u0022haystack\u0022 and the haystack has non-ASCII anywhere (to the left or right of the match). IOW, only the \u0022needle\u0022 is validated, not the \u0022haystack\u0022.\r\n* It seems a bit odd that some APIs have both \u0060ReadOnlySpan\u003Cchar\u003E\u0060 and \u0060string\u0060 and some only have \u0060ReadOnlySpan\u003Cchar\u003E\u0060. We should make it consistent.\r\n* \u0060IsAllAscii\u0060, \u0060IsAsciiChar\u0060, \u0060IsAsciiByte\u0060 should be an overloaded \u0060IsAscii\u0060 method\r\n* We should drop \u0060Invariant\u0060 suffix (for the same reason we dropped \u0060Ordinal\u0060, it\u0027s all ASCII here)\r\n* \u0060ToLower()\u0060 / \u0060ToUpper()\u0060 should throw when destination is too small (returning the \u0060int\u0060 is still fine)\r\n* \u0060GetHashCodeOrdinalIgnoreCase()\u0060 should be \u0060GetHashCodeIgnoreCase()\u0060\r\n* \u0060ToString()\u0060 should be dropped in favor of \u0060Encoding.Ascii.GetString()\u0060\r\n* \u0060Trim\u0060, \u0060TrimStart\u0060, \u0060TrimEnd\u0060 should return \u0060Range\u0060 so that callers can do the right thing\r\n* \u0060GetTrimmedRange()\u0060 suggest that it returns the whitespace\r\n* Several parameters were renamed from \u0060buffer\u0060 to \u0060value\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Text\r\n{\r\n    public static class Ascii\r\n    {\r\n        // Compares two ASCII buffers for equality, optionally treating [A-Z] and [a-z] as equal.\r\n        // All non-ASCII bytes / chars are compared for pure binary equivalence.\r\n\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n        public static bool Equals(ReadOnlySpan\u003Cchar\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cchar\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n\r\n        // Compares an ASCII byte buffer and an ASCII char buffer for equality, optionally treating\r\n        // [A-Z] and [a-z] as equal. Returns false if the ASCII byte buffer contains any non-ASCII\r\n        // data or if the char buffer contains any element in the range [ 0080 .. FFFF ], as we\r\n        // wouldn\u0027t know what encoding to use to perform the transcode-then-compare operation.\r\n\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, string right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, string right);\r\n\r\n        // Searches for the first occurrence of the target substring within the search space,\r\n        // optionally treating [A-Z] and [a-z] as equal. All non-ASCII bytes are compared for pure\r\n        // binary equivalence. Returns the index of where the first match is found, else returns -1.\r\n        // ADDENDUM: Also assume there are *Last equivalents of the following.\r\n\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cbyte\u003E value);\r\n\r\n        // Searches for the first occurrence of the target substring within the search space,\r\n        // optionally treating [A-Z] and [a-z] as equal. Returns the index of where the first match\r\n        // is found, else returns -1. If the target string contains any non-ASCII chars ([ 0080 .. FFFF ]),\r\n        // the search is assume to have failed, and the method returns -1.\r\n        // ADDENDUM: Also assume there are *Last equivalents of the following.\r\n\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, string value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, string value);\r\n\r\n        // Given a buffer, returns the index of the first element in the buffer which\r\n        // is a non-ASCII byte, or -1 if the buffer is empty or all-ASCII. The bool-\r\n        // returning method is a convenience shortcut to perform the same check.\r\n\r\n        public static int GetIndexOfFirstNonAsciiByte(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static int GetIndexOfFirstNonAsciiChar(ReadOnlySpan\u003Cchar\u003E buffer);\r\n        public static bool IsAscii(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static bool IsAscii(ReadOnlySpan\u003Cchar\u003E value);\r\n\r\n        // Returns true iff the provided byte is an ASCII byte; i.e., in the range [ 00 .. 7F ];\r\n        // or if the provided char is in the range [ 0000 .. 007F ].\r\n\r\n        public static bool IsAscii(byte value);\r\n        public static bool IsAscii(char value);\r\n\r\n        // Copies source to destination, converting [A-Z] -\u003E [a-z] or vice versa during\r\n        // the copy. All values outside [A-Za-z] - including non-ASCII values - are unchanged\r\n        // during the copy.\r\n        //\r\n        // If source.Length \u003C= destination.Length, succeeds and returns source.Length (# bytes copied).\r\n        // If source.Length \u003E destination.Length, returns -1.\r\n\r\n        public static int ToLower(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n        public static int ToLower(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n        public static int ToUpper(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n        public static int ToUpper(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n\r\n        // Performs case conversion ([A-Z] -\u003E [a-z] or vice versa) in-place. All values\r\n        // outside [A-Za-z] - including non-ASCII values - are unchanged.\r\n\r\n        public static void ToLowerInPlace(Span\u003Cbyte\u003E value);\r\n        public static void ToLowerInPlace(Span\u003Cchar\u003E value);\r\n        public static void ToUpperInPlace(Span\u003Cbyte\u003E value);\r\n        public static void ToUpperInPlace(Span\u003Cchar\u003E value);\r\n\r\n        // Performs case conversion on a single value, converting [A-Z] -\u003E [a-z] or vice versa.\r\n        // All values outside [A-Za-z] - including non-ASCII values - are unchanged.\r\n\r\n        public static byte ToLower(byte value);\r\n        public static byte ToLower(char value);\r\n        public static byte ToUpper(byte value);\r\n        public static byte ToUpper(char value);\r\n\r\n        // Returns a hash code for the provided buffer suitable for use in a dictionary or\r\n        // other keyed collection. For the OrdinalIgnoreCase method, the values [A-Z] and [a-z]\r\n        // are treated as equivalent during hash code computation. All non-ASCII values\r\n        // are treated as opaque data. The hash code is randomized but is not guaranteed to\r\n        // implement any particular algorithm, nor is it guaranteed to be a member of the same\r\n        // PRF family as other GetHashCode routines in the framework.\r\n\r\n        public static int GetHashCode(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int GetHashCode(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int GetHashCodeIgnoreCase(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int GetHashCodeIgnoreCase(ReadOnlySpan\u003Cchar\u003E value);\r\n\r\n        // Widens an ASCII buffer to UTF-16 or narrows a UTF-16 buffer to ASCII.\r\n        // Returns OperationStatus.InvalidData if the source buffer contains a non-ASCII byte\r\n        // or a char in the range [ 0080 .. FFFF ].\r\n        // OPEN QUESTION: Should we have an equivalent with Latin-1 semantics? Probably doesn\u0027t\r\n        // belong on the ASCII class if we do that.\r\n\r\n        public static OperationStatus WidenToUtf16(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cchar\u003E destination, out int bytesConsumed, out int charsWritten);\r\n        public static OperationStatus NarrowFromUTf16(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cbyte\u003E destination, out int charsConsumed, out int bytesWritten);\r\n\r\n        // Trims only ASCII whitespace values from the buffer, returning the trimmed buffer.\r\n\r\n        public static Range Trim(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range Trim(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static Range TrimStart(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range TrimStart(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static Range TrimEnd(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range TrimEnd(ReadOnlySpan\u003Cchar\u003E value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10100000000,
        "Apis": [
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetHashCode(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetHashCode(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetHashCodeIgnoreCase(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetHashCodeIgnoreCase(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetIndexOfFirstNonAsciiByte(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetIndexOfFirstNonAsciiChar(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.IsAscii(byte)",
          "M:Ascii.IsAscii(char)",
          "M:Ascii.IsAscii(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IsAscii(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.NarrowFromUTf16(ReadOnlySpan\u003Cchar\u003E,Span\u003Cbyte\u003E,out int,out int)",
          "M:Ascii.ToLower(byte)",
          "M:Ascii.ToLower(char)",
          "M:Ascii.ToLower(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToLower(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:Ascii.ToLowerInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInPlace(Span\u003Cchar\u003E)",
          "M:Ascii.ToUpper(byte)",
          "M:Ascii.ToUpper(char)",
          "M:Ascii.ToUpper(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpper(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:Ascii.ToUpperInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInPlace(Span\u003Cchar\u003E)",
          "M:Ascii.Trim(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.Trim(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.TrimEnd(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.TrimEnd(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.TrimStart(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.TrimStart(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.WidenToUtf16(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cchar\u003E,out int,out int)",
          "T:Ascii"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 26780,
          "Title": "Move appropriate parts of Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment into the shared framework",
          "Author": "tannergooding",
          "CreatedAt": "2018-07-11T21:43:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26780",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603448231",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/26780#issuecomment-603448231",
        "FeedbackMarkdown": "* Looks good\r\n    - We like that we don\u0027t duplicate code between the native and the managed implementation\r\n    - However, we should make sure that other hosts can access the logic in the hosting APIs, so it seems they should expose an easy API to compute the current RID and set the \u0060AppContext\u0060 value (or make sure they are automatically set)\r\n* We should make it a property\r\n* It shouldn\u0027t return a nullable string, rather it should do a sensible fallback (either in the host or the managed side)\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enabled\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class RuntimeInformation\r\n    {\r\n        // The current OS RID, e.g.: win7-x64, osx.10.11-x64, ubuntu.18.04-arm64, rhel.7-x64\r\n        public static string RuntimeIdentifier { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61270000000,
        "Apis": [
          "P:RuntimeInformation.RuntimeIdentifier",
          "T:RuntimeInformation"
        ]
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30820,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603451353",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30820#issuecomment-603451353",
        "FeedbackMarkdown": "It sounds like you need to design an extension point by making it class instead. That sounds reasonable, so we bumped it back to \u0060api-needs-work\u0060. Once you have a proposal, we can re-review.",
        "TimeCode": 69150000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30445,
          "Title": "Add a copy constructor to JsonSerializerOptions",
          "Author": "pranavkm",
          "CreatedAt": "2019-08-01T01:07:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30445",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603455704",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30445#issuecomment-603455704",
        "FeedbackMarkdown": "* Looks good\r\n* This will only copy settings, no cache information\r\n* Converters that were added automatically (e.g. factories) should not be copied.\r\n* Let\u0027s use \u0060options\u0060 for the parameter name\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public sealed partial class JsonSerializerOptions\r\n    {\r\n        public JsonSerializerOptions(JsonSerializerOptions options)\r\n        {\r\n            /* Copy all options from source to a new JsonSerializerOptions instance. */\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 74900000000,
        "Apis": [
          "M:JsonSerializerOptions.JsonSerializerOptions(JsonSerializerOptions)",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30687,
          "Title": "System.Text.Json ignore only when null API enhancement",
          "Author": "CodeBlanch",
          "CreatedAt": "2019-08-27T00:56:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30687",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603461964",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30687#issuecomment-603461964",
        "FeedbackMarkdown": "* Looks good\r\n* We should have a follow-up for \u0060JsonSerializerOptions.IgnoreDefault\u0060 to support skipping value types.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public enum JsonIgnoreCondition\r\n    {\r\n        Always,\r\n        WhenNull,\r\n        Never\r\n    }\r\n\r\n    public partial class JsonIgnoreAttribute\r\n    {\r\n        public JsonIgnoreCondition Condition { get; set; };\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 81160000000,
        "Apis": [
          "F:JsonIgnoreCondition.Always",
          "F:JsonIgnoreCondition.Never",
          "F:JsonIgnoreCondition.WhenNull",
          "P:JsonIgnoreAttribute.Condition",
          "T:JsonIgnoreAttribute",
          "T:JsonIgnoreCondition"
        ]
      }
    ]
  },
  {
    "Id": 88,
    "Date": "2020-04-01T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=jQw5hiePju0",
      "Id": "jQw5hiePju0",
      "StartDateTime": "2020-04-01T11:06:53.986-07:00",
      "EndDateTime": "2020-04-01T12:07:23-07:00",
      "Duration": 36290140000,
      "Title": ".NET Design Review: WasmHttpHandler",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jQw5hiePju0/mqdefault.jpg"
    },
    "Title": "System.Net.Http",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-wasm",
              "BackgroundColor": "eb6420",
              "Description": "WebAssembly architecture",
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-01T00:00:00-07:00",
        "FeedbackId": "607439446",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-607439446",
        "FeedbackMarkdown": "* **Shipping vehicle**. Which assembly should this go in? Should this be shipped out-of-band?\r\n* **Namespace**. We should consider either having a prefix for all types or introduce a new namespace.\r\n* **Scoping**. It seems those are really per request, having them on the handler seems problematic unless we say they are just defaults. But we\u0027d still need a way to pass them in per request.\r\n* **Mechanics**. It seems we all like the concept of a loose property bag over message that a handler can inspect to perform request specific operations. However, we don\u0027t like the loose typing of \u0060HttpRequestMessage.Properties\u0060 which is \u0060IDictionary\u003Cstring, object\u003E\u0060. It seems the easiest short term solution is an extension methods over \u0060HttpRequestMessage\u0060 like \u0060SetRequestCache\u0060/\u0060GetRequestCache\u0060 that will set/get the value in the property bag. Alternatively, we could expose a new type, such as \u0060HttpMessageOptions\u0060 that people can pass around and that we can be stored in \u0060HttpRequestMessage.Properties\u0060. This way, libraries can accept an \u0060HttpMessageOptions\u0060 and use that in case they are constructing HTTP messages themselves. @scalablecory also had [this idea](https://github.com/dotnet/runtime/issues/1793#issuecomment-607085294).\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Net.Http\r\n{\r\n    public class WebAssemblyHttpHandler : HttpMessageHandler\r\n    {\r\n        public WebAssemblyHttpHandler();\r\n        public string? Integrity { get; set; }\r\n        public RequestCache? RequestCache { get; set; }\r\n        public RequestCredentials? RequestCredentials { get; set; }\r\n        public RequestMode? RequestMode { get; set; }\r\n        public bool StreamingEnabled { get; set; }\r\n    }\r\n    public enum RequestCache\r\n    {\r\n        Default = 0,\r\n        NoStore = 1,\r\n        Reload = 2,\r\n        NoCache = 3,\r\n        ForceCache = 4,\r\n        OnlyIfCached = 5,\r\n    }\r\n    public enum RequestCredentials\r\n    {\r\n        Omit = 0,\r\n        SameOrigin = 1,\r\n        Include = 2,\r\n    }\r\n    public enum RequestMode\r\n    {\r\n        SameOrigin = 0,\r\n        NoCors = 1,\r\n        Cors = 2,\r\n        Navigate = 3,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:RequestCache.Default",
          "F:RequestCache.ForceCache",
          "F:RequestCache.NoCache",
          "F:RequestCache.NoStore",
          "F:RequestCache.OnlyIfCached",
          "F:RequestCache.Reload",
          "F:RequestCredentials.Include",
          "F:RequestCredentials.Omit",
          "F:RequestCredentials.SameOrigin",
          "F:RequestMode.Cors",
          "F:RequestMode.Navigate",
          "F:RequestMode.NoCors",
          "F:RequestMode.SameOrigin",
          "M:WebAssemblyHttpHandler.WebAssemblyHttpHandler()",
          "P:WebAssemblyHttpHandler.Integrity",
          "P:WebAssemblyHttpHandler.RequestCache",
          "P:WebAssemblyHttpHandler.RequestCredentials",
          "P:WebAssemblyHttpHandler.RequestMode",
          "P:WebAssemblyHttpHandler.StreamingEnabled",
          "T:RequestCache",
          "T:RequestCredentials",
          "T:RequestMode",
          "T:WebAssemblyHttpHandler"
        ]
      }
    ]
  },
  {
    "Id": 89,
    "Date": "2020-04-07T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=POdrqNOlY5g",
      "Id": "POdrqNOlY5g",
      "StartDateTime": "2020-04-07T10:04:11.783-07:00",
      "EndDateTime": "2020-04-07T12:19:30-07:00",
      "Duration": 81182170000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/POdrqNOlY5g/mqdefault.jpg"
    },
    "Title": "System.IO, System.Net.Sockets, System.Text.Json, System.Xml",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 862,
          "Title": "Consider exposing Socket(SafeSocketHandle fd) constructor",
          "Author": "dmirmilshteyn",
          "CreatedAt": "2016-11-27T22:33:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/862",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610520669",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/862#issuecomment-610520669",
        "FeedbackMarkdown": "Looks good as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        public Socket(SafeSocketHandle handle);\r\n    }\r\n}\r\n\u0060\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Socket.Socket(SafeSocketHandle)",
          "T:Socket"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33206,
          "Title": "MemoryMappedFile constructor",
          "Author": "carlossanlop",
          "CreatedAt": "2020-03-05T02:00:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33206",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610526663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33206#issuecomment-610526663",
        "FeedbackMarkdown": "* We\u0027re fine with taking the \u0060handle\u0060 parameter but we have concerns with the \u0060fileStream\u0060 parameter because it seems plumbing, not part of a sensible API.\r\n  * Option 1: Move the implementation from the higher level assembly to the assembly containing \u0060MemoryMappedFile\u0060 (while the ref assembly setup)\r\n  * Option 2.1 \u0022Smuggle\u0022 the file stream via the \u0060SafeMemoryMappedFileHandle\u0060 via a field\r\n  * Option 2.2 \u0022Smuggle\u0022 the file stream via the \u0060SafeMemoryMappedFileHandle\u0060 unsealing \u0026 deriving from \u0060SafeMemoryMappedFileHandle\u0060\r\n  * Option 3: do what\u0027s proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.MemoryMappedFiles\r\n{\r\n    public partial class MemoryMappedFile\r\n    {\r\n        public MemoryMappedFile(SafeMemoryMappedFileHandle handle, IDisposable fileStream);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15950000000,
        "Apis": [
          "M:MemoryMappedFile.MemoryMappedFile(SafeMemoryMappedFileHandle,IDisposable)",
          "T:MemoryMappedFile"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33618,
          "Title": "Implement IAsyncDisposable for XmlWriter and XmlReader",
          "Author": "buyaa-n",
          "CreatedAt": "2020-03-16T05:41:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33618",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Xml",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610535975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33618#issuecomment-610535975",
        "FeedbackMarkdown": "* We should not make \u0060XmlReader\u0060 implement \u0060IAsyncDisposable\u0060\r\n* We should not have a \u0060CloseAsync\u0060\r\n* We don\u0027t want a cancelable \u0060DisposeAsync\u0060, for scenarios that need that we add an overload to \u0060FlushAsync\u0060 that accepts a cancellation token. We generally want to dispose resources even when you\u0027re cancelled.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Xml\r\n{\r\n    public partial class XmlWriter : IAsyncDisposable\r\n    {\r\n        public ValueTask DisposeAsync();\r\n        protected virtual ValueTask DisposeAsyncCore();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23060000000,
        "Apis": [
          "M:XmlWriter.DisposeAsync()",
          "M:XmlWriter.DisposeAsyncCore()",
          "T:XmlWriter"
        ]
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34439,
          "Title": "Provide opt-in for custom converters to handle null",
          "Author": "layomia",
          "CreatedAt": "2020-04-02T04:20:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34439",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610556104",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34439#issuecomment-610556104",
        "FeedbackMarkdown": "* In this proposal the converter is only called when a \u0060null\u0060 value is included in the payload. If the property is missing in the payload, the the convert still won\u0027t be called. Does this satisfy the customer request? While this should probably be an independent feature it seems we\u0027ll want to make sure the design for both will work well together.\r\n* Should this be on the non-generic base \u0060JsonConverter\u0060?\r\n  * We concluded no, because the \u0060Read\u0060/\u0060Write\u0060 methods are also only on \u0060JsonConverter\u003CT\u003E\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class JsonConverter\u003CT\u003E\r\n    {\r\n        public virtual bool HandleNull { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34330000000,
        "Apis": [
          "P:JsonConverter\u003CT\u003E.HandleNull",
          "T:JsonConverter\u003CT\u003E"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34558,
          "Title": "JsonSerializer support for fields \u0026 non-public accessors",
          "Author": "layomia",
          "CreatedAt": "2020-04-05T05:20:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34558",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610571471",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34558#issuecomment-610571471",
        "FeedbackMarkdown": "* Let\u0027s rename \u0060JsonMemberAttribute\u0060 to \u0060JsonIncludeAttribute\u0060\r\n* We should change \u0060JsonIgnoreAttribute\u0060 to include fields\r\n* We don\u0027t see a need for \u0060JsonObjectAttribute\u0060 it should be a per property/field decisions\r\n* We should treat read-only fields like get-only properties\r\n* We can decide to support private/internal fields/properties by applying \u0060JsonInclude\u0060, but we need think through implications for AOT (generating the serialzier as part of the type would make this possible tho)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public bool IncludeFields { get; set; }\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    [AttributeUsage(AttributeTargets.Property |\r\n                    Attributes.Field, AllowMultiple = false)]\r\n    public sealed class JsonIncludeAttribute : JsonAttribute\r\n    {\r\n        public JsonIncludeAttribute();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59750000000,
        "Apis": [
          "M:JsonIncludeAttribute.JsonIncludeAttribute()",
          "P:JsonSerializerOptions.IncludeFields",
          "T:JsonIncludeAttribute",
          "T:JsonSerializerOptions"
        ]
      }
    ]
  },
  {
    "Id": 90,
    "Date": "2020-04-16T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=Ttscz2mBl-c",
      "Id": "Ttscz2mBl-c",
      "StartDateTime": "2020-04-16T10:06:06.298-07:00",
      "EndDateTime": "2020-04-16T12:30:25-07:00",
      "Duration": 86587020000,
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Ttscz2mBl-c/mqdefault.jpg"
    },
    "Title": "System.Runtime, System.Runtime.CompilerServices, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34626,
          "Title": "Don\u0027t forget about JsonSerializerOptions.CreateForWeb()",
          "Author": "Jozkee",
          "CreatedAt": "2020-04-07T04:33:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34626",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "easy",
              "BackgroundColor": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34626#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33328,
          "Title": "OSPlatform support for WASM/Blazor",
          "Author": "terrajobst",
          "CreatedAt": "2020-03-07T05:04:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33328",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-wasm",
              "BackgroundColor": "eb6420",
              "Description": "WebAssembly architecture",
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614802442",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33328#issuecomment-614802442",
        "FeedbackMarkdown": "* We considered expanding \u0060Wasm\u0060 to \u0060WebAssembly\u0060, but the RIDs will use \u0060wasm\u0060, so it makes more sense to aling the names.\r\n* Should \u0060OSPlatform.IsOSPlatform(OSPlatform.Windows)\u0060 return \u0060true\u0060 when running inside a browser on Windows. We concluded no, because that would likely break more people. Parties who care, need to use a more specific API that returns, for example, the user agent string.\r\n* @marek-safar what are the plans for the RIDs? It would be logical to call the RID \u0060browser-wasm\u0060, akin to \u0060win-x86\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial enum Architecture\r\n    {\r\n         Wasm\r\n    }\r\n    public partial struct OSPlatform\r\n    {\r\n         public static OSPlatform Browser { get; } = new OSPlatform(nameof(Browser));\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 4570000000,
        "Apis": [
          "F:Architecture.Wasm",
          "P:OSPlatform.Browser",
          "T:Architecture",
          "T:OSPlatform"
        ]
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33331,
          "Title": "Guarding calls to platform-specific APIs",
          "Author": "terrajobst",
          "CreatedAt": "2020-03-07T06:36:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33331",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614826740",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33331#issuecomment-614826740",
        "FeedbackMarkdown": "Some notes:\r\n\r\n* Right now \u0060OSPlatform\u0060 compares \u0060Ordinal\u0060, not \u0060OrdinalIgnoreCase\u0060. Unfortuantely, the field names don\u0027t match the strings passed to the constructor, which means \u0060nameof(OSPlaform.Windows)\u0060 and \u0060OSPlatform.Windows.ToString()\u0060 return different values. We should make the comparisons \u0060OrdinalIgnoreCase\u0060.\r\n* We shouldn\u0027t add \u0060macOS\u0060 and reuse \u0060OSX\u0060\r\n* We should allow multiple attributes to be applied\r\n* Maybe we should move \u0060Url\u0060 to \u0060OSPlatformVersionAttribute\u0060?",
        "TimeCode": 28360000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34978,
          "Title": "\u0060InitOnlyAttribute\u0060",
          "Author": "jcouv",
          "CreatedAt": "2020-04-15T00:08:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34978",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614845405",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34978#issuecomment-614845405",
        "FeedbackMarkdown": "* Seems like we should think about how reflections work with this feature\r\n    - Reflection doesn\u0027t honor \u0060modreq.\r\n    - Should we have a reflection feature for init only? It would construct, init, and call the validator. \u0060PropertyInfo.SetValue\u0060 could block setting init only.\r\n* Serializers probably need to handle \u0060init\u0060 setters (as in, they shoud be able to call them)\r\n* ModReqs and ModOpts are usually plain marker types, not attributes. The reason this was made an attribute was to make reflection easier, but it seems we should have a reflection API anyway in which case it doesn\u0027t matter. We should be consistent with existing modifier types and not derive from attribute.\r\n* We should prefix it with \u0060Is\u0060 to be consistent with the other modifier types\r\n* It was asked whether it only applies to properties and the answer is no, it might apply to fields and methods in the future, so the name should be generic\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public sealed class IsInitOnly\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54850000000,
        "Apis": [
          "T:IsInitOnly"
        ]
      }
    ]
  },
  {
    "Id": 91,
    "Date": "2020-04-23T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=1GkjoDSR7dE",
      "Id": "1GkjoDSR7dE",
      "StartDateTime": "2020-04-23T10:00:16-07:00",
      "EndDateTime": "2020-04-23T12:17:23-07:00",
      "Duration": 82270000000,
      "Title": ".NET Design Review: GitHub Quick Reviews (Apr 23)",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1GkjoDSR7dE/mqdefault.jpg"
    },
    "Title": "Meta, System.Runtime, System.Runtime.CompilerServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33861,
          "Title": "Add DynamicallyAccessedMembersAttribute",
          "Author": "MichalStrehovsky",
          "CreatedAt": "2020-03-20T14:32:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33861",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "linkable-framework",
              "BackgroundColor": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618548274",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33861#issuecomment-618548274",
        "FeedbackMarkdown": "* What about \u0060MetadataLoadContext\u0060?\r\n\t- Will need to make use of supressions, there is a separate attribute for that\r\n* It feels the defaults are flipped\r\n\t- We should have \u0060PublicMethods\u0060 and \u0060NonPublicMethods\u0060 to make it clear what\u0027s being returned\r\n\t- The semantics should match \u0060BindingFlags\u0060\r\n* Are attributes kept?\r\n\t- Depends, but there is a discussion on trimming those too\r\n* Should the enum have an \u0022All\u0022 member?\r\n* We should have a \u0060None\u0060 member with value \u00600\u0060\r\n* We should make sure the attribute can only be applied once is not inherited\r\n* The linker tooling should warn if the attribute is applied to things that aren\u0027t \u0060System.Type\u0060 or \u0060System.String\u0060, the linker should warn\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(\r\n        AttributeTargets.Field |\r\n        AttributeTargets.ReturnValue |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property)]\r\n    public sealed class DynamicallyAccessedMembersAttribute : Attribute\r\n    {\r\n        public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberKinds memberKinds)\r\n        {\r\n            MemberKinds = memberKinds;\r\n        }\r\n\r\n        public DynamicallyAccessedMemberKinds MemberKinds { get; }\r\n    }\r\n\r\n    [Flags]\r\n    public enum DynamicallyAccessedMemberKinds\r\n    {\r\n        DefaultConstructor  = 0b00000000_00000001,\r\n        PublicConstructors  = 0b00000000_00000011,\r\n        Constructors        = 0b00000000_00000111,\r\n        PublicMethods       = 0b00000000_00001000,\r\n        Methods             = 0b00000000_00011000,\r\n        PublicFields        = 0b00000000_00100000,\r\n        Fields              = 0b00000000_01100000,\r\n        PublicNestedTypes   = 0b00000000_10000000,\r\n        NestedTypes         = 0b00000001_10000000,\r\n        PublicProperties    = 0b00000010_00000000,\r\n        Properties          = 0b00000110_00000000,\r\n        PublicEvents        = 0b00001000_00000000,\r\n        Events              = 0b00011000_00000000,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:DynamicallyAccessedMemberKinds.Constructors",
          "F:DynamicallyAccessedMemberKinds.DefaultConstructor",
          "F:DynamicallyAccessedMemberKinds.Events",
          "F:DynamicallyAccessedMemberKinds.Fields",
          "F:DynamicallyAccessedMemberKinds.Methods",
          "F:DynamicallyAccessedMemberKinds.NestedTypes",
          "F:DynamicallyAccessedMemberKinds.Properties",
          "F:DynamicallyAccessedMemberKinds.PublicConstructors",
          "F:DynamicallyAccessedMemberKinds.PublicEvents",
          "F:DynamicallyAccessedMemberKinds.PublicFields",
          "F:DynamicallyAccessedMemberKinds.PublicMethods",
          "F:DynamicallyAccessedMemberKinds.PublicNestedTypes",
          "F:DynamicallyAccessedMemberKinds.PublicProperties",
          "M:DynamicallyAccessedMembersAttribute.DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberKinds)",
          "P:DynamicallyAccessedMembersAttribute.MemberKinds",
          "T:DynamicallyAccessedMemberKinds",
          "T:DynamicallyAccessedMembersAttribute"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35339,
          "Title": "Add SuppressLinkerWarningAttribute",
          "Author": "MichalStrehovsky",
          "CreatedAt": "2020-04-23T14:23:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35339",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "linkable-framework",
              "BackgroundColor": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework",
              "ForegroundColor": "black"
            },
            {
              "Name": "untriaged",
              "BackgroundColor": "fbca04",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618570506",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35339#issuecomment-618570506",
        "FeedbackMarkdown": "* We should position it as a peer to \u0060SuppressMessageAttribute\u0060, \u0060UnconditionalSuppressMessageAttribute\u0060\r\n* It should be \u0060System.Diagnostics.CodeAnalysis\u0060\r\n* The behavior is the same, except it\u0027s not marked \u0060[Conditonal]\u0060 and thus will always remain in metadata \r\n* We considered establishing an inheritance relationshop with \u0060SuppressMessageAttribute\u0060 but concluded we don\u0027t need it (neither for docs nor for consumption)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]\r\n    public sealed class UnconditionalSuppressMessageAttribute : Attribute\r\n    {\r\n    \t// Same API as SuppressMessageAttribute\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28950000000,
        "Apis": [
          "T:UnconditionalSuppressMessageAttribute"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30902,
          "Title": "Consider PreserveDependencyAttribute to help linker",
          "Author": "stephentoub",
          "CreatedAt": "2019-09-19T16:08:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30902",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "linkable-framework",
              "BackgroundColor": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618601805",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30902#issuecomment-618601805",
        "FeedbackMarkdown": "* It seems wild cards are also supported, which raises a few questions:\r\n\t- Does it include private and public APIs or just public?\r\n\t- How hard is it for upstream dependencies to implement (e.g. ILSpy or VS Find All Usages)\r\n\t- Do we need them? We\u0027d like because it seems [there are places](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Linq.Expressions/src/System/Runtime/CompilerServices/CallSite.cs#L278-L319) where we have a lot.\r\n* The linker should at least warn when the strings can\u0027t be matched\r\n* \u0060typeName\u0060 and \u0060assemblyName\u0060 are optional because they default to same and same assembly\r\n* Looks like \u0060memberSignature\u0060 should be non-nullable\r\n* Condition is some specific string that is interpreted by the linker, today that\u0027s only \u0060DEBUG\u0060 (which unfortunately doesn\u0027t map to the C# notion of compiling a debug build)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.Method |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Field,\r\n                    AllowMultiple = true,\r\n                    Inherited = false)]\r\n    public sealed class DynamicDependencyAttribute : Attribute\r\n    {\r\n        public DynamicDependencyAttribute(string memberSignature);\r\n        public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);\r\n        public DynamicDependencyAttribute(DynamicallyAccessedMemberKinds memberKinds, string typeName, string assemblyName);\r\n\r\n        public DynamicDependencyAttribute(string memberSignature, Type type);\r\n        public DynamicDependencyAttribute(DynamicallyAccessedMemberKinds memberKinds, Type type);\r\n\r\n        public DynamicallyAccessedMemberKinds? MemberKinds { get; }\r\n        public string? MemberSignature { get; }\r\n        public string? TypeName { get; }\r\n        public string? AssemblyName { get; }\r\n        public string? Condition { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50620000000,
        "Apis": [
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(DynamicallyAccessedMemberKinds,string,string)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(DynamicallyAccessedMemberKinds,Type)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string,string,string)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string,Type)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string)",
          "P:DynamicDependencyAttribute.AssemblyName",
          "P:DynamicDependencyAttribute.Condition",
          "P:DynamicDependencyAttribute.MemberKinds",
          "P:DynamicDependencyAttribute.MemberSignature",
          "P:DynamicDependencyAttribute.TypeName",
          "T:DynamicDependencyAttribute"
        ]
      }
    ]
  },
  {
    "Id": 92,
    "Date": "2020-05-05T00:00:00-07:00",
    "Video": null,
    "Title": "System.Runtime.Intrinsics",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34587,
          "Title": "Add empty X64/Arm64 nested classes to some System.Runtime.Intrinsics",
          "Author": "EgorBo",
          "CreatedAt": "2020-04-06T14:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34587",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "breaking-change",
              "BackgroundColor": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease.",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624197774",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34587#issuecomment-624197774",
        "FeedbackMarkdown": "* The problem makes sense, but instead of giving \u0060IsSupported\u0060 behavior, it might be better to hide the nested classes entirely and make calling \u0060IsSupported\u0060 a compile-time error:\r\n\r\n\u0060\u0060\u0060C#\r\n    partial class Sha1 : ArmBase\r\n    {\r\n        [EditorBrowsable(Never)]\r\n        public abstract class Arm64            \r\n        {\r\n            // No inheritance, no IsSupported\r\n        }\r\n    }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:Sha1",
          "T:Sha1.Arm64"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34929,
          "Title": "Consider adding Vector64\u003Cdouble\u003E.CreateScalar, Vector64\u003Culong\u003ECreateScalar and Vector64\u003Clong\u003E.CreateScalar or renaming Create",
          "Author": "echesakovMSFT",
          "CreatedAt": "2020-04-14T00:24:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34929",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624200505",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34929#issuecomment-624200505",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public partial class Vector64\r\n    {\r\n        public static unsafe Vector64\u003Cdouble\u003E CreateScalar(double value);\r\n        public static unsafe Vector64\u003Clong\u003E   CreateScalar(long value);\r\n        public static unsafe Vector64\u003Culong\u003E  CreateScalar(ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Vector64.CreateScalar(double)",
          "M:Vector64.CreateScalar(long)",
          "M:Vector64.CreateScalar(ulong)",
          "T:Vector64"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35037,
          "Title": "[Arm64] \u0022Move\u0022 Intrinsics",
          "Author": "tannergooding",
          "CreatedAt": "2020-04-16T02:04:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35037",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624211066",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35037#issuecomment-624211066",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* Should there be an \u0060InsertSelectedScalar\u0060 that returns \u0060Vector64\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Duplicate general-purpose register to vector\r\n        /// For each element result[elem] = value\r\n        /// Corresponds to vector forms of DUP and VDUP\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E    DuplicateToVector64(byte value);\r\n        Vector64\u003Cshort\u003E   DuplicateToVector64(short value);\r\n        Vector64\u003Cint\u003E     DuplicateToVector64(int value);\r\n        Vector64\u003Csbyte\u003E   DuplicateToVector64(sbyte value);\r\n        Vector64\u003Cushort\u003E  DuplicateToVector64(ushort value);\r\n        Vector64\u003Cuint\u003E    DuplicateToVector64(uint value);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateToVector128(byte value);\r\n        Vector128\u003Cshort\u003E  DuplicateToVector128(short value);\r\n        Vector128\u003Cint\u003E    DuplicateToVector128(int value);\r\n        Vector128\u003Csbyte\u003E  DuplicateToVector128(sbyte value);\r\n        Vector128\u003Cushort\u003E DuplicateToVector128(ushort value);\r\n        Vector128\u003Cuint\u003E   DuplicateToVector128(uint value);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Duplicate vector element to vector\r\n        /// For each element result[elem] = value[index]\r\n        /// Corresponds to vector forms of DUP and VDUP\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E    DuplicateSelectedScalarToVector64(Vector64\u003Cbyte\u003E value,     byte index);\r\n        Vector64\u003Cshort\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Cshort\u003E value,    byte index);\r\n        Vector64\u003Cint\u003E     DuplicateSelectedScalarToVector64(Vector64\u003Cint\u003E value,      byte index);\r\n        Vector64\u003Cfloat\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Cfloat\u003E value,    byte index);\r\n        Vector64\u003Csbyte\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Csbyte\u003E value,    byte index);\r\n        Vector64\u003Cushort\u003E  DuplicateSelectedScalarToVector64(Vector64\u003Cushort\u003E value,   byte index);\r\n        Vector64\u003Cuint\u003E    DuplicateSelectedScalarToVector64(Vector64\u003Cuint\u003E value,     byte index);\r\n\r\n        Vector64\u003Cbyte\u003E    DuplicateSelectedScalarToVector64(Vector128\u003Cbyte\u003E value,     byte index);\r\n        Vector64\u003Cshort\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Cshort\u003E value,    byte index);\r\n        Vector64\u003Cint\u003E     DuplicateSelectedScalarToVector64(Vector128\u003Cint\u003E value,      byte index);\r\n        Vector64\u003Cfloat\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Cfloat\u003E value,    byte index);\r\n        Vector64\u003Csbyte\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Csbyte\u003E value,    byte index);\r\n        Vector64\u003Cushort\u003E  DuplicateSelectedScalarToVector64(Vector128\u003Cushort\u003E value,   byte index);\r\n        Vector64\u003Cuint\u003E    DuplicateSelectedScalarToVector64(Vector128\u003Cuint\u003E value,     byte index);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateSelectedScalarToVector128(Vector64\u003Cbyte\u003E value,    byte index);\r\n        Vector128\u003Cshort\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Cshort\u003E value,   byte index);\r\n        Vector128\u003Cint\u003E    DuplicateSelectedScalarToVector128(Vector64\u003Cint\u003E value,     byte index);\r\n        Vector128\u003Cfloat\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Cfloat\u003E value,   byte index);\r\n        Vector128\u003Csbyte\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Csbyte\u003E value,   byte index);\r\n        Vector128\u003Cushort\u003E DuplicateSelectedScalarToVector128(Vector64\u003Cushort\u003E value,  byte index);\r\n        Vector128\u003Cuint\u003E   DuplicateSelectedScalarToVector128(Vector64\u003Cuint\u003E value,    byte index);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Cbyte\u003E value,   byte index);\r\n        Vector128\u003Cdouble\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cdouble\u003E value, byte index);\r\n        Vector128\u003Cshort\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Cshort\u003E value,  byte index);\r\n        Vector128\u003Cint\u003E    DuplicateSelectedScalarToVector128(Vector128\u003Cint\u003E value,    byte index);\r\n        Vector128\u003Clong\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Clong\u003E value,   byte index);\r\n        Vector128\u003Cfloat\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Cfloat\u003E value,  byte index);\r\n        Vector128\u003Csbyte\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Csbyte\u003E value,  byte index);\r\n        Vector128\u003Cushort\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cushort\u003E value, byte index);\r\n        Vector128\u003Cuint\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Cuint\u003E value,   byte index);\r\n        Vector128\u003Culong\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Culong\u003E value,  byte index);\r\n\r\n        public abstract class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Duplicate general-purpose register to vector\r\n            /// For each element result[elem] = value\r\n            /// Corresponds to vector forms of DUP\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Clong\u003E   DuplicateToVector64(long value);\r\n            Vector128\u003Culong\u003E  DuplicateToVector64(ulong value);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Insert vector element from another vector element\r\n            /// result[resultIndex] = value[valueIndex]\r\n            /// Corresponds to vector forms of INS\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E   InsertSelectedScalar(Vector128\u003Cbyte\u003E result,   byte resultIndex, Vector64\u003Cbyte\u003E value,    byte valueIndex);\r\n            Vector128\u003Cshort\u003E  InsertSelectedScalar(Vector128\u003Cshort\u003E result,  byte resultIndex, Vector64\u003Cshort\u003E value,   byte valueIndex);\r\n            Vector128\u003Cint\u003E    InsertSelectedScalar(Vector128\u003Cint\u003E result,    byte resultIndex, Vector64\u003Cint\u003E value,     byte valueIndex);\r\n            Vector128\u003Cfloat\u003E  InsertSelectedScalar(Vector128\u003Cfloat\u003E result,  byte resultIndex, Vector64\u003Cfloat\u003E value,   byte valueIndex);\r\n            Vector128\u003Csbyte\u003E  InsertSelectedScalar(Vector128\u003Csbyte\u003E result,  byte resultIndex, Vector64\u003Csbyte\u003E value,   byte valueIndex);\r\n            Vector128\u003Cushort\u003E InsertSelectedScalar(Vector128\u003Cushort\u003E result, byte resultIndex, Vector64\u003Cushort\u003E value,  byte valueIndex);\r\n            Vector128\u003Cuint\u003E   InsertSelectedScalar(Vector128\u003Cuint\u003E result,   byte resultIndex, Vector64\u003Cuint\u003E value,    byte valueIndex);\r\n\r\n            Vector128\u003Cbyte\u003E   InsertSelectedScalar(Vector128\u003Cbyte\u003E result,   byte resultIndex, Vector128\u003Cbyte\u003E value,   byte valueIndex);\r\n            Vector128\u003Cdouble\u003E InsertSelectedScalar(Vector128\u003Cdouble\u003E result, byte resultIndex, Vector128\u003Cdouble\u003E value, byte valueIndex);\r\n            Vector128\u003Cshort\u003E  InsertSelectedScalar(Vector128\u003Cshort\u003E result,  byte resultIndex, Vector128\u003Cshort\u003E value,  byte valueIndex);\r\n            Vector128\u003Cint\u003E    InsertSelectedScalar(Vector128\u003Cint\u003E result,    byte resultIndex, Vector128\u003Cint\u003E value,    byte valueIndex);\r\n            Vector128\u003Clong\u003E   InsertSelectedScalar(Vector128\u003Clong\u003E result,   byte resultIndex, Vector128\u003Clong\u003E value,   byte valueIndex);\r\n            Vector128\u003Cfloat\u003E  InsertSelectedScalar(Vector128\u003Cfloat\u003E result,  byte resultIndex, Vector128\u003Cfloat\u003E value,  byte valueIndex);\r\n            Vector128\u003Csbyte\u003E  InsertSelectedScalar(Vector128\u003Csbyte\u003E result,  byte resultIndex, Vector128\u003Csbyte\u003E value,  byte valueIndex);\r\n            Vector128\u003Cushort\u003E InsertSelectedScalar(Vector128\u003Cushort\u003E result, byte resultIndex, Vector128\u003Cushort\u003E value, byte valueIndex);\r\n            Vector128\u003Cuint\u003E   InsertSelectedScalar(Vector128\u003Cuint\u003E result,   byte resultIndex, Vector128\u003Cuint\u003E value,   byte valueIndex);\r\n            Vector128\u003Culong\u003E  InsertSelectedScalar(Vector128\u003Culong\u003E result,  byte resultIndex, Vector128\u003Culong\u003E value,  byte valueIndex);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.DuplicateToVector64(long)",
          "M:AdvSimd.Arm64.DuplicateToVector64(ulong)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cbyte\u003E,byte,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cbyte\u003E,byte,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cdouble\u003E,byte,Vector128\u003Cdouble\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cfloat\u003E,byte,Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cfloat\u003E,byte,Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cint\u003E,byte,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cint\u003E,byte,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Clong\u003E,byte,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Csbyte\u003E,byte,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Csbyte\u003E,byte,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cshort\u003E,byte,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cshort\u003E,byte,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cuint\u003E,byte,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cuint\u003E,byte,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Culong\u003E,byte,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cushort\u003E,byte,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cushort\u003E,byte,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cdouble\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateToVector128(byte)",
          "M:AdvSimd.DuplicateToVector128(int)",
          "M:AdvSimd.DuplicateToVector128(sbyte)",
          "M:AdvSimd.DuplicateToVector128(short)",
          "M:AdvSimd.DuplicateToVector128(uint)",
          "M:AdvSimd.DuplicateToVector128(ushort)",
          "M:AdvSimd.DuplicateToVector64(byte)",
          "M:AdvSimd.DuplicateToVector64(int)",
          "M:AdvSimd.DuplicateToVector64(sbyte)",
          "M:AdvSimd.DuplicateToVector64(short)",
          "M:AdvSimd.DuplicateToVector64(uint)",
          "M:AdvSimd.DuplicateToVector64(ushort)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33398,
          "Title": "ARM additional shifting intrinsics",
          "Author": "tannergooding",
          "CreatedAt": "2020-03-09T19:45:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33398",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624242885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33398#issuecomment-624242885",
        "FeedbackMarkdown": "* We should rename the \u0060shift\u0060 parameter to \u0060count\u0060\r\n* What happens when the vector-based counts are too large?\r\n* Some of the upper variants under \u0060Arm64\u0060 seem to belong to \u0060AdvSimd\u0060\r\n* Do we need \u0060SignExtendAndWidenLower\u0060, \u0060ZeroExtendAndWidenLower\u0060, \u0060SignExtendAndWidenUpper\u0060, SignExtendAndWidenUpper\u0060 at all?\r\n    - If we expose them, we need to drop the \u0060count\u0060 parameter\r\n* Should we change the encoding of methods and instead of making up Markov-chain-like method names take arguments (e.g. \u0060bool round\u0060 or \u0060SomeFlags flags\u0060)? The concern is metadata size.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of USHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogical(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogical(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogical(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogical(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogical(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogical(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogical(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogical(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogical(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogical(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogical(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogical(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogical(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogical(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of URSHL and VRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalRounded(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalRounded(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalRounded(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalRounded(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalRounded(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalRounded(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalRounded(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalRounded(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalRounded(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalRounded(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalRounded(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalRounded(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalRounded(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalRounded(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalRoundedScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalRoundedScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SSHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmetic(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmetic(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmetic(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmetic(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmetic(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmetic(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmetic(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SRSHL and VRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticRounded(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticRounded(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticRounded(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticRounded(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticRounded(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticRounded(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticRounded(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticRoundedScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of UQSHL and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalSaturate(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalSaturate(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalSaturate(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalSaturate(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalSaturate(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalSaturate(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalSaturate(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalSaturateScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of UQRSHL and VQRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalRoundedSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalRoundedSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalRoundedSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalRoundedSaturate(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SQSHL and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SQRSHL and VQRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Left Immediate\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogical(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftLeftLogical(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftLeftLogical(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogical(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftLeftLogical(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogical(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogical(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftLeftLogical(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftLeftLogical(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogical(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogical(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogical(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogical(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogical(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLeftLogicalScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Right Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of USHR and VSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogical(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogical(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogical(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogical(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogical(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogical(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogical(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogical(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogical(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogical(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogical(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogical(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogical(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogical(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Right Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of URSHR and VRSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalRounded(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalRounded(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalRounded(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalRounded(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalRounded(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalRounded(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalRounded(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalRounded(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalRounded(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalRounded(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalRounded(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalRounded(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalRounded(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalRounded(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalRoundedScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalRoundedScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Right Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SSHR and VSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmetic(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmetic(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmetic(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmetic(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmetic(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmetic(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmetic(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Right Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of SRSHR and VRSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticRounded(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticRounded(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticRounded(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticRounded(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticRounded(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticRounded(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticRounded(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticRoundedScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E shift)\r\n        /// Corresponds to vector forms of USRA and VSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAdd(Vector64\u003Cbyte\u003E addend, Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAdd(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAdd(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAdd(Vector64\u003Cushort\u003E addend, Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAdd(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAdd(Vector64\u003Cuint\u003E addend, Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalAdd(Vector128\u003Cbyte\u003E addend, Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalAdd(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalAdd(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalAdd(Vector128\u003Cuint\u003E addend, Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalAdd(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalAdd(Vector128\u003Culong\u003E addend, Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalAddScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalAddScalar(Vector64\u003Culong\u003E addend, Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E shift)\r\n        /// Corresponds to vector forms of SSRA and VSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAdd(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAdd(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAdd(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticAdd(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticAdd(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticAdd(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticAddScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E RoundedShift)\r\n        /// Corresponds to vector forms of URSRA and VRSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAddRounded(Vector64\u003Cbyte\u003E addend, Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAddRounded(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAddRounded(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAddRounded(Vector64\u003Cushort\u003E addend, Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAddRounded(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAddRounded(Vector64\u003Cuint\u003E addend, Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalAddRounded(Vector128\u003Cbyte\u003E addend, Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalAddRounded(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalAddRounded(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalAddRounded(Vector128\u003Cushort\u003E addend, Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalAddRounded(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalAddRounded(Vector128\u003Cuint\u003E addend, Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalAddRounded(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalAddRounded(Vector128\u003Culong\u003E addend, Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalAddRoundedScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalAddRoundedScalar(Vector64\u003Culong\u003E addend, Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E RoundedShift)\r\n        /// Corresponds to vector forms of SRSRA and VRSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAddRounded(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAddRounded(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAddRounded(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticAddRounded(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticAddRounded(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticAddRounded(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticAddRounded(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticAddRoundedScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left and Unsigned Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SQSHL, UQSHL, and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogicalSaturate(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftLeftLogicalSaturate(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftLeftLogicalSaturate(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogicalSaturate(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogicalSaturate(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftLeftLogicalSaturate(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftLeftLogicalSaturate(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalSaturate(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogicalSaturate(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalSaturate(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLeftLogicalSaturateScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalSaturateScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left Unsigned\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SQSHLU and VQSHLU\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalSaturateUnsignedScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SHRN and VSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Rounding Shift Right Narrow Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of RSHRN and VRSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Left Long\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SHLL and VSHLL\r\n        /// \u003C/summary\u003E\r\n        Vector128\u003Cshort\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cuint\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of UQSHRN and VQSHRUN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Rounded Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of UQRSHRN and VQRSHRUN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SQSHRN and VQSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Rounded Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SQRSHRN and VQRSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        public abstract class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SQRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SQSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticRoundedScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticRoundedScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticRoundedScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of UQRSHL and VQRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of UQSHL and VQSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalSaturateScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalSaturateScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalSaturateScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of URSHL and VRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalRoundedScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalRoundedScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalRoundedScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalRoundedScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalRoundedScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalRoundedScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of USHL and VSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SXTL\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E SignExtendAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E SignExtendAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E SignExtendAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of UXTL\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ZeroExtendAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ZeroExtendAndWidenLower(Vector64\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ZeroExtendAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ZeroExtendAndWidenLower(Vector64\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ZeroExtendAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ZeroExtendAndWidenLower(Vector64\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRUN\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector64\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n            Vector64\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRUN\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector64\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n            Vector64\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Rounding Shift Right Narrow Immediate\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n            /// Corresponds to vector forms of RSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Shift Left Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SHLL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SXTL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E SignExtendAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E SignExtendAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E SignExtendAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of UXTL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ZeroExtendAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ZeroExtendAndWidenUpper(Vector128\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ZeroExtendAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ZeroExtendAndWidenUpper(Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ZeroExtendAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ZeroExtendAndWidenUpper(Vector128\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of UQSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Rounded Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of UQRSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRUN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRUN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsignedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturateScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturateScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRoundedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRoundedScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalScalar(Vector64\u003Culong\u003E,byte)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      }
    ]
  },
  {
    "Id": 93,
    "Date": "2020-05-07T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=CmF8g030Hno",
      "Id": "CmF8g030Hno",
      "StartDateTime": "2020-05-07T10:11:03-07:00",
      "EndDateTime": "2020-05-07T12:12:21-07:00",
      "Duration": 72780000000,
      "Title": ".NET Design Review: AsnReader/Writer update",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CmF8g030Hno/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35649,
          "Title": "Extend default value handling in JsonSerializer",
          "Author": "layomia",
          "CreatedAt": "2020-04-30T03:47:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35649",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-07T00:00:00-07:00",
        "FeedbackId": "625418116",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35649#issuecomment-625418116",
        "FeedbackMarkdown": "* Looks great. Only suggestion is to change \u0060WhenWritingDefaultValues\u0060 to \u0060WhenWritingDefault\u0060.\r\n* \u0060JsonSerializerOptions.DefaultIgnoreCondition\u0060 should throw \u0060ArgumentException\u0060 rather than \u0060InvalidOperationException\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public enum JsonIgnoreCondition\r\n    {\r\n        Never = 0,\r\n        Always = 1,\r\n        WhenWritingDefault = 2\r\n    }    \r\n}\r\n\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public JsonIgnoreCondition DefaultIgnoreCondition { get; set; } = JsonIgnoreCondition.Never;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:JsonIgnoreCondition.Always",
          "F:JsonIgnoreCondition.Never",
          "F:JsonIgnoreCondition.WhenWritingDefault",
          "P:JsonSerializerOptions.DefaultIgnoreCondition",
          "T:JsonIgnoreCondition",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30820,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-07T00:00:00-07:00",
        "FeedbackId": "625444164",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30820#issuecomment-625444164",
        "FeedbackMarkdown": "* The problem with taking a func is that people might accidentally close over a local variable that now becomes a static. Since the resolver is supposed to hold a dictionary this might result in two errors: (1) concurrency issues when multiple threads serialize and (2) a memory leak because the dictionary gets never eligible for GC6\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public ReferenceHandler ReferenceHandler { get; set; }\r\n    }\r\n    public abstract class ReferenceHandler\r\n    {\r\n        public static ReferenceHandler Default { get; }\r\n        public static ReferenceHandler Preserve { get; }\r\n        public abstract ReferenceResolver CreateResolver();\r\n    }\r\n    public sealed partial class ReferenceHandler\u003CT\u003E : ReferenceHandler\r\n        where T: ReferenceResolver, new()\r\n    {\r\n        public override ReferenceResolver CreateResolver() =\u003E new T();\r\n    }\r\n    public abstract class ReferenceResolver\r\n    {\r\n        public abstract void AddReference(string referenceId, object value);\r\n        public abstract string GetReference(object value, out bool alreadyExists);\r\n        public abstract object ResolveReference(string referenceId);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40280000000,
        "Apis": [
          "M:ReferenceHandler.CreateResolver()",
          "M:ReferenceHandler\u003CT\u003E.CreateResolver()",
          "M:ReferenceResolver.AddReference(string,object)",
          "M:ReferenceResolver.GetReference(object,out bool)",
          "M:ReferenceResolver.ResolveReference(string)",
          "P:JsonSerializerOptions.ReferenceHandler",
          "P:ReferenceHandler.Default",
          "P:ReferenceHandler.Preserve",
          "T:JsonSerializerOptions",
          "T:ReferenceHandler",
          "T:ReferenceHandler\u003CT\u003E",
          "T:ReferenceResolver"
        ]
      }
    ]
  },
  {
    "Id": 94,
    "Date": "2020-05-26T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=I7whBbUrMcc",
      "Id": "I7whBbUrMcc",
      "StartDateTime": "2020-05-26T10:02:41-07:00",
      "EndDateTime": "2020-05-26T12:06:04-07:00",
      "Duration": 74030000000,
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/I7whBbUrMcc/mqdefault.jpg"
    },
    "Title": "Extensions-Logging, System.Runtime, System.Text.Encoding",
    "Items": [
      {
        "Id": 1,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35315,
          "Title": "RequireMethodImplToRemainInEffectAttribute",
          "Author": "fadimounir",
          "CreatedAt": "2020-04-22T23:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35315",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634163634",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35315#issuecomment-634163634",
        "FeedbackMarkdown": "A few questions:\r\n\r\n* We\u0027re not entirely sure what this attribute does:\r\n\t- The issue talks about covariant returns but all samples use \u0060void\u0060\r\n\t- None of the methdos use \u0060virtual\u0060 functions\r\n\t- What are the behavior differences of with and without the attribute? If this can\u0027t be expressed in C#, then ILDASM code would help too\r\n* \u0060RequireMethodImplToRemainInEffectAttribute\u0060 this name seems a bit abstract. Can make this a bit clearer, like \u0060PreserveBaseOverridesAttribute\u0060?\r\n* Does it have to be a new attribute or could be a new flag on \u0060MethodImplAttributes\u0060?\r\n* How does this attribute play with default interface methods?\r\n* How does this play with versioning where overrides are added to the middle of the hierarchy later?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34305,
          "Title": "Add activity Ids and Context to all logs ",
          "Author": "tarekgh",
          "CreatedAt": "2019-11-02T00:13:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34305",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Logging",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634181323",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34305#issuecomment-634181323",
        "FeedbackMarkdown": "* We should remove \u0060ActivityTrackingOptions.Default\u0060 because we can\u0027t change its value ever. Instead, we should just set the value in the \u0060LoggerFactoryOptions\u0060 contructor\r\n* We should make sure that default parameters in constructors are part of the spec that 3rd party DI containers have to support\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [Flags]\r\n    public enum ActivityTrackingOptions\r\n    {\r\n        None        = 0x0000,\r\n        SpanId      = 0x0001,\r\n        TraceId     = 0x0002,\r\n        ParentId    = 0x0004,\r\n        TraceState  = 0x0008,\r\n        TraceFlags  = 0x0010\r\n    }\r\n    public class LoggerFactoryOptions\r\n    {\r\n        public LoggerFactoryOptions();\r\n        public ActivityTrackingOptions ActivityTrackingOptions  { get; set; }\r\n    }\r\n    public partial class LoggerFactory\r\n    {\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers,\r\n                             IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption,\r\n                             IOptions\u003CLoggerFactoryOptions\u003E options = null);\r\n    }\r\n    public static partial class LoggingBuilderExtensions\r\n    {\r\n        public static ILoggingBuilder Configure(this ILoggingBuilder builder,\r\n                                                Action\u003CLoggerFactoryOptions\u003E action);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12700000000,
        "Apis": [
          "F:ActivityTrackingOptions.None",
          "F:ActivityTrackingOptions.ParentId",
          "F:ActivityTrackingOptions.SpanId",
          "F:ActivityTrackingOptions.TraceFlags",
          "F:ActivityTrackingOptions.TraceId",
          "F:ActivityTrackingOptions.TraceState",
          "M:LoggerFactory.LoggerFactory(IEnumerable\u003CILoggerProvider\u003E,IOptionsMonitor\u003CLoggerFilterOptions\u003E,IOptions\u003CLoggerFactoryOptions\u003E)",
          "M:LoggerFactoryOptions.LoggerFactoryOptions()",
          "M:LoggingBuilderExtensions.Configure(this ILoggingBuilder,Action\u003CLoggerFactoryOptions\u003E)",
          "P:LoggerFactoryOptions.ActivityTrackingOptions",
          "T:ActivityTrackingOptions",
          "T:LoggerFactory",
          "T:LoggerFactoryOptions",
          "T:LoggingBuilderExtensions"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 25819,
          "Title": "Add a GetEncodings method to System.Text.EncodingProvider to support enumerating available character encodings",
          "Author": "mklement0",
          "CreatedAt": "2018-04-09T20:59:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encoding",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634199380",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/25819#issuecomment-634199380",
        "FeedbackMarkdown": "* \u0060EncodingProvider.GetEncodings()\u0060 should be \u0060IEnumerable\u003CEncodingInfo\u003E\u0060\r\n* \u0060EncodingProvider.GetEncodings()\u0060 should be virtual and return an \u0060Enumerable.Empty\u003CEncodingInfo\u003E()\u0060 (instead of throwing). While this isn\u0027t correct it means that one provider that isn\u0027t updated doesn\u0027t spoil the enumeration for everyone else.\r\n* \u0060Encoding.GetEncodings()\u0060 should return all registered encodings across all providers and de-dupe them if necessary.\r\n* \u0060EncodingInfo.GetEncoding()\u0060 calls the static \u0060Encoding.GetEncoding()\u0060 method, which means getting encoding infos and using \u0060EncodingInfo.GetEncoding()\u0060 might create an encoding that isn\u0027t tied to that encoding provider.\r\n    - \u0060EncodingInfo\u0060 should take an \u0060EncodingProvider\u0060 that we\u0027ll use in \u0060EncodingInfo.GetEncoding()\u0060 and call \u0060EncodingProvider.GetEncoding(codePage)\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class EncodingProvider\r\n    {\r\n        public virtual IEnumerable\u003CEncodingInfo\u003E GetEncodings();\r\n    }\r\n    \r\n    public partial class EncodingInfo\r\n    {\r\n        public EncodingInfo(EncodingProvider provider, int codePage, string name, string displayName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32980000000,
        "Apis": [
          "M:EncodingInfo.EncodingInfo(EncodingProvider,int,string,string)",
          "M:EncodingProvider.GetEncodings()",
          "T:EncodingInfo",
          "T:EncodingProvider"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31038,
          "Title": "StringSplitOptions.TrimEntries",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-10-02T01:29:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31038",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634204949",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31038#issuecomment-634204949",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    [Flags]\r\n    public enum StringSplitOptions\r\n    {\r\n        // Existing:\r\n        // None = 0,\r\n        //RemoveEmptyEntries = 1,\r\n\r\n        // New:\r\n        TrimEntries = 2\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52180000000,
        "Apis": [
          "F:StringSplitOptions.TrimEntries",
          "T:StringSplitOptions"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31406,
          "Title": "Obsolete RuntimeHelpers.OffsetToStringData",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-11-06T05:43:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31406",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634212546",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31406#issuecomment-634212546",
        "FeedbackMarkdown": "* Looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public sealed class RuntimeHelpers\r\n    {\r\n        [Obsolete(\u0022Use string.GetPinnableReference() instead.\u0022)]\r\n        public static int OffsetToStringData { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58790000000,
        "Apis": [
          "P:RuntimeHelpers.OffsetToStringData",
          "T:RuntimeHelpers"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31549,
          "Title": "expose System.Text.Encoding.Latin1 getter publicly",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-11-22T22:47:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31549",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Encoding",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634217668",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31549#issuecomment-634217668",
        "FeedbackMarkdown": "* Looks good.\r\n* We won\u0027t be exposing the \u0060Latin1Encoding\u0060 type, because it\u0027s not necessary\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class Encoding\r\n    {\r\n        public static Encoding Latin1 =\u003E Encoding.GetEncoding(\u0022iso-8859-1\u0022);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 67430000000,
        "Apis": [
          "P:Encoding.Latin1",
          "T:Encoding"
        ]
      }
    ]
  },
  {
    "Id": 95,
    "Date": "2020-05-29T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=jhibZCgzB9o",
      "Id": "jhibZCgzB9o",
      "StartDateTime": "2020-05-29T10:06:18-07:00",
      "EndDateTime": "2020-05-29T12:05:54-07:00",
      "Duration": 71760000000,
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jhibZCgzB9o/mqdefault.jpg"
    },
    "Title": "Meta, System.Runtime, System.Runtime.CompilerServices, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35315,
          "Title": "RequireMethodImplToRemainInEffectAttribute",
          "Author": "fadimounir",
          "CreatedAt": "2020-04-22T23:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35315",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636093159",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35315#issuecomment-636093159",
        "FeedbackMarkdown": "Let\u0027s go with PreserveBaseOverridesAttribute then.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n    public sealed class PreserveBaseOverridesAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:PreserveBaseOverridesAttribute"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 720,
          "Title": "Use of \u0060EditorBrowsableState.Never\u0060 leads language service to claim it\u0027s gone",
          "Author": "AArnott",
          "CreatedAt": "2019-12-10T04:19:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/720",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636098716",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/720#issuecomment-636098716",
        "FeedbackMarkdown": "\u0060\u0060\u0060diff\r\n public enum ComInterfaceType \r\n { \r\n-    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)] \r\n-    [System.ObsoleteAttribute(\u0022Support for IDispatch may be unavailable in future releases.\u0022)] \r\n     InterfaceIsDual = 0, \r\n     InterfaceIsIUnknown = 1, \r\n-    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)] \r\n-    [System.ObsoleteAttribute(\u0022Support for IDispatch may be unavailable in future releases.\u0022)] \r\n     InterfaceIsIDispatch = 2, \r\n     InterfaceIsIInspectable = 3, \r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 13470000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35749,
          "Title": "ModuleInitializerAttribute",
          "Author": "jnm2",
          "CreatedAt": "2020-05-02T17:19:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35749",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "untriaged",
              "BackgroundColor": "fbca04",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636105051",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35749#issuecomment-636105051",
        "FeedbackMarkdown": "@jaredpar presumably this feature won\u0027t have language syntax. Normally we don\u0027t use \u0060S.R.CompilerServices\u0060 for stuff that developers are expected to use directly. Normally, the namespace is for stuff the compiler generates calls for. However, in this case it seems on par with other very advanced features that we don\u0027t want the general public to use, this feels OK.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\r\n    public sealed class ModuleInitializerAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21080000000,
        "Apis": [
          "T:ModuleInitializerAttribute"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36708,
          "Title": "Allow DynamicallyAccessedMembersAttribute on methods",
          "Author": "vitek-karas",
          "CreatedAt": "2020-05-19T15:59:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36708",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "linkable-framework",
              "BackgroundColor": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework",
              "ForegroundColor": "black"
            },
            {
              "Name": "untriaged",
              "BackgroundColor": "fbca04",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636106955",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36708#issuecomment-636106955",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\r\n\u0060\u0060\u0060diff\r\n [AttributeUsage(\r\n        AttributeTargets.Field |\r\n        AttributeTargets.ReturnValue |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property |\r\n\u002B       AttributeTargets.Method,\r\n        Inherited = false)]\r\n    public sealed class DynamicallyAccessedMembersAttribute : Attribute\r\n    {\r\n    }\r\n\u0060\u0060\u0060",
        "TimeCode": 29590000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36972,
          "Title": "PrincipalPermissionAttribute ctor should be obsolete as error",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2020-05-25T07:31:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36972",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "breaking-change",
              "BackgroundColor": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease.",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636122871",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36972#issuecomment-636122871",
        "FeedbackMarkdown": "* Looks good as proposed, but we should be adding an URL\r\n* We should also provide a fixer(er) with the potential suggestions (apply ASP.NET Core attribute, using the thread\u0027s principal).\r\n* We should consider a generic analyzer that warns on \u0060SecurityAction.Deny\u0060 usage across all attributes\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Permissions\r\n{\r\n    public partial class PrincipalPermissionAttribute\r\n    {\r\n        [Obsolete(\u0022\u003Cmessage goes here\u003E\u0022, error: true, DiagnosticId=\u0022\u003Cdiagnostic ID\u003E\u0022, UrlFormat=\u0022\u003CURL goes here\u003E\u0022)]\r\n        public PrincipalPermissionAttribute(SecurityAction action);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32110000000,
        "Apis": [
          "M:PrincipalPermissionAttribute.PrincipalPermissionAttribute(SecurityAction)",
          "T:PrincipalPermissionAttribute"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 14336,
          "Title": "Use TimeSpan everywhere we use an int for seconds, milliseconds, and timeouts",
          "Author": "briangru",
          "CreatedAt": "2015-03-11T01:39:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14336",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636135854",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/14336#issuecomment-636135854",
        "FeedbackMarkdown": "* We\u0027re happy to approve the first group, i.e. a set of overloads to existing methods where \u0060int\u0060 is replaced with \u0060TimeSpan\u0060.\r\n* We don\u0027t believe properties or using DIMs for interfaces is worth it.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System {\r\n    public static class GC {\r\n\u002B       public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout);\r\n\u002B       public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.ComponentModel.DataAnnotations {\r\n    public class RegularExpressionAttribute {\r\n!       This one might not end up being that useful, since people generally don\u0027t ever manipulate an instance of this attribute.\r\n\u002B       public TimeSpan MatchTimeout { get; }\r\n    }\r\n}\r\n\r\nnamespace System.Diagnostics {\r\n    public class Process {\r\n\u002B       public bool WaitForExit(TimeSpan timeout);\r\n\u002B       public bool WaitForInputIdle(TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.IO {\r\n    public class FileSystemWatcher {\r\n\u002B       public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, TimeSpan timeout);\r\n    }\r\n\r\n    public sealed class NamedPipeClientStream : PipeStream {\r\n\u002B       public void Connect(TimeSpan timeout);\r\n\u002B       public Task ConnectAsync(TimeSpan timeout, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace System.Net.NetworkInformation {\r\n    public class Ping {\r\n\u002B       public PingReply Send(IPAddress address, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null);\r\n\u002B       public PingReply Send(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null);\r\n\r\n!       Skipped EAP based methods; if they are desired, they can be added back in\r\n\r\n!       I added CancellationToken because it is probably worth it. If you don\u0027t want it you can remove it.\r\n\u002B       public Task\u003CPingReply\u003E SendPingAsync(IPAddress address, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null, CancellationToken cancellationToken = default);\r\n\u002B       public Task\u003CPingReply\u003E SendPingAsync(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace System.Net.Sockets {\r\n    public class NetworkStream : Stream {\r\n\u002B       public void Close(TimeSpan timeout);\r\n    }\r\n\r\n    public class Socket {\r\n\u002B       public bool Poll(TimeSpan timeout, SelectMode mode);\r\n\u002B       public static void Select(IList checkRead, IList checkWrite, IList checkError, TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.ServiceProcess {\r\n    public class ServiceBase {\r\n\u002B       public void RequestAdditionalTime(TimeSpan time);\r\n    }\r\n}\r\n\r\nnamespace System.Threading.Tasks {\r\n    public class Task {\r\n\u002B       public bool Wait(TimeSpan timeout, CancellationToken cancellationToken); \r\n    } \r\n} \r\n\r\nnamespace System.Timers {\r\n    public class Timer {\r\n\u002B       public Timer(TimeSpan interval);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51300000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 96,
    "Date": "2020-06-02T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=P1w3Tc7Oyqk",
      "Id": "P1w3Tc7Oyqk",
      "StartDateTime": "2020-06-02T09:55:54-07:00",
      "EndDateTime": "2020-06-02T11:59:48-07:00",
      "Duration": 74340000000,
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/P1w3Tc7Oyqk/mqdefault.jpg"
    },
    "Title": "System.Net.Http, System.Runtime.CompilerServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-wasm",
              "BackgroundColor": "eb6420",
              "Description": "WebAssembly architecture",
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-02T00:00:00-07:00",
        "FeedbackId": "637712249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-637712249",
        "FeedbackMarkdown": "* It doesn\u0027t seem we need the \u0060IHttpRequestOptions\u0060\r\n* We should combine the options with the \u0060Properties\u0060 collection the message\r\n* We don\u0027t believe we need the overloads on \u0060HttpClient\u0060 that take options; it feels like an advanced scenario which people can achieve by constructing the message\r\n* Users can store mismatched types via \u0060IDictionary\u003Cstring, object\u003E\u0060, but we should verify types on retrieval and throw an exception\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class HttpRequestOptions : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Explicit interface implementation\r\n        public bool TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, out TValue value);\r\n        public void Set(HttpRequestOptionsKey\u003CTValue\u003E key, TValue value);\r\n    }\r\n\r\n    public class HttpRequestMessage : IDisposable\r\n    {\r\n        [Obsolete(\u0022Use Options instead.\u0022)]\r\n        public IDictionary\u003Cstring, object\u003E Properties =\u003E Options;\r\n\r\n        public HttpRequestOptions Options { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpRequestOptions.Set(HttpRequestOptionsKey\u003CTValue\u003E,TValue)",
          "M:HttpRequestOptions.TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,out TValue)",
          "P:HttpRequestMessage.Options",
          "P:HttpRequestMessage.Properties",
          "T:HttpRequestMessage",
          "T:HttpRequestOptions"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36654,
          "Title": "IDynamicInterfaceCastable interface",
          "Author": "AaronRobinsonMSFT",
          "CreatedAt": "2020-05-18T15:33:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36654",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-02T00:00:00-07:00",
        "FeedbackId": "637742472",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36654#issuecomment-637742472",
        "FeedbackMarkdown": "* Looks good, but we should make the type name less attractive, such as \u0060IDynamicInterfaceCastable\u0060\r\n* The implementer of \u0060IDynamicInterfaceCastable\u0060 has to abide to the contract of only throwing when \u0060throwIfNotFound\u0060 is \u0060true\u0060 and even then should only throw \u0060InvalidCastException\u0060. However, the runtime doesn\u0027t handle the throwing so that implementers can tweak the message\r\n* However, it is valid for the implementer to return \u0060default\u0060 and the let the runtime throw\r\n* It would be nice if \u0060throwIfNotFound\u0060 would be renamed to indicate whether it\u0027s an \u0060is\u0060/\u0060as\u0060 or a hard cast\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public interface IDynamicInterfaceCastable\r\n    {\r\n        RuntimeTypeHandle GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound);\r\n    }\r\n    [AttributeUsage(AttributeTargets.Interface,\r\n                    AllowMultiple = false,\r\n                    Inherited = false)]\r\n    public sealed class DynamicInterfaceCastableImplementationAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39100000000,
        "Apis": [
          "M:IDynamicInterfaceCastable.GetInterfaceImplementation(RuntimeTypeHandle,bool)",
          "T:DynamicInterfaceCastableImplementationAttribute",
          "T:IDynamicInterfaceCastable"
        ]
      }
    ]
  },
  {
    "Id": 97,
    "Date": "2020-06-04T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=H3obznO9_uo",
      "Id": "H3obznO9_uo",
      "StartDateTime": "2020-06-04T10:02:08-07:00",
      "EndDateTime": "2020-06-04T12:05:04-07:00",
      "Duration": 73760000000,
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/H3obznO9_uo/mqdefault.jpg"
    },
    "Title": "System.Net.Sockets, System.Numerics, System.Runtime, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 14386,
          "Title": "Add overloads to string trimming",
          "Author": "ChrisEelmaa",
          "CreatedAt": "2015-03-25T17:47:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14386",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639002448",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/14386#issuecomment-639002448",
        "FeedbackMarkdown": "We made minor adjustments:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class String\r\n    {\r\n        public string RemoveStart(string value, StringComparison comparisonType);\r\n        public string RemoveEnd(string value, StringComparison comparisonType);\r\n    }\r\n\r\n    public static partial class MemoryExtensions\r\n    {\r\n        public static ReadOnlySpan\u003Cchar\u003E RemoveStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparisonType);\r\n        public static ReadOnlySpan\u003Cchar\u003E RemoveEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparisonType);\r\n    }\r\n}\r\nnamespace System.Globalization\r\n{\r\n     public class CompareInfo\r\n     {\r\n        public Range RemovePrefix(string source, string prefix, CompareOptions options = CompareOptions.None);\r\n        public Range RemovePrefix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E prefix, CompareOptions options = CompareOptions.None);\r\n\r\n        public Range RemoveSuffix(string source, string suffix, CompareOptions options = CompareOptions.None);\r\n        public Range RemoveSuffix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E suffix, CompareOptions options = CompareOptions.None);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CompareInfo.RemovePrefix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions)",
          "M:CompareInfo.RemovePrefix(string,string,CompareOptions)",
          "M:CompareInfo.RemoveSuffix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions)",
          "M:CompareInfo.RemoveSuffix(string,string,CompareOptions)",
          "M:MemoryExtensions.RemoveEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.RemoveStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:String.RemoveEnd(string,StringComparison)",
          "M:String.RemoveStart(string,StringComparison)",
          "T:CompareInfo",
          "T:MemoryExtensions",
          "T:String"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17393,
          "Title": "Non value returning TaskCompletionSource",
          "Author": "benaadams",
          "CreatedAt": "2016-05-24T17:58:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17393",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639004797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17393#issuecomment-639004797",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public class TaskCompletionSource\r\n    {\r\n        public TaskCompletionSource();\r\n        public TaskCompletionSource(object? state);\r\n        public TaskCompletionSource(TaskCreationOptions creationOptions);\r\n        public TaskCompletionSource(object? state, TaskCreationOptions creationOptions);\r\n        public Task Task { get; }\r\n        public void SetCanceled();\r\n        public void SetException(IEnumerable\u003CException\u003E exceptions);\r\n        public void SetException(Exception exception);\r\n        public void SetResult();\r\n        public bool TrySetCanceled();\r\n        public bool TrySetCanceled(CancellationToken cancellationToken);\r\n        public bool TrySetException(IEnumerable\u003CException\u003E exceptions);\r\n        public bool TrySetException(Exception exception);\r\n        public bool TrySetResult();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22620000000,
        "Apis": [
          "M:TaskCompletionSource.SetCanceled()",
          "M:TaskCompletionSource.SetException(Exception)",
          "M:TaskCompletionSource.SetException(IEnumerable\u003CException\u003E)",
          "M:TaskCompletionSource.SetResult()",
          "M:TaskCompletionSource.TaskCompletionSource()",
          "M:TaskCompletionSource.TaskCompletionSource(object?,TaskCreationOptions)",
          "M:TaskCompletionSource.TaskCompletionSource(object?)",
          "M:TaskCompletionSource.TaskCompletionSource(TaskCreationOptions)",
          "M:TaskCompletionSource.TrySetCanceled()",
          "M:TaskCompletionSource.TrySetCanceled(CancellationToken)",
          "M:TaskCompletionSource.TrySetException(Exception)",
          "M:TaskCompletionSource.TrySetException(IEnumerable\u003CException\u003E)",
          "M:TaskCompletionSource.TrySetResult()",
          "P:TaskCompletionSource.Task",
          "T:TaskCompletionSource"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17837,
          "Title": "Add methods to convert between hexadecimal strings and bytes",
          "Author": "GSPP",
          "CreatedAt": "2016-07-12T15:50:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17837",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639018813",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17837#issuecomment-639018813",
        "FeedbackMarkdown": "* We decided to go with a simpler route.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class Convert\r\n    {\r\n        public static byte[] FromHexString(string s);\r\n        public static byte[] FromHexString(ReadOnlySpan\u003Cchar\u003E chars);\r\n\r\n        public static string ToHexString(byte[] inArray);\r\n        public static string ToHexString(byte[] inArray, int offset, int length);\r\n        public static string ToHexString(ReadOnlySpan\u003Cbyte\u003E bytes);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25280000000,
        "Apis": [
          "M:Convert.FromHexString(ReadOnlySpan\u003Cchar\u003E)",
          "M:Convert.FromHexString(string)",
          "M:Convert.ToHexString(byte[],int,int)",
          "M:Convert.ToHexString(byte[])",
          "M:Convert.ToHexString(ReadOnlySpan\u003Cbyte\u003E)",
          "T:Convert"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1476,
          "Title": "TCP Fast Open implementation?",
          "Author": "icylogic",
          "CreatedAt": "2017-02-22T07:35:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1476",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Sockets",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "os-windows",
              "BackgroundColor": "fef2c0",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "tenet-performance",
              "BackgroundColor": "c2e0c6",
              "Description": "Performance related issue",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639025242",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1476#issuecomment-639025242",
        "FeedbackMarkdown": "* We need to decide wether we throw or whether we do a softwar fallback, but naming looks fine:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public enum SocketOptionName\r\n    {\r\n        FastOpen = 15\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41400000000,
        "Apis": [
          "F:SocketOptionName.FastOpen",
          "T:SocketOptionName"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 23021,
          "Title": "Proposal: Add Task.WhenAny(Task,Task) overload to avoid Task[] allocation",
          "Author": "clrjunkie",
          "CreatedAt": "2017-08-02T11:40:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23021",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639034041",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/23021#issuecomment-639034041",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic class Task\r\n{\r\n    // existing\r\n    //public static Task\u003CTask\u003E WhenAny(params Task[] tasks);\r\n    //public static Task\u003CTask\u003E WhenAny(IEnumerable\u003CTask\u003E tasks);\r\n    //public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(params Task\u003CTResult\u003E[] tasks);\r\n    //public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(IEnumerable\u003CTask\u003CTResult\u003E\u003E tasks);\r\n\r\n    // new\r\n    public static Task\u003CTask\u003E WhenAny(Task task1, Task task2);\r\n    public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(Task\u003CTResult\u003E task1, Task\u003CTResult\u003E task2);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48410000000,
        "Apis": [
          "M:Task.WhenAny(Task,Task)",
          "M:Task.WhenAny\u003CTResult\u003E(Task\u003CTResult\u003E,Task\u003CTResult\u003E)",
          "T:Task"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 936,
          "Title": "Add System.Numerics.Half 16 bit floating point number conforming to IEEE 754:2008 binary16",
          "Author": "4creators",
          "CreatedAt": "2017-12-04T23:39:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/936",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639050110",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/936#issuecomment-639050110",
        "FeedbackMarkdown": "* Type looks good as proposed\r\n* But we decided to put it in \u0060System\u0060 to align with the other primitves\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public readonly struct Half : IComparable, IFormattable, IComparable\u003CHalf\u003E, IEquatable\u003CHalf\u003E, IConvertible, ISpanFormattable\r\n    {\r\n        public static readonly Half MinValue;\r\n        public static readonly Half Epsilon;\r\n        public static readonly Half MaxValue;\r\n        public static readonly Half PositiveInfinity;\r\n        public static readonly Half NegativeInfinity;\r\n        public static readonly Half NaN;\r\n        public static bool IsInfinity(Half h);\r\n        public static bool IsFinite(Half value);\r\n        public static bool IsNaN(Half h);\r\n        public static bool IsNegativeInfinity(Half h);\r\n        public static bool IsPositiveInfinity(Half h);\r\n        public static bool IsNormal(Half h);\r\n        public static bool IsSubnormal(Half h);\r\n        public static bool IsNegative(Half h);\r\n        public static Half Parse(string s);\r\n        public static Half Parse(string s, NumberStyles style);\r\n        public static Half Parse(string s, NumberStyles style, IFormatProvider provider);\r\n        public static Half Parse(string s, IFormatProvider provider);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider provider);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider provider);\r\n        public static bool TryParse(string s, out Half result);\r\n        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out Half result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out Half result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider provider, out Half result);\r\n        public int CompareTo(object value);\r\n        public int CompareTo(Half value);\r\n        public bool Equals(Half obj);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n        public TypeCode GetTypeCode();\r\n        public string ToString(IFormatProvider provider);\r\n        public string ToString(string format);\r\n        public string ToString(string format, IFormatProvider provider);\r\n        public override string ToString();\r\n        public static explicit operator Half(float value);\r\n        public static explicit operator Half(double value);\r\n        public static explicit operator float(Half value);\r\n        public static explicit operator double(Half value);\r\n        public static bool operator ==(Half left, Half right);\r\n        public static bool operator !=(Half left, Half right);\r\n        public static bool operator \u003C(Half left, Half right);\r\n        public static bool operator \u003E(Half left, Half right);\r\n        public static bool operator \u003C=(Half left, Half right);\r\n        public static bool operator \u003E=(Half left, Half right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54090000000,
        "Apis": [
          "F:Half.Epsilon",
          "F:Half.MaxValue",
          "F:Half.MinValue",
          "F:Half.NaN",
          "F:Half.NegativeInfinity",
          "F:Half.PositiveInfinity",
          "M:Half.!=(Half,Half)",
          "M:Half.\u003C(Half,Half)",
          "M:Half.\u003C=(Half,Half)",
          "M:Half.==(Half,Half)",
          "M:Half.\u003E(Half,Half)",
          "M:Half.\u003E=(Half,Half)",
          "M:Half.CompareTo(Half)",
          "M:Half.CompareTo(object)",
          "M:Half.Equals(Half)",
          "M:Half.Equals(object)",
          "M:Half.explicit(double)",
          "M:Half.explicit(float)",
          "M:Half.explicit(Half)",
          "M:Half.GetHashCode()",
          "M:Half.GetTypeCode()",
          "M:Half.IsFinite(Half)",
          "M:Half.IsInfinity(Half)",
          "M:Half.IsNaN(Half)",
          "M:Half.IsNegative(Half)",
          "M:Half.IsNegativeInfinity(Half)",
          "M:Half.IsNormal(Half)",
          "M:Half.IsPositiveInfinity(Half)",
          "M:Half.IsSubnormal(Half)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:Half.Parse(string,IFormatProvider)",
          "M:Half.Parse(string,NumberStyles,IFormatProvider)",
          "M:Half.Parse(string,NumberStyles)",
          "M:Half.Parse(string)",
          "M:Half.ToString()",
          "M:Half.ToString(IFormatProvider)",
          "M:Half.ToString(string,IFormatProvider)",
          "M:Half.ToString(string)",
          "M:Half.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider)",
          "M:Half.TryParse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider,out Half)",
          "M:Half.TryParse(ReadOnlySpan\u003Cchar\u003E,out Half)",
          "M:Half.TryParse(string,NumberStyles,IFormatProvider,out Half)",
          "M:Half.TryParse(string,out Half)",
          "T:Half"
        ]
      },
      {
        "Id": 7,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24460,
          "Title": "Add \u0022Create\u0022 method to EqualityComparer\u003C\u003E class",
          "Author": "jkotas",
          "CreatedAt": "2017-12-14T21:49:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24460",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639054509",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24460#issuecomment-639054509",
        "FeedbackMarkdown": "Can someone update the sample to make a compelling case for the currently proposed API? The sample code was for a different proposal.\r\n\r\nIf \u0060Distinct\u0060 is the only use case, then maybe we should fix \u0060Distinct\u0060 itself.",
        "TimeCode": 64490000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 98,
    "Date": "2020-06-12T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=4sksWrrgXJg",
      "Id": "4sksWrrgXJg",
      "StartDateTime": "2020-06-12T10:03:24-07:00",
      "EndDateTime": "2020-06-12T12:08:33-07:00",
      "Duration": 75090000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/4sksWrrgXJg/mqdefault.jpg"
    },
    "Title": "System.Buffers, System.Memory, System.Net.Http, System.Numerics, System.Runtime.CompilerServices, System.Runtime.InteropServices, System.Threading.Channels, System.Threading.Tasks",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37495,
          "Title": "HttpContent.ReadAsStream sync API ",
          "Author": "ManickaP",
          "CreatedAt": "2020-06-05T16:46:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37495",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37495#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37612,
          "Title": "Update UnmanagedCallersOnlyAttribute to align with C# function pointers",
          "Author": "AaronRobinsonMSFT",
          "CreatedAt": "2020-06-08T21:22:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37612",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37612#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 4350000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30863,
          "Title": "TPL Dataflow TransformManyBlock support for IAsyncEnumerable",
          "Author": "onionhammer",
          "CreatedAt": "2019-09-15T18:27:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30863",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30863#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13410000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31297,
          "Title": "Consider introducing BitOperations.IsPow2 or Math.IsPow2",
          "Author": "john-h-k",
          "CreatedAt": "2019-10-25T11:10:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31297",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643407800",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31297#issuecomment-643407800",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static class BitOperations\r\n    {\r\n        public static bool IsPow2(int value);\r\n        public static bool IsPow2(uint value);\r\n        public static bool IsPow2(long value);\r\n        public static bool IsPow2(ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18460000000,
        "Apis": [
          "M:BitOperations.IsPow2(int)",
          "M:BitOperations.IsPow2(long)",
          "M:BitOperations.IsPow2(uint)",
          "M:BitOperations.IsPow2(ulong)",
          "T:BitOperations"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31308,
          "Title": "Add API to get bit length of BigInteger",
          "Author": "andrew-boyarshin",
          "CreatedAt": "2019-10-26T13:33:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31308",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643406480",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31308#issuecomment-643406480",
        "FeedbackMarkdown": "* Makes sense as proposed\r\n* We considered \u0060GetBitCount()\u0060 to be consistent with \u0060GetByteLength()\u0060 but it seems confusing because it sounds like \u0060GetPopCount()\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public struct BigInteger\r\n    {\r\n        public int GetBitLength();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21570000000,
        "Apis": [
          "M:BigInteger.GetBitLength()",
          "T:BigInteger"
        ]
      },
      {
        "Id": 6,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31354,
          "Title": "Add [CallerMustBeUnsafe] attribute to denote APIs which should be called in an unsafe block",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-10-31T02:33:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31354",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643417759",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31354#issuecomment-643417759",
        "FeedbackMarkdown": "* The idea is interesting, but we have concerns:\r\n    - Which kind of APIs would we apply this too? Every p/Invoke? \u0060CollectionMarshal.GetSpanForList()\u0060?\r\n    - The name should reflect what the method does, rather than what mechanically has to happen on the call side.\r\n    - Would we turn this on for existing APIs? If so, it seems this analyzer needs to opt-in. If it\u0027s opt-in, is it still useful?\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Property,\r\n                    AllowMultiple = false,\r\n                    Inherited = true)]\r\n    public sealed class CallerMustBeUnsafeAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28090000000,
        "Apis": [
          "T:CallerMustBeUnsafeAttribute"
        ]
      },
      {
        "Id": 7,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31355,
          "Title": "SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E sequence, ReadOnlySpan\u003CT\u003E delimiter)",
          "Author": "davidfowl",
          "CreatedAt": "2019-10-31T03:20:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31355",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643421064",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31355#issuecomment-643421064",
        "FeedbackMarkdown": "* We have an existing API that returns the sequence.\r\n* We don\u0027t want to offer an API that might allocate unexpectedly, especially on a type that is about avoiding allocations.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Existing API\r\n        // public bool TryReadTo(out ReadOnlySequence\u003CT\u003E sequence, T delimiter, bool advancePastDelimiter = true);\r\n\r\n        public bool TryReadTo(out ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E delimiter, bool advancePastDelimiter = true);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42870000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.TryReadTo(out ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,bool)",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Id": 8,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31357,
          "Title": "Utf8Parser overloads for ReadOnlySequence\u003Cbyte\u003E",
          "Author": "davidfowl",
          "CreatedAt": "2019-10-31T05:02:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31357",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Memory",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643427770",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31357#issuecomment-643427770",
        "FeedbackMarkdown": "@davidfowl have tried using APIs like this in Kestrel or is this API proposal a hypothetical? The question is whether you can the perf, because parsers should really be over spans, not sequences.  We already said we won\u0027t do parsers of \u0060Memory\u003CT\u003E\u0060 because accessing the span is not free. Doing it over sequences would be even worse.",
        "TimeCode": 47730000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31362,
          "Title": "Proposal: ChannelReader\u003CT\u003E.TryPeek",
          "Author": "stephentoub",
          "CreatedAt": "2019-11-01T02:12:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31362",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading.Channels",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643438552",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31362#issuecomment-643438552",
        "FeedbackMarkdown": "* We should add a virtual \u0060CanPeek\u0060 that returns \u0060false\u0060\r\n* We\u0027ll want more feedback so we should punt this to .NET 6.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Channels\r\n{\r\n    public abstract partial class ChannelReader\u003CT\u003E\r\n    {\r\n        public virtual bool CanPeek =\u003E false;\r\n\r\n        public virtual bool TryPeek([MaybeNullWhen(false)] out T item)\r\n        {\r\n            item = default!;\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57550000000,
        "Apis": [
          "M:ChannelReader\u003CT\u003E.TryPeek(out T)",
          "P:ChannelReader\u003CT\u003E.CanPeek",
          "T:ChannelReader\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "Id": 99,
    "Date": "2020-06-18T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=t-X09mGPvNM",
      "Id": "t-X09mGPvNM",
      "StartDateTime": "2020-06-18T10:04:46-07:00",
      "EndDateTime": "2020-06-18T12:11:47-07:00",
      "Duration": 76210000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/t-X09mGPvNM/mqdefault.jpg"
    },
    "Title": "System.ComponentModel.DataAnnotations, System.Net.Security, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37933,
          "Title": "SslStream API improvements for enhanced use cases ",
          "Author": "wfurt",
          "CreatedAt": "2020-06-15T22:20:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37933",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646228075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37933#issuecomment-646228075",
        "FeedbackMarkdown": "* ServerOptionsSelectionCallback should use a context object instead of the hostname for future expansion\r\n* Rename \u0060sender\u0060 to \u0060stream\u0060 in \u0060ServerOptionsSelectionCallback\u0060\r\n* Why is \u0060SslStream.HostName\u0060 \u0060virtual\u0060?\r\n* Rename \u0060HostName\u0060 to \u0060TargetHostName\u0060\r\n* Rename \u0060SslStreamCertificateContext.CreateForServer\u0060 to \u0060SslStreamCertificateContext.Create\u0060 to unify with client usage (and drop the usage type check)\r\n* Add an \u0060offline\u0060 parameter to the SslStreamCertificateContext Create method\r\n* Add a debugger proxy to show the target cert.\r\n\r\n\u0060\u0060\u0060C#\r\npublic readonly struct SslClientHelloInfo\r\n{\r\n    public string ServerName { get; }\r\n    public SslProtocols SslProtocols { get; }\r\n}\r\n\r\npublic delegate ValueTask\u003CSslServerAuthenticationOptions\u003E ServerOptionsSelectionCallback(SslStream stream, SslClientHelloInfo clientHelloInfo, object? state, CancellationToken cancellationToken);\r\n\r\npartial class SslStream\r\n{\r\n    public string TargetHostName { get; }\r\n    public Task AuthenticateAsServerAsync(\r\n        ServerOptionsSelectionCallback optionCallback,\r\n        object? state,\r\n        CancellationToken cancellationToken = default);      \r\n}\r\n\r\npublic sealed class SslStreamCertificateContext\r\n{\r\n    public static SslStreamCertificateContext Create(\r\n        X509Certificate2 target,\r\n        X509Certificate2Collection? additionalCertificates,\r\n        bool offline = false);\r\n}\r\n\r\npartial class SslServerAuthenticationOptions\r\n{\r\n    SslStreamCertificateContext ServerCertificateContext  { get; set; };\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SslStream.AuthenticateAsServerAsync(ServerOptionsSelectionCallback,object?,CancellationToken)",
          "M:SslStreamCertificateContext.Create(X509Certificate2,X509Certificate2Collection?,bool)",
          "P:SslClientHelloInfo.ServerName",
          "P:SslClientHelloInfo.SslProtocols",
          "P:SslServerAuthenticationOptions.ServerCertificateContext",
          "P:SslStream.TargetHostName",
          "T:ServerOptionsSelectionCallback(SslStream,SslClientHelloInfo,object?,CancellationToken)",
          "T:SslClientHelloInfo",
          "T:SslServerAuthenticationOptions",
          "T:SslStream",
          "T:SslStreamCertificateContext"
        ]
      },
      {
        "Id": 2,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29214,
          "Title": "CompareAttribute.Validate method does not create a ValidationResult with MemberNames",
          "Author": "ChrisJWoodcock",
          "CreatedAt": "2019-04-09T15:18:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ComponentModel.DataAnnotations",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "bug",
              "BackgroundColor": "f49cb1",
              "Description": "Product bug (most likely)",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29214#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 43740000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31400,
          "Title": "Add support for validating complex or collection properties using System.ComponentModel.DataAnnotations.Validator",
          "Author": "pranavkm",
          "CreatedAt": "2019-11-05T14:07:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31400",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.ComponentModel.DataAnnotations",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646249648",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31400#issuecomment-646249648",
        "FeedbackMarkdown": "* The new attribute seems fine, but be careful in how it gets consumed so as to not surprise users who use the objects in multiple contexts (Blazor, EF6, etc).\r\n* It seems like some new data belongs on ValidationContext, instead of new overloads to (Try)ValidateObject, around memberName-path representations and other handling of [ValidateComplexType].",
        "TimeCode": 49010000000,
        "Apis": []
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31944,
          "Title": "Add easy way to create a certificate from a multi-PEM or cert-PEM \u002B key-PEM",
          "Author": "bartonjs",
          "CreatedAt": "2020-02-07T21:47:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31944",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646253846",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31944#issuecomment-646253846",
        "FeedbackMarkdown": "Approved without the byte-based password inputs.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates {\r\n    partial class X509Certificate2 {\r\n        public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string keyPemFilePath = default);\r\n        public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan\u003Cchar\u003E password, string keyPemFilePath = default);\r\n\r\n        public static X509Certificate2 CreateFromPem(ReadOnlySpan\u003Cchar\u003E certPem, ReadOnlySpan\u003Cchar\u003E keyPem);\r\n        public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan\u003Cchar\u003E certPem, ReadOnlySpan\u003Cchar\u003E keyPem, ReadOnlySpan\u003Cchar\u003E password);\r\n    }\r\n\r\n    partial class X509Certificate2Collection {\r\n        public void ImportFromPemFile(string certPemFilePath);\r\n        public void ImportFromPem(ReadOnlySpan\u003Cchar\u003E certPem);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 70580000000,
        "Apis": [
          "M:X509Certificate2.CreateFromEncryptedPem(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2.CreateFromEncryptedPemFile(string,ReadOnlySpan\u003Cchar\u003E,string)",
          "M:X509Certificate2.CreateFromPem(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2.CreateFromPemFile(string,string)",
          "M:X509Certificate2Collection.ImportFromPem(ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2Collection.ImportFromPemFile(string)",
          "T:X509Certificate2",
          "T:X509Certificate2Collection"
        ]
      }
    ]
  },
  {
    "Id": 100,
    "Date": "2020-06-25T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=rx_098IdZU0",
      "Id": "rx_098IdZU0",
      "StartDateTime": "2020-06-25T09:54:00-07:00",
      "EndDateTime": "2020-06-25T12:02:22-07:00",
      "Duration": 77020000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/rx_098IdZU0/mqdefault.jpg"
    },
    "Title": "System.Drawing, System.Numerics, System.Runtime.Intrinsics, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34587,
          "Title": "Add empty X64/Arm64 nested classes to some System.Runtime.Intrinsics",
          "Author": "EgorBo",
          "CreatedAt": "2020-04-06T14:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34587",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "breaking-change",
              "BackgroundColor": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease.",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649714324",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34587#issuecomment-649714324",
        "FeedbackMarkdown": "* Good point\r\n* When inheriting, we always should also define all nested types and define \u0060IsSupported\u0060 the appropriately, even if they don\u0027t define any other members.\r\n* (this will probably require more nested types than listed below)\r\n\r\n\u0060\u0060\u0060C#\r\n[Intrinsic]\r\n[CLSCompliant(false)]\r\npublic partial class Sha1 : ArmBase\r\n{\r\n    public abstract class Arm64 : ArmBase.Arm64;\r\n    {\r\n        public static new bool IsSupported =\u003E Sha1.IsSupported \u0026\u0026 IntPtr.Size == 8;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:Sha1.IsSupported",
          "T:Sha1",
          "T:Sha1.Arm64"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 936,
          "Title": "Add System.Numerics.Half 16 bit floating point number conforming to IEEE 754:2008 binary16",
          "Author": "4creators",
          "CreatedAt": "2017-12-04T23:39:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/936",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/936#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16980000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33532,
          "Title": "[Arm64] Store Pair of SIMD\u0026FP registers",
          "Author": "echesakovMSFT",
          "CreatedAt": "2020-03-12T21:33:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33532",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649724378",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33532#issuecomment-649724378",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    partial class AdvSimd.Arm64\r\n    {\r\n        public static unsafe void StorePair(byte* address, Vector64\u003Cbyte\u003E value1, Vector64\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePair(double* address, Vector64\u003Cdouble\u003E value1, Vector64\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePair(short* address, Vector64\u003Cshort\u003E value1, Vector64\u003Cshort\u003E value2);\r\n        public static unsafe void StorePair(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePair(long* address, Vector64\u003Clong\u003E value1, Vector64\u003Clong\u003E value2);\r\n        public static unsafe void StorePair(sbyte* address, Vector64\u003Csbyte\u003E value1, Vector64\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePair(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePair(ushort* address, Vector64\u003Cushort\u003E value1, Vector64\u003Cushort\u003E value2);\r\n        public static unsafe void StorePair(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n        public static unsafe void StorePair(ulong* address, Vector64\u003Culong\u003E value1, Vector64\u003Culong\u003E value2);\r\n        public static unsafe void StorePair(byte* address, Vector128\u003Cbyte\u003E value1, Vector128\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePair(double* address, Vector128\u003Cdouble\u003E value1, Vector128\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePair(short* address, Vector128\u003Cshort\u003E value1, Vector128\u003Cshort\u003E value2);\r\n        public static unsafe void StorePair(int* address, Vector128\u003Cint\u003E value1, Vector128\u003Cint\u003E value2);\r\n        public static unsafe void StorePair(long* address, Vector128\u003Clong\u003E value1, Vector128\u003Clong\u003E value2);\r\n        public static unsafe void StorePair(sbyte* address, Vector128\u003Csbyte\u003E value1, Vector128\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePair(float* address, Vector128\u003Cfloat\u003E value1, Vector128\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePair(ushort* address, Vector128\u003Cushort\u003E value1, Vector128\u003Cushort\u003E value2);\r\n        public static unsafe void StorePair(uint* address, Vector128\u003Cuint\u003E value1, Vector128\u003Cuint\u003E value2);\r\n        public static unsafe void StorePair(ulong* address, Vector128\u003Culong\u003E value1, Vector128\u003Culong\u003E value2);\r\n\r\n        public static unsafe void StorePairScalar(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairScalar(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairScalar(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n\r\n        public static unsafe void StorePairNonTemporal(byte* address, Vector64\u003Cbyte\u003E value1, Vector64\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(double* address, Vector64\u003Cdouble\u003E value1, Vector64\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(short* address, Vector64\u003Cshort\u003E value1, Vector64\u003Cshort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(long* address, Vector64\u003Clong\u003E value1, Vector64\u003Clong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(sbyte* address, Vector64\u003Csbyte\u003E value1, Vector64\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ushort* address, Vector64\u003Cushort\u003E value1, Vector64\u003Cushort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ulong* address, Vector64\u003Culong\u003E value1, Vector64\u003Culong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(byte* address, Vector128\u003Cbyte\u003E value1, Vector128\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(double* address, Vector128\u003Cdouble\u003E value1, Vector128\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(short* address, Vector128\u003Cshort\u003E value1, Vector128\u003Cshort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(int* address, Vector128\u003Cint\u003E value1, Vector128\u003Cint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(long* address, Vector128\u003Clong\u003E value1, Vector128\u003Clong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(sbyte* address, Vector128\u003Csbyte\u003E value1, Vector128\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(float* address, Vector128\u003Cfloat\u003E value1, Vector128\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ushort* address, Vector128\u003Cushort\u003E value1, Vector128\u003Cushort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(uint* address, Vector128\u003Cuint\u003E value1, Vector128\u003Cuint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ulong* address, Vector128\u003Culong\u003E value1, Vector128\u003Culong\u003E value2);\r\n\r\n        public static unsafe void StorePairScalarNonTemporal(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairScalarNonTemporal(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairScalarNonTemporal(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26510000000,
        "Apis": [
          "M:.StorePair(byte*,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:.StorePair(byte*,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:.StorePair(double*,Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:.StorePair(double*,Vector64\u003Cdouble\u003E,Vector64\u003Cdouble\u003E)",
          "M:.StorePair(float*,Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:.StorePair(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePair(int*,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:.StorePair(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePair(long*,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:.StorePair(long*,Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:.StorePair(sbyte*,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:.StorePair(sbyte*,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:.StorePair(short*,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:.StorePair(short*,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:.StorePair(uint*,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:.StorePair(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePair(ulong*,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:.StorePair(ulong*,Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:.StorePair(ushort*,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:.StorePair(ushort*,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:.StorePairNonTemporal(byte*,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:.StorePairNonTemporal(byte*,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:.StorePairNonTemporal(double*,Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:.StorePairNonTemporal(double*,Vector64\u003Cdouble\u003E,Vector64\u003Cdouble\u003E)",
          "M:.StorePairNonTemporal(float*,Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:.StorePairNonTemporal(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairNonTemporal(int*,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:.StorePairNonTemporal(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairNonTemporal(long*,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:.StorePairNonTemporal(long*,Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:.StorePairNonTemporal(sbyte*,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:.StorePairNonTemporal(sbyte*,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:.StorePairNonTemporal(short*,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:.StorePairNonTemporal(short*,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:.StorePairNonTemporal(uint*,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:.StorePairNonTemporal(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePairNonTemporal(ulong*,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:.StorePairNonTemporal(ulong*,Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:.StorePairNonTemporal(ushort*,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:.StorePairNonTemporal(ushort*,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:.StorePairScalar(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairScalar(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairScalar(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePairScalarNonTemporal(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairScalarNonTemporal(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairScalarNonTemporal(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36696,
          "Title": "ARM Doubling Multiply intrinsics",
          "Author": "tannergooding",
          "CreatedAt": "2020-05-19T13:58:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36696",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649730379",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36696#issuecomment-649730379",
        "FeedbackMarkdown": "* The TODO versions are also approved\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSaturateHighScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSaturateHighScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningSaturateLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningSaturateLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningSaturateLower(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningSaturateLower(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E   MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cint\u003E   addend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cshort\u003E minuend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cint\u003E   minuend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n    }\r\n\r\n    public abstract class Rdm : AdvSimd\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E   right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E     right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E  right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E    right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cint\u003E   addend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cshort\u003E minuend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cint\u003E   minuend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28530000000,
        "Apis": [
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "P:Rdm.IsSupported",
          "T:AdvSimd",
          "T:Rdm"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37014,
          "Title": "Remaining ARM Intrinsics",
          "Author": "tannergooding",
          "CreatedAt": "2020-05-26T15:41:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37014",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-ready-for-review",
              "BackgroundColor": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649746313",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37014#issuecomment-649746313",
        "FeedbackMarkdown": "label:blocking \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public static class AdvSimd\r\n    {\r\n        public static unsafe (Vector64\u003Cbyte\u003E Value1,    Vector64\u003Cbyte\u003E Value2)    LoadPairVector64(byte*   address);\r\n        public static unsafe (Vector64\u003Csbyte\u003E Value1,   Vector64\u003Csbyte\u003E Value2)   LoadPairVector64(sbyte*  address);\r\n        public static unsafe (Vector64\u003Cshort\u003E Value1,   Vector64\u003Cshort\u003E Value2)   LoadPairVector64(short*  address);\r\n        public static unsafe (Vector64\u003Cushort\u003E Value1,  Vector64\u003Cushort\u003E Value2)  LoadPairVector64(ushort* address);\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairVector64(int*    address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairVector64(uint*   address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairVector64(float*  address);\r\n\r\n        public static unsafe (Vector128\u003Cbyte\u003E Value1,   Vector128\u003Cbyte\u003E Value2)   LoadPairVector128(byte*   address);\r\n        public static unsafe (Vector128\u003Csbyte\u003E Value1,  Vector128\u003Csbyte\u003E Value2)  LoadPairVector128(sbyte*  address);\r\n        public static unsafe (Vector128\u003Cshort\u003E Value1,  Vector128\u003Cshort\u003E Value2)  LoadPairVector128(short*  address);\r\n        public static unsafe (Vector128\u003Cushort\u003E Value1, Vector128\u003Cushort\u003E Value2) LoadPairVector128(ushort* address);\r\n        public static unsafe (Vector128\u003Cint\u003E Value1,    Vector128\u003Cint\u003E Value2)    LoadPairVector128(int*    address);\r\n        public static unsafe (Vector128\u003Cuint\u003E Value1,   Vector128\u003Cuint\u003E Value2)   LoadPairVector128(uint*   address);\r\n        public static unsafe (Vector128\u003Clong\u003E Value1,   Vector128\u003Clong\u003E Value2)   LoadPairVector128(long*   address);\r\n        public static unsafe (Vector128\u003Culong\u003E Value1,  Vector128\u003Culong\u003E Value2)  LoadPairVector128(ulong*  address);\r\n        public static unsafe (Vector128\u003Cfloat\u003E Value1,  Vector128\u003Cfloat\u003E Value2)  LoadPairVector128(float*  address);\r\n\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairScalarVector64(int*  address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairScalarVector64(uint* address);\r\n        public static unsafe (Vector64\u003Clong\u003E Value1,    Vector64\u003Clong\u003E Value2)    LoadPairScalarVector64(long*  address);\r\n        public static unsafe (Vector64\u003Culong\u003E Value1,   Vector64\u003Culong\u003E Value2)   LoadPairScalarVector64(ulong* address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairScalarVector64(float* address);\r\n        public static unsafe (Vector64\u003Cdouble\u003E Value1,  Vector64\u003Cdouble\u003E Value2)  LoadPairScalarVector64(double* address);\r\n\r\n        public static unsafe (Vector64\u003Cbyte\u003E Value1,    Vector64\u003Cbyte\u003E Value2)    LoadPairVector64NonTemporal(byte*   address);\r\n        public static unsafe (Vector64\u003Csbyte\u003E Value1,   Vector64\u003Csbyte\u003E Value2)   LoadPairVector64NonTemporal(sbyte*  address);\r\n        public static unsafe (Vector64\u003Cshort\u003E Value1,   Vector64\u003Cshort\u003E Value2)   LoadPairVector64NonTemporal(short*  address);\r\n        public static unsafe (Vector64\u003Cushort\u003E Value1,  Vector64\u003Cushort\u003E Value2)  LoadPairVector64NonTemporal(ushort* address);\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairVector64NonTemporal(int*    address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairVector64NonTemporal(uint*   address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairVector64NonTemporal(float*  address);\r\n\r\n        public static unsafe (Vector128\u003Cbyte\u003E Value1,   Vector128\u003Cbyte\u003E Value2)   LoadPairVector128NonTemporal(byte*   address);\r\n        public static unsafe (Vector128\u003Csbyte\u003E Value1,  Vector128\u003Csbyte\u003E Value2)  LoadPairVector128NonTemporal(sbyte*  address);\r\n        public static unsafe (Vector128\u003Cshort\u003E Value1,  Vector128\u003Cshort\u003E Value2)  LoadPairVector128NonTemporal(short*  address);\r\n        public static unsafe (Vector128\u003Cushort\u003E Value1, Vector128\u003Cushort\u003E Value2) LoadPairVector128NonTemporal(ushort* address);\r\n        public static unsafe (Vector128\u003Cint\u003E Value1,    Vector128\u003Cint\u003E Value2)    LoadPairVector128NonTemporal(int*    address);\r\n        public static unsafe (Vector128\u003Cuint\u003E Value1,   Vector128\u003Cuint\u003E Value2)   LoadPairVector128NonTemporal(uint*   address);\r\n        public static unsafe (Vector128\u003Clong\u003E Value1,   Vector128\u003Clong\u003E Value2)   LoadPairVector128NonTemporal(long*   address);\r\n        public static unsafe (Vector128\u003Culong\u003E Value1,  Vector128\u003Culong\u003E Value2)  LoadPairVector128NonTemporal(ulong*  address);\r\n        public static unsafe (Vector128\u003Cfloat\u003E Value1,  Vector128\u003Cfloat\u003E Value2)  LoadPairVector128NonTemporal(float*  address);\r\n\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairScalarVector64NonTemporal(int*  address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairScalarVector64NonTemporal(uint* address);\r\n        public static unsafe (Vector64\u003Clong\u003E Value1,    Vector64\u003Clong\u003E Value2)    LoadPairScalarVector64NonTemporal(long*  address);\r\n        public static unsafe (Vector64\u003Culong\u003E Value1,   Vector64\u003Culong\u003E Value2)   LoadPairScalarVector64NonTemporal(ulong* address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairScalarVector64NonTemporal(float* address);\r\n        public static unsafe (Vector64\u003Cdouble\u003E Value1,  Vector64\u003Cdouble\u003E Value2)  LoadPairScalarVector64NonTemporal(double* address);\r\n\r\n        public static Vector64\u003Csbyte\u003E   ExtractNarrowingSaturateLower(Vector128\u003Cshort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E   ExtractNarrowingSaturateLower(Vector128\u003Cint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ExtractNarrowingSaturateLower(Vector128\u003Clong\u003E   value);\r\n        public static Vector128\u003Csbyte\u003E  ExtractNarrowingSaturateUpper(Vector64\u003Cshort\u003E   lower, Vector128\u003Cshort\u003E  value);\r\n        public static Vector128\u003Cshort\u003E  ExtractNarrowingSaturateUpper(Vector64\u003Cint\u003E     lower, Vector128\u003Cint\u003E    value);\r\n        public static Vector128\u003Cint\u003E    ExtractNarrowingSaturateUpper(Vector64\u003Clong\u003E    lower, Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector64\u003Cbyte\u003E    ExtractNarrowingSaturateLower(Vector128\u003Cushort\u003E value);\r\n        public static Vector64\u003Cushort\u003E  ExtractNarrowingSaturateLower(Vector128\u003Cuint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E    ExtractNarrowingSaturateLower(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractNarrowingSaturateUpper(Vector64\u003Cushort\u003E  lower, Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractNarrowingSaturateUpper(Vector64\u003Cuint\u003E    lower, Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractNarrowingSaturateUpper(Vector64\u003Culong\u003E   lower, Vector128\u003Culong\u003E  value);\r\n\r\n        public static Vector64\u003Cbyte\u003E    ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cshort\u003E value);\r\n        public static Vector64\u003Cushort\u003E  ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E    ExtractNarrowingSaturateUnsignedLower(Vector128\u003Clong\u003E  value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Cint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Clong\u003E   lower, Vector128\u003Clong\u003E  value);\r\n\r\n        public static Vector64\u003Cushort\u003E  ReverseElement8(Vector64\u003Cushort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E   ReverseElement8(Vector64\u003Cshort\u003E   value);\r\n        public static Vector128\u003Cushort\u003E ReverseElement8(Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cshort\u003E  ReverseElement8(Vector128\u003Cshort\u003E  value);\r\n\r\n        public static Vector64\u003Cuint\u003E    ReverseElement8(Vector64\u003Cuint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ReverseElement8(Vector64\u003Cint\u003E     value);\r\n        public static Vector64\u003Cfloat\u003E   ReverseElement8(Vector64\u003Cfloat\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ReverseElement8(Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cint\u003E    ReverseElement8(Vector128\u003Cint\u003E    value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement8(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement8(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement8(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement8(Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector64\u003Cuint\u003E    ReverseElement16(Vector64\u003Cuint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ReverseElement16(Vector64\u003Cint\u003E     value);\r\n        public static Vector64\u003Cfloat\u003E   ReverseElement16(Vector64\u003Cfloat\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ReverseElement16(Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cint\u003E    ReverseElement16(Vector128\u003Cint\u003E    value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement16(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement16(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement16(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement16(Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement32(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement32(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement32(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement32(Vector128\u003Clong\u003E   value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38280000000,
        "Apis": [
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.LoadPairScalarVector64(double*)",
          "M:AdvSimd.LoadPairScalarVector64(float*)",
          "M:AdvSimd.LoadPairScalarVector64(int*)",
          "M:AdvSimd.LoadPairScalarVector64(long*)",
          "M:AdvSimd.LoadPairScalarVector64(uint*)",
          "M:AdvSimd.LoadPairScalarVector64(ulong*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(double*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(float*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(int*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(long*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(uint*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(ulong*)",
          "M:AdvSimd.LoadPairVector128(byte*)",
          "M:AdvSimd.LoadPairVector128(float*)",
          "M:AdvSimd.LoadPairVector128(int*)",
          "M:AdvSimd.LoadPairVector128(long*)",
          "M:AdvSimd.LoadPairVector128(sbyte*)",
          "M:AdvSimd.LoadPairVector128(short*)",
          "M:AdvSimd.LoadPairVector128(uint*)",
          "M:AdvSimd.LoadPairVector128(ulong*)",
          "M:AdvSimd.LoadPairVector128(ushort*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(byte*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(float*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(int*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(long*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(sbyte*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(short*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(uint*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(ulong*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(ushort*)",
          "M:AdvSimd.LoadPairVector64(byte*)",
          "M:AdvSimd.LoadPairVector64(float*)",
          "M:AdvSimd.LoadPairVector64(int*)",
          "M:AdvSimd.LoadPairVector64(sbyte*)",
          "M:AdvSimd.LoadPairVector64(short*)",
          "M:AdvSimd.LoadPairVector64(uint*)",
          "M:AdvSimd.LoadPairVector64(ushort*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(byte*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(float*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(int*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(sbyte*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(short*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(uint*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(ushort*)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cushort\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38137,
          "Title": "[Arm64] ASIMD InsertScalar",
          "Author": "echesakovMSFT",
          "CreatedAt": "2020-06-19T00:49:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38137",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649751957",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38137#issuecomment-649751957",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public static class AdvSimd\r\n    {\r\n        public static Vector128\u003Cdouble\u003E InsertScalar(Vector128\u003Cdouble\u003E result, byte resultIndex, Vector64\u003Cdouble\u003E value);\r\n        public static Vector128\u003Clong\u003E   InsertScalar(Vector128\u003Clong\u003E   result, byte resultIndex, Vector64\u003Clong\u003E   value);\r\n        public static Vector128\u003Culong\u003E  InsertScalar(Vector128\u003Culong\u003E  result, byte resultIndex, Vector64\u003Culong\u003E  value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57040000000,
        "Apis": [
          "M:AdvSimd.InsertScalar(Vector128\u003Cdouble\u003E,byte,Vector64\u003Cdouble\u003E)",
          "M:AdvSimd.InsertScalar(Vector128\u003Clong\u003E,byte,Vector64\u003Clong\u003E)",
          "M:AdvSimd.InsertScalar(Vector128\u003Culong\u003E,byte,Vector64\u003Culong\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37169,
          "Title": "[Arm64] SIMD dot product",
          "Author": "echesakovMSFT",
          "CreatedAt": "2020-05-29T18:14:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37169",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-arm64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649754359",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37169#issuecomment-649754359",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class Dp : AdvSimd\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        public static Vector64\u003Cint\u003E   DotProduct(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n        public static Vector64\u003Cuint\u003E  DotProduct(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n        public static Vector128\u003Cint\u003E  DotProduct(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector128\u003Csbyte\u003E right);\r\n        public static Vector128\u003Cuint\u003E DotProduct(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector128\u003Cbyte\u003E  right);\r\n\r\n        public static Vector64\u003Cint\u003E   DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector64\u003Cint\u003E   DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E right, byte rightScaledIndex);\r\n        public static Vector64\u003Cuint\u003E  DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte rightScaledIndex);\r\n        public static Vector64\u003Cuint\u003E  DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cint\u003E  DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector128\u003Csbyte\u003E right, byte rightScaledIndex);\r\n        public static Vector128\u003Cint\u003E  DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector64\u003Csbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cuint\u003E DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector128\u003Cbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cuint\u003E DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector64\u003Cbyte\u003E   right, byte rightScaledIndex);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64730000000,
        "Apis": [
          "M:Dp.DotProduct(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:Dp.DotProduct(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Dp.DotProduct(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:Dp.DotProduct(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "P:Dp.IsSupported",
          "T:Dp"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38348,
          "Title": "Allow creating more cryptographic objects from ReadOnlySpan\u003Cbyte\u003E",
          "Author": "bartonjs",
          "CreatedAt": "2020-06-24T18:25:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38348",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649759447",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38348#issuecomment-649759447",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography\r\n{\r\n    partial class AsnEncodedData\r\n    {\r\n        protected AsnEncodedData() { }\r\n        public AsnEncodedData(byte[] rawData) { }\r\n\u002B       public AsnEncodedData(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n        public AsnEncodedData(System.Security.Cryptography.AsnEncodedData asnEncodedData) { }\r\n        public AsnEncodedData(System.Security.Cryptography.Oid? oid, byte[] rawData) { }\r\n\u002B       public AsnEncodedData(System.Security.Cryptography.Oid? oid, System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n        public AsnEncodedData(string oid, byte[] rawData) { }\r\n\u002B       public AsnEncodedData(string oid, System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n    }\r\n}\r\n\r\nnamespace System.Security.Cryptography.Pkcs\r\n{\r\n    partial class ContentInfo\r\n    {\r\n        public static System.Security.Cryptography.Oid GetContentType(byte[] encodedMessage) { throw null; }\r\n\u002B       public static System.Security.Cryptography.Oid GetContentType(ReadOnlySpan\u003Cbyte\u003E encodedMessage) { throw null; }\r\n    }\r\n\r\n    partial class EnvelopedCms\r\n    {\r\n        public void Decode(byte[] encodedMessage) { }\r\n\u002B       public void Decode(System.ReadOnlySpan\u003Cbyte\u003E encodedMessage) { }\r\n    }\r\n\r\n    partial class SignedCms\r\n    {\r\n        public void Decode(byte[] encodedMessage) { }\r\n\u002B       public void Decode(System.ReadOnlySpan\u003Cbyte\u003E encodedMessage) { }\r\n     }\r\n}\r\n\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    partial class CertificateRequest\r\n    {\r\n        public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedName issuerName,\r\n            System.Security.Cryptography.X509Certificates.X509SignatureGenerator generator,\r\n            System.DateTimeOffset notBefore,\r\n            System.DateTimeOffset notAfter,\r\n            byte[] serialNumber) { throw null; }\r\n\u002B       public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n\u002B           System.Security.Cryptography.X509Certificates.X500DistinguishedName issuerName,\r\n\u002B           System.Security.Cryptography.X509Certificates.X509SignatureGenerator generator,\r\n\u002B           System.DateTimeOffset notBefore,\r\n\u002B           System.DateTimeOffset notAfter,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E serialNumber) { throw null; }\r\n        public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n            System.Security.Cryptography.X509Certificates.X509Certificate2 issuerCertificate,\r\n            System.DateTimeOffset notBefore,\r\n            System.DateTimeOffset notAfter,\r\n            byte[] serialNumber) { throw null; }\r\n\u002B       public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n\u002B           System.Security.Cryptography.X509Certificates.X509Certificate2 issuerCertificate,\r\n\u002B           System.DateTimeOffset notBefore,\r\n\u002B           System.DateTimeOffset notAfter,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E serialNumber) { throw null; }\r\n    }\r\n\r\n    partial class X500DistinguishedName : System.Security.Cryptography.AsnEncodedData\r\n    {\r\n        public X500DistinguishedName(byte[] encodedDistinguishedName) { }\r\n\u002B       public X500DistinguishedName(System.ReadOnlySpan\u003Cbyte\u003E encodedDistinguishedName) { }\r\n        public X500DistinguishedName(System.Security.Cryptography.AsnEncodedData encodedDistinguishedName) { }\r\n        public X500DistinguishedName(\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedName distinguishedName) { }\r\n        public X500DistinguishedName(string distinguishedName) { }\r\n        public X500DistinguishedName(\r\n            string distinguishedName,\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags flag) { }\r\n    }\r\n\r\n    partial class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate\r\n    {\r\n        public X509Certificate2() { }\r\n        public X509Certificate2(byte[] rawData) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(byte[] rawData, System.Security.SecureString? password) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(\r\n            byte[] rawData,\r\n            System.Security.SecureString? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(byte[] rawData, string? password) { }\r\n        public X509Certificate2(\r\n            byte[] rawData,\r\n            string? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(System.IntPtr handle) { }\r\n\u002B       public X509Certificate2(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n\u002B       public X509Certificate2(\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E rawData,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        protected X509Certificate2(\r\n            System.Runtime.Serialization.SerializationInfo info,\r\n            System.Runtime.Serialization.StreamingContext context) { }\r\n        public X509Certificate2(System.Security.Cryptography.X509Certificates.X509Certificate certificate) { }\r\n        public X509Certificate2(string fileName) { }\r\n\u002B       public X509Certificate2(\r\n\u002B           string fileName,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(string fileName, System.Security.SecureString? password) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(\r\n            string fileName,\r\n            System.Security.SecureString? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(string fileName, string? password) { }\r\n        public X509Certificate2(\r\n            string fileName,\r\n            string? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public static X509ContentType GetCertContentType(byte[] rawData) { throw null; }\r\n\u002B       public static X509ContentType GetCertContentType(System.ReadOnlySpan\u003Cbyte\u003E rawData) { throw null; }\r\n        public static X509ContentType GetCertContentType(string fileName) { throw null; }\r\n    }\r\n\r\n    partial class X509Certificate2Collection\r\n    {\r\n        public void Import(byte[] rawData) { }\r\n        public void Import(\r\n            byte[] rawData,\r\n            string? password,\r\n-           X509KeyStorageFlags keyStorageFlags) { }\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n\u002B       public void Import(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n\u002B       public void Import(\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E rawData,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        public void Import(string fileName) { }\r\n\u002B       public void Import(\r\n\u002B           string fileName,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        public void Import(\r\n            string fileName,\r\n            string? password,\r\n-           X509KeyStorageFlags keyStorageFlags) { }\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n    }\r\n\r\n    partial class X509Extension : System.Security.Cryptography.AsnEncodedData\r\n        protected X509Extension() { }\r\n        public X509Extension(System.Security.Cryptography.AsnEncodedData encodedExtension, bool critical) { }\r\n        public X509Extension(System.Security.Cryptography.Oid oid, byte[] rawData, bool critical) { }\r\n\u002B       public X509Extension(System.Security.Cryptography.Oid oid, System.ReadOnlySpan\u003Cbyte\u003E rawData, bool critical) { }\r\n        public X509Extension(string oid, byte[] rawData, bool critical) { }\r\n\u002B       public X509Extension(string oid, System.ReadOnlySpan\u003Cbyte\u003E rawData, bool critical) { }\r\n    }\r\n\r\n    partial class X509SubjectKeyIdentifierExtension : System.Security.Cryptography.X509Certificates.X509Extension\r\n    {\r\n        public X509SubjectKeyIdentifierExtension() { }\r\n        public X509SubjectKeyIdentifierExtension(byte[] subjectKeyIdentifier, bool critical) { }\r\n\u002B       public X509SubjectKeyIdentifierExtension(System.ReadOnlySpan\u003Cbyte\u003E subjectKeyIdentifier, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.AsnEncodedData encodedSubjectKeyIdentifier, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.X509Certificates.PublicKey key, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.X509Certificates.PublicKey key, System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical) { }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 67440000000,
        "Apis": []
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36105,
          "Title": "Implement CachedBitmap functionality in System.Drawing",
          "Author": "reflectronic",
          "CreatedAt": "2020-05-08T08:18:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36105",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Drawing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649761495",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36105#issuecomment-649761495",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Drawing.Imaging\r\n{\r\n\u002B   public sealed class CachedBitmap : MarshalByRefObject, IDisposable\r\n\u002B   {\r\n\u002B       public CachedBitmap(Bitmap bitmap, Graphics graphics);\r\n\u002B       public void Dispose();  \r\n\u002B   }\r\n} \r\n\r\nnamespace System.Drawing\r\n{\r\n    public sealed class Graphics : MarshalByRefObject, IDisposable, IDeviceContext\r\n    {\r\n\u002B       public void DrawCachedBitmap(CachedBitmap cachedBitmap, int x, int y);   \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 74070000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 101,
    "Date": "2020-06-26T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=R5G4scTRRNQ",
      "Id": "R5G4scTRRNQ",
      "StartDateTime": "2020-06-26T10:00:12-07:00",
      "EndDateTime": "2020-06-26T11:55:24-07:00",
      "Duration": 69120000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/R5G4scTRRNQ/mqdefault.jpg"
    },
    "Title": "Meta, System.Runtime",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33331,
          "Title": "Guarding calls to platform-specific APIs",
          "Author": "terrajobst",
          "CreatedAt": "2020-03-07T06:36:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33331",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-26T00:00:00-07:00",
        "FeedbackId": "650326500",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33331#issuecomment-650326500",
        "FeedbackMarkdown": "* We should rename \u0060TargetPlatformMinVersion\u0060\r\n    - It\u0027s a runtime concept, not a targeting concept\r\n* Can we change \u0060Platform\u0060 to \u0060OS\u0060?\r\n* \u0060MinimumPlatform\u0060 -\u003E \u0060MinimumOSPlatform\u0060\r\n* \u0060PlatformAttribute\u0060 should have an internal constructor\r\n* Add \u0060ObsoletedInPlatformAttribute.Message\u0060\r\n* \u0060RuntimeInformation\u0060\r\n    - \u0060IsOSPlatformOrLater\u0060 should also take a \u0060string\u0060\r\n    - \u0060IsOSPlatformEarlierThan\u0060 should also take a \u0060string\u0060\r\n    - The \u0060IsPlatformXXx\u0060 methods should be recognized by the JIT to be constant\r\n* \u0060OSPlatform\u0060\r\n    - Hide \u0060OSX\u0060\r\n    - Add \u0060macOS\u0060\r\n* Analyzer\r\n    - The analyzer should handle \u0060Debug.Assert\u0060 for these methods\r\n    - Should we support helpers methods? We concluded we don\u0027t need it yet",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37359,
          "Title": "OS compatibility analyzer",
          "Author": "buyaa-n",
          "CreatedAt": "2020-06-03T17:43:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37359",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Meta",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            },
            {
              "Name": "code-fixer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37359#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 48600000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 102,
    "Date": "2020-06-30T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=5w9Cbgr1HJY",
      "Id": "5w9Cbgr1HJY",
      "StartDateTime": "2020-06-30T11:04:39-07:00",
      "EndDateTime": "2020-06-30T12:16:26-07:00",
      "Duration": 43070000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5w9Cbgr1HJY/mqdefault.jpg"
    },
    "Title": "System.Data",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38028,
          "Title": "Async System.Data resultset and database schema APIs",
          "Author": "roji",
          "CreatedAt": "2020-06-17T14:05:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38028",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651967965",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38028#issuecomment-651967965",
        "FeedbackMarkdown": "* Instead of adding an interface member, we\u0027d prefer exposing a new virtual on \u0060DbDataReader\u0060 directly\r\n    - @ajcvickers will follow up to see why we had the extension method calling through the interface instead.\r\n* We avoid having more than two optional parameters b/c we found in UX studies that optional parameters are confusing\r\n    - We should mirror the sync version which has had three overloads\r\n    - Sadly all three were virtual and no overload accepts null (thus can\u0027t be chained)\r\n    - For consistency, we should follow this pattern.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbConnection\r\n    {\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(string collectionName, string[] restrictions, CancellationToken cancellationToken = default);\r\n    }\r\n\r\n    public partial class DbDataReader\r\n    {\r\n        public virtual Task\u003CDataTable\u003E GetSchemaTableAsync(CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CReadOnlyCollection\u003CDbColumn\u003E\u003E GetColumnSchemaAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DbConnection.GetSchemaAsync(CancellationToken)",
          "M:DbConnection.GetSchemaAsync(string,CancellationToken)",
          "M:DbConnection.GetSchemaAsync(string,string[],CancellationToken)",
          "M:DbDataReader.GetColumnSchemaAsync(CancellationToken)",
          "M:DbDataReader.GetSchemaTableAsync(CancellationToken)",
          "T:DbConnection",
          "T:DbDataReader"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34817,
          "Title": "Database-agnostic way to detect transient database errors",
          "Author": "roji",
          "CreatedAt": "2020-04-10T11:37:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34817",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651987951",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34817#issuecomment-651987951",
        "FeedbackMarkdown": "* Makes sense as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbException\r\n    {\r\n        public virtual bool IsTransient =\u003E false;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15540000000,
        "Apis": [
          "P:DbException.IsTransient",
          "T:DbException"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35601,
          "Title": "Introduce SqlState on DbException for standard cross-database errors",
          "Author": "roji",
          "CreatedAt": "2020-04-29T12:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35601",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651990751",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35601#issuecomment-651990751",
        "FeedbackMarkdown": "* Makes sense as proposed.\r\n* It seems if we had this, we could make the default implementation for \u0060DbException.IsTransient\u0060 (#34817) check whether \u0060SqlState\u0060 is not null and return true for transient SQLSTATE values.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbException\r\n    {\r\n        public virtual string? SqlState { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38870000000,
        "Apis": [
          "P:DbException.SqlState",
          "T:DbException"
        ]
      }
    ]
  },
  {
    "Id": 103,
    "Date": "2020-07-02T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=eDDX05uBtFc",
      "Id": "eDDX05uBtFc",
      "StartDateTime": "2020-07-02T10:04:18-07:00",
      "EndDateTime": "2020-07-02T12:54:02-07:00",
      "Duration": 101840000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/eDDX05uBtFc/mqdefault.jpg"
    },
    "Title": "Extensions-Logging, Interop-coreclr, System.Net.Http, System.Runtime.CompilerServices",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38133,
          "Title": "Add a new \u0060unmanaged\u0060 calling convention bit for use with function pointers",
          "Author": "tannergooding",
          "CreatedAt": "2020-06-19T00:27:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38133",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Interop-coreclr",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653130834",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38133#issuecomment-653130834",
        "FeedbackMarkdown": "Technically, the actual calling convention is expressed as modopt on the return type but we felt a vague name is good enough.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    public enum SignatureCallingConvention : byte\r\n    {\r\n        Unmanaged = 0x9\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:SignatureCallingConvention.Unmanaged",
          "T:SignatureCallingConvention"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38135,
          "Title": "\u0060System.Runtime.CompilerServices.RuntimeFeature.UnmanagedCallKind\u0060",
          "Author": "333fred",
          "CreatedAt": "2020-06-19T00:46:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38135",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653135036",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38135#issuecomment-653135036",
        "FeedbackMarkdown": "* We considered keying it off of the presence of the attribute but the attribute isn\u0027t the same feature. Also, the compiler would want the type to exist in corlib (to ensure it\u0027s not user defined). That would feel odd, considering all modifiers live in \u0060System.Runtime.InteropServices.dll\u0060.\r\n* We agree that making that \u0060RuntimeFeature\u0060 a dumping ground for all new compiler features would be bad, but it seems runtime type system constraints would be long to \u0060RuntimeFeature\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeFeature\r\n    {\r\n        public const string UnmanagedSignatureCallingConvention = nameof(UnmanagedSignatureCallingConvention);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10940000000,
        "Apis": [
          "F:RuntimeFeature.UnmanagedSignatureCallingConvention",
          "T:RuntimeFeature"
        ]
      },
      {
        "Id": 3,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38683,
          "Title": "Add NativeIntegerAttribute",
          "Author": "cston",
          "CreatedAt": "2020-07-01T21:39:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38683",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653136856",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38683#issuecomment-653136856",
        "FeedbackMarkdown": "* We didn\u0027t add \u0060NullableAttribute\u0060. We only added attributes that we expect users to reference explicitly by manually adding custom attributes. It seems this attribute would only be emitted and read by the compiler, so unless there is a reason, we\u0027d not add it.\r\n* Please reopen otherwise.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(\r\n        AttributeTargets.Class |\r\n        AttributeTargets.Event |\r\n        AttributeTargets.Field |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property |\r\n        AttributeTargets.ReturnValue,\r\n        AllowMultiple = false,\r\n        Inherited = false)]\r\n    public sealed class NativeIntegerAttribute : Attribute\r\n    {\r\n        public NativeIntegerAttribute()\r\n        {\r\n            TransformFlags = new[] { true };\r\n        }\r\n        public NativeIntegerAttribute(bool[] flags)\r\n        {\r\n            TransformFlags = flags;\r\n        }\r\n        public IList\u003Cbool\u003E TransformFlags { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16660000000,
        "Apis": [
          "M:NativeIntegerAttribute.NativeIntegerAttribute()",
          "M:NativeIntegerAttribute.NativeIntegerAttribute(bool[])",
          "P:NativeIntegerAttribute.TransformFlags",
          "T:NativeIntegerAttribute"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34742,
          "Title": "Flexible and efficient optionally-structured console logging out of the box",
          "Author": "jskeet",
          "CreatedAt": "2019-07-16T13:09:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34742",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Logging",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653193414",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34742#issuecomment-653193414",
        "FeedbackMarkdown": "* Drop \u0060Log\u0060 from names\r\n* Rename \u0060Default\u0060 so something that doesn\u0027t imply a subset relationship, such as \u0060Simple\u0060\r\n* Implementers of \u0060IConsoleFormatter\u0060 should use VT100 for colors\r\n* On Windows 7 we still want to show colors, not VT100 escape sequences\r\n* On Windows 10\u002B we want to see colors, not VT100 escape sequences, even if VT100 processing is off\r\n* Should .NET 5 by default enable VT100 processing? @shirhatti will file an issue for that.\r\n\r\n**Assembly:** Microsoft.Extensions.Logging.Abstractions.dll\r\n\r\n\u0060\u0060\u0060diff\r\n namespace Microsoft.Extensions.Logging\r\n {\r\n\u002B    public readonly struct LogEntry\u003CTState\u003E\r\n\u002B    {\r\n\u002B       public LogEntry(LogLevel logLevel,\r\n\u002B                       string category,\r\n\u002B                       EventId eventId,\r\n\u002B                       TState state,\r\n\u002B                       Exception exception,\r\n\u002B                       Func\u003CTState, Exception, string\u003E formatter);\r\n\u002B       public LogLevel LogLevel { get; }\r\n\u002B       public string Category { get; }\r\n\u002B       public EventId EventId { get; }\r\n\u002B       public TState State { get; }\r\n\u002B       public Exception Exception { get; }\r\n\u002B       public Func\u003CTState, Exception, string\u003E Formatter { get; }\r\n\u002B    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Assembly:** Microsoft.Extensions.Logging.Console.dll\r\n\r\n\u0060\u0060\u0060diff\r\n namespace Microsoft.Extensions.Logging\r\n {\r\n     public static partial class ConsoleLoggerExtensions\r\n     {\r\n         public static ILoggingBuilder AddConsole(this ILoggingBuilder builder);\r\n         public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, Action\u003CConsoleLoggerOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddConsoleFormatter\u003CTFormatter, TOptions\u003E(this ILoggingBuilder builder)\r\n\u002B                                      where TFormatter : class, IConsoleFormatter where TOptions : ConsoleFormatterOptions;\r\n\u002B        public static ILoggingBuilder AddConsoleFormatter\u003CTFormatter, TOptions\u003E(this ILoggingBuilder builder, Action\u003CTOptions\u003E configure)\r\n\u002B                                      where TFormatter : class, IConsoleFormatter where TOptions : ConsoleFormatterOptions;\r\n\u002B        public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, Action\u003CSimpleConsoleFormatterOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder, Action\u003CJsonConsoleFormatterOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder, Action\u003CConsoleFormatterOptions\u003E configure);\r\n     }\r\n }\r\n namespace Microsoft.Extensions.Logging.Console\r\n {\r\n\u002B    public static partial class ConsoleFormatterNames\r\n\u002B    {\r\n\u002B        public const string Simple = \u0022simple\u0022;\r\n\u002B        public const string Json = \u0022json\u0022;\r\n\u002B        public const string Systemd = \u0022systemd\u0022;\r\n\u002B    }\r\n\u002B    [ObsoleteAttribute(\u0022ConsoleLoggerFormat has been deprecated.\u0022, false)]\r\n     public enum ConsoleLoggerFormat\r\n     {\r\n         Default = 0,\r\n         Systemd = 1,\r\n     }\r\n     public partial class ConsoleLoggerOptions\r\n     {\r\n         public ConsoleLoggerOptions();\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.DisableColors has been deprecated. Please use ColoredConsoleFormatterOptions.DisableColors instead.\u0022, false)]\r\n         public bool DisableColors { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.Format has been deprecated. Please use ConsoleLoggerOptions.FormatterName instead.\u0022, false)]\r\n         public ConsoleLoggerFormat Format { get; set; }\r\n         public string FormatterName { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.IncludeScopes has been deprecated..\u0022, false)]\r\n         public bool IncludeScopes { get; set; }\r\n         public LogLevel LogToStandardErrorThreshold { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.TimestampFormat has been deprecated..\u0022, false)]\r\n         public string TimestampFormat { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.UseUtcTimestamp has been deprecated..\u0022, false)]\r\n         public bool UseUtcTimestamp { get; set; }\r\n     }\r\n     [ProviderAliasAttribute(\u0022Console\u0022)]\r\n     public partial class ConsoleLoggerProvider : ILoggerProvider, ISupportExternalScope, IDisposable\r\n     {\r\n         public ConsoleLoggerProvider(IOptionsMonitor\u003CConsoleLoggerOptions\u003E options);\r\n\u002B        public ConsoleLoggerProvider(IOptionsMonitor\u003CConsoleLoggerOptions\u003E options, IEnumerable\u003CIConsoleFormatter\u003E formatters);\r\n         public ILogger CreateLogger(string name);\r\n         public void Dispose();\r\n         public void SetScopeProvider(IExternalScopeProvider scopeProvider);\r\n     }\r\n\u002B    public partial class SimpleConsoleFormatterOptions : ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public SimpleConsoleFormatterOptions();\r\n\u002B        public bool DisableColors { get; set; }\r\n\u002B        public bool SingleLine { get; set; }\r\n\u002B    }\r\n\u002B    public partial abstract ConsoleFormatter\r\n\u002B    {\r\n\u002B        protected ConsoleFormatter(string name);\r\n\u002B        public string Name { get; }\r\n\u002B        public abstract void Write\u003CTState\u003E(in LogEntry\u003CTState\u003E logEntry,\r\n\u002B                                           IExternalScopeProvider scopeProvider,\r\n\u002B                                           TextWriter textWriter);\r\n\u002B    }\r\n\u002B    public partial class JsonConsoleFormatterOptions : ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public JsonConsoleFormatterOptions();\r\n\u002B        public JsonWriterOptions JsonWriterOptions { get; set; }\r\n\u002B    }\r\n\u002B    public partial class ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public ConsoleFormatterOptions();\r\n\u002B        public bool IncludeScopes { get; set; }\r\n\u002B        public string TimestampFormat { get; set; }\r\n\u002B        public bool UseUtcTimestamp { get; set; }\r\n\u002B    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19280000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35088,
          "Title": "HTTP2: Create additional connections when maximum active streams is reached",
          "Author": "JamesNK",
          "CreatedAt": "2020-04-17T01:20:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35088",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653248184",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35088#issuecomment-653248184",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public int MaxHttp2ConnectionsPerServer { get; set; }\r\n    }   \r\n    public partial class WinHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.MaxHttp2ConnectionsPerServer",
          "P:WinHttpHandler.EnableMultipleHttp2Connections",
          "T:SocketsHttpHandler",
          "T:WinHttpHandler"
        ]
      }
    ]
  },
  {
    "Id": 104,
    "Date": "2020-07-07T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=9sjP8x1L93w",
      "Id": "9sjP8x1L93w",
      "StartDateTime": "2020-07-07T10:05:29-07:00",
      "EndDateTime": "2020-07-07T12:16:21-07:00",
      "Duration": 78520000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9sjP8x1L93w/mqdefault.jpg"
    },
    "Title": "System.Diagnostics.Tracing, System.Net.Http",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38419,
          "Title": "Improve Activity API usability and OpenTelemetry integration (Part 2)",
          "Author": "tarekgh",
          "CreatedAt": "2020-06-26T00:34:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38419",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-07T00:00:00-07:00",
        "FeedbackId": "655054487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38419#issuecomment-655054487",
        "FeedbackMarkdown": "[Spec](https://github.com/dotnet/designs/pull/134)\r\n\r\n* \u0060ActivityContext.IsRemote\u0060 sounds like the instance is remoted, which isn\u0027t the case, but we can\u0027t think of a better name.\r\n* Making \u0060Activity.Kind\u0060 settable seems very unfortunate. Given we do this backward compat only, we should find another way of doing this without making one of the key properties mutable. One option is to disallow changing after it was observed (whatever that means). The preferred option would be to find a way that doesn\u0027t require mutation (constructor parameter, factory method etc). This part requries more design.\r\n* \u0060Activity.Attributes\u0060 seems unfortunate b/c it adds more concepts.\r\n    - Add \u0060SetTag(string, object)\u0060\r\n    - Add \u0060AddTag(string, object)\u0060\r\n    - Add \u0060TagObjects\u0060\r\n    - The existing \u0060Tags\u0060 property should probably be marked as obsolete and return all convert all objects to string.\r\n* \u0060ActivityAttributesCollection\u0060 should be renamed to something \u0060ActivityTagsCollection\u0060\r\n* \u0060ActivityListener.PregenerateNewRootId\u0060 has complex policy so be it\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public readonly partial struct ActivityContext\r\n    {\r\n        // This constructor already exist but we are adding extra defaulted parameter for isRemote.\r\n        public ActivityContext(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags traceFlags, string? traceState = null, isRemote = false);\r\n\r\n        // This is the new property\r\n        public bool IsRemote { get; }\r\n    }\r\n    public partial class Activity\r\n    {\r\n        public void AddTag(string key, object value);\r\n        public void SetTag(string key, object value);\r\n        public IEnumerable\u003CKeyValuePair\u003Cstring, object\u003E\u003E TagObjects { get; }\r\n    }\r\n    public readonly struct ActivityEvent\r\n    {\r\n        public ActivityEvent(string name);\r\n        public ActivityEvent(string name, DateTimeOffset? timestamp = null, ActivityTagsCollection? tags = null);\r\n    }\r\n    public readonly partial struct ActivityLink  : IEquatable\u003CActivityLink\u003E\r\n    {\r\n        public ActivityLink(ActivityContext context, ActivityTagsCollection? tags = null);\r\n    }\r\n    public class ActivityTagsCollection : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Implements this[key] = value as deleting the key\r\n        // Add(key, null) should throw if key already exists, otherwise no-op\r\n        // Should meant that this[key] returns null for-non existing keys too\r\n    }\r\n    public sealed class ActivityListener\r\n    {\r\n        public bool AutoGenerateRootContextTraceId { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Activity.AddTag(string,object)",
          "M:Activity.SetTag(string,object)",
          "M:ActivityContext.ActivityContext(ActivityTraceId,ActivitySpanId,ActivityTraceFlags,string?,isRemote)",
          "M:ActivityEvent.ActivityEvent(string,DateTimeOffset?,ActivityTagsCollection?)",
          "M:ActivityEvent.ActivityEvent(string)",
          "M:ActivityLink.ActivityLink(ActivityContext,ActivityTagsCollection?)",
          "P:Activity.TagObjects",
          "P:ActivityContext.IsRemote",
          "P:ActivityListener.AutoGenerateRootContextTraceId",
          "T:Activity",
          "T:ActivityContext",
          "T:ActivityEvent",
          "T:ActivityLink",
          "T:ActivityListener",
          "T:ActivityTagsCollection"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-wasm",
              "BackgroundColor": "eb6420",
              "Description": "WebAssembly architecture",
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-07T00:00:00-07:00",
        "FeedbackId": "655067469",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-655067469",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public readonly struct HttpRequestOptionsKey\u003CTValue\u003E\r\n    {\r\n        public HttpRequestOptionsKey(string key);\r\n        public string Key { get; }\r\n    }\r\n    public sealed class HttpRequestOptions : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Explicit interface implementation\r\n        public bool TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, out TValue value);\r\n        public void Set\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, TValue value);\r\n    }\r\n    public class HttpRequestMessage : IDisposable\r\n    {\r\n        [Obsolete(\u0022Use Options instead.\u0022)]\r\n        public IDictionary\u003Cstring, object\u003E Properties =\u003E Options;\r\n\r\n        public HttpRequestOptions Options { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62560000000,
        "Apis": [
          "M:HttpRequestOptions.Set\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,TValue)",
          "M:HttpRequestOptions.TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,out TValue)",
          "M:HttpRequestOptionsKey\u003CTValue\u003E.HttpRequestOptionsKey(string)",
          "P:HttpRequestMessage.Options",
          "P:HttpRequestMessage.Properties",
          "P:HttpRequestOptionsKey\u003CTValue\u003E.Key",
          "T:HttpRequestMessage",
          "T:HttpRequestOptions",
          "T:HttpRequestOptionsKey\u003CTValue\u003E"
        ]
      }
    ]
  },
  {
    "Id": 105,
    "Date": "2020-07-09T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=Uu-vtMorrC0",
      "Id": "Uu-vtMorrC0",
      "StartDateTime": "2020-07-09T10:09:30-07:00",
      "EndDateTime": "2020-07-09T12:17:58-07:00",
      "Duration": 77080000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Uu-vtMorrC0/mqdefault.jpg"
    },
    "Title": "Extensions-Logging, System.Buffers, System.Composition, System.Net.Http, System.Runtime, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38467,
          "Title": "System.Formats.Cbor: Add Reader and Writer methods for System.Half.",
          "Author": "eiriktsarpalis",
          "CreatedAt": "2020-06-26T19:45:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38467",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38467#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38984,
          "Title": "Add PlatformID.Unknown value",
          "Author": "marek-safar",
          "CreatedAt": "2020-07-09T07:10:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38984",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-wasm",
              "BackgroundColor": "eb6420",
              "Description": "WebAssembly architecture",
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656250578",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38984#issuecomment-656250578",
        "FeedbackMarkdown": "API review suggests that \u0022Other\u0022 is a better name, since it is \u0022known\u0022 to not be one of the other values.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System\r\n{\r\n    public enum PlatformID\r\n    {\r\n        MacOSX = 6,\r\n\u002B       Other = 7,\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nAdditionally, if we haven\u0027t already done obsoletion plans for this enum and the things related to it, it\u0027s probably a good idea.",
        "TimeCode": 920000000,
        "Apis": []
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35060,
          "Title": "Request for Logging Internals to be public again",
          "Author": "JakenVeina",
          "CreatedAt": "2020-02-24T03:32:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35060",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Logging",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656257152",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35060#issuecomment-656257152",
        "FeedbackMarkdown": "Adding the DefineScope T4-T6 for parity is approved.  If you want to add further ones, that\u0027s also approved, but in the review the comments were \u0022why stop at 8?\u0022 and \u0022do we need 7 and 8?\u0022.  If there\u0027s need for this, then they\u0027re approved.  If not, then maybe hold off.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\n    public static partial class LoggerMessage\r\n    {\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4\u003E(string formatString) { throw null; }\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4, T5\u003E(string formatString) { throw null; }\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, T6, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4, T5, T6\u003E(string formatString) { throw null; }\r\n    }",
        "TimeCode": 3570000000,
        "Apis": [
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4, T5, T6\u003E(string)",
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4, T5\u003E(string)",
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4\u003E(string)",
          "T:LoggerMessage"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38711,
          "Title": "Http header value Encoding selection",
          "Author": "MihaZupan",
          "CreatedAt": "2020-07-02T16:11:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38711",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656265904",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38711#issuecomment-656265904",
        "FeedbackMarkdown": "* ResponseHeaderEncodingSelector changed to using the request message, not the response, because of complexities of mutation across calls.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    // \u0022RequestHeaderEncodingSelector\u0022 in Kestrel\r\n\r\n    public sealed class SocketsHttpHandler\r\n    {\r\n        public Func\u003Cstring, HttpRequestMessage, Encoding?\u003E? RequestHeaderEncodingSelector { get; set; }\r\n        public Func\u003Cstring, HttpRequestMessage, Encoding?\u003E? ResponseHeaderEncodingSelector { get; set; }\r\n    }\r\n    \r\n    public class MultipartContent\r\n    {\r\n        public Func\u003Cstring, HttpContent, Encoding?\u003E? HeaderEncodingSelector { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nSince the \u0060string\u0060 argument in the Func is not obviously a headerName value, consider using a custom delegate to name the parameter:\r\n\r\n\u0060\u0060\u0060C#\r\npublic delegate Encoding? HeaderEncodingSelector\u003CTContext\u003E(string headerName, TContext context);\r\n\u0060\u0060\u0060",
        "TimeCode": 14010000000,
        "Apis": [
          "P:MultipartContent.HeaderEncodingSelector",
          "P:SocketsHttpHandler.RequestHeaderEncodingSelector",
          "P:SocketsHttpHandler.ResponseHeaderEncodingSelector",
          "T:HeaderEncodingSelector\u003CTContext\u003E(string,TContext)",
          "T:MultipartContent",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17590,
          "Title": "Add static hash helper methods",
          "Author": "GSPP",
          "CreatedAt": "2016-06-12T13:24:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17590",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656269790",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17590#issuecomment-656269790",
        "FeedbackMarkdown": "Approved as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MD5\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA1\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA256\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA384\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA512\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25490000000,
        "Apis": [
          "M:MD5.Hash(byte[])",
          "M:MD5.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:MD5.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:MD5.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA1.Hash(byte[])",
          "M:SHA1.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA1.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA1.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA256.Hash(byte[])",
          "M:SHA256.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA256.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA256.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA384.Hash(byte[])",
          "M:SHA384.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA384.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA384.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA512.Hash(byte[])",
          "M:SHA512.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA512.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA512.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "T:MD5",
          "T:SHA1",
          "T:SHA256",
          "T:SHA384",
          "T:SHA512"
        ]
      },
      {
        "Id": 6,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27655,
          "Title": "Add EnumMemberAttribute constructor",
          "Author": "TylerBrinkley",
          "CreatedAt": "2018-10-17T16:15:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27655",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "BackgroundColor": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656275959",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27655#issuecomment-656275959",
        "FeedbackMarkdown": "Since the property is already settable, our guidelines say that it can\u0027t also be a constructor parameter -- largely because it makes reading attributes harder via metadata readers.\r\n\r\n\u003E DO NOT provide constructor parameters to initialize properties corresponding to the optional arguments.",
        "TimeCode": 30490000000,
        "Apis": []
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29400,
          "Title": "Proposal: Inject existing object into MEF2",
          "Author": "gthvidsten",
          "CreatedAt": "2019-04-27T18:08:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29400",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "api-suggestion",
              "BackgroundColor": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Composition",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "enhancement",
              "BackgroundColor": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656282604",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29400#issuecomment-656282604",
        "FeedbackMarkdown": "After some discussion on the name of the methods, the use of defaults parameters, and the name of the generic, it\u0027s approved as\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Composition.Hosting\r\n{\r\n    public class ContainerConfiguration\r\n    {\r\n        public ContainerConfiguration WithExport\u003CTExport\u003E(TExport exportedInstance);\r\n        public ContainerConfiguration WithExport\u003CTExport\u003E(TExport exportedInstance, string? contractName = null, IDictionary\u003Cstring, object\u003E? metadata = null);\r\n\r\n        public ContainerConfiguration WithExport(Type contractType, object exportedInstance);\r\n        public ContainerConfiguration WithExport(Type contractType, object exportedInstance, string? contractName = null, IDictionary\u003Cstring, object\u003E? metadata = null);\r\n    }\r\n} \r\n\u0060\u0060\u0060\r\n\r\nWe also think it would be valueable to add an analyzer that warns when generic inference was used.  (e.g. \u0060WithExport(new SomeExportedType())\u0060)",
        "TimeCode": 38390000000,
        "Apis": [
          "M:ContainerConfiguration.WithExport(Type,object,string?,IDictionary\u003Cstring, object\u003E?)",
          "M:ContainerConfiguration.WithExport(Type,object)",
          "M:ContainerConfiguration.WithExport\u003CTExport\u003E(TExport,string?,IDictionary\u003Cstring, object\u003E?)",
          "M:ContainerConfiguration.WithExport\u003CTExport\u003E(TExport)",
          "T:ContainerConfiguration"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31355,
          "Title": "SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E sequence, ReadOnlySpan\u003CT\u003E delimiter)",
          "Author": "davidfowl",
          "CreatedAt": "2019-10-31T03:20:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31355",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Buffers",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656291313",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31355#issuecomment-656291313",
        "FeedbackMarkdown": "After much debate, approved as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial ref struct SequenceReader\r\n{\r\n    public bool TryReadTo(out ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E delimiter, bool advancePastDelimiter = true);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 47200000000,
        "Apis": [
          "M:SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,bool)",
          "T:SequenceReader"
        ]
      }
    ]
  },
  {
    "Id": 106,
    "Date": "2020-07-10T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=PlhWVNciJm4",
      "Id": "PlhWVNciJm4",
      "StartDateTime": "2020-07-10T10:08:05-07:00",
      "EndDateTime": "2020-07-10T11:59:53-07:00",
      "Duration": 67080000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PlhWVNciJm4/mqdefault.jpg"
    },
    "Title": "System.Collections, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17590,
          "Title": "Add static hash helper methods",
          "Author": "GSPP",
          "CreatedAt": "2016-06-12T13:24:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17590",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656829666",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17590#issuecomment-656829666",
        "FeedbackMarkdown": "We discussed this again, and accepted HashData.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MD5\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA1\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA256\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA384\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA512\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61450000000,
        "Apis": [
          "M:MD5.HashData(byte[])",
          "M:MD5.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:MD5.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:MD5.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA1.HashData(byte[])",
          "M:SHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA1.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA1.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA256.HashData(byte[])",
          "M:SHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA256.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA256.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA384.HashData(byte[])",
          "M:SHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA384.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA384.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA512.HashData(byte[])",
          "M:SHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA512.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA512.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "T:MD5",
          "T:SHA1",
          "T:SHA256",
          "T:SHA384",
          "T:SHA512"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37681,
          "Title": "Expose a ValueRef property on LinkedListNode\u003CT\u003E",
          "Author": "tannergooding",
          "CreatedAt": "2020-06-10T00:43:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37681",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Collections",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656831777",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37681#issuecomment-656831777",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public partial class LinkedListNode\u003CT\u003E\r\n    {\r\n        public ref T ValueRef { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61550000000,
        "Apis": [
          "P:LinkedListNode\u003CT\u003E.ValueRef",
          "T:LinkedListNode\u003CT\u003E"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35869,
          "Title": "Make IncrementalHash.CreateHMAC ReadOnlySpan\u003Cbyte\u003E key public",
          "Author": "vcsjones",
          "CreatedAt": "2020-05-05T23:36:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35869",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656833490",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35869#issuecomment-656833490",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n     public partial class IncrementalHash\r\n     {\r\n        public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan\u003Cbyte\u003E key);\r\n     }\r\n }",
        "TimeCode": 64080000000,
        "Apis": [
          "M:IncrementalHash.CreateHMAC(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E)",
          "T:IncrementalHash"
        ]
      }
    ]
  },
  {
    "Id": 107,
    "Date": "2020-07-14T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=Cw-kYXQ7Sw8",
      "Id": "Cw-kYXQ7Sw8",
      "StartDateTime": "2020-07-14T10:10:21-07:00",
      "EndDateTime": "2020-07-14T12:06:22-07:00",
      "Duration": 69610000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Cw-kYXQ7Sw8/mqdefault.jpg"
    },
    "Title": "System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30255,
          "Title": "System.Text.Json: (De)serialization support for quoted numbers ",
          "Author": "NickCraver",
          "CreatedAt": "2019-07-15T00:32:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30255",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-14T00:00:00-07:00",
        "FeedbackId": "658313884",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30255#issuecomment-658313884",
        "FeedbackMarkdown": "* Looks good.\r\n* We should have a discussion around defaults for .NET 5, especially web.\r\n* We decided to rename \u0060JsonNumberHandling.None\u0060 an \u0060JsonNumberHandling.Strict\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial sealed class JsonSerializerOptions\r\n    {\r\n        public JsonNumberHandling NumberHandling { get; set; }\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    [Flags]\r\n    public enum JsonNumberHandling\r\n    {\r\n        Strict = 0x0,\r\n        AllowReadingFromString = 0x1,\r\n        WriteAsString = 0x2,\r\n        AllowNamedFloatingPointLiterals = 0x4\r\n    }\r\n\r\n    [AttributeUsage(\r\n        AttributeTargets.Class |\r\n        AttributeTargets.Struct |\r\n        AttributeTargets.Property |\r\n        AttributeTargets.Field, AllowMultiple = false)]\r\n    public partial sealed class JsonNumberHandlingAttribute : JsonAttribute\r\n    {\r\n        public JsonNumberHandlingAttribute(JsonNumberHandling handling);\r\n        public JsonNumberHandling Handling { get; }    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:JsonNumberHandling.AllowNamedFloatingPointLiterals",
          "F:JsonNumberHandling.AllowReadingFromString",
          "F:JsonNumberHandling.Strict",
          "F:JsonNumberHandling.WriteAsString",
          "M:JsonNumberHandlingAttribute.JsonNumberHandlingAttribute(JsonNumberHandling)",
          "P:JsonNumberHandlingAttribute.Handling",
          "P:JsonSerializerOptions.NumberHandling",
          "T:JsonNumberHandling",
          "T:JsonNumberHandlingAttribute",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39152,
          "Title": "System.Text.Json: Ignore null values while serializing",
          "Author": "molinch",
          "CreatedAt": "2020-07-12T06:29:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39152",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-14T00:00:00-07:00",
        "FeedbackId": "658319929",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39152#issuecomment-658319929",
        "FeedbackMarkdown": "* Makes perfect sense.\r\n\r\n\u0060\u0060\u0060C#\r\npublic enum JsonIgnoreCondition\r\n{\r\n    // Never = 0,\r\n    // Always = 1,\r\n    // WhenWritingDefault = 2,\r\n    WhenWritingNull = 3\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14760000000,
        "Apis": [
          "F:JsonIgnoreCondition.WhenWritingNull",
          "T:JsonIgnoreCondition"
        ]
      }
    ]
  },
  {
    "Id": 108,
    "Date": "2020-07-16T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=7YpDyRMaDKE",
      "Id": "7YpDyRMaDKE",
      "StartDateTime": "2020-07-16T10:00:51-07:00",
      "EndDateTime": "2020-07-16T12:11:04-07:00",
      "Duration": 78130000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7YpDyRMaDKE/mqdefault.jpg"
    },
    "Title": "Interop-coreclr, System.Diagnostics, System.Globalization, System.IO, System.IO.Compression, System.Runtime.CompilerServices, System.Runtime.InteropServices, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2214,
          "Title": "File.ReadLinesAsync",
          "Author": "khellang",
          "CreatedAt": "2020-01-27T10:03:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659551371",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2214#issuecomment-659551371",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* The \u0060[EnumeratorCancellation]\u0060 attribute might be needed in the implementation if we use \u0060yield return\u0060, but it doesn\u0027t have to be part of the ref.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n        public static IAsyncEnumerable\u003Cstring\u003E ReadLinesAsync(string path, CancellationToken cancellationToken = default);\r\n        public static IAsyncEnumerable\u003Cstring\u003E ReadLinesAsync(string path, System.Text.Encoding encoding, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:File.ReadLinesAsync(string,CancellationToken)",
          "M:File.ReadLinesAsync(string,System.Text.Encoding,CancellationToken)",
          "T:File"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 3570,
          "Title": "Add \u0060IDeviceContext\u0060 to events that hold \u0060Graphics\u0060",
          "Author": "JeremyKuhne",
          "CreatedAt": "2020-07-13T19:00:24+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/3570",
          "Milestone": "5.0 RC1",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659555018",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/3570#issuecomment-659555018",
        "FeedbackMarkdown": "* We should implement \u0060IDisposable\u0060 following the dispose pattern if (1) the type doesn\u0027t already implement \u0060IDisposable\u0060 and (2) the type isn\u0027t sealed.\r\n* \u0060IDeviceContext\u0060 should be implemented explicitly.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class PaintEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawItemEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DataGridViewRowPostPaintEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawListViewItemEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawToolTipEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawTreeNodeEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripArrowRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripContentPanelRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripItemRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripPanelRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8380000000,
        "Apis": [
          "T:DataGridViewRowPostPaintEventArgs",
          "T:DrawItemEventArgs",
          "T:DrawListViewItemEventArgs",
          "T:DrawToolTipEventArgs",
          "T:DrawTreeNodeEventArgs",
          "T:PaintEventArgs",
          "T:ToolStripArrowRenderEventArgs",
          "T:ToolStripContentPanelRenderEventArgs",
          "T:ToolStripItemRenderEventArgs",
          "T:ToolStripPanelRenderEventArgs",
          "T:ToolStripRenderEventArgs"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 13788,
          "Title": "Expose CLong, CULong, and NFloat interchange types",
          "Author": "tannergooding",
          "CreatedAt": "2019-11-12T21:17:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/13788",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Interop-coreclr",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659573076",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/13788#issuecomment-659573076",
        "FeedbackMarkdown": "* Looks good\r\n* We should add ctors for the smaller sizes.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public readonly struct CLong : IEquatable\u003CCLong\u003E\r\n    {\r\n        public CLong(int value);\r\n        public CLong(nint value);\r\n        public nint Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(CLong other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public readonly struct CULong : IEquatable\u003CCULong\u003E\r\n    {\r\n        public CULong(uint value);\r\n        public CULong(nuint value);\r\n        public nuint Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(CULong other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public readonly struct NFloat : IEquatable\u003CNFloat\u003E\r\n    {\r\n        public NFloat(float value);\r\n        public NFloat(double value);\r\n        public double Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(NFloat other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19570000000,
        "Apis": [
          "M:CLong.CLong(int)",
          "M:CLong.CLong(nint)",
          "M:CLong.Equals(CLong)",
          "M:CLong.Equals(object)",
          "M:CLong.GetHashCode()",
          "M:CLong.ToString()",
          "M:CULong.CULong(nuint)",
          "M:CULong.CULong(uint)",
          "M:CULong.Equals(CULong)",
          "M:CULong.Equals(object)",
          "M:CULong.GetHashCode()",
          "M:CULong.ToString()",
          "M:NFloat.Equals(NFloat)",
          "M:NFloat.Equals(object)",
          "M:NFloat.GetHashCode()",
          "M:NFloat.NFloat(double)",
          "M:NFloat.NFloat(float)",
          "M:NFloat.ToString()",
          "P:CLong.Value",
          "P:CULong.Value",
          "P:NFloat.Value",
          "T:CLong",
          "T:CULong",
          "T:NFloat"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 413,
          "Title": "ECDiffieHellman X509 certificate management gaps",
          "Author": "CodeBlanch",
          "CreatedAt": "2019-11-30T20:24:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/413",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659580892",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/413#issuecomment-659580892",
        "FeedbackMarkdown": "* Makes sense, but we should make them proper instance methods, especially because the implementation private state of \u0060X509Certificate2\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public partial class X509Certificate2\r\n    {\r\n        public X509Certificate2 CopyWithPrivateKey(ECDiffieHellman privateKey);\r\n        public ECDiffieHellman GetECDiffieHellmanPrivateKey();\r\n        public ECDiffieHellman GetECDiffieHellmanPublicKey();\r\n    }\r\n    public partial class PublicKey\r\n    {\r\n        public PublicKey(AsymmetricAlgorithm key);\r\n        public bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public byte[] ExportSubjectPublicKeyInfo();\r\n        public static PublicKey CreateFromSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32050000000,
        "Apis": [
          "M:PublicKey.CreateFromSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E,out int)",
          "M:PublicKey.ExportSubjectPublicKeyInfo()",
          "M:PublicKey.PublicKey(AsymmetricAlgorithm)",
          "M:PublicKey.TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E,out int)",
          "M:X509Certificate2.CopyWithPrivateKey(ECDiffieHellman)",
          "M:X509Certificate2.GetECDiffieHellmanPrivateKey()",
          "M:X509Certificate2.GetECDiffieHellmanPublicKey()",
          "T:PublicKey",
          "T:X509Certificate2"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 587,
          "Title": "export SPKI on ECDiffieHellmanPublicKey",
          "Author": "vcsjones",
          "CreatedAt": "2019-12-05T20:45:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/587",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659582856",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/587#issuecomment-659582856",
        "FeedbackMarkdown": "* Makes sense. The implementation will throw \u0060NotSupportedException\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public abstract partial class ECDiffieHellmanPublicKey\r\n    {\r\n        public virtual bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public virtual byte[] ExportSubjectPublicKeyInfo();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40380000000,
        "Apis": [
          "M:ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo()",
          "M:ECDiffieHellmanPublicKey.TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E,out int)",
          "T:ECDiffieHellmanPublicKey"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 783,
          "Title": "New custom attribute required to support C\u002B\u002B inline namespaces",
          "Author": "tgani-msft",
          "CreatedAt": "2019-12-12T00:55:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/783",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659584823",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/783#issuecomment-659584823",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* @jkotas pointed out that you may no longer need it. If you don\u0027t, please close this issue. If you do, consider it approved.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=true)]\r\n    public sealed class CppInlineNamespaceAttribute : Attribute\r\n    {\r\n        public CppInlineNamespaceAttribute(string dottedName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42700000000,
        "Apis": [
          "M:CppInlineNamespaceAttribute.CppInlineNamespaceAttribute(string)",
          "T:CppInlineNamespaceAttribute"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2236,
          "Title": "Add support for zlib data format (RFC 1950)",
          "Author": "Ryder25",
          "CreatedAt": "2020-01-27T18:01:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2236",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO.Compression",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659590517",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2236#issuecomment-659590517",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Compression\r\n{\r\n    public class ZLibStream : Stream\r\n    {\r\n        public ZLibStream(Stream stream, CompressionLevel compressionLevel);\r\n        public ZLibStream(Stream stream, CompressionMode mode);\r\n        public ZLibStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);\r\n        public ZLibStream(Stream stream, CompressionMode mode, bool leaveOpen);\r\n        public Stream BaseStream { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45110000000,
        "Apis": [
          "M:ZLibStream.ZLibStream(Stream,CompressionLevel,bool)",
          "M:ZLibStream.ZLibStream(Stream,CompressionLevel)",
          "M:ZLibStream.ZLibStream(Stream,CompressionMode,bool)",
          "M:ZLibStream.ZLibStream(Stream,CompressionMode)",
          "P:ZLibStream.BaseStream",
          "T:ZLibStream"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2340,
          "Title": "IComparable for Rune",
          "Author": "Entomy",
          "CreatedAt": "2020-01-29T14:01:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2340",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Globalization",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659592809",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2340#issuecomment-659592809",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We should consider doing an analyzer that flags that. @terrajobst to file a request.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial struct Rune : IComparable\u003CRune\u003E, IComparable\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51730000000,
        "Apis": [
          "T:Rune"
        ]
      },
      {
        "Id": 9,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35692,
          "Title": "Do not use [Out] string for P/Invokes",
          "Author": "elinor-fung",
          "CreatedAt": "2020-05-01T02:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35692",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659595195",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35692#issuecomment-659595195",
        "FeedbackMarkdown": "The analyzer/fixer makes sense.",
        "TimeCode": 53830000000,
        "Apis": []
      },
      {
        "Id": 10,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35693,
          "Title": "Avoid StringBuilder parameters for P/Invokes",
          "Author": "elinor-fung",
          "CreatedAt": "2020-05-01T02:21:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35693",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659597092",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35693#issuecomment-659597092",
        "FeedbackMarkdown": "Shipping this as a warning and off by default makes sense. Setting the severity as suggestion would likely mean that nobody will ever see this.",
        "TimeCode": 57280000000,
        "Apis": []
      },
      {
        "Id": 11,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35695,
          "Title": "Prefer ExactSpelling=true on [DllImport] for known APIs",
          "Author": "elinor-fung",
          "CreatedAt": "2020-05-01T02:29:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35695",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659601306",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35695#issuecomment-659601306",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 59230000000,
        "Apis": []
      },
      {
        "Id": 12,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38076,
          "Title": "CryptoStream.FlushFinalBlockAsync method missing",
          "Author": "rupertsciamenna89",
          "CreatedAt": "2020-06-18T09:12:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38076",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659602801",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38076#issuecomment-659602801",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    partial class CryptoStream\r\n    {\r\n        public ValueTask FlushFinalBlockAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64570000000,
        "Apis": [
          "M:CryptoStream.FlushFinalBlockAsync(CancellationToken)",
          "T:CryptoStream"
        ]
      },
      {
        "Id": 13,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38238,
          "Title": "Attribute and analyzer for \u0022soft abstract\u0022",
          "Author": "terrajobst",
          "CreatedAt": "2020-06-22T22:25:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38238",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "code-analyzer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer",
              "ForegroundColor": "white"
            },
            {
              "Name": "code-fixer",
              "BackgroundColor": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659610010",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38238#issuecomment-659610010",
        "FeedbackMarkdown": "* We like the analzyer and we\u0027re OK with that not being handled by all languages\r\n    - @terrajobst to fill in more details after the meeting\r\n* The analyzer should only consider missing overrides in the direct base type. Warning on more derived base types isn\u0027t useful because the base type is most likely the one that would need to provide behavior.\r\n* We should do a scan for all types that have virtuals that throw\r\n* We should think about how and if we differentiate \u0022this always throw\u0022, \u0022this is an optional feature\u0022, \u0022this a less performant implementation, please provide a better one\u0022 so that we can differentiate the diagnostic ID/severity accordingly.",
        "TimeCode": 66310000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 109,
    "Date": "2020-07-17T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=n4Pq8e9OlpI",
      "Id": "n4Pq8e9OlpI",
      "StartDateTime": "2020-07-17T10:04:39-07:00",
      "EndDateTime": "2020-07-17T12:08:04-07:00",
      "Duration": 74050000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/n4Pq8e9OlpI/mqdefault.jpg"
    },
    "Title": "System.Net",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1793,
          "Title": "Connection Abstractions",
          "Author": "scalablecory",
          "CreatedAt": "2020-01-16T01:12:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1793",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-17T00:00:00-07:00",
        "FeedbackId": "660289247",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1793#issuecomment-660289247",
        "FeedbackMarkdown": "* Approved. We\u0027re done with it!\r\n\r\n\u0060\u0060\u0060C#\r\npublic abstract class ConnectionBase : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionBase();\r\n    public abstract IConnectionProperties ConnectionProperties { get; }\r\n    public abstract EndPoint? LocalEndPoint { get; }\r\n    public abstract EndPoint? RemoteEndPoint { get; }\r\n    public ValueTask CloseAsync(ConnectionCloseMethod method = ConnectionCloseMethod.GracefulShutdown, CancellationToken cancellationToken = default);\r\n    protected abstract ValueTask CloseAsyncCore(System.Net.Connections.ConnectionCloseMethod method, CancellationToken cancellationToken);\r\n}\r\n\r\npublic enum ConnectionCloseMethod\r\n{\r\n    GracefulShutdown,\r\n    Abort,\r\n    Immediate,\r\n}\r\n\r\n// needs review: FromPipe with disposable.\r\npublic abstract class Connection : ConnectionBase\r\n{\r\n    protected Connection();\r\n    public IDuplexPipe Pipe { get; }\r\n    public Stream Stream { get; }\r\n    protected virtual IDuplexPipe CreatePipe();\r\n    protected virtual Stream CreateStream();\r\n    public static Connection FromPipe(IDuplexPipe pipe, bool leaveOpen = false, IConnectionProperties? properties = null, EndPoint? localEndPoint = null, EndPoint? remoteEndPoint = null);\r\n    public static Connection FromStream(Stream stream, bool leaveOpen = false, IConnectionProperties? properties = null, EndPoint? localEndPoint = null, EndPoint? remoteEndPoint = null);\r\n}\r\n\r\npublic static class ConnectionExtensions\r\n{\r\n    public static ConnectionFactory Filter(this ConnectionFactory factory, Func\u003CConnection, IConnectionProperties?, CancellationToken, ValueTask\u003CConnection\u003E\u003E filter);\r\n    public static bool TryGet\u003CT\u003E(this IConnectionProperties properties, [MaybeNullWhenAttribute(false)] out T property);\r\n}\r\n\r\npublic abstract class ConnectionFactory : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionFactory();\r\n    public abstract ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic abstract class ConnectionListener : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionListener();\r\n    public abstract IConnectionProperties ListenerProperties { get; }\r\n    public abstract EndPoint? LocalEndPoint { get; }\r\n    public abstract ValueTask\u003CConnection\u003E AcceptAsync(IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic abstract class ConnectionListenerFactory : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionListenerFactory();\r\n    public abstract ValueTask\u003CConnectionListener\u003E BindAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic interface IConnectionProperties\r\n{\r\n    bool TryGet(Type propertyKey, [NotNullWhenAttribute(true)] out object? property);\r\n}\r\n\r\n// needs review. adding to existing class.\r\npublic class SocketsHttpHandler\r\n{\r\n    public ConnectionFactory? ConnectionFactory { get; set; }\r\n    public Func\u003CHttpRequestMessage, Connection, CancellationToken, ValueTask\u003CConnection\u003E\u003E? PlaintextFilter { get; set; }\r\n}\r\n\r\n// needs review\r\npublic class SocketsHttpConnectionFactory : ConnectionFactory\r\n{\r\n    public SocketsHttpConnectionFactory();\r\n    public sealed override ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual Socket CreateSocket(HttpRequestMessage message, EndPoint? endPoint, IConnectionProperties options);\r\n    protected virtual ValueTask\u003CConnection\u003E EstablishConnectionAsync(HttpRequestMessage message, EndPoint? endPoint, IConnectionProperties options, CancellationToken cancellationToken);\r\n}\r\n\r\n// needs review.\r\nclass SocketsConnectionFactory : ConnectionFactory\r\n{\r\n    // dual-mode IPv6 socket. See Socket(SocketType socketType, ProtocolType protocolType)\r\n    public SocketsConnectionFactory(SocketType socketType, ProtocolType protocolType);\r\n\r\n    // See Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)\r\n    public SocketsConnectionFactory(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);\r\n\r\n    public override ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n\r\n    // These exist to provide an easy way to shim the default behavior.\r\n    // A more idiomatic (but more API-heavy) way to do this would be to pass some sort of ISocketConfiguration that has all the pre-connect socket options one could want.\r\n    protected virtual Socket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, EndPoint? endPoint, IConnectionProperties? options);\r\n    protected virtual Stream CreateStream(Socket socket, IConnectionProperties? options);\r\n    protected virtual IDuplexPipe CreatePipe(Socket socket, IConnectionProperties? options);\r\n}\r\n\r\n// needs review.\r\nclass SocketsListenerFactory : ConnectionListenerFactory\r\n{\r\n    // dual-mode IPv6 socket. See Socket(SocketType socketType, ProtocolType protocolType)\r\n    public SocketsListenerFactory(SocketType socketType, ProtocolType protocolType);\r\n\r\n    // See Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)\r\n    public SocketsListenerFactory(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);\r\n\r\n    public override ValueTask\u003CConnectionListener\u003E BindAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n\r\n    // These exist to provide an easy way for users to override default behavior.\r\n    // A more idiomatic (but more API-heavy) way to do this would be to pass some sort of ISocketConfiguration that has all the pre-connect socket options one could want.\r\n    protected virtual Socket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, EndPoint? endPoint, IConnectionProperties? options);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ConnectionCloseMethod.Abort",
          "F:ConnectionCloseMethod.GracefulShutdown",
          "F:ConnectionCloseMethod.Immediate",
          "M:Connection.Connection()",
          "M:Connection.CreatePipe()",
          "M:Connection.CreateStream()",
          "M:Connection.FromPipe(IDuplexPipe,bool,IConnectionProperties?,EndPoint?,EndPoint?)",
          "M:Connection.FromStream(Stream,bool,IConnectionProperties?,EndPoint?,EndPoint?)",
          "M:ConnectionBase.CloseAsync(ConnectionCloseMethod,CancellationToken)",
          "M:ConnectionBase.CloseAsyncCore(System.Net.Connections.ConnectionCloseMethod,CancellationToken)",
          "M:ConnectionBase.ConnectionBase()",
          "M:ConnectionExtensions.Filter(this ConnectionFactory,Func\u003CConnection, IConnectionProperties?, CancellationToken, ValueTask\u003CConnection\u003E\u003E)",
          "M:ConnectionExtensions.TryGet\u003CT\u003E(this IConnectionProperties,out T)",
          "M:ConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:ConnectionFactory.ConnectionFactory()",
          "M:ConnectionFactory.Dispose(bool)",
          "M:ConnectionFactory.DisposeAsyncCore()",
          "M:ConnectionListener.AcceptAsync(IConnectionProperties?,CancellationToken)",
          "M:ConnectionListener.ConnectionListener()",
          "M:ConnectionListener.Dispose(bool)",
          "M:ConnectionListener.DisposeAsyncCore()",
          "M:ConnectionListenerFactory.BindAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:ConnectionListenerFactory.ConnectionListenerFactory()",
          "M:ConnectionListenerFactory.Dispose(bool)",
          "M:ConnectionListenerFactory.DisposeAsyncCore()",
          "M:IConnectionProperties.TryGet(Type,out object?)",
          "M:SocketsConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsConnectionFactory.CreatePipe(Socket,IConnectionProperties?)",
          "M:SocketsConnectionFactory.CreateSocket(AddressFamily,SocketType,ProtocolType,EndPoint?,IConnectionProperties?)",
          "M:SocketsConnectionFactory.CreateStream(Socket,IConnectionProperties?)",
          "M:SocketsConnectionFactory.SocketsConnectionFactory(AddressFamily,SocketType,ProtocolType)",
          "M:SocketsConnectionFactory.SocketsConnectionFactory(SocketType,ProtocolType)",
          "M:SocketsHttpConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsHttpConnectionFactory.CreateSocket(HttpRequestMessage,EndPoint?,IConnectionProperties)",
          "M:SocketsHttpConnectionFactory.EstablishConnectionAsync(HttpRequestMessage,EndPoint?,IConnectionProperties,CancellationToken)",
          "M:SocketsHttpConnectionFactory.SocketsHttpConnectionFactory()",
          "M:SocketsListenerFactory.BindAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsListenerFactory.CreateSocket(AddressFamily,SocketType,ProtocolType,EndPoint?,IConnectionProperties?)",
          "M:SocketsListenerFactory.SocketsListenerFactory(AddressFamily,SocketType,ProtocolType)",
          "M:SocketsListenerFactory.SocketsListenerFactory(SocketType,ProtocolType)",
          "P:Connection.Pipe",
          "P:Connection.Stream",
          "P:ConnectionBase.ConnectionProperties",
          "P:ConnectionBase.LocalEndPoint",
          "P:ConnectionBase.RemoteEndPoint",
          "P:ConnectionListener.ListenerProperties",
          "P:ConnectionListener.LocalEndPoint",
          "P:SocketsHttpHandler.ConnectionFactory",
          "P:SocketsHttpHandler.PlaintextFilter",
          "T:Connection",
          "T:ConnectionBase",
          "T:ConnectionCloseMethod",
          "T:ConnectionExtensions",
          "T:ConnectionFactory",
          "T:ConnectionListener",
          "T:ConnectionListenerFactory",
          "T:IConnectionProperties",
          "T:SocketsConnectionFactory",
          "T:SocketsHttpConnectionFactory",
          "T:SocketsHttpHandler",
          "T:SocketsListenerFactory"
        ]
      }
    ]
  },
  {
    "Id": 110,
    "Date": "2020-07-21T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=bGFsZSISlZ0",
      "Id": "bGFsZSISlZ0",
      "StartDateTime": "2020-07-21T10:03:13-07:00",
      "EndDateTime": "2020-07-21T12:01:05-07:00",
      "Duration": 70720000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bGFsZSISlZ0/mqdefault.jpg"
    },
    "Title": "Extensions-Logging, Extensions-Options, System.Console, System.Data, System.Diagnostics.Process, System.Drawing, System.Runtime, System.Threading",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33397,
          "Title": "Expose transaction savepoints in ADO.NET",
          "Author": "roji",
          "CreatedAt": "2020-03-09T19:17:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33397",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Data",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662004505",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33397#issuecomment-662004505",
        "FeedbackMarkdown": "* Looks good, but we\u0027d prefer \u0060SupportsSavepoints\u0060\r\n* We considered exposing a new type \u0060DbSavepoint\u0060 but we felt it\u0027s overkill for a niche feature like this\r\n* The \u0060System.SqlClient\u0060 and \u0060Microsoft.SqlClient\u0060 APIs should be updated to override these new base methods (instead of just hiding them) as well as \u0060SupportsSavepoints\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public class DbTransaction\r\n    {\r\n        public virtual Task SaveAsync(string savepointName, CancellationToken cancellationToken = default);\r\n        public virtual Task RollbackAsync(string savepointName, CancellationToken cancellationToken = default);\r\n        public virtual Task ReleaseAsync(string savepointName, CancellationToken cancellationToken = default);\r\n\r\n        public virtual void Save(string savepointName);\r\n        public virtual void Rollback(string savepointName);\r\n        public virtual void Release(string savepointName);\r\n\r\n        public virtual bool SupportsSavepoints { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DbTransaction.Release(string)",
          "M:DbTransaction.ReleaseAsync(string,CancellationToken)",
          "M:DbTransaction.Rollback(string)",
          "M:DbTransaction.RollbackAsync(string,CancellationToken)",
          "M:DbTransaction.Save(string)",
          "M:DbTransaction.SaveAsync(string,CancellationToken)",
          "P:DbTransaction.SupportsSavepoints",
          "T:DbTransaction"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39631,
          "Title": "Add new overloads for AddSystemdConsole and AddJsonConsole not needing configure argument",
          "Author": "maryamariyan",
          "CreatedAt": "2020-07-20T15:31:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39631",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Logging",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662009556",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39631#issuecomment-662009556",
        "FeedbackMarkdown": "* Makes sense\r\n* We should also add \u0060AddSimpleConsole\u0060 without \u0060configure\u0060, just for consistency\r\n\r\n\u0060\u0060\u0060C#\r\n\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    public static class ConsoleLoggerExtensions\r\n    {\r\n        // Existing APIs:\r\n        // public static ILoggingBuilder AddConsole(this ILoggingBuilder builder);\r\n        // public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, System.Action\u003CConsoleLoggerOptions\u003E configure);\r\n        // public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder, System.Action\u003CJsonConsoleFormatterOptions\u003E configure);\r\n        // public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, System.Action\u003CSimpleConsoleFormatterOptions\u003E configure);\r\n        // public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder, System.Action\u003CConsoleFormatterOptions\u003E configure);\r\n        public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder);\r\n        public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder);\r\n        public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20640000000,
        "Apis": [
          "M:ConsoleLoggerExtensions.AddJsonConsole(this ILoggingBuilder)",
          "M:ConsoleLoggerExtensions.AddSimpleConsole(this ILoggingBuilder)",
          "M:ConsoleLoggerExtensions.AddSystemdConsole(this ILoggingBuilder)",
          "T:ConsoleLoggerExtensions"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2127,
          "Title": "ConsoleKeyInfo does not implement IEquatable",
          "Author": "fghzxm",
          "CreatedAt": "2020-01-24T02:50:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2127",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Console",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662022231",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2127#issuecomment-662022231",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial readonly struct ConsoleKeyInfo : IEquatable\u003CConsoleKeyInfo\u003E\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38460000000,
        "Apis": [
          "T:ConsoleKeyInfo"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31996,
          "Title": "Implement IEquatable\u003CT\u003E for AsyncFlowControl",
          "Author": "reflectronic",
          "CreatedAt": "2020-02-09T15:20:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31996",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Threading",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662023094",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31996#issuecomment-662023094",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial struct AsyncFlowControl : IEquatable\u003CAsyncFlowControl\u003E\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40470000000,
        "Apis": [
          "T:AsyncFlowControl"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38244,
          "Title": "System.Drawing.Color is possibly missing 8 colors",
          "Author": "HumanEquivalentUnit",
          "CreatedAt": "2020-06-22T23:52:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38244",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Drawing",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662030348",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38244#issuecomment-662030348",
        "FeedbackMarkdown": "* For better or worse, framework spelling is en-us.\r\n* If this would be parsing, supporting both \u0060grey\u0060 and \u0060gray\u0060 seems reasonable, but duplicating API surface to offer AE and BE feels wrong, so we don\u0027t feel we should be exposing those.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    public enum KnownColor\r\n    {\r\n        RebeccaPurple\r\n    }\r\n    public readonly struct Color : IEquatable\u003CColor\u003E\r\n    {\r\n        public static Color RebeccaPurple;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41440000000,
        "Apis": [
          "F:Color.RebeccaPurple",
          "F:KnownColor.RebeccaPurple",
          "T:Color",
          "T:KnownColor"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36209,
          "Title": "Add BindConfiguration extension method for OptionsBuilder",
          "Author": "fredrikhr",
          "CreatedAt": "2020-05-11T11:04:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36209",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Options",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662034563",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36209#issuecomment-662034563",
        "FeedbackMarkdown": "* Looks reasonable\r\n* \u0060configPath\u0060 looks like a file system path; we should name it \u0060configSectionPath\u0060, unless we use \u0060configPath\u0060 elsewhere already.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static class OptionsBuilderConfigurationExtensions\r\n    {\r\n        public static OptionsBuilder\u003CTOptions\u003E BindConfiguration\u003CTOptions\u003E(\r\n            this OptionsBuilder\u003CTOptions\u003E optionsBuilder,\r\n            string configSectionPath,\r\n            Action\u003CBinderOptions\u003E configureBinder = null)\r\n            where TOptions : class =\u003E null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49400000000,
        "Apis": [
          "M:OptionsBuilderConfigurationExtensions.BindConfiguration\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E,string,Action\u003CBinderOptions\u003E)",
          "T:OptionsBuilderConfigurationExtensions"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28114,
          "Title": "Extend ProcessStartInfo to allow setting ",
          "Author": "SteveL-MSFT",
          "CreatedAt": "2018-12-09T21:47:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28114",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662039350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28114#issuecomment-662039350",
        "FeedbackMarkdown": "* The existing API already deviated from the Win32 naming convention (\u0060Load\u0060)\r\n* We should give it a better name, to make it clear what it does\r\n* We should mark the API as Windows-specific. We should check which API version this was introduced in, but it\u0027s probably Win7 or earlier anyways.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Process\r\n{\r\n    public class ProcessStartInfo\r\n    {\r\n        public bool LoadUserProfile { get; set; }\r\n        public bool UseCredentialsForNetworkingOnly { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 53850000000,
        "Apis": [
          "P:ProcessStartInfo.LoadUserProfile",
          "P:ProcessStartInfo.UseCredentialsForNetworkingOnly",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28198,
          "Title": "Add EnumMember API",
          "Author": "TylerBrinkley",
          "CreatedAt": "2018-12-13T20:14:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28198",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662047560",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28198#issuecomment-662047560",
        "FeedbackMarkdown": "We should add this API:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Enum\r\n    {\r\n        public static T[] GetValues\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nSo this code:\r\n\r\n\u0060\u0060\u0060C#\r\nvar values = (MyEnum[])Enum.GetValues(typeof(MyEnum));\r\nvar names = Enum.GetNames(typeof(MyEnum));\r\nfor (int i = 0; i \u003C values.Length; \u002B\u002Bi)\r\n{\r\n    MyEnum value = values[i];\r\n    string name = names[i];\r\n}\r\n\u0060\u0060\u0060\r\n\r\nbecomes\r\n\r\n\u0060\u0060\u0060C#\r\nvar values = Enum.GetValues\u003CMyEnum\u003E();\r\nforeach (var value in values)\r\n{\r\n    var name = value.ToString();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWith respect to custom attributes, you can already do this:\r\n\r\n\u0060\u0060\u0060C#\r\nFieldInfo enumField = ...;\r\nvar description = enumField.GetCustomAttributes\u003CDescriptionAttribute\u003E()\r\n                           .SingleOrDefault()?.Description ?? \u0022\u0022;\r\n\u0060\u0060\u0060",
        "TimeCode": 59900000000,
        "Apis": [
          "M:Enum.GetValues\u003CT\u003E()",
          "T:Enum"
        ]
      }
    ]
  },
  {
    "Id": 111,
    "Date": "2020-07-23T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=WW65sGkDINQ",
      "Id": "WW65sGkDINQ",
      "StartDateTime": "2020-07-23T10:07:23-07:00",
      "EndDateTime": "2020-07-23T12:07:38-07:00",
      "Duration": 72150000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/WW65sGkDINQ/mqdefault.jpg"
    },
    "Title": "Extensions-Primitives, System.Diagnostics.Process, System.Net.Http, System.Runtime.CompilerServices, System.Runtime.Intrinsics, System.Security",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35088,
          "Title": "HTTP2: Create additional connections when maximum active streams is reached",
          "Author": "JamesNK",
          "CreatedAt": "2020-04-17T01:20:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35088",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663129527",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35088#issuecomment-663129527",
        "FeedbackMarkdown": "* Makes sense. We discussed pushing it down but decided against because people are not likely to code against these properties in a generic fashion.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }   \r\n    public partial class WinHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.EnableMultipleHttp2Connections",
          "P:WinHttpHandler.EnableMultipleHttp2Connections",
          "T:SocketsHttpHandler",
          "T:WinHttpHandler"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31198,
          "Title": "configurable HTTP/2 PING timeouts in HttpClient",
          "Author": "chrisdot",
          "CreatedAt": "2019-10-17T12:25:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31198",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "BackgroundColor": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "blocking",
              "BackgroundColor": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work",
              "ForegroundColor": "white"
            }
          ],
          "IsBlocking": true
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663134549",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31198#issuecomment-663134549",
        "FeedbackMarkdown": "* Makes sense, but we propose to change \u0060Interval\u0060 to \u0060Delay\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class SocketsHttpHandler\r\n    {\r\n        public TimeSpan KeepAlivePingDelay { get; set; }\r\n        public TimeSpan KeepAlivePingTimeout { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6660000000,
        "Apis": [
          "P:SocketsHttpHandler.KeepAlivePingDelay",
          "P:SocketsHttpHandler.KeepAlivePingTimeout",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39489,
          "Title": "SocketsHttpHandler feature flag",
          "Author": "JamesNK",
          "CreatedAt": "2020-07-17T00:15:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39489",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Net.Http",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663144249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39489#issuecomment-663144249",
        "FeedbackMarkdown": "We should consider a factory method like:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class HttpMessageHandler\r\n    {\r\n        public static HttpMessageHandler CreateDefault();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would allow library code to write code like this:\r\n\r\n\u0060\u0060\u0060C#\r\nprivate HttpMessageHandler CreateHandler()\r\n{\r\n    var handler = HttpMessageHandler.CreateDefault();\r\n    if (handler is SocketsHttpHandler socketsHttpHandler)\r\n    {\r\n        // This property will throw PlatformNotSupportedException\r\n        socketsHttpHandler.MaxHttp2ConnectionsPerServer = int.MaxValue;\r\n    }\r\n\r\n    return handler;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHowever, the proposed API also makes sense:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler\r\n    {\r\n        public static bool IsSupported { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n@scalablecory, please discuss this with your networking folks and file a separate feature, likely for 6.0.",
        "TimeCode": 13340000000,
        "Apis": [
          "M:HttpMessageHandler.CreateDefault()",
          "P:SocketsHttpHandler.IsSupported",
          "T:HttpMessageHandler",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Id": 4,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36617,
          "Title": "API to provide the current system time",
          "Author": "YohDeadfall",
          "CreatedAt": "2020-05-17T19:17:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36617",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-Extensions-Primitives",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663156337",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36617#issuecomment-663156337",
        "FeedbackMarkdown": "@maryamariyan @davidfowl would we be OK with a breaking change to reconcile the \u0060ISystemClock\u0060 types into a single core type? If not, we shouldn\u0027t do this. If yes, then I think we can make progress.",
        "TimeCode": 24640000000,
        "Apis": []
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31170,
          "Title": "Unsafe.NullRef, IsNullRef",
          "Author": "jkotas",
          "CreatedAt": "2019-10-15T13:09:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31170",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663159454",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31170#issuecomment-663159454",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public class Unsafe\r\n    {\r\n        public bool IsNullRef\u003CT\u003E(ref T);\r\n        public ref T NullRef\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39930000000,
        "Apis": [
          "M:Unsafe.IsNullRef\u003CT\u003E(ref T)",
          "M:Unsafe.NullRef\u003CT\u003E()",
          "T:Unsafe"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 256,
          "Title": "Support for Intel SHA extensions",
          "Author": "Thealexbarney",
          "CreatedAt": "2019-11-25T23:56:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/256",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-x64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663163817",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/256#issuecomment-663163817",
        "FeedbackMarkdown": "* Looks good as proposed:\r\n     - Add \u0060IsSupported\u0060\r\n     - Change the \u0060Round\u0060 methods to indicate number of rounds\r\n     - Change parameters to match C\u002B\u002B naming\r\n* We should have an analyzer that flags usages, [just like for the AES types](https://github.com/dotnet/roslyn-analyzers/issues/3646). @tannergooding, please file the request and label it with \u0060code-analyzer\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public class Sha1\r\n    {\r\n        public static bool IsSupported { get; }\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E NextE(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E FourRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, byte func);\r\n    }\r\n\r\n    public class Sha256\r\n    {\r\n        public static bool IsSupported { get; }\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E TwoRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, Vector128\u003Cbyte\u003E k);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43960000000,
        "Apis": [
          "M:Sha1.FourRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Sha1.MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha1.MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha1.NextE(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.TwoRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "P:Sha1.IsSupported",
          "P:Sha256.IsSupported",
          "T:Sha1",
          "T:Sha256"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 371,
          "Title": "New ArgumentList constructors for Process classes",
          "Author": "Artoria2e5",
          "CreatedAt": "2019-11-27T17:30:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/371",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663169715",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/371#issuecomment-663169715",
        "FeedbackMarkdown": "* The added constructor seems to add little value, the bigger gains would be \u0060Process.Start()\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Process\r\n    {\r\n        // Existing overloads:\r\n        // public static Process Start(string fileName);\r\n        // public static Process Start(string fileName, string arguments);\r\n        // public static Process Start(string fileName, string userName, SecureString password, string domain);\r\n        // public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain);\r\n        // public static Process Start(ProcessStartInfo startInfo);\r\n        public static Process Start(string fileName, IEnumerable\u003Cstring\u003E arguments);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49460000000,
        "Apis": [
          "M:Process.Start(string,IEnumerable\u003Cstring\u003E)",
          "T:Process"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 785,
          "Title": "Provide x86 CPUID related information",
          "Author": "damageboy",
          "CreatedAt": "2019-12-12T07:27:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/785",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "arch-x64",
              "BackgroundColor": "eb6420",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            },
            {
              "Name": "up-for-grabs",
              "BackgroundColor": "23ef90",
              "Description": "Good issue for external contributors",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663178075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/785#issuecomment-663178075",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* All x86 types will extend X86Base (unless it already base type)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public class X86Base\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        public static (int Eax, int Ebx, int Ecx, int Edx) CpuId(int functionId, int subFunctionId = 0);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59310000000,
        "Apis": [
          "M:X86Base.CpuId(int,int)",
          "P:X86Base.IsSupported",
          "T:X86Base"
        ]
      },
      {
        "Id": 9,
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30612,
          "Title": "Obsolete the SecureString type",
          "Author": "GrabYourPitchforks",
          "CreatedAt": "2019-08-17T20:43:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30612",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "BackgroundColor": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Security",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663157607",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30612#issuecomment-663157607",
        "FeedbackMarkdown": "Updated proposal at https://github.com/dotnet/designs/pull/147.",
        "TimeCode": 67890000000,
        "Apis": []
      }
    ]
  },
  {
    "Id": 112,
    "Date": "2020-07-24T00:00:00-07:00",
    "Video": {
      "Url": "https://www.youtube.com/watch?v=TofmrPLEeFI",
      "Id": "TofmrPLEeFI",
      "StartDateTime": "2020-07-24T10:05:54-07:00",
      "EndDateTime": "2020-07-24T12:07:01-07:00",
      "Duration": 72670000000,
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/TofmrPLEeFI/mqdefault.jpg"
    },
    "Title": "System.Diagnostics, System.Diagnostics.Process, System.IO, System.Numerics, System.Runtime, System.Text.Json",
    "Items": [
      {
        "Id": 1,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38288,
          "Title": "Consider adding HalfToInt16Bits and Int16BitsToHalf to BitConverter",
          "Author": "pgovind",
          "CreatedAt": "2020-06-23T17:18:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38288",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663641179",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38288#issuecomment-663641179",
        "FeedbackMarkdown": "Looks good\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public sealed class BitConverter\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static short HalfToInt16Bits(Half value);\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static Half Int16BitsToHalf(short value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BitConverter.HalfToInt16Bits(Half)",
          "M:BitConverter.Int16BitsToHalf(short)",
          "T:BitConverter"
        ]
      },
      {
        "Id": 2,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38456,
          "Title": "Consider adding Half support to the BinaryPrimitives class",
          "Author": "eiriktsarpalis",
          "CreatedAt": "2020-06-26T17:13:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38456",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663643468",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38456#issuecomment-663643468",
        "FeedbackMarkdown": "* Looks good\r\n* But we should also do \u0060BinaryReader\u0060 and \u0060BinaryWriter\u0060 as they are the more high-level counterparts\r\n* @tannergooding, please scout the framework for support of \u0060float\u0060 and \u0060double\u0060 and see what makes sense for \u0060Half\u0060\r\n* We should consider \u0060Convert\u0060, but the interface dispatch due to lack of type code might be challenging.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Binary\r\n{\r\n    public static class BinaryPrimitives\r\n    {\r\n        public static Half ReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static Half ReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E source, out Half);\r\n        public static bool TryReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E source, out Half);\r\n\r\n        public static void WriteHalfLittleEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static void WriteHalfBigEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static bool TryWriteHalfLittleEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static bool TryWriteHalfBigEndian(Span\u003Cbyte\u003E destination, Half value);\r\n    }\r\n}\r\nnamespace System.IO\r\n{\r\n    public partial class BinaryReader\r\n    {\r\n        public virtual Half ReadHalf();\r\n    }\r\n    public partial class BinaryWriter\r\n    {\r\n        public virtual Half Write(Half value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3360000000,
        "Apis": [
          "M:BinaryPrimitives.ReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.TryReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E,out Half)",
          "M:BinaryPrimitives.TryReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out Half)",
          "M:BinaryPrimitives.TryWriteHalfBigEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.TryWriteHalfLittleEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.WriteHalfBigEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.WriteHalfLittleEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryReader.ReadHalf()",
          "M:BinaryWriter.Write(Half)",
          "T:BinaryPrimitives",
          "T:BinaryReader",
          "T:BinaryWriter"
        ]
      },
      {
        "Id": 3,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 13943,
          "Title": "Make Process.Start have a option to change handle inheritance",
          "Author": "pdelvo",
          "CreatedAt": "2014-12-19T21:45:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/13943",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663652191",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/13943#issuecomment-663652191",
        "FeedbackMarkdown": "* It shouldn\u0027t default to \u0060true\u0060, it should return the actual behavior of the underlying platform.\r\n* Marking the setter as platform specific makes sense, assuming we can\u0027t (or don\u0027t want to) implement the necessary gymnastics.\r\n* @adamsitnik @eiriktsarpalis please check what the possible behavior/desirable behavior for Linux/Unix/macOS is\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class ProcessStartInfo\r\n    {\r\n        public bool InheritHandles\r\n        {\r\n            get;\r\n            [MinimumOSPlatform(\u0022windows7.0\u0022)]\r\n            set;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6480000000,
        "Apis": [
          "P:ProcessStartInfo.InheritHandles",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Id": 4,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29681,
          "Title": "Consider exposing \u0060System.Diagnostics.StackTraceHiddenAttribute\u0060 publicly",
          "Author": "john-h-k",
          "CreatedAt": "2019-05-28T18:50:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29681",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Diagnostics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663656251",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29681#issuecomment-663656251",
        "FeedbackMarkdown": "* Since we can apply it to classes and structs, it seem one should be able to apply it to properties and events as well. Should we add \u0060Property\u0060, \u0060Event\u0060, \u0060Delegate\u0060?\r\n* We considered \u0060Interface\u0060 (DIM), but that seems ill-defined for non-DIMs. If people wanted them on DIMs, they can apply it to the method\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    [AttributeUsage(AttributeTargets.Class |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Struct, Inherited = false)]\r\n    public sealed class StackTraceHiddenAttribute : Attribute\r\n    {\r\n        public StackTraceHiddenAttribute();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18600000000,
        "Apis": [
          "M:StackTraceHiddenAttribute.StackTraceHiddenAttribute()",
          "T:StackTraceHiddenAttribute"
        ]
      },
      {
        "Id": 5,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1235,
          "Title": "Add ReadOnlySpan\u003Cchar\u003E overloads to JsonSerializer.Deserialize",
          "Author": "ahsonkhan",
          "CreatedAt": "2020-01-01T03:53:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1235",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Text.Json",
              "BackgroundColor": "d4c5f9",
              "Description": "",
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663657309",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1235#issuecomment-663657309",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic static partial class JsonSerializer\r\n{\r\n    public static object? Deserialize(ReadOnlySpan\u003Cchar\u003E json, Type returnType, JsonSerializerOptions? options = null);\r\n    [return: MaybeNull]\r\n    public static TValue Deserialize\u003CTValue\u003E(ReadOnlySpan\u003Cchar\u003E json, JsonSerializerOptions? options = null);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24860000000,
        "Apis": [
          "M:JsonSerializer.Deserialize(ReadOnlySpan\u003Cchar\u003E,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(ReadOnlySpan\u003Cchar\u003E,JsonSerializerOptions?)",
          "T:JsonSerializer"
        ]
      },
      {
        "Id": 6,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1630,
          "Title": "Add the ability to parse/format a float/double from/to a hexadecimal literal",
          "Author": "dovisutu",
          "CreatedAt": "2020-01-11T13:07:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1630",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663670728",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1630#issuecomment-663670728",
        "FeedbackMarkdown": "* API wise, the only change is the \u0060NumberStyles\u0060 addition of \u0060HexFloat\u0060\r\n* Behavior wise, this changes parsing of \u0060float\u0060 and \u0060double\u0060 to support the \u0060x\u0060 format specifier. This isn\u0027t a breaking change because \u0060float\u0060 and \u0060double\u0060 throw when \u0060x\u0060 is passed.\r\n* We considered adding \u0060AllowHexPrefix\u0060 because integers don\u0027t allow \u00600x\u0060 as  the prefix, while \u0060float\u0060 and \u0060double\u0060 would. However, for floats we want the prefix to be required, so \u0060AllowHexPrefix\u0060 would necessary be a separate bit. Combining it with \u0060HexFloat\u0060 would make it optional. Thus, we can do it later.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial enum NumberStyles\r\n    {\r\n        HexFloat = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowHexSpecifier | AllowDecimalPoint\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26350000000,
        "Apis": [
          "F:NumberStyles.HexFloat",
          "T:NumberStyles"
        ]
      },
      {
        "Id": 7,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30657,
          "Title": "Provide an overload of float/double.ToString that allow precision greater than 99",
          "Author": "Gnbrkm41",
          "CreatedAt": "2019-08-22T14:15:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30657",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Numerics",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663675920",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30657#issuecomment-663675920",
        "FeedbackMarkdown": "* There are issues with supporting more thant 99 digits of precision, some are in parsing behavior as pointed out by the OP, some of them are in public data structures which are size limited, and some are likely in the implementation.\r\n* Normally, it would seem better to extend the existing format specifier because it works better with resource strings and localization\r\n* However, given that production code is very unlikely to ever use more than 99 digits, it seems acceptable to have separate overloads to override the precision for debugging purposes\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct Single\r\n    {\r\n        public string ToString(char format, int precision);\r\n    }\r\n    public struct Double\r\n    {\r\n        public string ToString(char format, int precision);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 44660000000,
        "Apis": [
          "M:Double.ToString(char,int)",
          "M:Single.ToString(char,int)",
          "T:Double",
          "T:Single"
        ]
      },
      {
        "Id": 8,
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1916,
          "Title": "Introduce overloads of Enum.Parse/TryParse that accept ReadOnlySpan\u003Cchar\u003E",
          "Author": "Gnbrkm41",
          "CreatedAt": "2020-01-19T06:38:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1916",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "BackgroundColor": "159818",
              "Description": "API was approved in API review, it can be implemented",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.Runtime",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663679040",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1916#issuecomment-663679040",
        "FeedbackMarkdown": "* We should remove the \u0060Enum\u0060 constraint to match the other overloads\r\n* Otherwise, looks good\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Enum\r\n    {\r\n        public static TEnum Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value) where TEnum : struct;\r\n        public static TEnum Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase) where TEnum : struct;\r\n        public static bool TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, out TEnum result) where TEnum : struct;\r\n        public static bool TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase, out TEnum result) where TEnum : struct;\r\n\r\n        public static object Parse(Type enumType, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static object Parse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase);\r\n        public static bool TryParse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, out object result);\r\n        public static bool TryParse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase, out object result);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52910000000,
        "Apis": [
          "M:Enum.Parse(Type,ReadOnlySpan\u003Cchar\u003E,bool)",
          "M:Enum.Parse(Type,ReadOnlySpan\u003Cchar\u003E)",
          "M:Enum.Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,bool)",
          "M:Enum.Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E)",
          "M:Enum.TryParse(Type,ReadOnlySpan\u003Cchar\u003E,bool,out object)",
          "M:Enum.TryParse(Type,ReadOnlySpan\u003Cchar\u003E,out object)",
          "M:Enum.TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,bool,out TEnum)",
          "M:Enum.TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,out TEnum)",
          "T:Enum"
        ]
      },
      {
        "Id": 9,
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1953,
          "Title": "Add a delegate for OnDirectoryFinished()",
          "Author": "iSazonov",
          "CreatedAt": "2020-01-21T06:56:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1953",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "BackgroundColor": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation",
              "ForegroundColor": "white"
            },
            {
              "Name": "area-System.IO",
              "BackgroundColor": "d4c5f9",
              "Description": null,
              "ForegroundColor": "black"
            }
          ],
          "IsBlocking": false
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663688012",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1953#issuecomment-663688012",
        "FeedbackMarkdown": "* It seems \u0060OnDirectoryFinishedDelegate\u0060 should include the \u0060FileSystemEntry entry\u0060\r\n* Should \u0060ContinueOnErrorPredicate\u0060 provide some context? It seems one would want the container and the name the child to do anything useful for logging. If we see potential for more state, we may want to allow a struct, such as \u0060FileSystemError\u0060 instead.\r\n* @carlossanlop you may want to sync with @JeremyKuhne on how to evolve this API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Enumeration\r\n{\r\n    public partial class FileSystemEnumerable\u003CTResult\u003E : IEnumerable\u003CTResult\u003E\r\n    {\r\n        public delegate void OnDirectoryFinishedDelegate(ref FileSystemEntry entry);\r\n        public delegate bool ContinueOnErrorPredicate(ref FileSystemEntry parent, ReadOnlySpan\u003Cchar\u003E entry, int error);\r\n\r\n        public OnDirectoryFinishedDelegate? OnDirectoryFinishedAction { get; set; }\r\n        public ContinueOnErrorPredicate? ShouldContinueOnErrorPredicate { get; set; }\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57650000000,
        "Apis": [
          "P:FileSystemEnumerable\u003CTResult\u003E.OnDirectoryFinishedAction",
          "P:FileSystemEnumerable\u003CTResult\u003E.ShouldContinueOnErrorPredicate",
          "T:FileSystemEnumerable\u003CTResult\u003E",
          "T:FileSystemEnumerable\u003CTResult\u003E.ContinueOnErrorPredicate(ref FileSystemEntry,ReadOnlySpan\u003Cchar\u003E,int)",
          "T:FileSystemEnumerable\u003CTResult\u003E.OnDirectoryFinishedDelegate(ref FileSystemEntry)"
        ]
      }
    ]
  }
]