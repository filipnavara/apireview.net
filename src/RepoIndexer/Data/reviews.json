[
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "PXl1We3Yr0I",
      "StartDateTime": "2015-10-27T10:06:12.97-07:00",
      "EndDateTime": "2015-10-27T11:38:44-07:00",
      "Title": ".NET Core Design Reviews: C# Interactive APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PXl1We3Yr0I/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 3895,
          "Title": "Revising System.Net.Sockets contract v4.1",
          "Author": "SidharthNabar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-10-15T23:23:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15466",
          "Milestone": "1.0.0-rc1",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2015-10-27T00:00:00-07:00",
        "FeedbackId": "151577559",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/3895#issuecomment-151577559",
        "FeedbackMarkdown": "The PR for this issue is merged and the API review is completed. Hence closing this issue.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "nG-Af_TgYbI",
      "StartDateTime": "2015-12-04T10:04:55.599-08:00",
      "EndDateTime": "2015-12-04T10:47:26-08:00",
      "Title": ".NET Core Design Reviews: Backlog review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nG-Af_TgYbI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4636,
          "Title": "Missing several valuable members of System.Console in contract",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-11-23T12:45:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15765",
          "Milestone": "1.0.0-rtm",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2015-12-04T00:00:00-08:00",
        "FeedbackId": "162039060",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4636#issuecomment-162039060",
        "FeedbackMarkdown": "Looks good, except for \u0060BufferWidth\u0060 and \u0060BufferHeight\u0060 because they are not meaningful on Linux; they basically have to return \u0060WindowWidth\u0060 and \u0060WindowHeight\u0060.\r\n\r\n@stephentoub, can you create a list of all the missing APIs in \u0060Console\u0060? We should probably add all except for the ones we don\u0027t want/can\u0027t support.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4708,
          "Title": "Add ValueTask to corefx",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-11-28T21:13:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15809",
          "Milestone": "1.0.0-rc2",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2015-12-04T00:00:00-08:00",
        "FeedbackId": "162042013",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4708#issuecomment-162042013",
        "FeedbackMarkdown": "No major concerns. We should agree, though, how we name types that provide a struct-based alternative to a class. Should this be a prefix or a suffix?\r\n- **Prefix**. Matches how must people read C# code, i.e. \u0060struct Foo\u0060, \u0060ValueFoo\u0060.\r\n- **Suffix**. Sorts better in IntelliSense, documentation, or any other case where APIs are sorted.\r\n\r\nThe best location seems to be \u0060System.Threading.Tasks\u0060. We need to check whether we can make this a partial fa\u00E7ade for .NET Framework.",
        "TimeCode": 6270000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "VppFZYG-9cA",
      "StartDateTime": "2017-08-29T10:09:41.581-07:00",
      "EndDateTime": "2017-08-29T12:03:24-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VppFZYG-9cA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14903,
          "Title": "Allow fire and forget CancellationTokenRegisteration.Dispose",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-01-05T19:04:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19827",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14903#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16567,
          "Title": "Proposal: Update Type.GetMethod() overloads to simplify finding generic methods via reflection",
          "Author": "HaloFour",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-01T18:04:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20377",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325756004",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16567#issuecomment-325756004",
        "FeedbackMarkdown": "This\r\n\r\n\u0060\u0060\u0060C#\r\npublic static Type MakeGenericMethodParameterSignatureType(int position);\r\n\u0060\u0060\u0060\r\n\r\nshould be \r\n\r\n\u0060\u0060\u0060C#\r\npublic static Type MakeGenericMethodParameter(int position);\r\n\u0060\u0060\u0060\r\n\r\nWe should also rename \u0060genericArity\u0060 to \u0060genericParameterCount\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, Type[] types)\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers)\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);\r\npublic MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);\r\nprotected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers) =\u003E throw new NotSupported;\r\n\u0060\u0060\u0060\r\n\r\nWe should also expose a query API that identifies the new positional generic method parameters. We propose to go with some more foundational concept that could equally apply to references to generic type parameters. In the spec above @AtsushiKan used the term signature type. So we settled on:\r\n\r\n\u0060\u0060\u0060C#\r\npublic virtual bool IsSignatureType =\u003E false;\r\n\u0060\u0060\u0060",
        "TimeCode": 7980000000,
        "Apis": [
          "M:.GetMethodImpl(string,int,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])",
          "P:.IsSignatureType"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17232,
          "Title": "Need api to determine if a type is \u0022byref-like.\u0022",
          "Author": "ghost",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-17T15:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20673",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325756873",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17232#issuecomment-325756873",
        "FeedbackMarkdown": "We should align this with the attribute we approved earlier, which is named \u0060IsByRefLikeAttribute\u0060. Since the proposal matches that, it\u0027s approved as proposed.",
        "TimeCode": 53140000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 22866,
          "Title": "Add a way to opt out of TargetInvocationException wrapping on late-bound invokes.",
          "Author": "kingces95",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-08-02T15:36:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23023",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325761139",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/22866#issuecomment-325761139",
        "FeedbackMarkdown": "Looks good, the only suggestion is to rename \u0060PassExceptions\u0060 to \u0060DoNotWrapExceptions\u0060. The rationale being that specifying \u0060~PassExceptions\u0060 could be read as catch-all.\r\n\r\n\u0060\u0060\u0060C#\r\nvar bf = BindingFlags.Public | BindingFlags.DoNotWrapExceptions;\r\n\u0060\u0060\u0060",
        "TimeCode": 55060000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 20497,
          "Title": "Add ProcessStartInfo.StandardInputEncoding property",
          "Author": "madelson",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-05-31T11:01:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22051",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-08-29T00:00:00-07:00",
        "FeedbackId": "325762992",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/20497#issuecomment-325762992",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 63550000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "m4BUM3nJZRw",
      "StartDateTime": "2017-10-03T10:00:56.39-07:00",
      "EndDateTime": "2017-10-03T12:07:35-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/m4BUM3nJZRw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12442,
          "Title": "Add QueueUserWorkItem for local threadpool queues",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-10-07T08:21:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18881",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12442#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23828,
          "Title": "Add CancellationTokenRegistration.Token property",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-06T17:18:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23461",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333935487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23828#issuecomment-333935487",
        "FeedbackMarkdown": "Approved as proposed.",
        "TimeCode": 21760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23879,
          "Title": "Support casting ReadOnlyMemory\u003CT\u003E to Memory\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-08T12:51:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23491",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333939600",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23879#issuecomment-333939600",
        "FeedbackMarkdown": "OK, it seems we should separate the discussion on the pinnable references. But the readonly casting looks reasonable. We should, however, choose a generic type name so that we can add the pinnable stuff later on. \u0060Buffers\u0060 seems like a good candidate:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class BuffersMarshal\r\n    {\r\n        public static bool TryGetArray\u003CT\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out ArraySegment\u003CT\u003E arraySegment);\r\n        public static Memory\u003CT\u003E AsMemory\u003CT\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51990000000,
        "Apis": [
          "M:BuffersMarshal.AsMemory\u003CT\u003E(ReadOnlyMemory\u003CT\u003E)",
          "M:BuffersMarshal.TryGetArray\u003CT\u003E(ReadOnlyMemory\u003CT\u003E,out ArraySegment\u003CT\u003E)",
          "T:BuffersMarshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23883,
          "Title": "Add IsGenericTypeParameter and IsGenericMethodParameter to System.Type",
          "Author": "ghost",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-08T14:38:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23493",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333940885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23883#issuecomment-333940885",
        "FeedbackMarkdown": "Looks good, but we don\u0027t understand why the properties have to be virtual. It seems they are in nature static. At the end you explain that but how would we eliminate the virtual method call?",
        "TimeCode": 60560000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23916,
          "Title": "S.R.CS.Unsafe and read-only references",
          "Author": "ektrah",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-09T14:31:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23504",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333942166",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23916#issuecomment-333942166",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 63260000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23974,
          "Title": "Add MemoryHandle.HasPointer",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-12T15:11:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23526",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-03T00:00:00-07:00",
        "FeedbackId": "333943725",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23974#issuecomment-333943725",
        "FeedbackMarkdown": "The member on \u0060MemoryHandle\u0060 is called \u0060PinnedPointer\u0060. We should align the name here, so \u0060HasPinnedPointer\u0060. It seems @KrzysztofCwalina is unsure whether the existing property is named correctly. He\u0027ll chase this up offline.",
        "TimeCode": 65860000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "b96co3sNzNI",
      "StartDateTime": "2017-10-10T10:07:40.535-07:00",
      "EndDateTime": "2017-10-10T11:43:07-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b96co3sNzNI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23862,
          "Title": "Productizing APIs for {ReadOnly}Memory\u003CT\u003E and friends",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-07T20:14:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335543258",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23862#issuecomment-335543258",
        "FeedbackMarkdown": "@ahsonkhan mentioned he\u0027s not ready for a review yet.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24039,
          "Title": "Proposal: Add protected {Unmanaged}MemoryStream.Read/WriteSpan method",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-14T16:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23553",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335544053",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24039#issuecomment-335544053",
        "FeedbackMarkdown": "@KrzysztofCwalina suggested to generalize this beyond these two types; @stephentoub said he has to think about to do this and whether it\u0027s even possible.",
        "TimeCode": 1450000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23592,
          "Title": "Add ProcessStartInfo.ArgumentList",
          "Author": "mklement0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-08-27T20:08:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23347",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335552652",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23592#issuecomment-335552652",
        "FeedbackMarkdown": "The API looks good, and it\u0027s a good problem to solve. However, we don\u0027t like the idea that we have to roundtrip data between the two different representations because it means we have to both, parse and combine per operating system and get the semantics right. Instead, we\u0027d prefer a model like this:\r\n\r\n\u0060\u0060\u0060C#\r\npartial class ProcessStartInfo\r\n{\r\n    // Exists\r\n    string Arguments { get; set; }   \r\n\r\n    // new\r\n    IReadOnlyCollection\u003Cstring\u003E ArgumentList { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060Start\u0060 would verify that not both \u0060!string.IsNullOrEmpty(Arguments)\u0060 and \u0060ArgumentList.Count \u003E 1\u0060 are true, i.e. the caller may either use \u0060Arguments\u0060 or \u0060ArgumentList\u0060, but not both.\r\n\r\n[edit @danmosemsft changed Collection typo to IREadOnlyCollection]",
        "TimeCode": 2930000000,
        "Apis": [
          "P:ProcessStartInfo.ArgumentList",
          "P:ProcessStartInfo.Arguments",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24115,
          "Title": "Proposal: Add Array.Sort\u003CT\u003E(T[], int, int, Comparison\u003CT\u003E) overload",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-18T14:27:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23587",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335553699",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24115#issuecomment-335553699",
        "FeedbackMarkdown": "Looks good to us, but we should probably add the same API to \u0060List\u003CT\u003E\u0060",
        "TimeCode": 21920000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24105,
          "Title": "Change ReadOnlySpan indexer to return ref readonly",
          "Author": "ektrah",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-17T17:33:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23582",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24105#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24210000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23874,
          "Title": "StreamWriter .ctor pooling overloads",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-08T03:51:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23486",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-10T00:00:00-07:00",
        "FeedbackId": "335568547",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23874#issuecomment-335568547",
        "FeedbackMarkdown": "Couple of thoughts:\r\n\r\n* It seems opting in wouldn\u0027t get huge wins for existing code because everyone has to change their code. At the same time, making it opt-out might be too breaking. The question is whether we can find a way to get 90% of the wins without requiring calling a new API while making it 90% safe (of course, on .NET Framework pooling would be quirked so that apps only get it when retargeting against the latest version).\r\n* We generally have to think about more aggressive buffer pooling\r\n* We\u0027d prefer the bool over the \u0060pool\u0060 because it allows us to change the implementation",
        "TimeCode": 24600000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "BEBq3__WfDc",
      "StartDateTime": "2017-10-17T10:07:23.564-07:00",
      "EndDateTime": "2017-10-17T12:03:46-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BEBq3__WfDc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24426,
          "Title": "Rename MemoryHandle.PinnedPointer to Pointer",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-04T16:17:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23734",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337305000",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24426#issuecomment-337305000",
        "FeedbackMarkdown": "Looks good as proposed. Also, rename the constructor.\r\n\r\nAND NEXT TIME INCLUDE THE API REF.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14891,
          "Title": "SerialDisposable, CompositeDisposable, etc",
          "Author": "clairernovotny",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-01-05T15:34:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19822",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14891#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 10880000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24449,
          "Title": "Add DateTime.UnixEpoch and DateTimeOffset.UnixEpoch fields",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-05T16:46:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23747",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337315763",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24449#issuecomment-337315763",
        "FeedbackMarkdown": "Looks good as proposed. We may want to add the \u0060ToUnixXxx\u0060 and \u0060FromUnixXxx\u0060 to \u0060DateTime\u0060 as well though.",
        "TimeCode": 24230000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24694,
          "Title": "[ExcludeFromCodeCoverageAttribute] should be applicable to assemblies",
          "Author": "abatishchev",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-17T17:57:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23874",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24694#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 31070000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24568,
          "Title": "Add Base64 conversion APIs that support UTF-8 for Span\u003CT\u003E ",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-11T03:33:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23808",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-17T00:00:00-07:00",
        "FeedbackId": "337334707",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24568#issuecomment-337334707",
        "FeedbackMarkdown": "This needs more work. Raw notes:\r\n\r\n### Rough shape of API\r\n\r\n\u0060\u0060\u0060C#\r\n// System.Memory.dll\r\nnamespace System.Buffers.Text {\r\n    public static class Base64 {\r\n        public static OperationStatus EncodeToUtf8(ReadOnlySpan\u003Cbyte\u003E bytes, Span\u003Cbyte\u003E utf8, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static OperationStatus EncodeToUtf8InPlace(Span\u003Cbyte\u003E buffer, int bytesLength, out int written, bool isFinalBlock = true);\r\n        public static int GetMaxEncodedUtf8Length(int length);\r\n        public static OperationStatus DecodeFromUtf8(ReadOnlySpan\u003Cbyte\u003E utf8, Span\u003Cbyte\u003E bytes, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static OperationStatus DecodeFromUtf8InPlace(Span\u003Cbyte\u003E buffer, out int consumed, out int written, bool isFinalBlock = true);\r\n        public static int GetMaxDecodedBytesLength(int length);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### isFinalBlock\r\n\r\nWe need it, using a more general term (as opposed to \u0060usePadding\u0060) avoids the caller having to understand the format/specification.\r\n\r\n### OperationStatus/TransformationStatus\r\n\r\nIt was brought up that we may not need the enum at all.\r\n\r\n@ahsonkhan /Levi: Look at the general pattern and decide whether the API is needed. In the past we concluded that the code becomes too convoluted and the conditions are easy to get wrong.\r\n\r\n### Length\r\n\r\nWe should not take the input, only the size. We should also not take the \u0060isFinalBlock\u0060. Basically, the contract is \u0022give an upper bound\u0022.",
        "TimeCode": 65460000000,
        "Apis": [
          "M:Base64.DecodeFromUtf8(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.DecodeFromUtf8InPlace(Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.EncodeToUtf8(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:Base64.EncodeToUtf8InPlace(Span\u003Cbyte\u003E,int,out int,bool)",
          "M:Base64.GetMaxDecodedBytesLength(int)",
          "M:Base64.GetMaxEncodedUtf8Length(int)",
          "T:Base64"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "OZnaGV2omvI",
      "StartDateTime": "2017-10-24T10:06:29.118-07:00",
      "EndDateTime": "2017-10-24T12:02:36-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/OZnaGV2omvI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24555,
          "Title": "Add Microseconds and Nanoseconds to TimeStamp, DateTime, and DateTimeOffset",
          "Author": "ChristopherHaws",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-10T22:37:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23799",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339062792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24555#issuecomment-339062792",
        "FeedbackMarkdown": "Given the above concerns about overflow and precision, let\u0027s discuss a bit more on what would the right return type should be.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24442,
          "Title": "SocketTaskExtensions as instance methods",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-05T02:58:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23741",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339063781",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24442#issuecomment-339063781",
        "FeedbackMarkdown": "Given that the methods are already instance methods on the implementation, it implementation wise there is no benefit of doing the move. The driving factor here would be if we wanted to expose for customers as instance methods, so, for example, they can derive from \u0060Socket\u0060 and override them. So we\u0027d go with Option 1.",
        "TimeCode": 660000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24115,
          "Title": "Proposal: Add Array.Sort\u003CT\u003E(T[], int, int, Comparison\u003CT\u003E) overload",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-18T14:27:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23587",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339064985",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24115#issuecomment-339064985",
        "FeedbackMarkdown": "Seems like it \uD83D\uDE22",
        "TimeCode": 3250000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24575,
          "Title": "Make BigInteger BigEndian-friendly",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-11T15:31:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23812",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339072735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24575#issuecomment-339072735",
        "FeedbackMarkdown": "Looks good, minor comments:\r\n\r\n* We may want to swap the \u0060isBigEndian\u0060 and \u0060isUnsigned\u0060\r\n* It\u0027s a bit odd to have one type for signed and unsigned, but adding \u0060UBigInteger\u0060 seems like overkill",
        "TimeCode": 5710000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24840,
          "Title": "Add SpanExtensions.EndsWith",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-24T16:38:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23942",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339074798",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24840#issuecomment-339074798",
        "FeedbackMarkdown": "Seems reasonable. We should consider removing the \u0060Span\u003Cbyte\u003E\u0060 as we believe we can specialize the implementation without performance loss.",
        "TimeCode": 21280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24839,
          "Title": "Add SpanExtensions.LastIndexOf",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-24T16:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23941",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339076860",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24839#issuecomment-339076860",
        "FeedbackMarkdown": "Looks good:\r\n\r\n* Why do we need the \u0060struct\u0060 constraint?\r\n* Can we just collapse the \u0060T\u0060 version and the \u0060byte\u0060 versions?\r\n* Why is there no \u0060LastIndexOfAny\u0060 version?",
        "TimeCode": 25530000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24607,
          "Title": "UTF8 Parsing and Formatting",
          "Author": "ghost",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-12T16:05:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23831",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339086989",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24607#issuecomment-339086989",
        "FeedbackMarkdown": "* \u0060ParsedFormat\u0060  -\u003E \u0060StandardFormat\u0060\r\n* \u0060ParsedFormat\u0060 should implement \u0060IEquatable\u003CParsedFormat\u003E\u0060\r\n* Follow @benaadams\u0027s proposal and drop the type names from methods on \u0060Utf8Parser\u0060\r\n* Rename the \u0060format\u0060 parameter on \u0060Utf8Parser\u0060 to \u0060standardFormat\u0060",
        "TimeCode": 29510000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24568,
          "Title": "Add Base64 conversion APIs that support UTF-8 for Span\u003CT\u003E ",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-11T03:33:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23808",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-24T00:00:00-07:00",
        "FeedbackId": "339096554",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24568#issuecomment-339096554",
        "FeedbackMarkdown": "Looks good as proposed. It seems @GrabYourPitchforks conceded that the enum is useful. We should, however, remove the \u0060dataLength\u0060 parameter from \u0060DecodeFromUtf8InPlace\u0060 -- it\u0027s not needed.",
        "TimeCode": 52010000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "bHwCPVNQLwo",
      "StartDateTime": "2017-10-31T10:05:29.096-07:00",
      "EndDateTime": "2017-10-31T11:54:01-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bHwCPVNQLwo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 22412,
          "Title": "Add TransformationStatus enum from corefxlab",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-07-18T21:29:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22845",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocked",
              "Color": "b60205",
              "Description": "Issue/PR is blocked on something - see comments"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340833769",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/22412#issuecomment-340833769",
        "FeedbackMarkdown": "This is now tracked as part of other work item.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23862,
          "Title": "Productizing APIs for {ReadOnly}Memory\u003CT\u003E and friends",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-07T20:14:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340845398",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23862#issuecomment-340845398",
        "FeedbackMarkdown": "We don\u0027t want to add the bulk methods. We believe it could become a performance trap and it invites having to keep \u0060Span\u003CT\u003E\u0060 and \u0060Memory\u003CT\u003E\u0060 in sync.\r\n\r\n\u0060\u0060\u0060C#\r\n// instance methods\r\npublic struct Memory\u003CT\u003E {\r\n  public void CopyTo(Memory\u003CT\u003E destination);\r\n  public bool TryCopyTo(Memory\u003CT\u003E destination);\r\n}\r\npublic struct ReadOnlyMemory\u003CT\u003E {\r\n  public void CopyTo(Memory\u003CT\u003E destination);\r\n  public bool TryCopyTo(Memory\u003CT\u003E destination);\r\n}\r\n// extension methods\r\n// Merge with SpanExtensions\r\npublic static class MemoryExtensions {\r\n  public static void CopyTo\u003CT\u003E(this T[] array, Memory\u003CT\u003E destination);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe should probably rename \u0060SpanExtensions\u0060 to \u0060MemoryExtensions\u0060.",
        "TimeCode": 3110000000,
        "Apis": [
          "M:Memory\u003CT\u003E.CopyTo(Memory\u003CT\u003E)",
          "M:Memory\u003CT\u003E.TryCopyTo(Memory\u003CT\u003E)",
          "M:MemoryExtensions.CopyTo\u003CT\u003E(this T[],Memory\u003CT\u003E)",
          "M:ReadOnlyMemory\u003CT\u003E.CopyTo(Memory\u003CT\u003E)",
          "M:ReadOnlyMemory\u003CT\u003E.TryCopyTo(Memory\u003CT\u003E)",
          "T:Memory\u003CT\u003E",
          "T:MemoryExtensions",
          "T:ReadOnlyMemory\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24103,
          "Title": "Add Overlaps/Within extension methods for ReadOnlySpan\u003CT\u003E",
          "Author": "nietras",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-17T10:07:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23580",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340856211",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24103#issuecomment-340856211",
        "FeedbackMarkdown": "We seem to believe \u0060Overlaps\u0060 seems like a good addition (having both overloads), but it looks like \u0060Within\u0060 is redundant/not any faster. \r\n\r\n\u0060\u0060\u0060C#\r\npublic static class SpanExtensions\r\n{\r\n    public static bool Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E first, ReadOnlySpan\u003CT\u003E second);\r\n    public static bool Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E first, ReadOnlySpan\u003CT\u003E second,  out int elementOffset);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24700000000,
        "Apis": [
          "M:SpanExtensions.Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,out int)",
          "M:SpanExtensions.Overlaps\u003CT\u003E(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "T:SpanExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24296,
          "Title": "Memory and ReadOnlyMemory validation errors not matching",
          "Author": "Drawaes",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-28T03:41:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23670",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-10-31T00:00:00-07:00",
        "FeedbackId": "340868030",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24296#issuecomment-340868030",
        "FeedbackMarkdown": "We went back and forth, but it seems we\u0027re in agreement that these can be useful. We shouldn\u0027t expose static types \u0060Span\u0060 and \u0060Memory\u0060 in \u0060InteropServices\u0060. Instead, we should add them to the new [\u0060MemoryMarshal\u0060 type](https://github.com/dotnet/corefx/issues/23879#issuecomment-340861229).",
        "TimeCode": 45510000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "HnKmLJcEM74",
      "StartDateTime": "2017-11-07T10:11:30.709-08:00",
      "EndDateTime": "2017-11-07T12:06:50-08:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/HnKmLJcEM74/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24946,
          "Title": "Expose RuntimeWrappedException constructor",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-30T02:10:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23991",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342573013",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24946#issuecomment-342573013",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24854,
          "Title": "Provide IEnumerable\u003CT\u003E support for Memory\u003CT\u003E",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-25T00:59:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23950",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342577441",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24854#issuecomment-342577441",
        "FeedbackMarkdown": "Looks good as proposed. \u0060MemoryExtensions\u0060 doesn\u0027t exist yet but \u0060SpanExtensions\u0060 will be renamed to it.",
        "TimeCode": 2520000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25085,
          "Title": "Add String support to ReadOnlyMemory\u003Cchar\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-06T19:26:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24064",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342585466",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25085#issuecomment-342585466",
        "FeedbackMarkdown": "Based on the discussion with @stephentoub we concluded that we should merge the two types:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class MemoryExtensions\r\n    {\r\n        // Existing class containing AsReadOnlySpan(this string)\r\n        public static ReadOnlyMemory\u003Cchar\u003E AsReadOnlyMemory(this string text);\r\n\r\n        // We already have ReadOnlyMemory\u003CT\u003E.TryGetArray(out ArraySegment\u003CT\u003E segment)\r\n        public static bool TryGetString(this ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string value, out int offset, out int count);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 11270000000,
        "Apis": [
          "M:MemoryExtensions.AsReadOnlyMemory(this string)",
          "M:MemoryExtensions.TryGetString(this ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "T:MemoryExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24839,
          "Title": "Add SpanExtensions.LastIndexOf",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-24T16:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23941",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342587703",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24839#issuecomment-342587703",
        "FeedbackMarkdown": "Looks good as proposed",
        "TimeCode": 28440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 20903,
          "Title": "Additional API for DbProviderFactories in .NET Core",
          "Author": "divega",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-06-10T20:34:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22229",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data.SqlClient",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-07T00:00:00-08:00",
        "FeedbackId": "342605350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/20903#issuecomment-342605350",
        "FeedbackMarkdown": "Looks good with some minor tweaks:\r\n\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class DbProviderFactories\r\n{\r\n    // exiting members\r\n    \r\n    public static DbProviderFactory GetFactory(string providerInvariantName); \r\n    public static DbProviderFactory GetFactory(DataRow providerRow); \r\n    public static DbProviderFactory GetFactory(DbConnection connection); \r\n    public static DataTable GetFactoryClasses(); \r\n\r\n    // new members\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Registers a provider factory using the assembly qualified name of the factory and an \r\n    /// invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, string factoryTypeAssemblyQualifiedName);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Registers a provider factory using the provider factory type and an invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, Type factoryType);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Register a provider factory using the provider factory instance and \r\n    /// an invariant name\r\n    /// \u003C/summary\u003E\r\n    public static void RegisterFactory(string providerInvariantName, DbProviderFactory factory);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Returns the provider factory instance if one is registered for the given invariant name\r\n    /// \u003C/summary\u003E\r\n    public static bool TryGetFactory(string providerInvariantName, out DbProviderFactory factory);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Removes the provider factory registration for the given invariant name  \r\n    /// \u003C/summary\u003E\r\n    public static bool UnregisterFactory(string providerInvariantName);\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Returns the invariant names for all the factories registered\r\n    /// \u003C/summary\u003E\r\n    public static IEnumerable\u003Cstring\u003E GetProviderInvariantNames();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32150000000,
        "Apis": [
          "M:DbProviderFactories.GetFactory(DataRow)",
          "M:DbProviderFactories.GetFactory(DbConnection)",
          "M:DbProviderFactories.GetFactory(string)",
          "M:DbProviderFactories.GetFactoryClasses()",
          "M:DbProviderFactories.GetProviderInvariantNames()",
          "M:DbProviderFactories.RegisterFactory(string,DbProviderFactory)",
          "M:DbProviderFactories.RegisterFactory(string,string)",
          "M:DbProviderFactories.RegisterFactory(string,Type)",
          "M:DbProviderFactories.TryGetFactory(string,out DbProviderFactory)",
          "M:DbProviderFactories.UnregisterFactory(string)",
          "T:DbProviderFactories"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "o5JFZtgaJLs",
      "StartDateTime": "2017-11-21T10:16:08.038-08:00",
      "EndDateTime": "2017-11-21T11:47:37-08:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/o5JFZtgaJLs/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23879,
          "Title": "Support casting ReadOnlyMemory\u003CT\u003E to Memory\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-08T12:51:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23491",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346117097",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23879#issuecomment-346117097",
        "FeedbackMarkdown": "API review: Let\u0027s separate @jkotas\u0027s rename change into separate issue -- #25412.\r\nMarking as api-approved again.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25412,
          "Title": "Move (ReadOnly)Span.DangerousGetPinnableReference to MemoryMarshal",
          "Author": "karelz",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-21T18:30:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24207",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346119552",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25412#issuecomment-346119552",
        "FeedbackMarkdown": "Looks good as proposed. We should also remove the corresponding GetDangerousXxxx() instance methods.\r\n\r\n@jkotas why are they marked as in? Does it make a difference?",
        "TimeCode": 4980000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24694,
          "Title": "[ExcludeFromCodeCoverageAttribute] should be applicable to assemblies",
          "Author": "abatishchev",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-17T17:57:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23874",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346119984",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24694#issuecomment-346119984",
        "FeedbackMarkdown": "As long as we\u0027re working with the code coverage tool providers to make it\u0027s honored, I sounds good (and it seems we are).",
        "TimeCode": 10060000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25094,
          "Title": "Proposal: String.Contains(char)",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-07T05:29:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24068",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25094#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 11650000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 10981,
          "Title": "Expose UnixDomainSocket",
          "Author": "swernli",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-08-19T01:06:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18227",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-linux",
              "Color": "fef2c0",
              "Description": "Linux OS (any supported distro)"
            },
            {
              "Name": "os-mac-os-x",
              "Color": "fef2c0",
              "Description": "macOS aka OSX"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/10981#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 12490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25337,
          "Title": "TryFormat with format strings as ReadOnlySpan\u003Cchar\u003E or string",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-18T19:38:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24171",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346126703",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25337#issuecomment-346126703",
        "FeedbackMarkdown": "We seem to gravitate to (2) because it doesn\u0027t require an implicit conversion, but also doesn\u0027t prevent us from adding it in the future.\r\n\r\n@stephentoub has filed a separate issue to discuss (3) #25413.",
        "TimeCode": 15430000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25189,
          "Title": "\u0022ItemRef\u0022 - Ref element accessor for types that already have an indexer.",
          "Author": "VSadov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-11T01:10:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24110",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-21T00:00:00-08:00",
        "FeedbackId": "346139011",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25189#issuecomment-346139011",
        "FeedbackMarkdown": "For data types like \u0060Stack\u003CT\u003E\u0060 and \u0060Queue\u003CT\u003E\u0060 the proposed name \u0060ItemRef\u0060 wouldn\u0027t work. Thus, this would be more like a pattern where the name depends on the concept you add a \u0060ref\u0060-returning method for:\r\n\r\n* Indexers -\u003E \u0060ItemRef()\u0060\r\n* \u0060Peek()\u0060 -\u003E \u0060PeekRef()\u0060",
        "TimeCode": 26170000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9F_NsviGT0Y",
      "StartDateTime": "2017-11-28T10:04:25.337-08:00",
      "EndDateTime": "2017-11-28T11:00:56-08:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9F_NsviGT0Y/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25535,
          "Title": "Add overload to Path.GetFullPath() to specify base path",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-28T02:05:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24262",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25535#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25539,
          "Title": "Need Span overloads for Path APIs",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-28T04:36:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24264",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25539#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 5580000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25536,
          "Title": "Need Span based path join API",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-28T02:17:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24263",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "347624492",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25536#issuecomment-347624492",
        "FeedbackMarkdown": "It seems weird to me to introduce a new API without deprecating the old API. However, deprecating the old API would be fairly invasive (high usage).\r\n\r\n1. Could we fix the behavior of \u0060Combine\u0060? We could quirk the behavior. @JeremyKuhne will take a look.\r\n2. It seems less ideal but more acceptable to me to introduce an overload of \u0060Combine\u0060 that takes \u0060Span\u0060 with the new behavior. People would opt-into the new behavior by converting to \u0060Span\u0060. Reason being we have a unified set of verbs.",
        "TimeCode": 7920000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25427,
          "Title": "Add PipeOptions.CurrentUserOnly option",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-22T03:22:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24212",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25427#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 26420000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23519,
          "Title": "Add Scalar Intel hardware intrinsic functions",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-08-24T15:55:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23315",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-11-28T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23519#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29560000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "BI3iXFT8H7E",
      "StartDateTime": "2017-12-05T10:06:23.791-08:00",
      "EndDateTime": "2017-12-05T11:57:04-08:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BI3iXFT8H7E/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25303,
          "Title": "Regex should have a static TryParse() method",
          "Author": "udlose",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-16T23:58:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24159",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349394486",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25303#issuecomment-349394486",
        "FeedbackMarkdown": "We don\u0027t believe this API is very useful, because\r\n\r\n1. \u0060TryParse\u0060 is really about parsing user input in tight loops, which regex shouldn\u0027t be.\r\n2. Returning a \u0060bool\u0060 isn\u0027t very informative. Granted, our current \u0060ArgumentException\u0060 we expose information as a string, which is not machine readable, but that\u0027s probably the area we should be improving instead.\r\n3. Plumbing it through the current engine would be non-trival as we throw \u0060ArgumentException\u0060 left and right.\r\n\r\nWe already have plans to rewrite the regex engine; when we do, we should think about diagnostics.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12644,
          "Title": "Allow for ArrayPool\u003CT\u003E to create buffers with a different minimum length",
          "Author": "xoofx",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-10-14T11:20:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18959",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349398101",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12644#issuecomment-349398101",
        "FeedbackMarkdown": "The ordering is unfortunate. @KrzysztofCwalina mentioned that we might want to take more options in the future to customize how the sizes are spread inside the pool; this indicates that we probably shouldn\u0027t take more values as individual arguments but instead introduce a new class that holds the the options like this:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class ArrayPoolOptions\r\n{\r\n    public int MaxArrayLength { get; set; }\r\n    public int MaxArraysPerBucket { get; set; }\r\n    public int MinArrayLength { get; set; }\r\n}\r\n\r\npublic static class ArrayPool\u003CT\u003E\r\n{\r\n    public static ArrayPool\u003CT\u003E Create();\r\n    public static ArrayPool\u003CT\u003E Create(int maxArrayLength, int maxArraysPerBucket);\r\n    public static ArrayPool\u003CT\u003E Create(ArrayPoolOptions options);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n(this needs more design, but illustrates the point)",
        "TimeCode": 9440000000,
        "Apis": [
          "M:ArrayPool\u003CT\u003E.Create()",
          "M:ArrayPool\u003CT\u003E.Create(ArrayPoolOptions)",
          "M:ArrayPool\u003CT\u003E.Create(int,int)",
          "P:ArrayPoolOptions.MaxArrayLength",
          "P:ArrayPoolOptions.MaxArraysPerBucket",
          "P:ArrayPoolOptions.MinArrayLength",
          "T:ArrayPool\u003CT\u003E",
          "T:ArrayPoolOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24445,
          "Title": "Add Dictionary\u003CTKey, TValue\u003E.Capacity to let you resize map after created",
          "Author": "davkean",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-05T08:16:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23744",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349406685",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24445#issuecomment-349406685",
        "FeedbackMarkdown": "Looks like the API needs more discussion.",
        "TimeCode": 17020000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23881,
          "Title": "ReadOnlySpan\u003CT\u003E.DangerousGetPinnableReference should return a readonly reference",
          "Author": "ektrah",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-08T13:50:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23492",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349408257",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23881#issuecomment-349408257",
        "FeedbackMarkdown": "We don\u0027t care super much; we see the value in promoting generally safe behavior so the API suggestion looks sensible to me. However, we lack expertise to judge whether this causes clutter (additional casting, like C\u002B\u002B const). So I\u0027d leave it to runtime/compiler folks to decided what to do here.",
        "TimeCode": 33810000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25229,
          "Title": "Change OwnedMemory Pin to take an optional integer offset",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-13T23:49:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24126",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25229#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 37500000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24072,
          "Title": "Span extension method to slice off of a string instance",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-15T14:44:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23569",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349412729",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24072#issuecomment-349412729",
        "FeedbackMarkdown": "That seems like a good suggestion, but we should do the same for arrays.",
        "TimeCode": 38830000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16878,
          "Title": "MemoryExtensions.SequenceCompare",
          "Author": "AronParker",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-08T23:42:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20525",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349414287",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16878#issuecomment-349414287",
        "FeedbackMarkdown": "We should change the name to \u0060SequenceCompareTo\u0060 (notice the \u0060To\u0060 at the end).\r\n\r\n\u0060\u0060\u0060csharp\r\nclass static SpanExtensions\r\n{\r\n    static int SequenceCompareTo(this ReadOnlySpan\u003Cbyte\u003E first, ReadOnlySpan\u003Cbyte\u003E second);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46500000000,
        "Apis": [
          "T:"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14336,
          "Title": "String should implement IReadOnlyList\u003Cchar\u003E",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-12-08T22:47:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19609",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349415239",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14336#issuecomment-349415239",
        "FeedbackMarkdown": "String isn\u0027t (logically) a collection of chars, so giving a read-only view seems off. Considering how far we\u0027re with the new span based APIs, I\u0027m not convinced this interface is adding a ton of value for code that cares about performance (and code that doesn\u0027t has alternatives today).",
        "TimeCode": 47990000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24343,
          "Title": "Add SpanExtensions.AsVector",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-29T20:00:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23688",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "349418624",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24343#issuecomment-349418624",
        "FeedbackMarkdown": "We should align it with the existing APIs, so I\u0027d rather make this a ctor on \u0060Vector\u003CT\u003E\u0060 itself:\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Numerics\r\n{\r\n    public struct Vector\u003CT\u003E\r\n    {\r\n        // Existing API\r\n        public Vector(T[] values);\r\n        // Proposed API\r\n        public Vector(Span\u003CT\u003E values);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52080000000,
        "Apis": [
          "M:Vector\u003CT\u003E.Vector(Span\u003CT\u003E)",
          "M:Vector\u003CT\u003E.Vector(T[])",
          "T:Vector\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24946,
          "Title": "Expose RuntimeWrappedException constructor",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-30T02:10:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23991",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24946#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 58880000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "IIKqOagRdWA",
      "StartDateTime": "2017-12-19T14:08:58.263-08:00",
      "EndDateTime": "2017-12-19T16:00:31-08:00",
      "Title": ".NET Design Reviews Brotli",
      "ThumbnailUrl": "https://i.ytimg.com/vi/IIKqOagRdWA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25785,
          "Title": "Add Brotli Compression to CoreFX",
          "Author": "ianhays",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-07T23:19:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24389",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Compression",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2017-12-19T00:00:00-08:00",
        "FeedbackId": "352921246",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25785#issuecomment-352921246",
        "FeedbackMarkdown": "We reviewed the API and made some minor tweaks:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic partial class BrotliStream : Stream\r\n{\r\n    public BrotliStream(Stream stream, CompressionLevel compressionLevel);\r\n    public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);\r\n    public BrotliStream(Stream stream, CompressionMode mode);\r\n    public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);\r\n    public Stream BaseStream { get; }\r\n\r\n    // We don\u0027t think we need those for now. Not having aligns the type with DeflateStream/GzipStream\r\n    // public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int bufferSize);\r\n    // public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen, int bufferSize);\r\n\r\n    // Overrides omitted for clarity\r\n}\r\n// We discussed making these guys classes and derive from CFO ourselves instead of wrapping a SafeHandle\r\n// but we decided against it due to complexity and only minor savings (like when these are boxed)\r\npublic struct BrotliDecoder : IDisposable\r\n{\r\n    public OperationStatus Decompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesConsumed, out int bytesWritten);\r\n    public void Dispose();\r\n\r\n    public static bool TryDecompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n}\r\npublic struct BrotliEncoder : IDisposable\r\n{\r\n\tBrotliEncoder(int quality, int window);\r\n\r\n    public OperationStatus Compress(ReadOnlySpan\u003Cbyte\u003E source,\r\n    \t                            Span\u003Cbyte\u003E destination,\r\n    \t                            out int bytesConsumed,\r\n    \t                            out int bytesWritten,\r\n    \t                            bool isFinalBlock);\r\n    public OperationStatus Flush(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n    public void Dispose();\r\n\r\n    public static bool TryCompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n    public static bool TryCompress(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten, int quality, int window);\r\n    public static int GetMaxCompressedLength(int length);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BrotliDecoder.Decompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int)",
          "M:BrotliDecoder.Dispose()",
          "M:BrotliDecoder.TryDecompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:BrotliEncoder.BrotliEncoder(int,int)",
          "M:BrotliEncoder.Compress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,out int,bool)",
          "M:BrotliEncoder.Dispose()",
          "M:BrotliEncoder.Flush(Span\u003Cbyte\u003E,out int)",
          "M:BrotliEncoder.GetMaxCompressedLength(int)",
          "M:BrotliEncoder.TryCompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,int,int)",
          "M:BrotliEncoder.TryCompress(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:BrotliStream.BrotliStream(Stream,CompressionLevel,bool)",
          "M:BrotliStream.BrotliStream(Stream,CompressionLevel)",
          "M:BrotliStream.BrotliStream(Stream,CompressionMode,bool)",
          "M:BrotliStream.BrotliStream(Stream,CompressionMode)",
          "P:BrotliStream.BaseStream",
          "T:BrotliDecoder",
          "T:BrotliEncoder",
          "T:BrotliStream"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "dOpH6bUNbcw",
      "StartDateTime": "2018-01-02T10:03:50.039-08:00",
      "EndDateTime": "2018-01-02T10:52:49-08:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dOpH6bUNbcw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25846,
          "Title": "Add StringBuilder.Equals(string) to efficiently compare a StringBuilder with a string.",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-11T23:48:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24418",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354837835",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25846#issuecomment-354837835",
        "FeedbackMarkdown": "It\u0027s a bit odd that the existing \u0060Equals(StringBuilder)\u0060 does an ordinal comparison -- that\u0027s inconsistent with how string comparisons work (defaults to current culture). Hence, it seems acceptable to have an \u0060Equals(string)\u0060 that is ordinal only too. Adding \u0060Equals(string, StringComparison)\u0060 would be doable too, but the only efficient one would be ordinal (all others likely have to enumerate char by char or even allocate), which might make the API a performance trap.\r\n\r\nConclusion: approved as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25671,
          "Title": "Add MemberInfo.IsCollectible \u0026 Assembly.IsCollectible",
          "Author": "JonHanna",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-04T04:13:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24330",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354839520",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25671#issuecomment-354839520",
        "FeedbackMarkdown": "Looks good as proposed; my only question is whether we need/should expose this on \u0060TypeInfo\u0060 as well?\r\n\r\n**Edit** Looks like \u0060TypeInfo\u0060 now inherits from \u0060Type\u0060 so we should be fine.",
        "TimeCode": 9540000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 1593,
          "Title": "XPathNodeIterator should implement IEnumerable\u003CXPathNavigator\u003E",
          "Author": "krwq",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-04-30T18:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14515",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Xml",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354841164",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/1593#issuecomment-354841164",
        "FeedbackMarkdown": "Implementing \u0060IE\u003CX\u003E\u0060 additionally would be fine, but this doesn\u0027t buy you anything for avoiding the cast in the \u0060foreach\u0060 scenario as the compiler will still call through the existing non-generic \u0060GetEnumerator()\u0060 method.\r\n\r\nAm I missing anything?",
        "TimeCode": 13820000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16493,
          "Title": "X509Certificate GetCertHash and GetCertHashString with SHA256",
          "Author": "logiclink",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-27T12:37:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20349",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-02T00:00:00-08:00",
        "FeedbackId": "354843685",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16493#issuecomment-354843685",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 19340000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1t_a9fbB3jY",
      "StartDateTime": "2018-01-12T13:06:19.158-08:00",
      "EndDateTime": "2018-01-12T15:39:05-08:00",
      "Title": ".NET Design Review: Core Pipelines APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1t_a9fbB3jY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25850,
          "Title": "Add MemoryExtension APIs to get parity with array APIs",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-12T01:42:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24420",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "357358606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25850#issuecomment-357358606",
        "FeedbackMarkdown": "Let\u0027s only add \u0060Reverse\u0060 and not the rest. Reason being that delegate invocations could potentially become a perf trap; the have obvious 1 - 5 line replacements for the caller. \u0060Reverse\u0060 can be optimized and seems generally useful.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "357363944",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-357363944",
        "FeedbackMarkdown": "We don\u0027t think this is ready yet. @ahsonkhan, please redesign the APIs to avoid allocations by returning new spans. Instead, they should follow our \u0060TryXxx\u0060 pattern. But we have to keep in mind that many times folks will start with \u0060ReadOnlySpan\u003Cchar\u003E\u0060 from a \u0060string\u0060 where in-place isn\u0027t possible. It would help to have some sample code that shows how these APIs are used.",
        "TimeCode": 12280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25846,
          "Title": "Add StringBuilder.Equals(string) to efficiently compare a StringBuilder with a string.",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-11T23:48:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24418",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-12T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25846#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 26310000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "rSVM5RmAhso",
      "StartDateTime": "2018-01-16T10:06:19.237-08:00",
      "EndDateTime": "2018-01-16T13:32:34-08:00",
      "Title": ".NET Design Reviews GitHub Triage and MemoryPool",
      "ThumbnailUrl": "https://i.ytimg.com/vi/rSVM5RmAhso/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26173,
          "Title": "char.GetUnicodeCategory(unicode scalar)",
          "Author": "ufcpp",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-05T03:14:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24581",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358057543",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26173#issuecomment-358057543",
        "FeedbackMarkdown": "Looks good but we should rename the parameter:\r\n\r\n\u0060\u0060\u0060csharp\r\n public static class CharUnicodeInfo\r\n {\r\n      public static UnicodeCategory GetUnicodeCategory(int codePoint);\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CharUnicodeInfo.GetUnicodeCategory(int)",
          "T:CharUnicodeInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17135,
          "Title": "Helper class for dealing with native shared libraries and function pointers",
          "Author": "mellinoe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-15T00:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20635",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358069191",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17135#issuecomment-358069191",
        "FeedbackMarkdown": "* \u0060IDisposable\u0060. We\u0027re concerned that by making this type \u0060IDisposable\u0060 we lead people down the path of disposing these instances over-aggressively (due to static code analysis rules), resulting in undefined behavior. However, we expect most people never having to unload the library. Thus, we believe it\u0027s more consistent with other concepts, such as \u0060AssemblyLoadContext\u0060, by calling it \u0060Unload\u0060.\r\n\r\n* \u0060throwOnError\u0060. Since failing seems to be the default here, we\u0027ve changed the APIs to follow the Try-pattern.\r\n\r\n* \u0060SearchDirectories\u0060. We\u0027ve removed \u0060SearchDirectories\u0060 as there seems to be no scenario where someone would need to probe that; most probing should be handled by calling \u0060TryOpen.\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\npublic sealed class NativeLibrary\r\n{\r\n    public static bool TryOpen(string name, DllImportSearchPath paths, out NativeLibrary result);\r\n\r\n    public IntPtr Handle { get; }\r\n    public bool TryGetSymbolAddress(string name, out IntPtr result);\r\n    public bool TryGetDelegate\u003CT\u003E(string name, out T result);\r\n    public void Unload();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10210000000,
        "Apis": [
          "M:NativeLibrary.TryGetDelegate\u003CT\u003E(string,out T)",
          "M:NativeLibrary.TryGetSymbolAddress(string,out IntPtr)",
          "M:NativeLibrary.TryOpen(string,DllImportSearchPath,out NativeLibrary)",
          "M:NativeLibrary.Unload()",
          "P:NativeLibrary.Handle",
          "T:NativeLibrary"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26357,
          "Title": "Add MemoryPool APIs",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-16T16:21:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24681",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358079441",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26357#issuecomment-358079441",
        "FeedbackMarkdown": "* **Minimum size**. The sentinel of \u0060int.MinValue\u0060 seems over the top, \u0060-1\u0060 seesm good enough. \u00601\u0060 would be too harsh, as the semantics we want is \u0022give me any buffer size that is convenient for the pool\u0022.\r\n\r\n* **Finalizer**. Don\u0027t define a finalizer. Otherwise, all derived types (even the fully managed ones) go into the finalizer queue.\r\n\r\n* **Default**. Renamed to \u0060Shared\u0060 to align with \u0060ArrayPool\u003CT\u003E\u0060.\r\n\r\n* **Dispose**. What should \u0060Dispose\u0060 do for the \u0060Shared\u0060 instance? It seems no-op is the best choice, otherwise everyone has to special case when folks.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic abstract class MemoryPool\u003CT\u003E : IDisposable\r\n{\r\n    public static MemoryPool\u003CT\u003E Shared { get; }\r\n\r\n    public abstract OwnedMemory\u003CT\u003E Rent(int minBufferSize=-1);\r\n    public abstract int MaxBufferSize { get; }\r\n\r\n    protected MemoryPool();\r\n    public void Dispose();\r\n    protected abstract void Dispose(bool disposing);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33790000000,
        "Apis": [
          "M:MemoryPool\u003CT\u003E.Dispose()",
          "M:MemoryPool\u003CT\u003E.Dispose(bool)",
          "M:MemoryPool\u003CT\u003E.MemoryPool()",
          "M:MemoryPool\u003CT\u003E.Rent(int)",
          "P:MemoryPool\u003CT\u003E.MaxBufferSize",
          "P:MemoryPool\u003CT\u003E.Shared",
          "T:MemoryPool\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-16T00:00:00-08:00",
        "FeedbackId": "358087851",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-358087851",
        "FeedbackMarkdown": "\u0060\u0060\u0060c#\r\n// Approved, but needs to go somewhere else due to globalization\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    \r\n    public static bool Equals(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int Compare(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool Contains(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n\r\n    public static bool StartsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool EndsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E span);\r\n}\r\n\r\n// Needs more work\r\n\r\npublic static class MemoryExtensions\r\n{\r\n    // APIs designed to avoid allocations:\r\n\r\n    public static bool Remove(this ReadOnlySpan\u003Cchar\u003E source, int startIndex, int count, Span\u003Cchar\u003E destination);\r\n    \r\n    public static bool Replace(this ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E oldValue, ReadOnlySpan\u003Cchar\u003E newValue, Span\u003Cchar\u003E destination, out int bytesWritten);\r\n    \r\n    // do we need bytesWritten? It should be source.Length on success\r\n    public static bool ToUpper(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToLower(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static bool ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n}\r\n\r\n// We probably don\u0027t want these    \r\n\r\npublic static class MemoryExtensions\r\n{\r\n    public static bool PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination); \r\n    public static bool PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, char paddingChar, Span\u003Cchar\u003E destination);\r\n    public static bool PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static bool PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, char paddingChar, Span\u003Cchar\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54840000000,
        "Apis": [
          "M:MemoryExtensions.Compare(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Contains(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.EndsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Equals(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,char,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,char,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Remove(this ReadOnlySpan\u003Cchar\u003E,int,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Replace(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,out int)",
          "M:MemoryExtensions.StartsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.ToLower(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpper(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Qcqn-yv1X0o",
      "StartDateTime": "2018-01-19T14:07:06.962-08:00",
      "EndDateTime": "2018-01-19T17:17:29-08:00",
      "Title": ".NET Design Reviews Awaiter APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Qcqn-yv1X0o/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26002,
          "Title": "Change OwnedMemory\u003CT\u003E to IOwnedMemory\u003CT\u003E",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-20T20:48:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24495",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359105642",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26002#issuecomment-359105642",
        "FeedbackMarkdown": "We decided against it. We cannot model read-only spans with this interface unless we\u0027re creating RW and RO interfaces for this.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26139,
          "Title": "Move Span.DangerousCreate to MemoryMarshal.Create",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-03T22:50:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24562",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359111438",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26139#issuecomment-359111438",
        "FeedbackMarkdown": "We should consider changing the second overload to be \u0060in\u0060. Otherwise, it looks good as proposed.",
        "TimeCode": 8150000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26368,
          "Title": "Move Span.NonPortableCast to MemoryMarshal and rename to Cast",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-16T22:18:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24689",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-19T00:00:00-08:00",
        "FeedbackId": "359109249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26368#issuecomment-359109249",
        "FeedbackMarkdown": "Looks good as proposed. We can add a more specialized API that handles the \u0060else\u0060 case if we we want to. Only difference from the proposal is to leave it on \u0060MemoryExtensions\u0060 as the API is now safe.\r\n\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System\r\n{\r\n    public static partial class MemoryExtensions\r\n    {\r\n        public static bool TryCast\u003CTFrom, TTo\u003E(this ReadOnlySpan\u003CTFrom\u003E source, out ReadOnlySpan\u003CTTo\u003E output) where TFrom : struct where TTo : struct;\r\n        public static bool TryCast\u003CTFrom, TTo\u003E(this Span\u003CTFrom\u003E source, out Span\u003CTTo\u003E output) where TFrom : struct where TTo : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe\u0027ll also leave the \u0060NonPortableCast\u0060 API but we\u0027ll move it \u0060MemoryMarshal\u0060. We need to make sure it\u0027s not an extension method, under which case we can rename it to just \u0060Cast\u0060.",
        "TimeCode": 22940000000,
        "Apis": [
          "M:MemoryExtensions.TryCast\u003CTFrom, TTo\u003E(this ReadOnlySpan\u003CTFrom\u003E,out ReadOnlySpan\u003CTTo\u003E)",
          "M:MemoryExtensions.TryCast\u003CTFrom, TTo\u003E(this Span\u003CTFrom\u003E,out Span\u003CTTo\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "m3Q6MENq17g",
      "StartDateTime": "2018-01-23T10:08:02.689-08:00",
      "EndDateTime": "2018-01-23T11:58:45-08:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/m3Q6MENq17g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 4382,
          "Title": "Update HttpStatusCode enum with updates",
          "Author": "mteper",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-11-06T18:28:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15650",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/4382#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26201,
          "Title": "Add application/json to System.Net.Mime.MediaTypeNames.Application",
          "Author": "madelson",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-06T01:17:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24597",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26201#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 2670000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26451,
          "Title": "Unsafe API for comparing byrefs as pointers",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-19T17:36:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24729",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359887092",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26451#issuecomment-359887092",
        "FeedbackMarkdown": "We think these names align closer to the framework naming:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class Unsafe\r\n{\r\n    public static bool IsAddressLessThan\u003CT\u003E(ref T left, ref T right);\r\n    public static bool IsAddressGreaterThan\u003CT\u003E(ref T left, ref T right);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3830000000,
        "Apis": [
          "M:Unsafe.IsAddressGreaterThan\u003CT\u003E(ref T,ref T)",
          "M:Unsafe.IsAddressLessThan\u003CT\u003E(ref T,ref T)",
          "T:Unsafe"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25718,
          "Title": "New APIs for Accessing RSS Optional Elements",
          "Author": "shmao",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-05T17:59:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24348",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.ServiceModel.Syndication",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359890337",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25718#issuecomment-359890337",
        "FeedbackMarkdown": "* \u0060TimeToLive\u0060 should throw when the \u0060TimeSpan\u0060 when the time span cannot be represented as an \u0060int\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.ServiceModel.Syndication\r\n{\r\n    public partial class SyndicationFeed\r\n    {\r\n        public SyndicationLink Documentation { get; set; }\r\n        public Collection\u003Cstring\u003E SkipDays { get; }\r\n        public Collection\u003Cint\u003E SkipHours { get; }\r\n        public SyndicationTextInput TextInput { get; set; }\r\n        public TimeSpan? TimeToLive { get; set; }\r\n    }\r\n    public partial class SyndicationTextInput\r\n    {\r\n        public string Description { get; set; }\r\n        public SyndicationLink Link { get; set; }\r\n        public string Name { get; set; }\r\n        public string Title { get; set; }\r\n        public SyndicationTextInput();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17330000000,
        "Apis": [
          "M:SyndicationTextInput.SyndicationTextInput()",
          "P:SyndicationFeed.Documentation",
          "P:SyndicationFeed.SkipDays",
          "P:SyndicationFeed.SkipHours",
          "P:SyndicationFeed.TextInput",
          "P:SyndicationFeed.TimeToLive",
          "P:SyndicationTextInput.Description",
          "P:SyndicationTextInput.Link",
          "P:SyndicationTextInput.Name",
          "P:SyndicationTextInput.Title",
          "T:SyndicationFeed",
          "T:SyndicationTextInput"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 21395,
          "Title": "String-like extension methods to ReadOnlySpan\u003Cchar\u003E Epic",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-06-23T00:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22434",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-01-23T00:00:00-08:00",
        "FeedbackId": "359906138",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/21395#issuecomment-359906138",
        "FeedbackMarkdown": "* We can expose all these APIs from MemoryExtensions, even the ones that need globalization APIs as this just means we can\u0027t expose them (yet).\r\n* We\u0027ll not expose APIs that make \u0060StringComparison\u0060 or \u0060CultureInfo\u0060 implicit. We might get feedback, but we think forcing the developer to make a decision is less prone to errors than selecting a default.\r\n* We\u0027ve removed \u0060Replace\u0060 as we don\u0027t think the API interaction / pattern works out. It need more thought/design.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class MemoryExtensions\r\n{\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E Trim(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, char trimChar);\r\n    public static ReadOnlySpan\u003Cchar\u003E TrimEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E trimChars);\r\n\r\n    public static bool IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E span);\r\n\r\n    public static void Remove(this ReadOnlySpan\u003Cchar\u003E source, int startIndex, int count, Span\u003Cchar\u003E destination);    \r\n    public static void PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static void PadLeft(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination, char paddingChar);\r\n    public static void PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination);\r\n    public static void PadRight(this ReadOnlySpan\u003Cchar\u003E source, int totalWidth, Span\u003Cchar\u003E destination, char paddingChar);\r\n\r\n    // Those need access to globalization APIs. We\u0027ll also expose them from\r\n    // the .NET Framework OOB (slow span). They will try to extract the string\r\n    // from the underlying span (because slow span stores it) -- or -- allocate\r\n    // a new string. This avoids bifurcating the API surface.\r\n\r\n    public static bool Contains(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool EndsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool Equals(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static bool StartsWith(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int CompareTo(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n    public static int IndexOf(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparison);\r\n\r\n    public static void ToLower(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination, CultureInfo culture);\r\n    public static void ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n    public static void ToUpper(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination, CultureInfo culture);\r\n    public static void ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24440000000,
        "Apis": [
          "M:MemoryExtensions.CompareTo(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Contains(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.EndsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.Equals(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IndexOf(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.IsWhiteSpace(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E,char)",
          "M:MemoryExtensions.PadLeft(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E,char)",
          "M:MemoryExtensions.PadRight(this ReadOnlySpan\u003Cchar\u003E,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Remove(this ReadOnlySpan\u003Cchar\u003E,int,int,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.StartsWith(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.ToLower(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,CultureInfo)",
          "M:MemoryExtensions.ToLowerInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.ToUpper(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,CultureInfo)",
          "M:MemoryExtensions.ToUpperInvariant(this ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.Trim(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimEnd(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.TrimStart(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "4hIcv01O3aQ",
      "StartDateTime": "2018-02-13T10:08:00.752-08:00",
      "EndDateTime": "2018-02-13T12:08:59-08:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/4hIcv01O3aQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 10749,
          "Title": "Add time-constant equals and other utility methods to System.Security",
          "Author": "clintharrison",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-08-13T02:06:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18086",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365354366",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/10749#issuecomment-365354366",
        "FeedbackMarkdown": "Looks good as updated in [the last comment](https://github.com/dotnet/corefx/issues/10749#issuecomment-365027340).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17135,
          "Title": "Helper class for dealing with native shared libraries and function pointers",
          "Author": "mellinoe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-15T00:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20635",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365365224",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17135#issuecomment-365365224",
        "FeedbackMarkdown": "@dotMorten \r\n\r\nThe \u0060name\u0060 argument for \u0060TryLoad\u0060 allows relative paths but behavior depends on the value of \u0060paths\u0060.",
        "TimeCode": 2900000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26935,
          "Title": "Add API for reading/writing PDB Checksum Debug Directory entry",
          "Author": "tmat",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-07T20:58:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24953",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection.Metadata",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365370670",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26935#issuecomment-365370670",
        "FeedbackMarkdown": "We just took a look. Looks good as proposed. Questions that came up:\r\n\r\n* Should the \u0060ImmtuableArray\u003Cbyte\u003E\u0060 be a \u0060ReadOnlySpan\u003Cbyte\u003E\u0060. We assumed the answer to be no, as S.R.M doesn\u0027t depend on span yet and you need to ship downlevel. Once you spannify S.R.M we can still add overloads.\r\n* \u0060IdStartOffset\u0060 are 32 bit enough? Assumption is yes, but hey :-)",
        "TimeCode": 24440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26894,
          "Title": "Cleanup after removal of MemoryExtensions As* api.",
          "Author": "KrzysztofCwalina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-06T16:53:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24938",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365381215",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26894#issuecomment-365381215",
        "FeedbackMarkdown": "Looks good as proposed. Regarding the open issues at the end:\r\n\r\n5. **Limit constructors to the longest (most flexible) overload.**. Makes sense, we want the .ctors to be largely plumbing. However, we don\u0027t want to lose perf due to excessive argument validation. We\u0027ll add overloads as needed for perf, but not usability.\r\n\r\n6. **Provide \u0060AsReadOnly()\u0060 methods on r/w/ slice types.**. We agreed to not adding these methods.\r\n\r\n7. **Skip \u0060ReadOnly\u0060 from conversion method names if the source type is already read-only. For example, string can be converted only to \u0060ReadOnlySpan\u003Cchar\u003E\u0060 and so the As\u003Cslice_type\u003E method should be called \u0060AsSpan\u0060, not \u0060AsReadOnlySpan\u0060**. Makes sense.",
        "TimeCode": 35930000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25875,
          "Title": "Add overloads to enumeration APIs that take FindOptions flags",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-12T23:21:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24431",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365383129",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25875#issuecomment-365383129",
        "FeedbackMarkdown": "Superseded by #25873",
        "TimeCode": 57560000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25873,
          "Title": "Add file enumeration extensibility points",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-12T23:11:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24429",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-13T00:00:00-08:00",
        "FeedbackId": "365388259",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25873#issuecomment-365388259",
        "FeedbackMarkdown": "Looks good. Comments:\r\n\r\n* \u0060MatchType\u0060, \u0060MatchCasing\u0060, \u0060EnumerationOptions\u0060 should live in \u0060System.IO\u0060. Please submit a proposal with the updated \u0060System.IO\u0060 APIs\r\n* \u0060EnumerationOptions.IgnoreInaccessible\u0060 should be \u0060true\u0060 by default\r\n* \u0060EnumerationOptions.AttributesToSkip\u0060 should include system and hidden files.",
        "TimeCode": 61440000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9BC3Q1kgWAA",
      "StartDateTime": "2018-02-20T10:05:09.983-08:00",
      "EndDateTime": "2018-02-20T11:02:19-08:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9BC3Q1kgWAA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27237,
          "Title": "Consider adding MemoryMarshal.GetOwner(ROM)",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-18T17:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25082",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "367072826",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27237#issuecomment-367072826",
        "FeedbackMarkdown": "We believe this API would slightly better and would be more consistent:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static bool TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out TOwner ownedMemory)\r\n           where TOwner: OwnedMemory\u003CT\u003E;\r\n        public static bool TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E readOnlyMemory, out TOwner ownedMemory, out int index, out int length)\r\n           where TOwner: OwnedMemory\u003CT\u003E;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MemoryMarshal.TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E,out TOwner,out int,out int)",
          "M:MemoryMarshal.TryGetOwnedMemory\u003CT, TOwner\u003E(ReadOnlyMemory\u003CT\u003E,out TOwner)",
          "T:MemoryMarshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26995,
          "Title": "Add DecompressionMethods.Brotli?",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-09T13:16:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24986",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26995#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 15140000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25873,
          "Title": "Add file enumeration extensibility points",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-12T23:11:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24429",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-20T00:00:00-08:00",
        "FeedbackId": "367082482",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25873#issuecomment-367082482",
        "FeedbackMarkdown": "We should probably rename \u0060MatchType.Dos\u0060 to \u0060MatchType.Win32\u0060. Otherwise, looks good as proposed.",
        "TimeCode": 22910000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1pR7fDL0PBA",
      "StartDateTime": "2018-02-27T10:06:34.794-08:00",
      "EndDateTime": "2018-02-27T12:04:59-08:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1pR7fDL0PBA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27500,
          "Title": "Drop \u0060IMemoryList\u0060 and replace with abstract \u0060ReadOnlySequenceSegment\u0060",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-27T06:38:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25213",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27500#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27403,
          "Title": "Add GetPosition overload to ReadOnlySequence that only takes an int/long",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-23T08:22:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25166",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368977923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27403#issuecomment-368977923",
        "FeedbackMarkdown": "We decided to go with @KrzysztofCwalina\u0027s proposal:\r\n\r\n\u0060\u0060\u0060c#\r\nvar position = sequence.GetPosition(100, sequence.Start);\r\n// and\r\nvar position = sequence.GetPosition(100);\r\n\u0060\u0060\u0060",
        "TimeCode": 9850000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27451,
          "Title": "Move Memory.TryGetXxx Extensions to MemoryMarshal.TryGetXxx",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-25T14:12:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25187",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368979558",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27451#issuecomment-368979558",
        "FeedbackMarkdown": "Argument makes sense, but we don\u0027t need the second one as the existing \u0060TryGetArray\u0060 covers that.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class MemoryMarshal\r\n{\r\n    public static bool TryGetString(ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string text, out int start, out int length);\r\n}\r\n\u0060\u0060\u0060\u0060\r\n\r\nBut we still need to remove these instance methods:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static partial class MemoryExtensions\r\n{\r\n    public static bool TryGetString(this ReadOnlyMemory\u003Cchar\u003E readOnlyMemory, out string text, out int start, out int length);\r\n}\r\n\r\npublic static partial struct Memory\u003CT\u003E\r\n{\r\n    public bool TryGetArray(out ArraySegment\u003CT\u003E arraySegment)\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12880000000,
        "Apis": [
          "M:Memory\u003CT\u003E.TryGetArray(out ArraySegment\u003CT\u003E)",
          "M:MemoryExtensions.TryGetString(this ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "M:MemoryMarshal.TryGetString(ReadOnlyMemory\u003Cchar\u003E,out string,out int,out int)",
          "T:Memory\u003CT\u003E",
          "T:MemoryExtensions",
          "T:MemoryMarshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27464,
          "Title": "Change new QueueUserWorkItem method to use \u0060TState\u0060",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-26T04:57:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25193",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27464#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 17150000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16767,
          "Title": "Expose Thread.GetCurrentProcessorId() as a public API",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-06T17:34:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20480",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "368983869",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16767#issuecomment-368983869",
        "FeedbackMarkdown": "Makes but we believe it (1) should be a method and (2) live on \u0060Thread\u0060.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Threading\r\n{\r\n    public partial class Thread\r\n    {\r\n        public static int GetCurrentProcessorId();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17700000000,
        "Apis": [
          "M:Thread.GetCurrentProcessorId()",
          "T:Thread"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27329,
          "Title": "SocketsHttpHandler: Consider exposing setting for maximum response drain size",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-21T17:29:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25130",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27329#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24360000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24668,
          "Title": "New APIs in SyndicationFeedFormatter",
          "Author": "shmao",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-16T18:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23860",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.ServiceModel.Syndication",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-02-27T00:00:00-08:00",
        "FeedbackId": "369004374",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24668#issuecomment-369004374",
        "FeedbackMarkdown": "BTW: structs renamed to \u0060*Data\u0060, delegates are \u0060*Callback\u0060, args renamed to \u0060data\u0060.",
        "TimeCode": 64420000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "RsNFSBH3XX0",
      "StartDateTime": "2018-03-13T10:04:05.32-07:00",
      "EndDateTime": "2018-03-13T11:01:27-07:00",
      "Title": ".NET Design Reviews GitHub Triage and Span(of T) Consistency",
      "ThumbnailUrl": "https://i.ytimg.com/vi/RsNFSBH3XX0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 12038,
          "Title": "Add support for RemoteCertificateValidationCallback with ClientWebSocket",
          "Author": "BravoTango86",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-09-24T18:42:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/18696",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-03-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/12038#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27417,
          "Title": "[System.Runtime.InteropServices] Introduce broader platform definitions. ",
          "Author": "migueldeicaza",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-23T20:31:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25172",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-03-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27417#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 6320000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "HvGnuR6zxfI",
      "StartDateTime": "2018-03-20T10:04:54.246-07:00",
      "EndDateTime": "2018-03-20T12:02:48-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/HvGnuR6zxfI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27418,
          "Title": "Path Span APIs that write into a specified buffer",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-23T21:14:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25173",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-03-20T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27418#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "cwX05hKkp8s",
      "StartDateTime": "2018-03-27T10:10:49.214-07:00",
      "EndDateTime": "2018-03-27T10:57:46-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/cwX05hKkp8s/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24553,
          "Title": "SNI API for SslStream",
          "Author": "Drawaes",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-10T21:13:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23797",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-03-27T00:00:00-07:00",
        "FeedbackId": "376614353",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24553#issuecomment-376614353",
        "FeedbackMarkdown": "@krwq, please make sure that deciding on the cert via a callback is viable, i.e. you don\u0027t have to pass a mapping of host name to cert up front on any of the platforms we support with .NET Core. Otherwise, the API shape won\u0027t work.\r\n\r\n\u003E When caller returns \u0060null\u0060 certificate we will throw \u0060AuthenticationException\u0060\r\n\r\nAlternative design would be that \u0060null\u0060 means use the default certificate (\u0060SslServerAuthenticationOptions.ServerCertificate\u0060). That might be more convenient without forcing the delegate to allocate a closure.\r\n\r\n@davidfowl @halter73, preferences?",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "FwqoZUlanYg",
      "StartDateTime": "2018-04-10T10:07:15.315-07:00",
      "EndDateTime": "2018-04-10T10:55:40-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/FwqoZUlanYg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28959,
          "Title": "Remove SequenceMarshal.TryGetMemoryManager for ReadOnlySequence",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-10T02:19:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25825",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28959#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28954,
          "Title": "Make CreateFromPinnedArray visible and move it to MemoryMarshal",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-09T23:55:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25824",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28954#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 3000000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28751,
          "Title": "Remove .Length from MemoryManager\u003CT\u003E",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-03T03:40:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25728",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28751#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 8150000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28969,
          "Title": "Add GetPinnableReference back to Span and ReadOnlySpan",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-10T05:18:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25830",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-10T00:00:00-07:00",
        "FeedbackId": "380190393",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28969#issuecomment-380190393",
        "FeedbackMarkdown": "* The API looks fine. It\u0027s a bit weird to have these APIs on \u0060Span\u003CT\u003E\u0060 and \u0060ReadOnlySpan\u003CT\u003E\u0060, it would be more consistent to have these APIs on \u0060MemoryMarshal\u0060. However, one could also argue that these API are are safe, as they return \u0060null\u0060 for empty spans, so callers will get a null reference rather than being able to get into corrupted states.\r\n\r\n* It\u0027s true that we mostly don\u0027t have extension methods there, but I don\u0027t see a reason why we wouldn\u0027t declare them as extension methods. However, the real issue is that moving them to \u0060MemoryMarshal\u0060 is that without the using, the feature wouldn\u0027t work. Yes, its not different from Linq, but it seems desirable to have these APIs just work.\r\n\r\nHence, we believe these should be instance methods on \u0060Span\u003CT\u003E\u0060 and \u0060ReadOnlySpan\u003CT\u003E\u0060. We\u0027d still mark the APIs as \u0060[EditorBrowsable(Never)]\u0060 as this API is plumbing only.",
        "TimeCode": 13650000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "8m4ijdz0CXw",
      "StartDateTime": "2018-04-17T10:21:41.214-07:00",
      "EndDateTime": "2018-04-17T11:02:24-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8m4ijdz0CXw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29026,
          "Title": "Expose \u0060System.Runtime.CompilerServices.SkipLocalsInitAttribute\u0060",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-11T15:09:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25850",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-17T00:00:00-07:00",
        "FeedbackId": "382076991",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29026#issuecomment-382076991",
        "FeedbackMarkdown": "Questions:\r\n\r\n* Will there be a keyword in the language too or will developers use the attribute?\r\n* Presumably people will be able to define the attribute in their own code and get the same behavior?\r\n* Does it make sense to be applied to fields? Presumably no, because what matters is the constructor in case initializers are present?\r\n* Do you plan to support override behavior, i.e. apply to assembly/module/type to turn on/off and then override on the a per member basis?\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeUsage.All, Inherited = false)]\r\n    public sealed class SkipLocalsInitAttribute : Attribute\r\n    {\r\n        public SkipLocalsInitAttribute(bool isEnabled);\r\n        public bool IsEnabled { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SkipLocalsInitAttribute.SkipLocalsInitAttribute(bool)",
          "P:SkipLocalsInitAttribute.IsEnabled",
          "T:SkipLocalsInitAttribute"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28944,
          "Title": "Add a GetEncodings method to System.Text.EncodingProvider to support enumerating available character encodings",
          "Author": "mklement0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-09T20:59:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encoding",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-17T00:00:00-07:00",
        "FeedbackId": "382081100",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28944#issuecomment-382081100",
        "FeedbackMarkdown": "* \u0060EncodingProvider.GetEncodings()\u0060 should be \u0060IEnumerable\u003CEncodingInfo\u003E\u0060\r\n* \u0060EncodingProvider.GetEncodings()\u0060 should be virtual and return an empty list (instead of throwing). While this isn\u0027t correct it means that one provider that isn\u0027t updated doesn\u0027t spoil the enumeration for everyone else.\r\n* \u0060Encoding.GetEncodings()\u0060 should return all registered encodings across all providers and de-dupe them if necessary.",
        "TimeCode": 5930000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "E9X-kNjBtG8",
      "StartDateTime": "2018-04-24T10:04:39.717-07:00",
      "EndDateTime": "2018-04-24T11:02:36-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/E9X-kNjBtG8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26406,
          "Title": "SignedCms extensibility to support external private keys",
          "Author": "clairernovotny",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-18T02:17:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24707",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384009048",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26406#issuecomment-384009048",
        "FeedbackMarkdown": "Looks good, any reason we wouldn\u0027t expose a matching property? @bartonjs suggested to use the name \u0060privateKey\u0060 instead of just \u0060key\u0060, which seems reasonable to me too.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29273,
          "Title": "Add FileSystem.Watcher.FilterList Property",
          "Author": "Anipik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-22T21:03:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25967",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384014580",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29273#issuecomment-384014580",
        "FeedbackMarkdown": "Looks a good. A few points:\r\n\r\n* We should just use a plural form instead of the \u0060List\u0060 suffix, e.g. \u0060Filters\u0060.\r\n* The property shouldn\u0027t be settable as this avoids problems when the watcher needs to use a derived type in the implementation.\r\n* The existing API \u0060Filter\u0060 will return the first item in \u0060Filters\u0060. If set, it will clear \u0060Filters\u0060 and add the one item.\r\n* Adding a constructor that takes path and filters would be a source breaking change if people call it with a null value for the second argument (because we have an existing one that takes string). However, we could add a longer version that would also accept, say, the matcher type. But that would be a separate API review.",
        "TimeCode": 3100000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29207,
          "Title": "Public setter for System.Diagnostics.Activity.Current",
          "Author": "lmolkova",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-19T04:24:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25936",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29207#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13630000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24145,
          "Title": "Consider Span\u003Cchar\u003E overloads on Regex classes",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-19T16:40:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23602",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24145#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19790000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16011,
          "Title": "Proposal: New Zip LINQ Tuple Overload API",
          "Author": "jcouv",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-09T20:39:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20167",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-04-24T00:00:00-07:00",
        "FeedbackId": "384022447",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16011#issuecomment-384022447",
        "FeedbackMarkdown": "\u2764\uFE0F",
        "TimeCode": 20470000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "-6wyH7K4L9g",
      "StartDateTime": "2018-05-22T10:08:46.33-07:00",
      "EndDateTime": "2018-05-22T12:00:12-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/-6wyH7K4L9g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29770,
          "Title": "Adding GetChunks which allow efficient scanning of a StringBuilder",
          "Author": "vancem",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-17T20:43:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26207",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391080101",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29770#issuecomment-391080101",
        "FeedbackMarkdown": "Looks good, only change is that we think we should collapse the two types:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass StringBuilder {\r\n        public ChunkEnumerator GetChunks();\r\n\r\n        public struct ChunkEnumerator\r\n        {\r\n            [EditorBrowsable(Never)] // Only here to make foreach work\r\n            public ChunkEnumerator GetEnumerator();\r\n            public bool MoveNext();\r\n            public ReadOnlyMemory\u003Cchar\u003E Current { get; }\r\n        }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n* Potentially we can add \u0060CurrentSpan\u0060 to make it cheaper to get the span\r\n* We could also in the future expose a \u0060CurrentSpanReadWrite\u0060 if we ever need a mutating version.",
        "TimeCode": 0,
        "Apis": [
          "M:StringBuilder.ChunkEnumerator.GetEnumerator()",
          "M:StringBuilder.ChunkEnumerator.MoveNext()",
          "M:StringBuilder.GetChunks()",
          "P:StringBuilder.ChunkEnumerator.Current",
          "T:StringBuilder",
          "T:StringBuilder.ChunkEnumerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29696,
          "Title": "Exception.HResult setter should be made public",
          "Author": "luqunl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-14T18:36:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26163",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29696#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 22670000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29623,
          "Title": "Add SpinWait.SpinOnce overload to specify or disable the Sleep(1) threshold",
          "Author": "kouvel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-10T01:27:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26132",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391085259",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29623#issuecomment-391085259",
        "FeedbackMarkdown": "* Looks good but we should shorten the name.\r\n* Are there any other thresholds that we need to expose?\r\n\r\n\u0060\u0060\u0060csharp\r\npublic struct SpinWait\r\n{\r\n    public void SpinOnce(int sleep1Threshold);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25560000000,
        "Apis": [
          "M:SpinWait.SpinOnce(int)",
          "T:SpinWait"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29327,
          "Title": "Enable EnvelopedCms to work with an external private key",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-25T14:56:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25991",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391088582",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29327#issuecomment-391088582",
        "FeedbackMarkdown": "Looks good, after minor name change:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic partial class EnvelopedCms\r\n{\r\n     public void Decrypt(RecipientInfo recipientInfo, AsymmetricAlgorithm privateKey);\r\n}\r\n\r\npublic partial class SubjectIdentifier\r\n{\r\n     public bool MatchesCertificate(X509Certificate2 certificate);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32010000000,
        "Apis": [
          "M:EnvelopedCms.Decrypt(RecipientInfo,AsymmetricAlgorithm)",
          "M:SubjectIdentifier.MatchesCertificate(X509Certificate2)",
          "T:EnvelopedCms",
          "T:SubjectIdentifier"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29243,
          "Title": "Add DecompressionMethods.All?",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-20T20:01:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25950",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "Color": "5319e7",
              "Description": "Issues picked for Hackathon"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391095592",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29243#issuecomment-391095592",
        "FeedbackMarkdown": "Seems reasonable.",
        "TimeCode": 38160000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25040,
          "Title": "Implement portable support for TCP_KEEPCNT, TCP_KEEPIDLE and TCP_KEEPINTVL socket options",
          "Author": "GoldenCrystal",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-03T12:53:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24041",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "Color": "5319e7",
              "Description": "Issues picked for Hackathon"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391097721",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25040#issuecomment-391097721",
        "FeedbackMarkdown": "Looks good.\r\n\r\nCan we double check what happens if options are no-ops or are unsupported. Do we throw? If so, should the name of the option indicate that things might be unsupported or are no-ops?",
        "TimeCode": 51700000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26975,
          "Title": "[Cookie] CookieCollection should implement ICollection\u003CCookie\u003E",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-08T23:25:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24973",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "Color": "5319e7",
              "Description": "Issues picked for Hackathon"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391098529",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26975#issuecomment-391098529",
        "FeedbackMarkdown": "Looks good but for consistency we should also implement \u0060IReadOnlyCollection\u003C\u003E\u0060.",
        "TimeCode": 54400000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28046,
          "Title": "Support struct Enumerator for ConcurrentDictionary",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-14T04:08:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25448",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391102771",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28046#issuecomment-391102771",
        "FeedbackMarkdown": "The options listed here are all somewhat unfortunate (that is, they suck for various reasons :-)).\r\n\r\nOne compromise would be to add a new method called \u0060GetEnumerator2()\u0060 and change the compiler to support foreach-ing enumerators and code would like this:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar dict = new ConcurrentDictionary\u003Cstring, int\u003E();\r\n// add stuff\r\n\r\nforeach (var kv in dict.GetEnumerator2())\r\n{\r\n    Use(enumerator.Current);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe established patterns for struct-based alternative is \u0060ValueXxx\u0060, like \u0060ValueTuple\u0060 or \u0060ValueTask\u0060 but in this case \u0060value\u0060 might be a bad idea due to the generic parameter \u0060TValue\u0060.\r\n\r\n@jaredpar, are you still supportive of this change to the compiler?\r\n@stephentoub, are you OK with the resulting usage?",
        "TimeCode": 56680000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14334,
          "Title": "TypeInfo doesn\u0027t expose a parameterless constructor",
          "Author": "mellinoe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-12-08T22:16:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19608",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-22T00:00:00-07:00",
        "FeedbackId": "391103797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14334#issuecomment-391103797",
        "FeedbackMarkdown": "Let\u0027s start doing this in .NET Core. This doesn\u0027t help the RefEmit case for .NET Standard, but we gonna start somewhere :-)",
        "TimeCode": 64720000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ZHKLi8qWTCs",
      "StartDateTime": "2018-05-29T10:07:46.628-07:00",
      "EndDateTime": "2018-05-29T10:52:04-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ZHKLi8qWTCs/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28410,
          "Title": "Regex Match, Split and Matches should support RegexOptions.AnyNewLine as (?=\\r\\z|\\n\\z|\\r\\n\\z|\\z)",
          "Author": "jzabroski",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-23T15:39:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25598",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "392863409",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28410#issuecomment-392863409",
        "FeedbackMarkdown": "Looks good. A few comments:\r\n\r\n* We cannot use the proposed value of 128 because it\u0027s already taken (see \u0060#if DBG\u0060 in code)\r\n* The table looks wrong (Windows on Windows on the Current should work IMHO)\r\n* May be \u0060AcceptAllLineEndings\u0060?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 23262,
          "Title": "GroupCollection should implement IReadOnlyDictionary interface to align with its Dictionary-Type Usage",
          "Author": "michael-hawker",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-08-15T20:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23186",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "Hackathon",
              "Color": "5319e7",
              "Description": "Issues picked for Hackathon"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "392866863",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/23262#issuecomment-392866863",
        "FeedbackMarkdown": "Looks good.\r\n\r\n* We should also implement IDictionary\u003CK,V\u003E as the BCL exposes the notion of read-onlyness as a mode (\u0060IsReadOnly\u0060 returns true)\r\n* Given that we implemen \u0060IList\u003C\u003E\u0060, should we also implement \u0060IReadOnlyList\u003C\u003E\u0060?",
        "TimeCode": 6200000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29917,
          "Title": "Socket support for TCP_QUICKACK",
          "Author": "felipepessoto",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-25T13:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/798",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29917#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13000000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 14334,
          "Title": "TypeInfo doesn\u0027t expose a parameterless constructor",
          "Author": "mellinoe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-12-08T22:16:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19608",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-05-29T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/14334#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16730000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "CcocbzCjCxM",
      "StartDateTime": "2018-06-12T10:09:04.232-07:00",
      "EndDateTime": "2018-06-12T12:04:14-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CcocbzCjCxM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30048,
          "Title": "Make it easy for large StringBuilders to be written to TextWriters without making a large string ",
          "Author": "vancem",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-01T15:57:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26347",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "396671773",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30048#issuecomment-396671773",
        "FeedbackMarkdown": "Looks good as proposed. A few minor suggestions:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass TextWriter {\r\n    public virtual void Write(StringBuilder value);\r\n    public virtual void WriteLine(StringBuilder value);\r\n    public virtual Task WriteAsync(StringBuilder value, CancelationToken cancellationToken=default);\r\n    public virtual Task WriteLineAsync(StringBuilder value, CancelationToken cancellationToken=default);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe should consider special casing \u0060Write(object)\u0060 to check for \u0060StringBuilder\u0060 to avoid going through \u0060StringBuilder.ToString()\u0060. Althought it seems we aren\u0027t special casing any other types but \u0060IFormattable\u0060 today.",
        "TimeCode": 0,
        "Apis": [
          "M:TextWriter.Write(StringBuilder)",
          "M:TextWriter.WriteAsync(StringBuilder,CancelationToken)",
          "M:TextWriter.WriteLine(StringBuilder)",
          "M:TextWriter.WriteLineAsync(StringBuilder,CancelationToken)",
          "T:TextWriter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29979,
          "Title": "Allow Dictionary\u003CK,V\u003E.Remove during enumeration",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-30T16:27:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26314",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29979#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28594,
          "Title": "Proposal: new System.ComponentModel.VersionConverter class",
          "Author": "0xced",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-29T13:10:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25671",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.ComponentModel",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-12T00:00:00-07:00",
        "FeedbackId": "396690545",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28594#issuecomment-396690545",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 47690000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "PKQLZXybOUA",
      "StartDateTime": "2018-06-26T10:09:06.741-07:00",
      "EndDateTime": "2018-06-26T11:35:20-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PKQLZXybOUA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30649,
          "Title": "Add SpanExtensions.LastIndexOf StringComparison overload",
          "Author": "ViktorHofer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-25T18:56:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26605",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30649#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30613,
          "Title": "API for interpretting Span\u003Cbyte\u003E as struct without copying",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-22T18:29:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26587",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400400504",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30613#issuecomment-400400504",
        "FeedbackMarkdown": "This API and scenarios make sense but we shouldn\u0027t use \u0060Struct\u0060 in the name. It seems to make more sense to align this with \u0060Unsafe.AsRef()\u0060, thus:\r\n\r\n\r\n\u0060\u0060\u0060csharp\r\nstatic class MemoryMarshal\r\n{\r\n    public static ref readonly T AsRef\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E span) where T : struct;\r\n    public static ref T AsRef(Span\u003Cbyte\u003E span) where T : struct;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 2490000000,
        "Apis": [
          "M:MemoryMarshal.AsRef(Span\u003Cbyte\u003E)",
          "M:MemoryMarshal.AsRef\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E)",
          "T:MemoryMarshal"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29544,
          "Title": "Add Interlocked ops w/ explicit memoryOrder",
          "Author": "sdmaclea",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-07T18:28:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26092",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400405014",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29544#issuecomment-400405014",
        "FeedbackMarkdown": "Are we sure the enum members are sensibly named? The names do not make a lot of sense to us, but that might just domain knowledge. Also, @GrabYourPitchforks just noticed that \u0060Release\u0060 is being deprecated. Before approving I\u0027d like to get confirmation on the names.",
        "TimeCode": 16490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27418,
          "Title": "Path Span APIs that write into a specified buffer",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-23T21:14:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25173",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400409299",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27418#issuecomment-400409299",
        "FeedbackMarkdown": "Let\u0027s remove \u0060 TryGetTempPath\u0060 but otherwise it looks good.",
        "TimeCode": 25030000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26948,
          "Title": "Need a method similar to S.R.CS.RuntimeHelpers.InitializeArray, but for spans",
          "Author": "VSadov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-07T23:38:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24961",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400409742",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26948#issuecomment-400409742",
        "FeedbackMarkdown": "Alright, this is it:\r\n\r\n\u0060\u0060\u0060csharp\r\nclass RuntimeHelpers\r\n{\r\n\tReadOnlySpan\u003CT\u003E CreateSpan\u003CT\u003E(RuntimeFieldHandle fldHandle);\t\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33110000000,
        "Apis": [
          "M:RuntimeHelpers.CreateSpan\u003CT\u003E(RuntimeFieldHandle)",
          "T:RuntimeHelpers"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25189,
          "Title": "\u0022ItemRef\u0022 - Ref element accessor for types that already have an indexer.",
          "Author": "VSadov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-11T01:10:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24110",
          "Milestone": "2.1.0",
          "Labels": [
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "400418417",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25189#issuecomment-400418417",
        "FeedbackMarkdown": "This issue was about the naming convention (concept suffixing with \u0060Ref\u0060); it wasn\u0027t a particular set of members. It seems there are issues with the particular APIs being added (specifically \u0060List\u003CT\u003E\u0060 and \u0060Dictionary\u003CK,V\u003E\u0060.)\r\n\r\nPlease file API review requests for the specific members so we can review those (or alternatively update the issue description to have their signatures and reopen this one).",
        "TimeCode": 38690000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 50860000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "dCwHCg9TUvA",
      "StartDateTime": "2018-07-17T10:15:29.824-07:00",
      "EndDateTime": "2018-07-17T11:56:49-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dCwHCg9TUvA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26234,
          "Title": "Expand Process.Kill to Optionally Kill a Process Tree",
          "Author": "bgribaudo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-09T15:16:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24617",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405661428",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26234#issuecomment-405661428",
        "FeedbackMarkdown": "We don\u0027t see the value in an enum as it seems unlikely that we\u0027d do more than the two options. All examples we could come up with would likely result in more parameters. The usability of booleans on call sides have been solved in C# with named parameters.\r\n\r\nWe shouldn\u0027t make the parameter optional as there is no way this will ever be used by the compiler as we\u0027d still have the parameterless version (which cannot be removed as that would be a binary breaking change).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30873,
          "Title": "CSPRNG integers with ranges",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-06T14:28:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26716",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405664452",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30873#issuecomment-405664452",
        "FeedbackMarkdown": "We discussed if we should add a \u0060float\u0060 or \u0060double\u0060 version because that would be consistent with \u0060Random\u0060 but that\u0027s because the underlying primitive there is a \u0060double\u0060 while \u0060RandomNumberGenerator\u0060\u0027s primitive is a random bits. We could add floating point version if someone ever cares.\r\n\r\nWe considered a parameterless overload \u0060GetInt32()\u0060 as this would allow \u0060int.MaxValue\u0060 to be part of the range but in practice there really isn\u0027t a scenario for it (and it can be down allocation free with the \u0060GetBytes()\u0060 method if ever needed).\r\n\r\nWe also considered \u0060GetInt64()\u0060 versions but given that these values are mostly used for indexing this seems equally over the top.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace System.Security.Cryptography\r\n{\r\n  public abstract class RandomNumberGenerator\r\n  {\r\n    public static int GetInt32(int fromInclusive, int toExclusive);\r\n    public static int GetInt32(int toExclusive);\r\n  }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6490000000,
        "Apis": [
          "M:RandomNumberGenerator.GetInt32(int,int)",
          "M:RandomNumberGenerator.GetInt32(int)",
          "T:RandomNumberGenerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30677,
          "Title": "Add Public API Marshal.GetExceptionPointers ",
          "Author": "luqunl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-26T20:32:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26620",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405668842",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30677#issuecomment-405668842",
        "FeedbackMarkdown": "Agree with @jkotas  -- we should just return \u0060null\u0060 as that\u0027s a valid answer even on Windows. Normally, if we cannot implement an API we\u0027d throw \u0060PlatformNotSupportedException\u0060 rather than \u0060NotSupportedException\u0060.\r\n\r\nLooks good as proposed.",
        "TimeCode": 12200000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30592,
          "Title": "Add MemoryExtensions.Trim methods for ReadOnlyMemory\u003Cchar\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-22T03:05:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26570",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30592#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20670000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30424,
          "Title": "Add better ZipFile extraction APIs",
          "Author": "ianhays",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-15T16:23:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1552",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO.Compression",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405676075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30424#issuecomment-405676075",
        "FeedbackMarkdown": "The scenario makes sense.\r\n\r\nThe idea with an option type looks good in principles, but we\u0027d probably want one for creation and one for extraction because not all options for both sides -- which seems overkill.\r\n\r\n@weshaggard had the idea of introducing the new method using default parameters so that we get away with fewer overloads.\r\n\r\n@ianhays, could you give that a shot?",
        "TimeCode": 21900000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28001,
          "Title": "Proposal: Add ReadOnlySpan\u003Cchar\u003E overloads to CompareInfo",
          "Author": "ViktorHofer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-13T00:11:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25428",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405683985",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28001#issuecomment-405683985",
        "FeedbackMarkdown": "The scenario is reasonable.\r\n\r\n@GrabYourPitchforks brought up that we should also add an overload for \u0060GetHashCode()\u0060.\r\n\r\nIt\u0027s worth pointing out \u0060CompareInfo\u0060 can be derived from and the existing overloads are virtual. Presumably, these new APIs wouldn\u0027t normally delegate to them (because we want to avoid allocating a string in the first place), which now means that if a custom derivative exists and overrides the other methods, these methods would do the wrong thing.\r\n\r\nHowever, the type doesn\u0027t expose a public constructor so in practice nobody can derive from it. And it doesn\u0027t seem our implementation does either.\r\n\r\nOptions:\r\n\r\n1. **Ignore**. We make these methods non-virtual and don\u0027t delegate to the existing methods.\r\n\r\n2. **Handle**. We make these methods virtual and have the implementation do a type check. If the instance is \u0060CompareInfo\u0060 exactly, do the cheap thing. Otherwise, create strings and dispatch to the existing virtual methods. Implementers would have to override them to not pay the allocation cost.\r\n\r\nWe\u0027re leaning towards option (1) as we don\u0027t believe deriving from \u0060CompareInfo\u0060 to be a thing.",
        "TimeCode": 34630000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30207,
          "Title": "Add Bad\u00ED\u02BF Calendar to Globalization",
          "Author": "glittle",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-08T07:19:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26419",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-17T00:00:00-07:00",
        "FeedbackId": "405690297",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30207#issuecomment-405690297",
        "FeedbackMarkdown": "Thanks for the detailed proposal!\r\n\r\nThe cost for us to support a calendar can be high because we have to react if definitions or rules change. It seems neither Windows, nor macOS, nor ICU support this calendar natively.\r\n\r\nThankfully, the .NET globalization APIs are extensible so you\u0027ll be able to ship this calendar as a NuGet package. If it gets very popular, adding it to the platform seems reasonable. But considering that major vendors haven\u0027t added it, makes us believe it might not be popular enough to warrant us carrying the calendar -- and committing on keeping it up-to-date.\r\n\r\nFor now, I\u0027ll be closing this issue. Please feel free to reopen if you believe your package has become so popular that adding it the platform is sensible.",
        "TimeCode": 47380000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "vkOaqpdiF5U",
      "StartDateTime": "2018-07-24T10:06:11.411-07:00",
      "EndDateTime": "2018-07-24T11:06:18-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/vkOaqpdiF5U/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407484728",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-407484728",
        "FeedbackMarkdown": "Personally, I\u0027m fine with the first two bullet points but I don\u0027t understand the last. Could you elaborate? Reading the issue description it sounds like peeking could result in marking all data as \u0022preserve\u0022 which would block dequeues from removing data and thus could result in a state where enqueues would fail and the collection is stuck. Is copying not an option?\r\n\r\nThere are also some concerns about the second bullet point although I find this acceptable as callers have to opt-in.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26313,
          "Title": "Allow easier access to binary representation of blittable types",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-13T01:46:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24656",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407486861",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26313#issuecomment-407486861",
        "FeedbackMarkdown": "\u003E Isn\u0027t this equivalent to turning a \u0060ref T\u0060 into a \u0060Span\u003CT\u003E\u0060 followed by \u0060Cast\u003CT, byte\u003E\u0060? I thought turning a \u0060ref T\u0060 into a \u0060Span\u003CT\u003E\u0060 is not possible, even with fast span.\r\n\r\nRight. Thus we don\u0027t believe we need a dedicated API for this. Yet.",
        "TimeCode": 9400000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30527,
          "Title": "SocketsHttpHandler: Add MaxHttpVersion property",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-19T19:38:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26545",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-07-24T00:00:00-07:00",
        "FeedbackId": "407499225",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30527#issuecomment-407499225",
        "FeedbackMarkdown": "We\u0027ve talked with @davidsh about the proposed shape and it looks good.\r\n\r\nIf we find ourselves wanting to add this property to \u0060HttpMessageHandler\u0060 we can just physically move the property from \u0060SocketsHttpHandler\u0060 as that\u0027s binary/source compatible. We don\u0027t need the property to be virtual.\r\n\r\nFrom a usage standpoint, it seems more logical to put the property on the \u0060HttpClient\u0060 as that\u0027s what vast majority of users is going to do. @davidsh\u0027s argument is that API is part of the underlying pipe which is what the handler represents. There is another problem with that design in that consumers of \u0060HttpClient\u0060 can still construct an \u0060HttpRequestMessage\u0060 which wouldn\u0027t/can\u0027t honor the value from \u0060HttpClient\u0060.\r\n\r\n@bartonjs is proposing to expose \u0060HttpClient.DefaultHttpVersion\u0060 (instance property) that would control what the default value for \u0060HttpRequestMessage\u0060 objects will be that are constructed by \u0060HttpClient\u0060.\r\n\r\nAny objections to this?",
        "TimeCode": 13080000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "hLbCfJSPIaI",
      "StartDateTime": "2018-08-28T10:08:02.086-07:00",
      "EndDateTime": "2018-08-28T12:12:04-07:00",
      "Title": ".NET Design Reviews GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/hLbCfJSPIaI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27526,
          "Title": "Add MemoryExtensions.Contains",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-27T22:18:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25228",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27526#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31011,
          "Title": "Proposal: Trim/TrimStart/TrimEnd methods for Memory and Span with trim element",
          "Author": "schungx",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-12T08:17:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26785",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416678327",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31011#issuecomment-416678327",
        "FeedbackMarkdown": "We can probably cut the APIs that don\u0027t specify a element (because \u0060default(T)\u0060 doesn\u0027t seem reasonable) but it\u0027s still 6 APIs. We feel like we need a bit more justification to add these APIs.\r\n\r\n@schungx what are the scenarios where you needed this API?",
        "TimeCode": 16020000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31302,
          "Title": "Add span-based overloads of String.GetHashCode",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-24T04:35:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26924",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31302#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 23280000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31488,
          "Title": "Need one step API for creating files on Windows with security",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-30T17:49:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27021",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416680473",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31488#issuecomment-416680473",
        "FeedbackMarkdown": "@JeremyKuhne \r\n\r\nWhat would it look like if were to add them back where they were? How bad would the dependency be? These APIs show up a lot in porting.",
        "TimeCode": 24370000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31511,
          "Title": "File.Move(string,string, bool) overload",
          "Author": "mburbea",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-31T15:32:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27031",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416681677",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31511#issuecomment-416681677",
        "FeedbackMarkdown": "Makes sense. A few points:\r\n\r\n* We should probably add corresponding APIs to \u0060FileInfo\u0060 and \u0060DirectoryInfo\u0060.\r\n* Can this be implemented on Mac/Linux/Unix?",
        "TimeCode": 26780000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31614,
          "Title": "CustomAttributeData\u0027s AttributeType property should be virtual.",
          "Author": "ghost",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-06T17:22:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27071",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31614#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29030000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31787,
          "Title": "a new GC API for large array allocation",
          "Author": "Maoni0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-15T21:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27146",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416688698",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31787#issuecomment-416688698",
        "FeedbackMarkdown": "* Should it just be \u0060AllocateArray\u0060? In the end, the developer controls the size.\r\n* What happens if the developer specifies gen-0 but wants to create a 50 MB array? Will the API fail or will it silently promote the object to, say, gen-1?\r\n* No clearing the memory is fine, but we want to make sure it shows up visibly on the call side (a plain \u0060false\u0060 isn\u0027t good enough). We\u0027d like this to be an overload, such a \u0060AllocateLargeArrayUninitialized\u0060? The other benefit of having an overload is that this could be constrained to only allow \u0060T\u0060s with no references (unmanaged constraint).\r\n* Is LOH the same as MaxGeneration? If not, how can a developer explicitly allocate on the LOH?",
        "TimeCode": 30560000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31798,
          "Title": "Expose the ability to create signature generic instance types.",
          "Author": "ghost",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-16T14:41:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27152",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31798#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 41760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31902,
          "Title": "Expose additional MidpointRounding modes",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-23T02:21:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27205",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31902#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 45580000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31903,
          "Title": "Expose some additional Math and MathF operations",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-23T02:50:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27206",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416696207",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31903#issuecomment-416696207",
        "FeedbackMarkdown": "Some minor feedback:\r\n\r\n* NextValue -\u003E BitIncrement\r\n* PreviousValue -\u003E BitDecrement\r\n* Copysign -\u003E CopySign",
        "TimeCode": 47760000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31942,
          "Title": "Add string keyed dictionary ReadOnlySpan\u003Cchar\u003E lookup support",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-24T20:07:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27229",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-08-28T00:00:00-07:00",
        "FeedbackId": "416704108",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31942#issuecomment-416704108",
        "FeedbackMarkdown": "On the surface, the extension approach looks more appealing because it would allow the lookups to work against any instance of a dictionary (at least in principle, the current design only works if the dictionary was instantiated with a comparer that implements \u0060IStringEqualityComparer\u0060).\r\n\r\nHowever, this also complicates the implementation and might have performance implications if we have to expose more methods that only make sense when \u0060TKey\u0060 happens to be \u0060string\u0060. Also, one could argue that in the hot paths where people would be inclined to lookup with spans that they do in fact control their dictionary and whether they need to pass in the correct comparer or use a derived type of \u0060Dictionary\u003C,\u003E\u0060 doesn\u0027t matter.\r\n\r\nI totally buy the scenario, but adding a new collection type (even if derived from \u0060Dictionary\u003C,\u003E\u0060) feels heavy handed, but maybe I\u0027m overthinking this. Maybe just putting it in \u0060S.C.Specialized\u0060 is good enough.\r\n\r\nWhat do others think?",
        "TimeCode": 55400000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "nJleHEiiX14",
      "StartDateTime": "2018-09-25T10:08:04.7-07:00",
      "EndDateTime": "2018-09-25T11:58:39-07:00",
      "Title": ".NET Design Reviews: GitHub Triage",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nJleHEiiX14/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26528,
          "Title": "Add \u0027split\u0027 support for ReadOnlySpan\u003Cchar\u003E similar to string",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-23T01:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/934",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "utf8-impact",
              "Color": "eddf84",
              "Description": "Potentially impacts UTF-8 support in the runtime"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424438136",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26528#issuecomment-424438136",
        "FeedbackMarkdown": "We don\u0027t think we want these APIs:\r\n\r\n1. They allocate\r\n2. They aren\u0027t as convenient as \u0060String.Split\u0060\r\n\r\nIf you care about allocations, then you want a different API. And if you don\u0027t care about allocations, well, then you can just use \u0060String.Split\u0060.\r\n\r\nSo what API would we like to see? It could be a struct-based enumerator that allows the consumer to \u0060foreach\u0060 the individual spans without allocations. Alternatively (or additionally) we could have a method that allows the consumer to pass in a buffer with the locations, which, for the most part, could be \u0060stackalloc\u0060ated.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24365,
          "Title": "Proposal: BoundedConcurrentQueue\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-01T13:28:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23700",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24365#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24550000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29258,
          "Title": "Capability APIs for runtime code generation",
          "Author": "morganbr",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-21T02:03:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25959",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424442400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29258#issuecomment-424442400",
        "FeedbackMarkdown": "This is related: https://github.com/dotnet/standard/issues/832\r\n\r\nI believe this feature needs a more comprehensive design. I\u0027ll follow-up.",
        "TimeCode": 27930000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30968,
          "Title": "Vector\u003CT\u003E should have a ctor that accepts ReadOnlySpan\u003CT\u003E",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-10T21:57:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26763",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424448085",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30968#issuecomment-424448085",
        "FeedbackMarkdown": "@GrabYourPitchforks also suggested these APIs:\r\n\r\n\u0060\u0060\u0060cs\r\npublic struct Vector\u003CT\u003E {\r\n    /* new ctor overload proposal */\r\n    public Vector(ReadOnlySpan\u003Cbyte\u003E values);\r\n   \r\n    /* new instance method proposals */\r\n    public void CopyTo(Span\u003Cbyte\u003E destination);\r\n    public bool TryCopyTo(Span\u003Cbyte\u003E destination);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would avoid consumers having to re-interpret case the spans. We don\u0027t know what happens when the \u0060Vector\u003CT\u003E\u0060 is instantiated with \u0060byte\u0060 though.  @GrabYourPitchforks, please take a look and file another item.",
        "TimeCode": 32290000000,
        "Apis": [
          "M:Vector\u003CT\u003E.CopyTo(Span\u003Cbyte\u003E)",
          "M:Vector\u003CT\u003E.TryCopyTo(Span\u003Cbyte\u003E)",
          "M:Vector\u003CT\u003E.Vector(ReadOnlySpan\u003Cbyte\u003E)",
          "T:Vector\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31291,
          "Title": "Add IPEndPoint.Parse() \u0026 .TryParse()",
          "Author": "NickCraver",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-24T00:09:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26916",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424450665",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31291#issuecomment-424450665",
        "FeedbackMarkdown": "We should probably also expose this for \u0060DnsEndPoint\u0060, but that should be another issue. This one looks good as proposed.",
        "TimeCode": 41800000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31570,
          "Title": "Make internal directory separator helpers public",
          "Author": "cdmihai",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-02T23:59:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27053",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-09-25T00:00:00-07:00",
        "FeedbackId": "424461314",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31570#issuecomment-424461314",
        "FeedbackMarkdown": "The \u0060EndsIn*\u0060 methods seem problematic. The first ones seems fine but we should add support memory.\r\n\r\n\u0060\u0060\u0060c#\r\nnamespace System.IO\r\n{\r\n    public static class Path\r\n    {\r\n        public static string TrimEndingDirectorySeparator(string path);\r\n        public static ReadOnlySpan\u003Cchar\u003E TrimEndingDirectorySeparator(ReadOnlySpan\u003Cchar\u003E path);\r\n        public static ReadOnlyMemory\u003Cchar\u003E TrimEndingDirectorySeparator(ReadOnlyMemory\u003Cchar\u003E path);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46690000000,
        "Apis": [
          "M:Path.TrimEndingDirectorySeparator(ReadOnlyMemory\u003Cchar\u003E)",
          "M:Path.TrimEndingDirectorySeparator(ReadOnlySpan\u003Cchar\u003E)",
          "M:Path.TrimEndingDirectorySeparator(string)",
          "T:Path"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "6QOv4c1O6ME",
      "StartDateTime": "2018-12-11T10:06:59.033-08:00",
      "EndDateTime": "2018-12-11T12:13:47-08:00",
      "Title": ".NET Design Review: JSON DOM",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6QOv4c1O6ME/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33968,
          "Title": "Random-access document model for JSON (JsonDocument)",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-11T00:17:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28132",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-11T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33968#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "iQMNIeVoAdY",
      "StartDateTime": "2018-12-18T10:08:33.41-08:00",
      "EndDateTime": "2018-12-18T11:59:33-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/iQMNIeVoAdY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32850,
          "Title": "API: Native Library Resolve Event",
          "Author": "swaroop-sridhar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-16T21:10:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27647",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32850#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32015,
          "Title": "Native Library Loader API",
          "Author": "annaaniol",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-31T22:52:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27267",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448324606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32015#issuecomment-448324606",
        "FeedbackMarkdown": "This is the shape we agreed on:\r\n\r\n* We centrlized the APIs on a new type \u0060NativeLibrary\u0060 as opposed to \u0060Marshal\u0060 because it helps the developer using these APIs as it groups them better. \u0060Marshal\u0060 already has a ton of APIs.\r\n* We renamed \u0060RegisterDllImportResolver\u0060 to \u0060SetDllImportResolver\u0060. Register implies having an unregister and having a chain. \u0060Set\u0060 makes it clear there is a single value and \u0060null\u0060 will clear it.\r\n* We replaced the func of \u0060SetDllImportResolver\u0060 with a named delegate so that we can name the parameters.\r\n* Open item: we need to clarify whether the \u0060DllImportSearchPath?\u0060 argument to \u0060DllImportResolver\u0060 is different from any other existing enum value. If not, we should make it non-nullable.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public delegate IntPtr DllImportResolver(string libraryName,\r\n                                             Assembly assembly,\r\n                                             DllImportSearchPath? searchPath);\r\n\r\n    public static partial class NativeLibrary\r\n    {\r\n        // Typical or for dependencies which must be there or failure should happen.\r\n\r\n        public static IntPtr Load(string libraryPath);\r\n        public static IntPtr Load(string libraryName,\r\n                                  Assembly assembly,\r\n                                  DllImportSearchPath? searchPath);\r\n\r\n        // For fast probing scenarios:\r\n\r\n        public static bool TryLoad(string libraryPath,\r\n                                   out IntPtr handle);\r\n        public static bool TryLoad(string libraryName,\r\n                                   Assembly assembly,\r\n                                   DllImportSearchPath? searchPath,\r\n                                   out IntPtr handle);\r\n\r\n        public static void Free(IntPtr handle);\r\n\r\n        public static IntPtr GetExport(IntPtr handle, string name);\r\n        public static bool TryGetExport(IntPtr handle, string name, out IntPtr address);\r\n\r\n        public static bool SetDllImportResolver(Assembly assembly, DllImportResolver resolver);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 4760000000,
        "Apis": [
          "M:NativeLibrary.Free(IntPtr)",
          "M:NativeLibrary.GetExport(IntPtr,string)",
          "M:NativeLibrary.Load(string,Assembly,DllImportSearchPath?)",
          "M:NativeLibrary.Load(string)",
          "M:NativeLibrary.SetDllImportResolver(Assembly,DllImportResolver)",
          "M:NativeLibrary.TryGetExport(IntPtr,string,out IntPtr)",
          "M:NativeLibrary.TryLoad(string,Assembly,DllImportSearchPath?,out IntPtr)",
          "M:NativeLibrary.TryLoad(string,out IntPtr)",
          "T:DllImportResolver(string,Assembly,DllImportSearchPath?)",
          "T:NativeLibrary"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33284,
          "Title": "Proposal: MatchFailureException",
          "Author": "gafter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-06T22:11:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27832",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448332714",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33284#issuecomment-448332714",
        "FeedbackMarkdown": "* There is a possibility for a breaking change: library author ships a library for 3.0 and then later downgrades to 2.0, which is is expected to be transparent to consumer. Now a different exception exception is thrown. Seems remote though.\r\n* We don\u0027t expect any user code to specifically handle this exception (outside of implicit catch-all style handlers). We should move this to \u0060System.Runtime.CompilerServices\u0060.\r\n* We should have a less generic name, for instance \u0060SwitchExpressionException\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Indicates that a switch expression that was non-exhaustive failed to match its input\r\n    /// at runtime, e.g. in the C# 8 expression \u003Ccode\u003E3 switch { 4 =\u003E 5 }\u003C/code\u003E.\r\n    /// The exception optionally contains an object representing the unmatched value.\r\n    /// \u003C/summary\u003E\r\n    [System.Runtime.InteropServices.ComVisible(true)]\r\n    [Serializable]\r\n    public sealed class SwitchExpressionException : InvalidOperationException\r\n    {\r\n        public SwitchExpressionException();\r\n        public SwitchExpressionException(object unmatchedValue);\r\n        public object UnmatchedValue { get; }\r\n        [System.Security.SecurityCritical]\r\n        public override void GetObjectData(SerializationInfo info, StreamingContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18250000000,
        "Apis": [
          "M:SwitchExpressionException.GetObjectData(SerializationInfo,StreamingContext)",
          "M:SwitchExpressionException.SwitchExpressionException()",
          "M:SwitchExpressionException.SwitchExpressionException(object)",
          "P:SwitchExpressionException.UnmatchedValue",
          "T:SwitchExpressionException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33165,
          "Title": "Add API for resolving component dependencies",
          "Author": "vitek-karas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-31T08:53:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27787",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448337807",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33165#issuecomment-448337807",
        "FeedbackMarkdown": "* Should we offer a resolver that represents the \u0022global\u0022 context? \u0060AssemblyLoadContext\u0060 kind of does that, but it doesn\u0027t talk in paths.\r\n* The term component seems a bit ill-defined. \u0060AssemblyDependencyResolver\u0060 seems to make sense, given that this type is for resolving dependencies of assemblies (managed or unamanged). The only caveat is that you need to pass the path to the assembly that has the corresponding \u0060\u003Cassembly\u003E.deps.json\u0060 file, i.e. the main assembly or the entry point of the plug-in.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Loader\r\n{\r\n    public sealed class AssemblyDependencyResolver\r\n    {\r\n        // Should this API exist?\r\n        // public static AssemblyDependencyResolver GlobalResolver { get; }\r\n\r\n        public AssemblyDependencyResolver(string assemblyPath);\r\n\r\n        public string ResolveAssemblyToPath(AssemblyName assemblyName);\r\n        public string ResolveUnmanagedDllToPath(string unmanagedDllName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32870000000,
        "Apis": [
          "M:AssemblyDependencyResolver.AssemblyDependencyResolver(string)",
          "M:AssemblyDependencyResolver.ResolveAssemblyToPath(AssemblyName)",
          "M:AssemblyDependencyResolver.ResolveUnmanagedDllToPath(string)",
          "T:AssemblyDependencyResolver"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 135,
          "Title": "Setting/Getting HighDpiMode in WinForms Core Apps",
          "Author": "KlausLoeffelmann",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-04T12:32:11+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/135",
          "Milestone": "3.0-Preview3",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448340808",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/135#issuecomment-448340808",
        "FeedbackMarkdown": "* It\u0027s a bit odd to use a method; one would expect a regular property setter.\r\n* However, after reading the text it seems that\u0027s because the method might ignore the value. Presumably the method returns \u0060false\u0060 in this case, as well as in your case (a)?\r\n* Thus, the shape looks good as proposed.",
        "TimeCode": 42760000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 218,
          "Title": "DataObject.SetAudio should be exposed with a new overload taking Span\u003Cbyte\u003E",
          "Author": "raffaeler",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-09T21:38:21+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/218",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "(2) API is ready for formal API review; applied by the issue owner"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2018-12-18T00:00:00-08:00",
        "FeedbackId": "448343258",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/218#issuecomment-448343258",
        "FeedbackMarkdown": "We aren\u0027t experts on \u0060IDataObject\u0060 but what is the benefit of using \u0060Span\u003CT\u003E\u0060 here? The \u0060Stream\u0060 API allows you to slice the data already, and it seems the implementation pushes the state into the heap.\r\n\r\nFor this scenario \u0060Span\u003CT\u003E\u0060 doesn\u0027t make sense; at the very minimum it would need to be \u0060Memory\u003CT\u003E\u0060 (because \u0060Span\u003CT\u003E\u0060 cannot be stored on the heap). However, this seems to complicate the API surface more than it helps.\r\n\r\nIf slicing the array would be common, I suggest we instead add an overload that simply accepts two ints, or an \u0060ArraySegment\u003CT\u003E\u0060.",
        "TimeCode": 48580000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "e1nUhoqMJn8",
      "StartDateTime": "2019-01-08T10:10:45.7-08:00",
      "EndDateTime": "2019-01-08T12:03:08-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/e1nUhoqMJn8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32015,
          "Title": "Native Library Loader API",
          "Author": "annaaniol",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-31T22:52:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27267",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32015#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33909,
          "Title": "Proposal: IAsyncEnumerable\u003CT\u003E.WithCancellation extension method",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-07T17:25:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28105",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33909#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13470000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 134,
          "Title": "PlaceholderText API addition to TextBox control",
          "Author": "stefanov-stefan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-04T08:42:14+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/134",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "452412351",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/134#issuecomment-452412351",
        "FeedbackMarkdown": "Presumably \u0060PlaceholderText\u0060 will behave like \u0060Text\u0060 with respect to handling \u0060null\u0060 vs \u0060string.Empty\u0060?",
        "TimeCode": 24780000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34330,
          "Title": "string.Concat(ReadOnlySpan\u003Cchar\u003E, ...)",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-03T14:56:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28310",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-08T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34330#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 27020000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "jjgr5xruXj4",
      "StartDateTime": "2019-01-22T10:10:01.124-08:00",
      "EndDateTime": "2019-01-22T11:12:13-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jjgr5xruXj4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32742,
          "Title": "Proposal: Add IAsyncEnumerable\u003CT\u003E support to System.Threading.Channels",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-10T15:09:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27593",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Channels",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456511279",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32742#issuecomment-456511279",
        "FeedbackMarkdown": "We concluded that exposing it as a method is better as it\u0027s \u0022destructive\u0022, i.e. it drains the items. We settled on \u0060ReadAllAsync()\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33336,
          "Title": "Proposal: IAsyncDisposable.ConfigureAwait(bool continueOnCapturedContext)",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-08T15:47:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27857",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33336#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13970000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 134,
          "Title": "PlaceholderText API addition to TextBox control",
          "Author": "stefanov-stefan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-04T08:42:14+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/134",
          "Milestone": "3.0-Preview2",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456519247",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/134#issuecomment-456519247",
        "FeedbackMarkdown": ":shipit: #238",
        "TimeCode": 17830000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33717,
          "Title": "Allow recovering writable/heapable buffers from \u0022lower level\u0022 types.",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-27T22:20:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28008",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456520584",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33717#issuecomment-456520584",
        "FeedbackMarkdown": "* \u0060Overlaps\u003CT\u003E()\u0060 with memories. We concluded we don\u0027t want these overloads. We generally want to poeple to go from memory to span; we also believe they are fast enough. If we ever need them for perf reasons, we can revisit this.\r\n\r\n* \u0060SliceTo\u0060. We\u0027re unsure whether this API will fix the usability issues of the \u0060Overlap\u003CT\u003E()\u0060 methods. For now, we don\u0027t think we want this API. However, we might want add a different API that will address these issues and makes working with spans when you need to compare bounds of other values (memories, other span, strings etc) based on how to two other spans relate to each other.",
        "TimeCode": 27260000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34683,
          "Title": "Add Rune creation API from UTF-16 surrogate pair",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-18T20:56:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28456",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encoding",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-22T00:00:00-08:00",
        "FeedbackId": "456524835",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34683#issuecomment-456524835",
        "FeedbackMarkdown": "Can we name this just \u0060TryCreate\u0060, given the overloads? It\u0027s clear from your signature that you\u0027re creating a rune from a surrogate pair.\r\n\r\nWe should also add the corresponding constructor.",
        "TimeCode": 31310000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "3KCS0GW6lUU",
      "StartDateTime": "2019-01-29T10:08:02.266-08:00",
      "EndDateTime": "2019-01-29T11:52:28-08:00",
      "Title": ".NET Design Review: GitHub Quick Review and DbDataReader Additions",
      "ThumbnailUrl": "https://i.ytimg.com/vi/3KCS0GW6lUU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32959,
          "Title": "System.Reflection.Emit.Label should implement IEquatable",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-22T19:04:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27697",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection.Emit",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32959#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34124,
          "Title": "Exception to throw when interface dispatch is ambiguous",
          "Author": "MichalStrehovsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-17T14:08:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28221",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458653253",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34124#issuecomment-458653253",
        "FeedbackMarkdown": "Looks good. A few things:\r\n\r\n* We should have a parameterless constructor\r\n* We should add the serialization contructor\r\n* We should add the inner exception constructor\r\n* We should mark the exception serializable\r\n* We should seal the type",
        "TimeCode": 1700000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34902,
          "Title": "Consider moving several HWIntrinsic instance methods to be extension methods",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-28T16:12:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28542",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34902#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13650000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34881,
          "Title": "Take another look at the \u0060COMISS\u0060 and \u0060UCOMISS\u0060 hardware intrinisics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-26T23:28:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28533",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458659597",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34881#issuecomment-458659597",
        "FeedbackMarkdown": "A derivative of @benaadams suggestion @tannergooding suggested (where \u0060Xxx\u0060 is \u0060Equals\u0060, \u0060LessThan\u0060 etc):\r\n\r\n* CompareOrderedScalarXxx\r\n* CompareUnorderdScalarXxx",
        "TimeCode": 17920000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33279,
          "Title": "SafeBuffer Span\u003CT\u003E methods",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-06T18:56:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27831",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33279#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 24320000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31595,
          "Title": "Add string overloads to DbDataReader.Get*()",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-04T05:41:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27059",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-01-29T00:00:00-08:00",
        "FeedbackId": "458677042",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31595#issuecomment-458677042",
        "FeedbackMarkdown": "We concluded that we want to leave these ones off for now. The reason being that ADO.NET really wants to expose a \u0060ValueTask\u003CT\u003E\u0060 as opposed to \u0060Task\u003CT\u003E\u0060 but we\u0027ll need to revisit how we\u0027d plumb this through:\r\n\r\n\u0060\u0060\u0060C#\r\npublic Task\u003CT\u003E GetFieldValueAsync\u003CT\u003E(string name); // Forwards to CancellationToken \r\npublic Task\u003CT\u003E GetFieldValueAsync\u003CT\u003E(string name, CancellationToken cancellationToken);\r\npublic Task\u003Cbool\u003E IsDBNullAsync(string name); // Forwards to CancellationToken \r\npublic Task\u003Cbool\u003E IsDBNullAsync(string name, CancellationToken cancellationToken);\r\n\u0060\u0060\u0060\r\n\r\nThis one is a mistake:\r\n\r\n\u0060\u0060\u0060C#\r\npublic int GetProviderSpecificValues(object[] values);\r\n\u0060\u0060\u0060\r\n\r\nWhich leaves us with this:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class DbDataReader\r\n{        \r\n    public bool GetBoolean(string name);\r\n    public byte GetByte(string name);\r\n    public long GetBytes(string name, long dataOffset, byte[] buffer, int bufferOffset, int length);\r\n    public char GetChar(string name);\r\n    public long GetChars(string name, long dataOffset, char[] buffer, int bufferOffset, int length);\r\n    public DbDataReader GetData(string name);\r\n    public string GetDataTypeName(string name);\r\n    public DateTime GetDateTime(string name);\r\n    public DateTime GetDbDataReader(string name);\r\n    public decimal GetDecimal(string name);\r\n    public double GetDouble(string name);\r\n    public Type GetFieldType(string name);\r\n    public T GetFieldValue\u003CT\u003E(string name);\r\n    public float GetFloat(string name);\r\n    public Guid GetGuid(string name);\r\n    public short GetInt16(string name);\r\n    public int GetInt32(string name);\r\n    public long GetInt64(string name);\r\n    public Type GetProviderSpecificFieldType(string name);\r\n    public object GetProviderSpecificValue(string name);\r\n    public Stream GetStream(string name);\r\n    public string GetString(string name);\r\n    public TextReader GetTextReader(string name);\r\n    public object GetValue(string name);\r\n    public bool IsDBNull(string name);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27620000000,
        "Apis": [
          "M:DbDataReader.GetBoolean(string)",
          "M:DbDataReader.GetByte(string)",
          "M:DbDataReader.GetBytes(string,long,byte[],int,int)",
          "M:DbDataReader.GetChar(string)",
          "M:DbDataReader.GetChars(string,long,char[],int,int)",
          "M:DbDataReader.GetData(string)",
          "M:DbDataReader.GetDataTypeName(string)",
          "M:DbDataReader.GetDateTime(string)",
          "M:DbDataReader.GetDbDataReader(string)",
          "M:DbDataReader.GetDecimal(string)",
          "M:DbDataReader.GetDouble(string)",
          "M:DbDataReader.GetFieldType(string)",
          "M:DbDataReader.GetFieldValue\u003CT\u003E(string)",
          "M:DbDataReader.GetFloat(string)",
          "M:DbDataReader.GetGuid(string)",
          "M:DbDataReader.GetInt16(string)",
          "M:DbDataReader.GetInt32(string)",
          "M:DbDataReader.GetInt64(string)",
          "M:DbDataReader.GetProviderSpecificFieldType(string)",
          "M:DbDataReader.GetProviderSpecificValue(string)",
          "M:DbDataReader.GetStream(string)",
          "M:DbDataReader.GetString(string)",
          "M:DbDataReader.GetTextReader(string)",
          "M:DbDataReader.GetValue(string)",
          "M:DbDataReader.IsDBNull(string)",
          "T:DbDataReader"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "jfJkaggdGws",
      "StartDateTime": "2019-02-05T09:55:27.116-08:00",
      "EndDateTime": "2019-02-05T12:01:01-08:00",
      "Title": ".NET Design Review: GitHub Quick Review and UTF8 APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jfJkaggdGws/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34768,
          "Title": "Expose line number and byte position in line as public properties on Utf8JsonReader",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-23T05:40:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28482",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460749514",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34768#issuecomment-460749514",
        "FeedbackMarkdown": "This looks useful. We discussed whether we should expose this on the state as well so that consumers can use that information when invalid schema information was found (rather than when the reader detects invalid JSON).\r\n\r\nThe current design has the unfortunate behavior that the line/byte position represents where the next token will start reading. Note that this isn\u0027t even the start of next token (due to skipped whitespace). Since schema validation requires the token to be read, it\u0027s always at the end of the token, rather than at the beginning.\r\n\r\n@ahsonkhan please explore what the documentation for these APIs would say to explaint their behavior. We can then review wether that\u0027s something developers will be able to reason about.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34794,
          "Title": "Option to support trailing commas with JsonReader",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-24T01:24:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28493",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34794#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20010000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34690,
          "Title": "Add (Try)GetDateTime(Offset) to Utf8JsonReader and JsonDocument",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-19T01:35:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28459",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460761972",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34690#issuecomment-460761972",
        "FeedbackMarkdown": "Looks good.\r\n\r\nWe should consider applying the same principle from the writer to the reader: the writer differentiates between the underlying primitive and the convenience conversion (e.g. \u0060WriteString\u0060 that takes a \u0060DateTime\u0060). For example, instead of \u0060GetDateTime()\u0060 we\u0027d have \u0060GetStringAsDateTime\u0060. That also makes it clear where we expect the value to come from, e.g. \u0060GetNumberAsInt32\u0060 makes it clear we won\u0027t parse the \u0060int\u0060 from a \u0060string\u0060. And it makes the reader and the writer more consistent.",
        "TimeCode": 26780000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34094,
          "Title": "System.Text.Utf8Char data type to represent UTF-8 text data",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-14T07:38:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28204",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460774440",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34094#issuecomment-460774440",
        "FeedbackMarkdown": "* We need to decide if we want -- or need -- language support, including built-in conversions. If so, we can\u0027t ship user defined operators.\r\n* Should the API be in \u0060System.Text\u0060? We probably want to align this choice wherever we\u0027ll think we\u0027ll want to ship the UTF8 string type.\r\n* How should we name the type? We probably want to align this choice with the UTF8 string support and the language support.\r\n* Does this type need consideration for marshaling? We\u0027ll want to makes sure that the behavior we have in 3.0 we don\u0027t need to change later.\r\n\r\nIt seems as a next step we should have a meeting with the language folks.",
        "TimeCode": 40650000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34822,
          "Title": "Rune.DecodeFirstRune and friends",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-24T22:49:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28504",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-05T00:00:00-08:00",
        "FeedbackId": "460780898",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34822#issuecomment-460780898",
        "FeedbackMarkdown": "Looks good.\r\n\r\n* We\u0027ll have to make sure that the \u0060out\u0060 parameter \u0060charsConsumed\u0060 makes sense with the final name of \u0060Utf8Char\u0060. If it doesn\u0027t have \u0060char\u0060 in the name. Alternatively, we could decide to use something like \u0060consumedCount\u0060 that implies that it\u0027s number of elements, regardless of the type.\r\n\r\n\u0060\u0060\u0060C#\r\npublic static OperationStatus Decode(ReadOnlySpan\u003Cchar\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus Decode(ReadOnlySpan\u003CUtf8Char\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus DecodeFromEnd(ReadOnlySpan\u003Cchar\u003E source, out Rune result, out int charsConsumed);\r\npublic static OperationStatus DecodeFromEnd(ReadOnlySpan\u003CUtf8Char\u003E source, out Rune result, out int charsConsumed);\r\n\u0060\u0060\u0060\r\n\r\n@KrzysztofCwalina, do you have an opinion on the name of the \u0060out\u0060 parameter?",
        "TimeCode": 61630000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9TSP4awoHuI",
      "StartDateTime": "2019-02-07T10:06:38.252-08:00",
      "EndDateTime": "2019-02-07T11:39:57-08:00",
      "Title": ".NET Design Review:  PipeReader and PipeWriter implementations over a Stream",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9TSP4awoHuI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27246,
          "Title": "PipeReader and PipeWriter implementations over a Stream",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-19T05:13:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25087",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-07T00:00:00-08:00",
        "FeedbackId": "461567272",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27246#issuecomment-461567272",
        "FeedbackMarkdown": "Notes are here: https://github.com/dotnet/apireviews/pull/90",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "0ReXmy2bQvQ",
      "StartDateTime": "2019-02-22T10:11:23.946-08:00",
      "EndDateTime": "2019-02-22T11:02:17-08:00",
      "Title": ".NET Design Review: UTF8 APIs",
      "ThumbnailUrl": "https://i.ytimg.com/vi/0ReXmy2bQvQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34826,
          "Title": "Complex Rune enumeration over spans of UTF-16 and UTF-8 text",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-25T00:19:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28507",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-22T00:00:00-08:00",
        "FeedbackId": "466507394",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34826#issuecomment-466507394",
        "FeedbackMarkdown": "* \u0060RunPosition\u0060\r\n    - We considered swapping \u0060rune\u0060 and \u0060startIndex\u0060 in the deconstruct method\r\n      to match Go, but decided against it because we also expose \u0060length\u0060 and\r\n      the order \u0060startIndex\u0060, \u0060rune\u0060, \u0060length\u0060 would be very weird.\r\n    - We should have a constructor that sets all four fields\r\n* \u0060Rune\u0060\r\n    - We should move the enumerate methods to \u0060RunePosition\u0060, which allows\r\n      making the names shorter\r\n\r\n        \u0060\u0060\u0060C#\r\n        public readonly struct RunPosition\r\n        {\r\n            public static Utf16Enumerator EnumerateUtf16(ReadOnlySpan\u003Cchar\u003E span);\r\n            public static Utf8Enumerator EnumerateUtf8(ReadOnlySpan\u003Cbyte\u003E span);\r\n\r\n            public ref struct Utf8Enumerator;\r\n            public ref struct Utf16Enumerator;\r\n        }\r\n        \u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:RunPosition.EnumerateUtf16(ReadOnlySpan\u003Cchar\u003E)",
          "M:RunPosition.EnumerateUtf8(ReadOnlySpan\u003Cbyte\u003E)",
          "T:RunPosition",
          "T:RunPosition.Utf16Enumerator",
          "T:RunPosition.Utf8Enumerator"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "qlj29o0R1rs",
      "StartDateTime": "2019-02-26T10:05:41.685-08:00",
      "EndDateTime": "2019-02-26T12:04:28-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/qlj29o0R1rs/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33602,
          "Title": "Obsolete string.Copy(string) method",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-19T19:16:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27957",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467551787",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33602#issuecomment-467551787",
        "FeedbackMarkdown": "We should mark this obsolete in .NET Standard as well. I\u0027ll submit the PR for that.\r\n\r\n@GrabYourPitchforks are you on the hook for cleaning up any call sites in CoreFX?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35419,
          "Title": "Proposal: Expose existing BitOps methods",
          "Author": "grant-d",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-19T19:39:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28725",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467557134",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35419#issuecomment-467557134",
        "FeedbackMarkdown": "Having a separate type makes sense as the existing types don\u0027t make sense (\u0060Math\u0060, \u0060BitConverter\u0060). We shouldn\u0027t put it in the \u0060System\u0060 namespace though?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static partial class BitOperations\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7110000000,
        "Apis": [
          "T:BitOperations"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35508,
          "Title": "Consider removing Range.OffsetAndLength",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-21T23:18:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28758",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35508#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 15910000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35560,
          "Title": "Remove some unnecessary HWIntrinsic API overloads",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-25T16:22:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28781",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35560#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19060000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35530,
          "Title": "Add Rune.TryEncodeToUtf8Bytes",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-22T21:28:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28767",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467570023",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35530#issuecomment-467570023",
        "FeedbackMarkdown": "Looks good, minor suggestion from review:\r\n\r\n\u0060\u0060\u0060C#\r\nbool TryEncodeAsUtf8(...);\r\n\u0060\u0060\u0060\r\n\r\n@GrabYourPitchforks should we also add a non-\u0060Try\u0060 version that throws?",
        "TimeCode": 33420000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34366,
          "Title": "EnvelopedCms encryption with RSA padding modes",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-04T19:30:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28322",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34366#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 36740000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34830,
          "Title": "UTF-8 web encoders",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-25T02:31:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28509",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Encodings.Web",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467582155",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34830#issuecomment-467582155",
        "FeedbackMarkdown": "After giving it more thought, we\u0027d prefer the alternative proposal, meaning having a single class hierarchy for UTF16 and UTF8.\r\n\r\nThere are two ways to do the alternative:\r\n\r\n1. Completely additive, i.e. non-breaking.\r\n2. Redo the abstract members to make it sane (avoid \u0060char*\u0060 and encoding agnostic API pattern).\r\n\r\n@GrabYourPitchforks, please send me a mail with a write-up on the justification for the breaking change and I\u0027ll help you getting this approved by whoever is in charge for that :-)",
        "TimeCode": 41570000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34258,
          "Title": "Unsafe.Unbox should return \u0022ref readonly T\u0022, not \u0022ref T\u0022",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-27T15:43:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28278",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-02-26T00:00:00-08:00",
        "FeedbackId": "467591284",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34258#issuecomment-467591284",
        "FeedbackMarkdown": "It seems \u0060ref\u0060 is a closer match. There is nuance, and that is sufficiently addressed by the \u0060Unsafe\u0060 name plus proper documentation.\r\n\r\n@GrabYourPitchforks, could you file a doc bug / submit a PR?",
        "TimeCode": 55910000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "aaFcBs6cFqg",
      "StartDateTime": "2019-03-12T10:10:28.639-07:00",
      "EndDateTime": "2019-03-12T12:20:04-07:00",
      "Title": ".NET Design Review: Tensor",
      "ThumbnailUrl": "https://i.ytimg.com/vi/aaFcBs6cFqg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32987,
          "Title": "Add remove Range to sorted List",
          "Author": "hernot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-23T19:13:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27713",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-12T00:00:00-07:00",
        "FeedbackId": "472132435",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32987#issuecomment-472132435",
        "FeedbackMarkdown": "@hernot could you please update the issue to include a formal api proposal? I think it makes sense to have this API but we need to include Rationale and Usage. Once you\u0027ve done that I can bring it over to API Review to get its approval and then implement it. \r\n\r\nHere is an example of an API Proposal: https://github.com/dotnet/corefx/issues/30953#issue-339950811",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "vHqgsQ23GRg",
      "StartDateTime": "2019-03-19T10:03:00.909-07:00",
      "EndDateTime": "2019-03-19T12:03:58-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/vHqgsQ23GRg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31570,
          "Title": "Make internal directory separator helpers public",
          "Author": "cdmihai",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-02T23:59:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27053",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31570#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34252,
          "Title": "ColorConverter in System.ComponentModel.TypeConverters does not handle SystemColors",
          "Author": "DustinCampbell",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-26T23:34:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28272",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34252#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 18750000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35145,
          "Title": "Rename Range to IndexRange",
          "Author": "YohDeadfall",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-07T09:27:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28637",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474491396",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35145#issuecomment-474491396",
        "FeedbackMarkdown": "We discussed this today but we feel it\u0027s too late to make this change now.",
        "TimeCode": 22980000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8173,
          "Title": "Simpler way to specify leaveOpen in StreamWriter constructor",
          "Author": "svick",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-29T16:53:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17157",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474495698",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8173#issuecomment-474495698",
        "FeedbackMarkdown": "Just realized that adding a bool would butt heads with \u0060StreamReader(Stream, bool)\u0060. Need to look at this a bit more to see if we can come up with a pattern that will work well across our readers/writers.",
        "TimeCode": 25680000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33295,
          "Title": "Implement Utf8JsonReader.Skip() with support for incomplete data",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-07T04:46:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27838",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474501111",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33295#issuecomment-474501111",
        "FeedbackMarkdown": "\u0060TrySkip()\u0060 is unfortunate because it\u0027s an unbounded buffering read; compared to calling \u0060Read()\u0060 which would throw data away as you go. That looks like a perf trap. But it\u0027s convenient so let\u0027s keep it.\r\n\r\nWe shouldn\u0027t do \u0060Skip()\u0060 because callers typically can\u0027t know whether it\u0027s the final block.\r\n\r\nThe \u0060TrySkipToDepth(int targetDepth)\u0060 API seems fine. Skipping is a weird term, but hey, that\u0027s the term everyone else is using so let\u0027s keep that.",
        "TimeCode": 28870000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35500,
          "Title": "Add APIs for some threading metrics",
          "Author": "kouvel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-21T20:30:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28755",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474513603",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35500#issuecomment-474513603",
        "FeedbackMarkdown": "Looks good.\r\n\r\nThe only concern is about local vs. global. Unless there is a specific scenario needing the differentiation. If there isn\u0027t we should just expose the total.",
        "TimeCode": 36360000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34867,
          "Title": "Add SslStream.NegotiatedCipherSuite",
          "Author": "krwq",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-25T22:46:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28527",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-19T00:00:00-07:00",
        "FeedbackId": "474516862",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34867#issuecomment-474516862",
        "FeedbackMarkdown": "This does *NOT* look good, but it seems we have issues with adjacent numbers that we\u0027ll have to to separate by underscores. Given that this means this enum will never look \u0022.NET-ty\u0022, and that like five people in the world will care about this API, we might as well expose the IANA names.\r\n\r\nEvery time I\u0027ll be looking at this, I\u0027ll throw up in little my mouth, but hey. Approved.\r\n\r\nWe should make \u0060NegotiatedCipherSuite\u0060 nullable in cases we can\u0027t determine the TLS cipher. The API might also throw if it wasn\u0027t negotiated that.",
        "TimeCode": 49590000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "SNc-nABLZws",
      "StartDateTime": "2019-03-26T11:08:12.558-07:00",
      "EndDateTime": "2019-03-26T11:51:51-07:00",
      "Title": ".NET Design Review: AssemblyLoadContext improvements",
      "ThumbnailUrl": "https://i.ytimg.com/vi/SNc-nABLZws/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36236,
          "Title": "API proposal AssemblyLoadContext.ActiveForContextSensitiveReflection",
          "Author": "sdmaclea",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-22T16:41:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29042",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-26T00:00:00-07:00",
        "FeedbackId": "476796579",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36236#issuecomment-476796579",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Loader\r\n{\r\n    public partial class AssemblyLoadContext\r\n    {\r\n        public static AssemblyLoadContext CurrentContextualReflectionContext { get; }\r\n\r\n        public ContextualReflectionScope EnterContextualReflection();\r\n        static public ContextualReflectionScope EnterContextualReflection(Assembly activating);\r\n\r\n        [EditorBrowsable(Never)]\r\n        public struct ContextualReflectionScope : IDisposable\r\n        {\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AssemblyLoadContext.EnterContextualReflection()",
          "M:AssemblyLoadContext.EnterContextualReflection(Assembly)",
          "P:AssemblyLoadContext.CurrentContextualReflectionContext",
          "T:AssemblyLoadContext",
          "T:AssemblyLoadContext.ContextualReflectionScope"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34791,
          "Title": "AssemblyLoadContext .NET Core 3.0 improvements",
          "Author": "sdmaclea",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-23T23:28:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28491",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-26T00:00:00-07:00",
        "FeedbackId": "476796715",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34791#issuecomment-476796715",
        "FeedbackMarkdown": "* Replace \u0060AssemblyLoadContext.Contexts\u0060 with \u0060AssemblyLoadContext.All\u0060 to make \u0060foreach\u0060 easier to read\r\n* Other than that, looks good as proposed",
        "TimeCode": 25760000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "_Uq0qG3KAzg",
      "StartDateTime": "2019-03-28T10:09:59.066-07:00",
      "EndDateTime": "2019-03-28T11:02:59-07:00",
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_Uq0qG3KAzg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36148,
          "Title": "Build a JsonDocument from an already positioned Utf8JsonReader",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-19T15:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29008",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-28T00:00:00-07:00",
        "FeedbackId": "477696501",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36148#issuecomment-477696501",
        "FeedbackMarkdown": "We should have a consistent naming with the \u0060Parse\u0060 methods. We suggest to go with \u0060ParseValue\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class JsonDocument\r\n{\r\n    public static bool TryParseValue(ref Utf8JsonReader reader, out JsonDocument document);\r\n    public static JsonDocument ParseValue(ref Utf8JsonReader reader);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonDocument.ParseValue(ref Utf8JsonReader)",
          "M:JsonDocument.TryParseValue(ref Utf8JsonReader,out JsonDocument)",
          "T:JsonDocument"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36153,
          "Title": "Utf8JsonWriter and JsonElement, redux",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-19T16:04:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29012",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-03-28T00:00:00-07:00",
        "FeedbackId": "477705735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36153#issuecomment-477705735",
        "FeedbackMarkdown": "Usability wise, this proposal seems less than ideal. Not sure I personal buy the layering argument, but if we feel strongly we should rename the method and swap the arguments:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial struct JsonElement\r\n{\r\n    public void WriteAsValue(ref Utf8JsonWriter writer);\r\n    public void WriteAsProperty(ReadOnlySpan\u003Cchar\u003E propertyName, ref Utf8JsonWriter writer);\r\n    public void WriteAsProperty(ReadOnlySpan\u003Cbyte\u003E utf8PropertyName, ref Utf8JsonWriter writer);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12900000000,
        "Apis": [
          "M:JsonElement.WriteAsProperty(ReadOnlySpan\u003Cbyte\u003E,ref Utf8JsonWriter)",
          "M:JsonElement.WriteAsProperty(ReadOnlySpan\u003Cchar\u003E,ref Utf8JsonWriter)",
          "M:JsonElement.WriteAsValue(ref Utf8JsonWriter)",
          "T:JsonElement"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "x5vbM3zB0_I",
      "StartDateTime": "2019-04-02T10:03:59.732-07:00",
      "EndDateTime": "2019-04-02T12:02:26-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/x5vbM3zB0_I/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36129,
          "Title": "Evolving EventCounter API",
          "Author": "sywhang",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-18T21:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29001",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479128603",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36129#issuecomment-479128603",
        "FeedbackMarkdown": "* MetaData -\u003E \u0060Metadata\u0060\r\n* \u0060AddMetaData\u0060 to \u0060SetMetaData\r\n* Add a \u0060DiagnosticCounter\u0060 abstract base\r\n    - Have protected ctor that accepts the name and \u0060EventSource\u0060\r\n    - Add \u0060Name\u0060 get-only property\r\n    - Add \u0060EventSource\u0060 get-only property\r\n    - Add \u0060DisplayName\u0060 get/set property\r\n    - Add abstract \u0060SetMetadata(string key, string value) method\r\n    - All counters, including the existing \u0060EventCounter\u0060 should inherit from it\r\n* \u0060getMetricFunction\u0060 -\u003E \u0060metricProvider\u0060\r\n* \u0060getCountFunction\u0060 -\u003E \u0060totalValueProvider\u0060\r\n* We should consider using \u0060double\u0060 instead of \u0060float\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33809,
          "Title": "API: SSLStream Allow Configuration of CipherSuites",
          "Author": "krwq",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-04T01:32:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28048",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479132747",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33809#issuecomment-479132747",
        "FeedbackMarkdown": "Going through the builder feels odd; especially because it doesn\u0027t itself represent a collection. It seems more natural to do something like:\r\n\r\n\u0060\u0060\u0060C#\r\npublic sealed class CipherSuitesPolicy\r\n{\r\n    public CipherSuitesPolicy(IEnumerable\u003CTlsCipherSuite\u003E allowedCipherSuites);\r\n\r\n    public IEnumerable\u003CTlsCipherSuite\u003E AllowedCipherSuites { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIt was proposed to apply hide the \u0060AllowedCipherSuites\u0060 property from other types; we don\u0027t believe that\u0027s the way to give guidance. Rather, we should document the API, provide relevant guidance developers are likely searching for (e.g. \u0022How to properly configure SSL with TLS\u0022). We should also invest in an analyzer.",
        "TimeCode": 42580000000,
        "Apis": [
          "M:CipherSuitesPolicy.CipherSuitesPolicy(IEnumerable\u003CTlsCipherSuite\u003E)",
          "P:CipherSuitesPolicy.AllowedCipherSuites",
          "T:CipherSuitesPolicy"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8173,
          "Title": "Simpler way to specify leaveOpen in StreamWriter constructor",
          "Author": "svick",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-29T16:53:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17157",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-02T00:00:00-07:00",
        "FeedbackId": "479149933",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8173#issuecomment-479149933",
        "FeedbackMarkdown": "We\u0027d prefer the first option (i.e. default constructors), reason being:\r\n\r\n1. It works for all settings, including the ones that we can\u0027t change after construction\r\n2. We can apply it elsewhere, such as \u0060FileStream\u0060\r\n\r\nThe counter argument is that it might make it harder for folks to find bugs because we\u0027d now accept \u0060null\u0060, but that\u0027s already the case in the framework. Hopefully, non-nullable reference types can help with that.",
        "TimeCode": 50890000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "BgF2UKtQjWA",
      "StartDateTime": "2019-04-09T10:05:40.561-07:00",
      "EndDateTime": "2019-04-09T11:31:50-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/BgF2UKtQjWA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34631,
          "Title": "Making the info GC.GetMemoryInfo provides public",
          "Author": "Maoni0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-16T21:27:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28439",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481358549",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34631#issuecomment-481358549",
        "FeedbackMarkdown": "Looks good! Comments from the review:\r\n\r\n* \u0060GCMemoryInfo\u0060 should be marked readonly\r\n* We should suffix all members with \u0060Bytes\u0060\r\n* We should normalzie all values into bytes\r\n* \u0060HighMemoryLoadThreshold\u0060 should return \u0060long\u0060 and be named \u0060HighMemoryLoadThresholdBytes\u0060\r\n* \u0060MemoryLoad\u0060 should return \u0060long\u0060 and be named \u0060MemoryLoadBytes\u0060\r\n* \u0060Fragmentation\u0060 should be \u0060FragmentedBytes\u0060\r\n* \u0060GetTotalAllocatedBytes()\u0060 should default the parameter to \u0060false\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35972,
          "Title": "Revisit Index/Range API requirements",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-11T23:55:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28939",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35972#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 22350000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35768,
          "Title": "VPMOVZXBD and friends need pointer-based overloads",
          "Author": "saucecontrol",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-04T22:48:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28868",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35768#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 29670000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34881,
          "Title": "Take another look at the \u0060COMISS\u0060 and \u0060UCOMISS\u0060 hardware intrinisics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-26T23:28:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28533",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481371966",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34881#issuecomment-481371966",
        "FeedbackMarkdown": "Works for us.",
        "TimeCode": 41450000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36152,
          "Title": "Clarity and control on a JsonDocument lifetime",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-19T15:49:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29011",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-09T00:00:00-07:00",
        "FeedbackId": "481375975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36152#issuecomment-481375975",
        "FeedbackMarkdown": "Let\u0027s remove \u0060IsPersistable\u0060 for now and make \u0060Clone()\u0060 a no-op. This way, callers can always call \u0060Clone()\u0060 before storing it.",
        "TimeCode": 44230000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "M1Hc0qrL_Oo",
      "StartDateTime": "2019-04-16T10:07:33.958-07:00",
      "EndDateTime": "2019-04-16T11:01:23-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/M1Hc0qrL_Oo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36351,
          "Title": "Json serializer support for a property name policy",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-25T23:26:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29063",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483773918",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36351#issuecomment-483773918",
        "FeedbackMarkdown": "* \u0060JsonNamePolicy\u0060 should have a protected constructor\r\n* For \u0060PropertyNameCaseInsensitive\u0060 we need to think about how we match names (comparisons and normalization aren\u0027t yielding the same results). @GrabYourPitchforks and @steveharter should chat.\r\n* The \u0060ConvertName()\u0060 method produces strings but that seems fine because they are going to be cached.\r\n* The code calling \u0060ConvertName()\u0060 should disallow \u0060null\u0060 values, but must accept empty strings. Likewise, \u0060ConvertName()\u0060 should be documented as  disallowing \u0060null\u0060 values but as accepting empty strings.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36129,
          "Title": "Evolving EventCounter API",
          "Author": "sywhang",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-18T21:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29001",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483778953",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36129#issuecomment-483778953",
        "FeedbackMarkdown": "The APIs were exposed via https://github.com/dotnet/coreclr/pull/23808 and all the changes discussed during the API review were implemented.",
        "TimeCode": 23310000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35012,
          "Title": "Add missing async methods in System.Data.Common and implement IAsyncDisposable",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-01T00:40:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28596",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-16T00:00:00-07:00",
        "FeedbackId": "483779404",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35012#issuecomment-483779404",
        "FeedbackMarkdown": "@roji @divega\r\n\r\n* What does it mean to cancel \u0060CancelAsync()\u0060? Also, how is calling \u0060CancelAsync()\u0060 different from cancelling the cancellation token that was passed to the operation that \u0060CancelAsync()\u0060 would cancel?\r\n* Is there a reason why \u0060CloseAsync()\u0060 returns \u0060ValueTask\u0060? It doesn\u0027t seem to on the perf critical path?\r\n* Should we really add \u0060DbDataReader.CloseAsync()\u0060 seems odd to add an API that is known to be not useful.",
        "TimeCode": 29110000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "5heMq4U2ek8",
      "StartDateTime": "2019-04-23T11:11:00.351-07:00",
      "EndDateTime": "2019-04-23T12:07:49-07:00",
      "Title": ".NET Design Review: RESX",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5heMq4U2ek8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37041,
          "Title": "System.Resources API additions for non-primitive objects",
          "Author": "ericstj",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-19T20:55:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29324",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Resources",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-23T00:00:00-07:00",
        "FeedbackId": "485934735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37041#issuecomment-485934735",
        "FeedbackMarkdown": "Looks good:\r\n\r\n* Seal the types and make the protected members private or remove them\r\n* \u0060closeAfterWrite\u0060 should be defaulted\r\n* Remove the \u0060TypeNameConverter\u0060, assuming MSBuild doens\u0027t need it",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "byHU4Ube7fg",
      "StartDateTime": "2019-04-25T11:02:15.48-07:00",
      "EndDateTime": "2019-04-25T12:00:29-07:00",
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/byHU4Ube7fg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33967,
          "Title": "Should Utf8JsonReader expose TokenStartIndex?",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-10T22:25:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28131",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33967#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "jQjHzmAomLE",
      "StartDateTime": "2019-04-30T10:01:28.906-07:00",
      "EndDateTime": "2019-04-30T11:02:07-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jQjHzmAomLE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36553,
          "Title": "Implement global proxy configuration for HttpClient",
          "Author": "davidsh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-03T04:29:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29147",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36553#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37224,
          "Title": "Proposal: HttpClient.DefaultRequestVersion",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-26T15:45:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29389",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37224#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 20590000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35143,
          "Title": "add Netlink, Packet and Can to AddressFamily and ProtocolFamily enum",
          "Author": "wfurt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-07T04:29:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28636",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-04-30T00:00:00-07:00",
        "FeedbackId": "488053098",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35143#issuecomment-488053098",
        "FeedbackMarkdown": "We should rename \u0060Can\u0060 to \u0060ControllerAreaNetwork\u0060 to avoid confusion with it being a word in English. \u0060Packet\u0060 seems generic, but we can\u0027t think of a better, so it\u0027s fine.",
        "TimeCode": 28660000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "cP2E0gSe8is",
      "StartDateTime": "2019-05-14T10:08:24.891-07:00",
      "EndDateTime": "2019-05-14T11:11:06-07:00",
      "Title": ".NET Design Review: System.Data",
      "ThumbnailUrl": "https://i.ytimg.com/vi/cP2E0gSe8is/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35012,
          "Title": "Add missing async methods in System.Data.Common and implement IAsyncDisposable",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-01T00:40:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28596",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "492336595",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35012#issuecomment-492336595",
        "FeedbackMarkdown": "* To follow the existing pattern, \u0060BeginConnection\u0060 should be non-virtual and we should add a single BeginDbConnectionAsync that takes an isolation level\r\n* Consider for reach API whether you want \u0060Task\u003CT\u003E\u0060 or \u0060ValueTask\u003CT\u003E\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35564,
          "Title": "Add missing feature detection properties to DbProviderFactory",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-25T18:47:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28785",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35564#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 18750000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35135,
          "Title": "New System.Data.Common batching API",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-06T16:44:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28633",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-14T00:00:00-07:00",
        "FeedbackId": "492347155",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35135#issuecomment-492347155",
        "FeedbackMarkdown": "* Have you considered making \u0060DbBatch\u0060 extend \u0060DbCommand\u0060?\r\n* \u0060IList\u003CDbBatchCommand\u003E\u0060 should probably be \u0060DbBatchCollection : Collection\u003CDbBatch\u003E\u0060\r\n* Validate this against multiple providers; shipping a new concept is best validated by having multiple implementations.",
        "TimeCode": 21710000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "zAhOxraBsi0",
      "StartDateTime": "2019-05-21T10:06:10.035-07:00",
      "EndDateTime": "2019-05-21T11:34:27-07:00",
      "Title": ".NET Design Review: Nullable Annotation Attributes",
      "ThumbnailUrl": "https://i.ytimg.com/vi/zAhOxraBsi0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37826,
          "Title": "Attributes for nullable annotations",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-20T22:46:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29617",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-21T00:00:00-07:00",
        "FeedbackId": "494505569",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37826#issuecomment-494505569",
        "FeedbackMarkdown": "Summary:\r\n\r\n* We didn\u0027t want to put them in compiler services, because most APIs aren\u0027t meant to be used by developers.\r\n* \u0060NullableAttribute\u0060 (emitted by the compiler for question marks) will still go to compiler services.\r\n* We decided to go with the existing \u0060System.Diagnostics.CodeAnalysis\u0060 namespace\r\n* Since the new namespace is low in terms of types, we decided that we don\u0027t need a base type\r\n\r\nHere is the API shape we agreed on:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis \r\n{\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property)]\r\n    public sealed class AllowNullAttribute : Attribute\r\n    {    \t\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property)]\r\n    public sealed class DisallowNullAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue)]\r\n    public sealed class MaybeNullAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue)]\r\n    public sealed class NotNullAttribute : Attribute\r\n    {    \t\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class MaybeNullWhenAttribute : Attribute\r\n    {\r\n        public MaybeNullWhenAttribute(bool returnValue);\r\n        public bool ReturnValue { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class NotNullWhenAttribute : Attribute\r\n    {\r\n        public NotNullWhenAttribute(bool returnValue);\r\n        public bool ReturnValue { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.ReturnValue, AllowMultiple = true)]\r\n    public sealed class NotNullIfNotNullAttribute : Attribute\r\n    {\r\n        public NotNullIfNotNullAttribute(string parameterName);\r\n        public string ParameterName { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor)]\r\n    public sealed class DoesNotReturnAttribute : Attribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Parameter)]\r\n    public sealed class DoesNotReturnIfAttribute : Attribute\r\n    {\r\n        public DoesNotReturnIfAttribute(bool parameterValue);\r\n        public bool ParameterValue { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DoesNotReturnIfAttribute.DoesNotReturnIfAttribute(bool)",
          "M:MaybeNullWhenAttribute.MaybeNullWhenAttribute(bool)",
          "M:NotNullIfNotNullAttribute.NotNullIfNotNullAttribute(string)",
          "M:NotNullWhenAttribute.NotNullWhenAttribute(bool)",
          "P:DoesNotReturnIfAttribute.ParameterValue",
          "P:MaybeNullWhenAttribute.ReturnValue",
          "P:NotNullIfNotNullAttribute.ParameterName",
          "P:NotNullWhenAttribute.ReturnValue",
          "T:AllowNullAttribute",
          "T:DisallowNullAttribute",
          "T:DoesNotReturnAttribute",
          "T:DoesNotReturnIfAttribute",
          "T:MaybeNullAttribute",
          "T:MaybeNullWhenAttribute",
          "T:NotNullAttribute",
          "T:NotNullIfNotNullAttribute",
          "T:NotNullWhenAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "_VAq-ORjkqk",
      "StartDateTime": "2019-05-28T09:57:26.748-07:00",
      "EndDateTime": "2019-05-28T11:01:22-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_VAq-ORjkqk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35283,
          "Title": "SslStream.AuthenticateAsServer/ClientAsync methods should default CancellationToken to default(CancellationToken)",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-13T03:41:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28677",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496610570",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35283#issuecomment-496610570",
        "FeedbackMarkdown": "We should. Looks good.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35499,
          "Title": "Add Environment.LongTickCount",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-21T20:10:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28754",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496612786",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35499#issuecomment-496612786",
        "FeedbackMarkdown": "And we landed on:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static class Environment\r\n{\r\n    public static long TickCount64 { get; }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16030000000,
        "Apis": [
          "P:Environment.TickCount64",
          "T:Environment"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36741,
          "Title": "Consider moving RuntimeHelper.GetSubArray to Array",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-09T18:08:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29218",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496613684",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36741#issuecomment-496613684",
        "FeedbackMarkdown": "Since we don\u0027t feel super strongly and the compiler would need to change, we\u0027re leaving it where it is.",
        "TimeCode": 19210000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37396,
          "Title": "Remove in and readonly ref from Activity apis",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-03T03:47:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29441",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496615275",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37396#issuecomment-496615275",
        "FeedbackMarkdown": "@tommcdon / @noahfalk / @sywhang are you OK with this? This change looks good to us.",
        "TimeCode": 20660000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37534,
          "Title": "Comparing Utf8JsonReader to default instance with the == operator",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-09T05:00:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29488",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496618927",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37534#issuecomment-496618927",
        "FeedbackMarkdown": "We certainly don\u0027t want the comparison operators as they feel hard to define. \u0060IsDefault\u0060 feels OK \u0026 consistent, but we\u0027re unsure how much value this adds. Why can\u0027t the receive just read? Why is the validation necessary? Why is the \u0060Try\u0060-pattern not sufficient?\r\n\r\nFor now, we\u0027re deciding to not take the API. If you feel differently, please re-open and answer the above questions.",
        "TimeCode": 23270000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37701,
          "Title": "StreamPipeReader/Writer should allow to leave underlying stream opened",
          "Author": "azhmur",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-16T08:14:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29569",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-28T00:00:00-07:00",
        "FeedbackId": "496622595",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37701#issuecomment-496622595",
        "FeedbackMarkdown": "The API shape as outlined by @anurse\u0027s [comment](https://github.com/dotnet/corefx/issues/37701#issuecomment-495461474) looks good.\r\n\r\n@tannergooding has filed a separate bug for removing the explicit buffer sizes and instead use sentinels so we can change their values later.",
        "TimeCode": 29730000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "EVUtzNK3tdA",
      "StartDateTime": "2019-05-30T10:03:48.916-07:00",
      "EndDateTime": "2019-05-30T11:02:39-07:00",
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/EVUtzNK3tdA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36974,
          "Title": "We should base64 encode byte[] when writing Json",
          "Author": "BrennanConroy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-17T20:23:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29299",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497411886",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36974#issuecomment-497411886",
        "FeedbackMarkdown": "* \u0060Utf8JsonWriter.WriteAsBase64String()\u0060 -\u003E \u0060WriteBase64String()\u0060\r\n* \u0060Utf8JsonReader.GetBytes()\u0060 -\u003E \u0060GetBytesFromBase64()\u0060\r\n* \u0060Utf8JsonReader.TryGetBytes()\u0060 -\u003E \u0060TryGetBytesFromBase64()\u0060\r\n* \u0060JsonElement.GetBytes()\u0060 -\u003E \u0060GetBytesFromBase64()\u0060\r\n* \u0060JsonElement.TryGetBytes()\u0060 -\u003E \u0060TryGetBytesFromBase64()\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36714,
          "Title": "JsonSerializer writing into Utf8JsonWriter",
          "Author": "BrennanConroy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-08T22:18:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29205",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497417558",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36714#issuecomment-497417558",
        "FeedbackMarkdown": "* We should make the \u0060stream, reader, writer\u0060-thingie the first argument as they are logically extension methods\r\n* \u0060ReadValue\u0060 makes sense\r\n* The \u0060As\u0060 infix notation feels odd. We should just call it \u0060WriteValue\u0060 and \u0060WriteProperty\u0060. We should also change them in \u0060JsonElement\u0060.\r\n* Adding \u0060WriteProperty(JsonEncodedText propertyName, Utf8JsonWriter writer)\u0060 makes sense.",
        "TimeCode": 13040000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36717,
          "Title": "JsonSerializer reading from Utf8JsonReader",
          "Author": "BrennanConroy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-09T00:15:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29208",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497418459",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36717#issuecomment-497418459",
        "FeedbackMarkdown": "Approved because we approved the combined one #36714.",
        "TimeCode": 23550000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36125,
          "Title": "Utf8JsonReader\\Writer should support all primitive types",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-18T19:27:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29000",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-05-30T00:00:00-07:00",
        "FeedbackId": "497424987",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36125#issuecomment-497424987",
        "FeedbackMarkdown": "The \u0060char\u0060 one might be harder to define. We should get @JamesNK input on those. Basically two options:\r\n\r\n* **We can treat it as a number**. If the primary goal is to define serialization behavior, that might be OK. And given that we have to write UTF8 that might be more honest.\r\n\r\n* **Treat it as a single character string**. This would mean that we either throw for chars that we can\u0027t represent in UTF8 or write garbage.\r\n\r\nThe other ones seem fine.",
        "TimeCode": 24550000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "CJLCnj82kSA",
      "StartDateTime": "2019-06-05T14:06:52.234-07:00",
      "EndDateTime": "2019-06-05T15:55:05-07:00",
      "Title": ".NET Design Review: Nullable Annotations",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CJLCnj82kSA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35993,
          "Title": "Add protected SecurityDescriptor to ObjectSecurity",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-12T18:25:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28948",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-05T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35993#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "XWSjh7qkHkg",
      "StartDateTime": "2019-06-11T10:04:33.285-07:00",
      "EndDateTime": "2019-06-11T11:04:08-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/XWSjh7qkHkg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36999,
          "Title": "Add a per Activity API to set the default ActivityIdFormat",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-18T15:06:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29308",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500941214",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36999#issuecomment-500941214",
        "FeedbackMarkdown": "Personally, I\u0027d prefer this being a property but it seems folks on the thread have strong opinion that this should be method, which is also accetable.\r\n\r\nIf that\u0027s a method it should be called \u0060SetIdFormat\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\npublic void SetIdFormat(ActivityIdFormat idFormat);\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37510,
          "Title": "Add DisplayUnits property to EventCounter and friends",
          "Author": "sywhang",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-08T07:06:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29477",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500943921",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37510#issuecomment-500943921",
        "FeedbackMarkdown": "Looks like we\u0027re OK with this. The default return value would be \u0060string.Empty\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Tracing\r\n{\r\n    public partial abstract class DiagnosticCounter\r\n    {\r\n        public string DisplayUnits { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9740000000,
        "Apis": [
          "P:DiagnosticCounter.DisplayUnits",
          "T:DiagnosticCounter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38422,
          "Title": "Add Timers.Count",
          "Author": "kouvel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-10T21:23:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29840",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500951300",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38422#issuecomment-500951300",
        "FeedbackMarkdown": "After long discussion, we agreed on:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial class Timer\r\n    {\r\n        public static long ActiveCount { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13820000000,
        "Apis": [
          "P:Timer.ActiveCount",
          "T:Timer"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36222,
          "Title": "Add NullableAttribute",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-21T23:49:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29039",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-11T00:00:00-07:00",
        "FeedbackId": "500957428",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36222#issuecomment-500957428",
        "FeedbackMarkdown": "We decided to keep doing the code spit because\r\n\r\n1. Any code reasoning about the attribute has to assume that attribute is emitted, so you can\u0027t optimize the path.\r\n2. The size is small",
        "TimeCode": 25790000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "56yfsgHtJ1E",
      "StartDateTime": "2019-06-18T10:03:01.494-07:00",
      "EndDateTime": "2019-06-18T12:02:12-07:00",
      "Title": ".NET Design Review: Nullable Reflection APIs \u002B JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/56yfsgHtJ1E/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 16364,
          "Title": "Allow X509Chain to replace the root trust list for a single call",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-21T23:14:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20302",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503226830",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/16364#issuecomment-503226830",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38087,
          "Title": "Expose top-level nullability information from reflection",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-31T03:07:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29723",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503265497",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38087#issuecomment-503265497",
        "FeedbackMarkdown": "* Given that we don\u0027t have all the features in-place, we believe this feature doesn\u0027t make the cut for 3.0\r\n* What about the custom attributes, such as \u0060NullIfNotNullAttribute\u0060?\r\n* What about generic type parameters (e.g. for tuples)\r\n* Namespace choice: should this be in the \u0060System.Reflection\u0060 namespace or should this go into a nested namespace?\r\n* There is the general question whether MVC or EF should even handle nullable annotations.\r\n* How do we square making runtime decisions with being able to change annotations\r\n* We should consider generalizing the feature to handle \u0060dynamic\u0060 and tuple names.",
        "TimeCode": 4280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36639,
          "Title": "Support for custom converters and OnXXX callbacks",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-05T20:47:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29177",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-18T00:00:00-07:00",
        "FeedbackId": "503265607",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36639#issuecomment-503265607",
        "FeedbackMarkdown": "Notes from toady:\r\n\r\n* \u0060JsonConverterAttribute\u0060: let\u0027s make \u0060CreateConverter\u0060 public\r\n* \u0060JsonConverter\u003CT\u003E.Read/Write\u0060: We shouldn\u0027t catch specific types, instead, we should catch exceptions whose \u0060Source\u0060 indicate that it originates from the reader/writer. The reader/writer only marks exception types that it expects the serializer to catch, for example, it would not mark argument exception because those should go unhandled. We should, however, still special case \u0060JsonException\u0060 so that implementers of JSON converters don\u0027t have to set the source.\r\n* \u0060JsonConverterAttribute\u0060 we should add \u0060protected JsonConverterAttribute()\u0060 constructor that can be used by derived types.",
        "TimeCode": 66040000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1k-niYNMo4w",
      "StartDateTime": "2019-06-25T15:05:49.167-07:00",
      "EndDateTime": "2019-06-25T16:56:19-07:00",
      "Title": ".NET Design Review: JSON",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1k-niYNMo4w/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38821,
          "Title": "Proposal: Add hard limit to MemoryInfo API",
          "Author": "andy-ms",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-24T16:49:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29998",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-06-25T00:00:00-07:00",
        "FeedbackId": "505662309",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38821#issuecomment-505662309",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "SdNdvSN_OHY",
      "StartDateTime": "2019-07-02T10:10:18.945-07:00",
      "EndDateTime": "2019-07-02T10:37:07-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/SdNdvSN_OHY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39037,
          "Title": "Add WriteTo convenience APIs on JsonDocument and JsonProperty",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-28T19:05:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30084",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507769350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39037#issuecomment-507769350",
        "FeedbackMarkdown": "We liked option Part A) \u002B Part B) 2, i.e. a single \u0060WriteTo(writer)\u0060 on all three elements.\r\n\r\n\u003E Can we instead add Write methods to \u0060Utf8JsonWriter\u0060?\r\n\r\nWe don\u0027t want this for layering reasons, i.e. the DOM knows about the writer, but the writer shouldn\u0027t know about the DOM.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37984,
          "Title": "PipeOptions, StreamPipeReaderOptions, and StreamPipeWriterOptions should not hardcode default sizes.",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-28T17:56:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29680",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507774253",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37984#issuecomment-507774253",
        "FeedbackMarkdown": "That makes sense. We should make the same change across\r\n\r\n* \u0060PipeOptions\u0060 constructor\r\n* \u0060StreamPipeReaderOptions\u0060 constructor\r\n* \u0060StreamPipeWriterOptions\u0060 constructor\r\n\r\nAfter construction, the properties should reflect the actual default. In other words, we should only change the literal of the parameter itself to \u0060-1\u0060.\r\n\r\n@bartonjs brought up the question if we should expose something like \u0060Buffer.DefaultBufferSize\u0060 that is \u0060-1\u0060. We believe that\u0027s overkill. Also, many of the BCL construct that accept buffer sizes currently don\u0027t accept negative values. We could change that, but this would be a sizable work item and we\u0027re in the wrong part in the cycle to do that.",
        "TimeCode": 5770000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507770664",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-507770664",
        "FeedbackMarkdown": "@davidfowl the method is abstract. Does that mean we\u0027ll make it virtual and a no-nop? Also, what does deprecation mean to you, marking in Obsolete? What\u0027s the message gonna say?",
        "TimeCode": 13710000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37199,
          "Title": "Change how the Arm intrinsics are exposed",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-25T21:25:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29376",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm32",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-02T00:00:00-07:00",
        "FeedbackId": "507775790",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37199#issuecomment-507775790",
        "FeedbackMarkdown": "This was reviewed and approved over e-mail. I\u0027ve started the work on changing the surface area to match this here: https://github.com/dotnet/coreclr/pull/25508, but it won\u0027t get merged until after dotnet/master begins targeting .NET 5.",
        "TimeCode": 14200000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "EERe5C9qty0",
      "StartDateTime": "2019-07-09T10:08:18.332-07:00",
      "EndDateTime": "2019-07-09T12:06:27-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/EERe5C9qty0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39241,
          "Title": "Add async versions of PipeReader and PipeWriter completion",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-05T22:27:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30162",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39241#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509732308",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-509732308",
        "FeedbackMarkdown": "Decision:\r\n\r\n* Make the implementation virtual.\r\n* Make the implementation a no-op\r\n* Mark the API as \u0060[Obsolete]\u0060\r\n* Apply the same to \u0060PipeWriter.OnWriterCompleted\u0060\r\n\r\n@davidfowl, what should the message be for \u0060PipeReader.OnReaderCompleted\u0060 and \u0060PipeWriter.OnWriterCompleted\u0060?",
        "TimeCode": 6420000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37984,
          "Title": "PipeOptions, StreamPipeReaderOptions, and StreamPipeWriterOptions should not hardcode default sizes.",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-28T17:56:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29680",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509735688",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37984#issuecomment-509735688",
        "FeedbackMarkdown": "Conclusion:\r\n\r\n* Nullable would have been nice, but we can\u0027t change the type for some of the APIs (because they shipped) and we prefer consistency, so we\u0027re going with the sentinel value of \u0060-1\u0060.",
        "TimeCode": 10060000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39307,
          "Title": "Make JsonConverterFactory.CreateConverter public.",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-09T00:04:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30190",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509740229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39307#issuecomment-509740229",
        "FeedbackMarkdown": "* Making the API public makes sense.\r\n* However, it seems if the scenario is composition, we should pass in the \u0060JsonSerializerOptions\u0060 so that someone implementing a converter for a generic type, can ask the options for getting a converter for its type arguments.\r\n     - The same logic would also apply to \u0060CanConvert()\u0060, however, it seems the design seems to be that the answer can be deferred.\r\n     - In fact, it seems \u0060GetConverter()\u0060 could too because the logic can be deferred to \u0060JsonConverter\u003CT\u003E.Read\u0060 and \u0060JsonConverter\u003CT\u003E.Write\u0060\r\n     - If that\u0027s the case the API can be approved.\r\n\r\n@JeremyKuhne please take a look.",
        "TimeCode": 15930000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39308,
          "Title": "Make Microsoft.Win32.SystemEvents static",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-09T00:11:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30191",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Microsoft.Win32",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509744182",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39308#issuecomment-509744182",
        "FeedbackMarkdown": "(You can use this issue for any class where all public APIs are static, all constructors are private, and the type is sealed)",
        "TimeCode": 24970000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36897,
          "Title": "Add AppContext.ApplicationConfig",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-15T20:04:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29271",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Configuration",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "509749369",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36897#issuecomment-509749369",
        "FeedbackMarkdown": "Conclusion\r\n\r\n* Exposing the API on \u0060AppDomainSetup\u0060 is fine, but we shouldn\u0027t expose the property on \u0060AppContext\u0060\r\n* We may want to expose the backing store for .NET Core\u0027s \u0060runtimeconfig.json\u0060 (and that should go on \u0060AppContext\u0060) but it would point to a different file, obviously.",
        "TimeCode": 29180000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36842,
          "Title": "ServiceBase.IsRunningInWindowsService",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-13T15:31:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29252",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.ServiceProcess",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36842#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 39590000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "JdaQ2RP2tqM",
      "StartDateTime": "2019-07-16T10:03:28.805-07:00",
      "EndDateTime": "2019-07-16T12:01:59-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/JdaQ2RP2tqM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39523,
          "Title": "Add Encode(ReadOnlySpan\u003Cchar\u003E) method to TextEncoder for performance",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-16T05:59:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30274",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encodings.Web",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39523#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38362,
          "Title": "Deprecate PipeWriter.OnReaderCompleted",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-08T05:03:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29818",
          "Milestone": "3.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38362#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 6490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35434,
          "Title": "(System.Numerics) Cross Product for Vector2 and Vector4",
          "Author": "danmosemsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-20T01:42:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28731",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "511933825",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35434#issuecomment-511933825",
        "FeedbackMarkdown": "Generally this seems like a reasonable API. The only sticking point is that it seems undefined and only DirectX exposes this operation for \u0060Vector2\u0060 and \u0060Vector4\u0060. This may be odd, but doesn\u0027t seem to be a blocker to us.",
        "TimeCode": 19350000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 17745,
          "Title": "Add StringBuilder(Char)",
          "Author": "iSazonov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-31T18:49:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20848",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-07-16T00:00:00-07:00",
        "FeedbackId": "511942559",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/17745#issuecomment-511942559",
        "FeedbackMarkdown": "So after discussion we think it\u0027s not worth it. It\u0027s been 20 years and this isn\u0027t a widespread enough problem.",
        "TimeCode": 53190000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "dfzXrQCINHM",
      "StartDateTime": "2019-08-20T11:01:58.518-07:00",
      "EndDateTime": "2019-08-20T12:18:34-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dfzXrQCINHM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 9680,
          "Title": "Add a Socket.Listen() overload",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-06-25T15:58:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17708",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523130997",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/9680#issuecomment-523130997",
        "FeedbackMarkdown": "Makes sense.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19408,
          "Title": "Add ImmutableInterlocked.Update for ImmutableArray",
          "Author": "sharwell",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-05-05T17:47:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21534",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523140923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19408#issuecomment-523140923",
        "FeedbackMarkdown": "We should make sure that the new overloads don\u0027t cause ambiguities but recompiling CoreFx will probably be sufficient.",
        "TimeCode": 3450000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19416,
          "Title": "Add support for getting current stack into Exception",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-05-05T22:13:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21539",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523144443",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19416#issuecomment-523144443",
        "FeedbackMarkdown": "Based on the scenario, it seems \u0060SetCurrentStackTrace\u0060 would more sense; if we ever need an append, we can add an overload with a Boolean. @stephentoub suggested to make it fail for exceptions with existing stack traces.",
        "TimeCode": 18110000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26528,
          "Title": "Add \u0027split\u0027 support for ReadOnlySpan\u003Cchar\u003E similar to string",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-23T01:10:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/934",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "utf8-impact",
              "Color": "eddf84",
              "Description": "Potentially impacts UTF-8 support in the runtime"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-20T00:00:00-07:00",
        "FeedbackId": "523152939",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26528#issuecomment-523152939",
        "FeedbackMarkdown": "Based on the conversation, we believe we would prefer something more scoped:\r\n\r\n\u0060\u0060\u0060C#\r\npartial class MemoryExtensions\r\n{\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span);\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span, char separator);\r\n    public static SpanSplitEnumerator\u003Cchar\u003E Split(this ReadOnlySpan\u003Cchar\u003E span, string separator);\r\n\r\n    // This API seems possible, but we can defer until we see scenarios\r\n    // public static SpanSplitEnumerator\u003Cchar\u003E SplitAny(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E separators);\r\n\r\n    // This API seems possible, but we should defer until we see scenarios. It wouldn\u0027t be good make this work for UTF8, for example.\r\n    // public static SpanSplitEnumerator\u003CT\u003E Split\u003CT\u003E(this ReadOnlySpan\u003CT\u003E span, T separator);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe enumerator returns ranges so you cans split a memory via this API and use the span to slice the memory and to unify span and read-only spans. It\u0027s unclear whether we need different enumerator types for different \u0060Split\u0060 behaviors, but we don\u0027t expect people to exchange those, which is why they are currently proposed to be nested types too.",
        "TimeCode": 23950000000,
        "Apis": [
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E,char)",
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E,string)",
          "M:MemoryExtensions.Split(this ReadOnlySpan\u003Cchar\u003E)",
          "T:MemoryExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "maDBdlZfCGA",
      "StartDateTime": "2019-08-27T11:00:30.756-07:00",
      "EndDateTime": "2019-08-27T12:10:42-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/maDBdlZfCGA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 26772,
          "Title": "Expression support for ref and readonly ref types",
          "Author": "JonHanna",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-02T00:53:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24884",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq.Expressions",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocked",
              "Color": "b60205",
              "Description": "Issue/PR is blocked on something - see comments"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525417923",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/26772#issuecomment-525417923",
        "FeedbackMarkdown": "There is a general item on the compiler team to figure out how expression trees are going to be evolved (and if).",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 28379,
          "Title": "Add a ValueStringBuilder",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-22T21:28:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25587",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocked",
              "Color": "b60205",
              "Description": "Issue/PR is blocked on something - see comments"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525424732",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/28379#issuecomment-525424732",
        "FeedbackMarkdown": "We believe that without a feature that forces consumers to pass value types by reference (either language feature or in-box analyzer) this will cause unreliable applications due to corruption of the array pool when accidental copies are being made.\r\n\r\n@JeremyKuhne do you want to drive that discussion with @jaredpar?",
        "TimeCode": 3440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30701,
          "Title": "Add Path.RemoveRelativeSegments Api",
          "Author": "Anipik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-27T18:37:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2162",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525429074",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30701#issuecomment-525429074",
        "FeedbackMarkdown": "@Anipik you mentioned you don\u0027t want to use \u0060GetFullPath()\u0060 because you want to preserve the relativeness. What\u0027s the scenario for this API then? Functionally, it seems \u0060GetFullPath()\u0060 or keeping the path with the dots seems both OK.",
        "TimeCode": 14480000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 19814,
          "Title": "Proposal: List\u003CT\u003E.AsSpan()",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-05-16T02:52:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21727",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-08-27T00:00:00-07:00",
        "FeedbackId": "525432693",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/19814#issuecomment-525432693",
        "FeedbackMarkdown": "Let\u0027s start with no :)",
        "TimeCode": 20960000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Vf-Gj0h8Uws",
      "StartDateTime": "2019-09-10T10:07:57.521-07:00",
      "EndDateTime": "2019-09-10T11:56:39-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Vf-Gj0h8Uws/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40962,
          "Title": "Review System.Buffers.SequenceReader\u003CT\u003E proposals",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-10T02:04:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30807",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530060857",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857",
        "FeedbackMarkdown": "* We should rename the \u0060skip\u0060 parameters to \u0060offset\u0060\r\n    - We don\u0027t use \u0060skip\u0060 anywhere else and it kind of implies a side effect\r\n    - \u0060offset\u0060 implies relative to *something* and for a reader it makes to be relative to current position\r\n* We should the \u0060count\u0060 parameter to \u0060length\u0060\r\n* We should remove the overloads of TryPeek that take two arguments and whose first argument is \u0060count\u0060 -- because it conflicts \u0060TryPeek(int skip, out T value)\u0060\r\n* Arguments referring to position and lengths should be typed as \u0060long\u0060\r\n* We should add \u0060readonly\u0060 annotations\r\n* It\u0027s sad that \u0060TryPeek()\u0060 that returns a span might have to allocate if the span crosses buffers but there is no way around that.\r\n* FDG: we need to consider what we do for out parameters where the out type is the same as the input type as that allows you modify the \u0060this\u0060 while it\u0027s running (ask Levi for details).\r\n* \u0060public void SetPosition(SequencePosition position);\u0060 needs more work as there are a lot of concerns (like O(n) complexity).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Optimized API to position the reader at the end of the sequence (much faster than what users can write)\r\n        public void AdvanceToEnd();\r\n\r\n        // Pairs with existing Span\u003CT\u003E UnreadSpan;\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence { get; }\r\n\r\n        // Overloads for TryRead that allow reading out a given count rather than to some delimiter (as with existing\r\n        // API span out will slice if it can or allocate and copy if it has to).\r\n        public bool TryRead(int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public bool TryRead(long length, out ReadOnlySequence\u003CT\u003E value);\r\n\r\n        // Peeking out T, while skipping. This is more performant than users can write (avoids rewinding).\r\n        public readonly bool TryPeek(long offset, out T value);\r\n\r\n        // Equivalent \u0022Peek\u0022 versions. They need a offset as peeking doesn\u0027t advance the reader and rewinding is super expensive.\r\n        public readonly bool TryPeek(long offset, int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public readonly bool TryPeek(long offset, long length, out ReadOnlySequence\u003CT\u003E value);\r\n \r\n        // Pairs with existing TryCopyTo(Span\u003CT\u003E destination), which does not advance the reader (neither does this)\r\n        public readonly bool TryCopyTo(long offset, Span\u003CT\u003E destination);\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.AdvanceToEnd()",
          "M:SequenceReader\u003CT\u003E.TryCopyTo(long,Span\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,int,out ReadOnlySpan\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,long,out ReadOnlySequence\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryPeek(long,out T)",
          "M:SequenceReader\u003CT\u003E.TryRead(int,out ReadOnlySpan\u003CT\u003E)",
          "M:SequenceReader\u003CT\u003E.TryRead(long,out ReadOnlySequence\u003CT\u003E)",
          "P:SequenceReader\u003CT\u003E.UnreadSequence",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40843,
          "Title": "SequenceReader\u003CT\u003E.AdvanceTo(SequencePosition)",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-05T18:16:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30770",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530066043",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40843#issuecomment-530066043",
        "FeedbackMarkdown": "This was reviewed in #40962.  Concerns about [performance and usability](https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857) pretty much as described so putting back to \u0022needs work\u0022.",
        "TimeCode": 45190000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 8126,
          "Title": "Allow custom format strings for boolean values",
          "Author": "martingbrown",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-27T17:42:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17141",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530066335",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/8126#issuecomment-530066335",
        "FeedbackMarkdown": "Honestly, while I agree with that being useful, it\u0027s trivial for people to define helper methods:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static string ToState(this bool value, string trueValue, string falseValue)\r\n    =\u003E value ? trueValue : falseValue;\r\npublic static string ToState(this bool? value, string trueValue, string falseValue, string nullValue)\r\n    =\u003E value is null ? nullValue : value.Value ? trueValue : nullValue;\r\n\u0060\u0060\u0060\r\n\r\nFor \u0060bool\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\nstring.Format($\u0022The kettle is {kettle.ToState(\u0022on\u0022, \u0022off\u0022)}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nFor \u0060bool?\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\nstring.Format($\u0022The kettle is {kettle.ToState(\u0022on\u0022, \u0022off\u0022, \u0022Unknown\u0022)}\u0022);\r\n\u0060\u0060\u0060\r\n\r\nUsing the formatting APIs seems way too complex for this case.",
        "TimeCode": 51490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37156,
          "Title": "Proposal: SequenceReader\u003CT\u003E.ReadToEnd / AdvanceToEnd",
          "Author": "GoldenCrystal",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-24T21:29:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29360",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530067301",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37156#issuecomment-530067301",
        "FeedbackMarkdown": "This was approved in #40962 as:\r\n\r\n\u0060\u0060\u0060 C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Optimized API to position the reader at the end of the sequence (much faster than what users can write)\r\n        public void AdvanceToEnd();\r\n\r\n        // Pairs with existing Span\u003CT\u003E UnreadSpan;\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHere are the rough implementations:\r\n\r\n\u0060\u0060\u0060 C#\r\n        /// \u003Csummary\u003E\r\n        /// The unread portion of the \u003Csee cref=\u0022Sequence\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        public readonly ReadOnlySequence\u003CT\u003E UnreadSequence\r\n        {\r\n            get =\u003E Sequence.Slice(Position);\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n\r\n\u0060\u0060\u0060 C#\r\n        public void AdvanceToEnd()\r\n        {\r\n            if (_moreData)\r\n            {\r\n                Consumed = Length;\r\n                CurrentSpan = default;\r\n                CurrentSpanIndex = 0;\r\n                _currentPosition = Sequence.End;\r\n                _moreData = false;\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nMarking as up-for-grabs to fully implement/test.",
        "TimeCode": 53960000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.AdvanceToEnd()",
          "P:.UnreadSequence",
          "P:SequenceReader\u003CT\u003E.UnreadSequence",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40870,
          "Title": "SequenceReader\u003CT\u003E.TryRead overloads to read a specified number of elements",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-06T05:30:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30778",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530068389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40870#issuecomment-530068389",
        "FeedbackMarkdown": "Approved: https://github.com/dotnet/corefx/issues/40962#issuecomment-530060857\r\n\r\n\u0060\u0060\u0060 C#\r\n        public bool TryRead(int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public bool TryRead(long length, out ReadOnlySequence\u003CT\u003E value);\r\n\u0060\u0060\u0060",
        "TimeCode": 55580000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40845,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads for look ahead",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-05T18:21:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30771",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530069306",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40845#issuecomment-530069306",
        "FeedbackMarkdown": "Approved: #40962 (comment):\r\n\r\n\u0060\u0060\u0060 C#\r\n        public readonly bool TryPeek(long offset, out T value);\r\n\u0060\u0060\u0060",
        "TimeCode": 57020000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40871,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads to read a specified number of elements from any position",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-06T05:33:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30779",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-10T00:00:00-07:00",
        "FeedbackId": "530070064",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40871#issuecomment-530070064",
        "FeedbackMarkdown": "Approved: #40962 (comment):\r\n\r\n\u0060\u0060\u0060 C#\r\n        // Equivalent \u0022Peek\u0022 versions. They need a offset as peeking doesn\u0027t advance the reader and rewinding is super expensive.\r\n        public readonly bool TryPeek(long offset, int length, out ReadOnlySpan\u003CT\u003E value);\r\n        public readonly bool TryPeek(long offset, long length, out ReadOnlySequence\u003CT\u003E value);\r\n \r\n        // Pairs with existing TryCopyTo(Span\u003CT\u003E destination), which does not advance the reader (neither does this)\r\n        public readonly bool TryCopyTo(long offset, Span\u003CT\u003E destination);\r\n\u0060\u0060\u0060",
        "TimeCode": 58490000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "6Kd92ScY3gM",
      "StartDateTime": "2019-09-17T11:10:28.876-07:00",
      "EndDateTime": "2019-09-17T12:13:38-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6Kd92ScY3gM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39564,
          "Title": "Add UnderScoreCase support for System.Text.Json",
          "Author": "hez2010",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-17T05:17:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/782",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532341171",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39564#issuecomment-532341171",
        "FeedbackMarkdown": "Makes sense. We also considered others (such as kebap casing) but it seems we should defer that until someone actually needs that.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41002,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532349735",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41002#issuecomment-532349735",
        "FeedbackMarkdown": "We seem to lean towards not having \u0060Ignore\u0060 -- it results in payloads that nobody can reason about. The right fix for those scenarios to modify the C# types to exclude back pointers from serialization.\r\n\r\nWe\u0027d like to see more detailed spec for the behavior, specifically error cases.",
        "TimeCode": 5790000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40558,
          "Title": "HashAlgorithmName.FromOid",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-24T16:02:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30671",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40558#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 19480000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24770,
          "Title": "Add RemoveIfValue to ConcurrentDictionary",
          "Author": "CornedBee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-20T09:05:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23909",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-17T00:00:00-07:00",
        "FeedbackId": "532361229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24770#issuecomment-532361229",
        "FeedbackMarkdown": "If we\u0027re adding it, it should be \u0060TryRemove(KV\u003CK, V\u003E)\u0060.",
        "TimeCode": 27490000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "8M5rFkINsus",
      "StartDateTime": "2019-09-24T11:10:08.464-07:00",
      "EndDateTime": "2019-09-24T12:10:33-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8M5rFkINsus/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27453,
          "Title": "Add a Generic version of GetValues to Enum (probably GetName/GetNames)",
          "Author": "andreigit",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-25T17:06:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2364",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534690642",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27453#issuecomment-534690642",
        "FeedbackMarkdown": "I stand corrected, we believe we\u0027d prefer this API shape:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial abstract class Enum\r\n    {\r\n        public static TEnum[] GetValues\u003CTEnum\u003E() where TEnum : struct, Enum;\r\n        public static string GetName\u003CTEnum\u003E(TEnum value) where TEnum : struct, Enum;\r\n        public static string[] GetNames\u003CTEnum\u003E() where TEnum : struct, Enum;     \r\n        public static bool IsDefined\u003CTEnum\u003E(TEnum value) where TEnum : struct, Enum;       \r\n        public static bool HasFlag\u003CTEnum\u003E(TEnum value, TEnum test) where TEnum : struct, Enum;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Enum.GetName\u003CTEnum\u003E(TEnum)",
          "M:Enum.GetNames\u003CTEnum\u003E()",
          "M:Enum.GetValues\u003CTEnum\u003E()",
          "M:Enum.HasFlag\u003CTEnum\u003E(TEnum,TEnum)",
          "M:Enum.IsDefined\u003CTEnum\u003E(TEnum)",
          "T:Enum"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30701,
          "Title": "Add Path.RemoveRelativeSegments Api",
          "Author": "Anipik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-06-27T18:37:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2162",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534695882",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30701#issuecomment-534695882",
        "FeedbackMarkdown": "Alright, here is the shape we\u0027d like to see:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class Path\r\n    {\r\n        public static string RemoveRedundantSegments(string path);\r\n        public static string RemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E path);\r\n        public static bool TryRemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E path, Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14520000000,
        "Apis": [
          "M:Path.RemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E)",
          "M:Path.RemoveRedundantSegments(string)",
          "M:Path.TryRemoveRedundantSegments(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E,out int)",
          "T:Path"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31597,
          "Title": "Add List\u003CT\u003E AsSpan to CollectionsMarshal",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-04T14:02:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27061",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-09-24T00:00:00-07:00",
        "FeedbackId": "534703891",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31597#issuecomment-534703891",
        "FeedbackMarkdown": "Approved shape:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial static class CollectionsMarshal\r\n    {\r\n        public static Span\u003CT\u003E AsSpan(List\u003CT\u003E list);\r\n        public static ReadOnlySpan\u003CT\u003E AsReadOnlySpan(List\u003CT\u003E list);\r\n\r\n        // We don\u0027t want this one:\r\n        // public Memory\u003CT\u003E AsMemory(List\u003CT\u003E list);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22430000000,
        "Apis": [
          "M:CollectionsMarshal.AsReadOnlySpan(List\u003CT\u003E)",
          "M:CollectionsMarshal.AsSpan(List\u003CT\u003E)",
          "T:CollectionsMarshal"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "b-Hz_CBobfU",
      "StartDateTime": "2019-10-01T10:10:24.661-07:00",
      "EndDateTime": "2019-10-01T12:05:42-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b-Hz_CBobfU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41166,
          "Title": "Add Encoding/Decoding APIs for new System.Buffer types",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-18T05:00:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30882",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537141144",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41166#issuecomment-537141144",
        "FeedbackMarkdown": "* The signatures makes sense\r\n* Should also add \r\n    \u0060\u0060\u0060C#\r\n    public static long GetByteCount(this Encoding encoding, in ReadOnlySequence\u003Cchar\u003E chars);\r\n    public static long GetCharCount(this Encoding encoding, in ReadOnlySequence\u003Cbyte\u003E bytes);\r\n    \u0060\u0060\u0060\r\n* Making this an extension seems slightly sad; is this the point where we should consider movign \u0060ReadOnlySequence\u003CT\u003E\u0060, \u0060IBfferWriter\u003CT\u003E\u0060 into corlib? Can anybody think of scenarios where we\u0027d like those types down?\r\n* @GrabYourPitchforks filed #41474 to make these instance methods should we move the types down",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41326,
          "Title": "Add Encoder/Decoder for new System.Buffer types",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-25T20:32:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30957",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537150026",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41326#issuecomment-537150026",
        "FeedbackMarkdown": "* Should these be \u0060OperationStatus\u0060 APIs? We decided not to, because we modeled these overloads after the existing APIs.\r\n* We considered replacing the outed sequence position with an \u0060int\u0060, but slicing with a position is simpler and more performant (because O(1)).\r\n* We should rename \u0060bytesUsedPosition\u0060 to just \u0060position\u0060\r\n* Same as #41166: if we move \u0060ReadOnlySequence\u003CT\u003E\u0060 and \u0060IBufferWriter\u003CT\u003E\u0060 to corlib, we should make those instance methods.",
        "TimeCode": 9180000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31597,
          "Title": "Add List\u003CT\u003E AsSpan to CollectionsMarshal",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-04T14:02:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27061",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537151655",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31597#issuecomment-537151655",
        "FeedbackMarkdown": "We decided to not increment the version, which is why we removed the \u0060AsReadOnlySpan()\u0060 overload.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial static class CollectionsMarshal\r\n    {\r\n        public static Span\u003CT\u003E AsSpan(List\u003CT\u003E? list);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21570000000,
        "Apis": [
          "M:CollectionsMarshal.AsSpan(List\u003CT\u003E?)",
          "T:CollectionsMarshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31787,
          "Title": "a new GC API for large array allocation",
          "Author": "Maoni0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-15T21:24:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27146",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537157276",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31787#issuecomment-537157276",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class GC\r\n    {\r\n        public static T[] AllocateArray\u003CT\u003E(int length, int generation=-1, bool pinned=false, int alignment=-1);\r\n        public static T[] AllocateUninitializedArray\u003CT\u003E(int length, int generation=-1, bool pinned=false, int alignment=-1);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23760000000,
        "Apis": [
          "M:GC.AllocateArray\u003CT\u003E(int,int,bool,int)",
          "M:GC.AllocateUninitializedArray\u003CT\u003E(int,int,bool,int)",
          "T:GC"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31807,
          "Title": "long ReadOnlySequence\u003CT\u003E.GetPosition(SequencePosition)",
          "Author": "AArnott",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-16T18:56:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27158",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537160854",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31807#issuecomment-537160854",
        "FeedbackMarkdown": "Given that the nomenclature uses \u0060offset\u0060 for \u0060long\u0060-based absolute values and \u0060position\u0060 for a \u0060SequencePosition\u0060 value, we should be using \u0060GetOffset()\u0060. This also solves some overload issue that only @tannergooding understands \uD83D\uDE04 \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct ReadOnlySequence\u003CT\u003E\r\n    {\r\n       public long GetOffset(SequencePosition position);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31780000000,
        "Apis": [
          "M:ReadOnlySequence\u003CT\u003E.GetOffset(SequencePosition)",
          "T:ReadOnlySequence\u003CT\u003E"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 31820,
          "Title": "Color should implement FromHsl methods",
          "Author": "AraHaan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-16T23:57:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27164",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537164275",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/31820#issuecomment-537164275",
        "FeedbackMarkdown": "* It [sounds like](https://stackoverflow.com/questions/15668623/hsb-vs-hsl-vs-hsv) HSL is different from HSB.\r\n* Given that your sample code uses \u0060GetBrightness()\u0060 as the input to \u0060FromHsl\u0060, is it possible that you really meant \u0060FromHsb()\u0060?",
        "TimeCode": 37180000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32201,
          "Title": "Extend CultureInfo.GetCultureInfo and new CultureInfo to optionally accept predefined cultures only",
          "Author": "mklement0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-09-10T20:53:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27352",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537177127",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32201#issuecomment-537177127",
        "FeedbackMarkdown": "After some debate we settled on this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial class CultureInfo\r\n    {\r\n        public static CultureInfo GetCulture(string name, bool prefinedOnly);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis API would throw for invalid names as well as names that weren\u0027t system provided when \u0060predefinedOnly\u0060 is \u0060true\u0060.",
        "TimeCode": 42150000000,
        "Apis": [
          "M:CultureInfo.GetCulture(string,bool)",
          "T:CultureInfo"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32987,
          "Title": "Add remove Range to sorted List",
          "Author": "hernot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-23T19:13:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27713",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-01T00:00:00-07:00",
        "FeedbackId": "537183526",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32987#issuecomment-537183526",
        "FeedbackMarkdown": "The generic sorted list doesn\u0027t allow indexing by \u0060int\u0060, however, it does expose a \u0060RemoveAt\u0060 method. But we\u0027d have to make sure this plays nicely for cases where custom compares are used that, for example, take into consideration the number of elements and use different sorting.\r\n\r\nRight now, we\u0027re not convinced the usability and minor performance gains are motivating enough. Feel free to push back though and provide more arguments :-)",
        "TimeCode": 59900000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "7KTxd_41Lus",
      "StartDateTime": "2019-10-10T13:07:01.117-07:00",
      "EndDateTime": "2019-10-10T14:16:41-07:00",
      "Title": ".NET Design Review: .NET Core 3.1",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7KTxd_41Lus/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41614,
          "Title": "Add file and directory creation methods that take an ACL",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-07T21:22:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31095",
          "Milestone": "3.1",
          "Labels": [
            {
              "Name": "Security",
              "Color": "b60205",
              "Description": null
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540773661",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41614#issuecomment-540773661",
        "FeedbackMarkdown": "We considered adding the APIs back to the relevant types (i.e. as constructors). While this would be preferred from a porting/backwards compabitility case, it would mean we\u0027d have to pull-in a large amount of ACL / Windows security into \u0060System.Private.Corelib\u0060.\r\n\r\nWe think these APIs are weird and shouldn\u0027t be exposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class FileSystemAclExtensions\r\n    {\r\n        public static FileStream CreateFile(\r\n            this FileSecurity fileSecurity,\r\n            string path,\r\n            FileMode mode,\r\n            FileSystemRights rights,\r\n            FileShare share,\r\n            int bufferSize,\r\n            FileOptions options);\r\n\r\n        public static DirectoryInfo CreateDirectory(\r\n            this DirectorySecurity directorySecurity\r\n            string path);\r\n    }\r\n }\r\n\u0060\u0060\u0060\r\n\r\nThese APIs look fine (assuming they match the existing instance methods of .NET Framework in terms of naming and order):\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class FileSystemAclExtensions\r\n    {\r\n        // Add\r\n        public static FileStream Create(\r\n            this FileInfo fileInfo,\r\n            FileMode mode,\r\n            FileSystemRights rights,\r\n            FileShare share,\r\n            int bufferSize,\r\n            FileOptions options,\r\n            FileSecurity fileSecurity);\r\n\r\n        public static void Create(\r\n            this DirectoryInfo directoryInfo,\r\n            DirectorySecurity directorySecurity);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:FileSystemAclExtensions.Create(this DirectoryInfo,DirectorySecurity)",
          "M:FileSystemAclExtensions.Create(this FileInfo,FileMode,FileSystemRights,FileShare,int,FileOptions,FileSecurity)",
          "M:FileSystemAclExtensions.CreateDirectory(this DirectorySecurity,string)",
          "M:FileSystemAclExtensions.CreateFile(this FileSecurity,string,FileMode,FileSystemRights,FileShare,int,FileOptions)",
          "T:FileSystemAclExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41654,
          "Title": "Port \u0060MemoryMappedFileSecurity\u0060 and add extensions for \u0060MemoryMappedFile\u0060",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-08T21:21:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/941",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540781324",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41654#issuecomment-540781324",
        "FeedbackMarkdown": "We should introduce a new static type in the same assembly as \u0060FileSystemAclExtensions\u0060. The pattern we settled on was suffixing the type with \u0060Acl\u0060.\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.MemoryMappedFiles\r\n{\r\n    public static class MemoryMappedFileAcl\r\n    {\r\n        public static MemoryMappedFile CreateFromFile(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            FileStream fileStream,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            HandleInheritability inheritability,\r\n            bool leaveOpen);\r\n\r\n        public static MemoryMappedFile CreateNew(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            MemoryMappedFileOptions options,\r\n            HandleInheritability inheritability);\r\n\r\n        public static MemoryMappedFile CreateOrOpenMappedFile(\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity,\r\n            string mapName,\r\n            long capacity,\r\n            MemoryMappedFileAccess access,\r\n            MemoryMappedFileOptions options,\r\n            HandleInheritability inheritability);\r\n\r\n        // Those are fine as extensions:\r\n\r\n        public static MemoryMappedFileSecurity GetAccessControl(\r\n            this MemoryMappedFile memoryMappedFile);\r\n\r\n        public static void SetAccessControl(\r\n            this MemoryMappedFile memoryMappedFile,\r\n            MemoryMappedFileSecurity memoryMappedFileSecurity);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10470000000,
        "Apis": [
          "M:MemoryMappedFileAcl.CreateFromFile(MemoryMappedFileSecurity,FileStream,string,long,MemoryMappedFileAccess,HandleInheritability,bool)",
          "M:MemoryMappedFileAcl.CreateNew(MemoryMappedFileSecurity,string,long,MemoryMappedFileAccess,MemoryMappedFileOptions,HandleInheritability)",
          "M:MemoryMappedFileAcl.CreateOrOpenMappedFile(MemoryMappedFileSecurity,string,long,MemoryMappedFileAccess,MemoryMappedFileOptions,HandleInheritability)",
          "M:MemoryMappedFileAcl.GetAccessControl(this MemoryMappedFile)",
          "M:MemoryMappedFileAcl.SetAccessControl(this MemoryMappedFile,MemoryMappedFileSecurity)",
          "T:MemoryMappedFileAcl"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41657,
          "Title": "Add pipe creation extension methods that take an ACL",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-08T21:52:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31112",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "Security",
              "Color": "b60205",
              "Description": null
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540786760",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41657#issuecomment-540786760",
        "FeedbackMarkdown": "We should not make them extension methods. We should follow the other pattern and create new static types suffixed with \u0060Acl\u0060:\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipes\r\n{\r\n    public static class AnonymousPipeServerStreamAcl\r\n    {\r\n        public AnonymousPipeServerStream Create(\r\n            PipeSecurity pipeSecurity\r\n            PipeDirection direction,\r\n            HandleInheritability inheritability,\r\n            int bufferSize);\r\n    }\r\n\r\n    public static class NamedPipeServerStreamAcl\r\n    {\r\n        public NamedPipeServerStream Create(\r\n            PipeSecurity pipeSecurity\r\n            string pipeName,\r\n            PipeDirection direction,\r\n            int maxNumberOfServerInstances,\r\n            PipeTransmissionMode transmissionMode,\r\n            PipeOptions options,\r\n            int inBufferSize,\r\n            int outBufferSize,\r\n            HandleInheritability inheritability = HandleInheritability.None,\r\n            PipeAccessRights additionalAccessRights = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19120000000,
        "Apis": [
          "M:AnonymousPipeServerStreamAcl.Create(PipeSecurity,PipeDirection,HandleInheritability,int)",
          "M:NamedPipeServerStreamAcl.Create(PipeSecurity,string,PipeDirection,int,PipeTransmissionMode,PipeOptions,int,int,HandleInheritability,PipeAccessRights)",
          "T:AnonymousPipeServerStreamAcl",
          "T:NamedPipeServerStreamAcl"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41662,
          "Title": "Add Mutex, Semaphore, and EventWaitHandle creation extension methods that take an ACL",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-08T22:22:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31114",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "Security",
              "Color": "b60205",
              "Description": null
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540790209",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41662#issuecomment-540790209",
        "FeedbackMarkdown": "We should not make them extension methods. We should follow the other pattern and create new static types suffixed with \u0060Acl\u0060:\r\n\r\n@JeremyKuhne: we need to update the ordering to match the existing APIs. Please update this comment.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static class EventWaitHandleAcl\r\n    {   \r\n        public static EventWaitHandle Create(\r\n            EventWaitHandleSecurity eventSecurity\r\n            bool initialState,\r\n            EventResetMode mode,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n\r\n    public static class MutexAcl\r\n    {   \r\n        public static Mutex Create(\r\n            MutexSecurity mutexSecurity,\r\n            bool initiallyOwned,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n\r\n    public static class SemaphoreAcl\r\n    {   \r\n        public static Semaphore Create(\r\n            SemaphoreSecurity semaphoreSecurity,\r\n            int initialCount,\r\n            int maximumCount,\r\n            string name,\r\n            out bool createdNew);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25060000000,
        "Apis": [
          "M:EventWaitHandleAcl.Create(EventWaitHandleSecurity,bool,EventResetMode,string,out bool)",
          "M:MutexAcl.Create(MutexSecurity,bool,string,out bool)",
          "M:SemaphoreAcl.Create(SemaphoreSecurity,int,int,string,out bool)",
          "T:EventWaitHandleAcl",
          "T:MutexAcl",
          "T:SemaphoreAcl"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40407,
          "Title": "Readonly members in Drawing primitives ",
          "Author": "sonnemaf",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-19T09:22:33+00:00",
          "Url": "https://github.com/dotnet/corefx/pull/40407",
          "Milestone": "5.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-10T00:00:00-07:00",
        "FeedbackId": "540800566",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40407#issuecomment-540800566",
        "FeedbackMarkdown": "This seems reasonable to be merged (for 5.0, we don\u0027t believe this makes the bar for 3.1). We probably want to do this piecemeal, like we do for nullable. We already have a tracking issue to do a pass (#36586). /cc @tannergooding \r\n\r\nThis also seems like a good idea for an analyzer that can suggest adding the \u0060readonly\u0060 modifier. /cc @stephentoub",
        "TimeCode": 30120000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "VQuFvX2k-HA",
      "StartDateTime": "2019-10-22T10:13:04.646-07:00",
      "EndDateTime": "2019-10-22T11:59:51-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VQuFvX2k-HA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40740,
          "Title": "Attribute for minimal runtime impact during an unmanaged call",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-01T22:26:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30741",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545076797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40740#issuecomment-545076797",
        "FeedbackMarkdown": "* Would probably make sense on \u0060DllImportAttribute\u0060 but this attribute is specially encoded in metadata, so we can\u0027t easily do that\r\n* We believe this can\u0027t be internal and library authors will likely want this\r\n* This concept should work function pointers, however, it\u0027s unclear how this can be expressed. There is currently no way to express this.\r\n* The more generic API names (\u0060TrivialUnmanagedMethodAttribute\u0060, \u0060LimitedUnmanagedMethodAttribute\u0060) seem problematic because we\u0027re probably not likely to turn more runtime optimizations on when a method is attributed as *trivial*, which makes specific naming like this more useful.\r\n* We should probably make this attribute work for \u0060UnmanagedFunctionPointerAttribute\u0060 which names we should include \u0060Delegate\u0060 in the attribute targets.\r\n\t- @AaronRobinsonMSFT please confirm whether this feature will work for the existing umanaged function pointer delegates.\r\n* How would this feature work with function pointers?\r\n\t- @333fred @jaredpar what are you thoughts on this?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38585,
          "Title": "Provide an \u0060Unsafe.SkipInit\u0060 method to allow bypassing definite assignment rules.",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-16T14:42:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29905",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545079783",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38585#issuecomment-545079783",
        "FeedbackMarkdown": "Looks good as proposed, ~~but we should constrain the \u0060T\u0060 to be unamanged.~~\r\n\r\nAfter discussion with @jkotas we concluded that we don\u0027t want *any* constraint. The JIT will do the right thing. Not even the \u0060struct\u0060 constraint should be there.\r\n\r\n\u0060\u0060\u0060C#\r\npublic static partial class Unsafe\r\n{\r\n    public static void SkipInit\u003CT\u003E(out T value);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20540000000,
        "Apis": [
          "M:Unsafe.SkipInit\u003CT\u003E(out T)",
          "T:Unsafe"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41784,
          "Title": "Make Type implement IEquatable\u003CType\u003E",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-15T13:21:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31171",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545080947",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41784#issuecomment-545080947",
        "FeedbackMarkdown": "What about other types in the \u0060MemberInfo\u0060 hierarchy?\r\n\r\n@steveharter what are you thoughts?",
        "TimeCode": 24870000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41695,
          "Title": "Mark Assembly.CodeBase as obsolete",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-09T23:56:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31127",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545084027",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41695#issuecomment-545084027",
        "FeedbackMarkdown": "Looks good. We should also mark it as \u0060[EditorBrowsable(Never)]\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection\r\n{\r\n    public partial class Assembly\r\n    {\r\n        [Obsolete(\u0022Use Location instead.\u0022)]\r\n        public virtual string CodeBase { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26580000000,
        "Apis": [
          "P:Assembly.CodeBase",
          "T:Assembly"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 9071,
          "Title": "Add HttpContent.SerializeToStreamAsync overload with cancellation",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-06-02T17:40:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17492",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545093260",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/9071#issuecomment-545093260",
        "FeedbackMarkdown": "~~We should consider making the existing one non-abstract so that new types inheriting it don\u0027t have to overide the *bad* one. We obviously can\u0027t call each other because if a person didn\u0027t override either method, we shouldn\u0027t crash with a stack overflow.~~\r\n\r\n**Edit** We changed our mind. We\u0027ll leave it abstract and implementers should override both. We should think about a *soft abstract* attribute where an analyzer could warn people if they inherited but didn\u0027t override.\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpContent\r\n{\r\n    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken token);\r\n    protected abstract Task SerializeToStreamAsync(Stream stream, TransportContext context);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31270000000,
        "Apis": [
          "M:HttpContent.SerializeToStreamAsync(Stream,TransportContext,CancellationToken)",
          "M:HttpContent.SerializeToStreamAsync(Stream,TransportContext)",
          "T:HttpContent"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24475,
          "Title": "Proposal: SmtpClient.SendMailAsync overload with cancellation",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-06T13:39:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23756",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545097103",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24475#issuecomment-545097103",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Mail\r\n{\r\n    public partial class SmtpClient\r\n    {\r\n        public Task SendMailAsync(MailMessage message, CancellationToken cancellationToken);\r\n        public Task SendMailAsync(string from, string recipients, string subject, string body, CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45020000000,
        "Apis": [
          "M:SmtpClient.SendMailAsync(MailMessage,CancellationToken)",
          "M:SmtpClient.SendMailAsync(string,string,string,string,CancellationToken)",
          "T:SmtpClient"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 25295,
          "Title": "TryParse for email addresses ",
          "Author": "Grauenwolf",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-16T17:50:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/907",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545099733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/25295#issuecomment-545099733",
        "FeedbackMarkdown": "* If we were to expose the \u0060TryParse\u0060 ones, we should also define corresponding static \u0060Parse\u0060 methods.\r\n* The bigger question is whether we\u0027d recommend \u0060MailAddress\u0060 at all. The [data annotations implementation for \u0060IsValid\u0060](https://source.dot.net/#System.ComponentModel.Annotations/System/ComponentModel/DataAnnotations/EmailAddressAttribute.cs,1dcffef3eace5290,references) is much simpler, probably because email addresses are complex and in practice most validators reject rare, but valid email addreses.",
        "TimeCode": 51160000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36379,
          "Title": "Provide a zero-cost mechanism for going between System.Numerics.Vector and System.Runtime.Intrinsics.Vector types",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-26T21:25:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/952",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545102767",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36379#issuecomment-545102767",
        "FeedbackMarkdown": "Can we move \u0060Vector2\u0060, \u0060Vector3\u0060, \u0060Vector4\u0060 to corlib? It seems weird to add one more dumping ground for extension methods. Another benefit is that we\u0027d end up with all intrinsically understood types to be corlib then.",
        "TimeCode": 55190000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29780,
          "Title": "Add new overloads with ReadOnlySpan to System.Net.NetworkInformation.PhysicalAddress ",
          "Author": "iSazonov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-18T06:39:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-10-22T00:00:00-07:00",
        "FeedbackId": "545105286",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29780#issuecomment-545105286",
        "FeedbackMarkdown": "We should also have \u0060string\u0060-based \u0060TryParse\u0060 method. We should also name the \u0060out\u0060 parameter \u0060value\u0060. Other than that, looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.NetworkInformation\r\n{\r\n    public class PhysicalAddress\r\n    {\r\n        public static bool TryParse(string address, out PhysicalAddress value);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E address, out PhysicalAddress value);\r\n        public static PhysicalAddress Parse(ReadOnlySpan\u003Cchar\u003E address);\r\n        // Existing\r\n        // public static PhysicalAddress Parse(string address);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59510000000,
        "Apis": [
          "M:PhysicalAddress.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:PhysicalAddress.TryParse(ReadOnlySpan\u003Cchar\u003E,out PhysicalAddress)",
          "M:PhysicalAddress.TryParse(string,out PhysicalAddress)",
          "T:PhysicalAddress"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "6NLJ1csBw14",
      "StartDateTime": "2019-11-12T10:05:42.319-08:00",
      "EndDateTime": "2019-11-12T12:00:36-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6NLJ1csBw14/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 29660,
          "Title": "HMAC-based Extract-and-Expand Key Derivation Function (HKDF)",
          "Author": "cocowalla",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-05-11T14:45:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26147",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553037689",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/29660#issuecomment-553037689",
        "FeedbackMarkdown": "* ~~\u0060Expand\u0060. We should align the optionality of the \u0060info\u0060 parameter between the span version and the byte array version.~~\r\n    - This might cause ambiguity. We decided that optionality is omitted from the span versions\r\n    - However, we should align the order to \u0060outputLength\u0060 and \u0060output\u0060. We should swap \u0060output\u0060 and \u0060info\u0060 in the span-based version.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public static class HKDF\r\n    {\r\n        public static byte[] Extract(HashAlgorithmName hashAlgorithmName, byte[] ikm, byte[] salt = null);\r\n        public static int Extract(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E ikm, ReadOnlySpan\u003Cbyte\u003E salt, Span\u003Cbyte\u003E prk);\r\n\r\n        public static byte[] Expand(HashAlgorithmName hashAlgorithmName, byte[] prk, int outputLength, byte[] info = null);\r\n        public static void Expand(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E prk, Span\u003Cbyte\u003E output, ReadOnlySpan\u003Cbyte\u003E info);\r\n\r\n        public static byte[] DeriveKey(HashAlgorithmName hashAlgorithmName, byte[] ikm, int outputLength, byte[] salt = null, byte[] info = null);\r\n        public static void DeriveKey(HashAlgorithmName hashAlgorithmName, ReadOnlySpan\u003Cbyte\u003E ikm, Span\u003Cbyte\u003E output, ReadOnlySpan\u003Cbyte\u003E salt, ReadOnlySpan\u003Cbyte\u003E info);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HKDF.DeriveKey(HashAlgorithmName,byte[],int,byte[],byte[])",
          "M:HKDF.DeriveKey(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HKDF.Expand(HashAlgorithmName,byte[],int,byte[])",
          "M:HKDF.Expand(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HKDF.Extract(HashAlgorithmName,byte[],byte[])",
          "M:HKDF.Extract(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "T:HKDF"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 32615,
          "Title": "Add cancellation overloads on HttpClient and HttpContent",
          "Author": "baal2000",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-04T14:38:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/916",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553050411",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/32615#issuecomment-553050411",
        "FeedbackMarkdown": "* Looks good, but optionality is pointless because the overload without the token already exists\r\n* Name of methods on \u0060HttpContent\u0060 should be \u0060ReadAsXxx\u0060\r\n* Return types needs fixing up\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpClient\r\n{\r\n    // New APIs\r\n\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    public Task\u003CStream\u003E GetStreamAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003CStream\u003E GetStreamAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    public Task\u003Cstring\u003E GetStringAsync(string requestUri, CancellationToken cancellationToken);\r\n    public Task\u003Cstring\u003E GetStringAsync(Uri requestUri, CancellationToken cancellationToken);\r\n\r\n    // Existing APIs\r\n\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(string requestUri);\r\n    public Task\u003Cbyte[]\u003E GetByteArrayAsync(Uri requestUri);\r\n\r\n    public Task\u003CStream\u003E GetStreamAsync(string requestUri);\r\n    public Task\u003CStream\u003E GetStreamAsync(Uri requestUri);\r\n\r\n    public Task\u003Cstring\u003E GetStringAsync(string requestUri);\r\n    public Task\u003Cstring\u003E GetStringAsync(Uri requestUri);\r\n}\r\n\r\npartial class HttpContent\r\n{\r\n    // New APIs\r\n\r\n    public Task\u003Cbyte[]\u003E ReadAsByteArrayAsync(CancellationToken cancellationToken);\r\n    public Task\u003CStream\u003E ReadAsStreamAsync(CancellationToken cancellationToken);\r\n    public Task\u003Cstring\u003E ReadAsStringAsync(CancellationToken cancellationToken);\r\n\r\n    // Existing APIs\r\n\r\n    public Task\u003Cbyte[]\u003E ReadAsByteArrayAsync();\r\n    public Task\u003CStream\u003E ReadAsStreamAsync();\r\n    public Task\u003Cstring\u003E ReadAsStringAsync();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14240000000,
        "Apis": [
          "M:HttpClient.GetByteArrayAsync(string,CancellationToken)",
          "M:HttpClient.GetByteArrayAsync(string)",
          "M:HttpClient.GetByteArrayAsync(Uri,CancellationToken)",
          "M:HttpClient.GetByteArrayAsync(Uri)",
          "M:HttpClient.GetStreamAsync(string,CancellationToken)",
          "M:HttpClient.GetStreamAsync(string)",
          "M:HttpClient.GetStreamAsync(Uri,CancellationToken)",
          "M:HttpClient.GetStreamAsync(Uri)",
          "M:HttpClient.GetStringAsync(string,CancellationToken)",
          "M:HttpClient.GetStringAsync(string)",
          "M:HttpClient.GetStringAsync(Uri,CancellationToken)",
          "M:HttpClient.GetStringAsync(Uri)",
          "M:HttpContent.ReadAsByteArrayAsync()",
          "M:HttpContent.ReadAsByteArrayAsync(CancellationToken)",
          "M:HttpContent.ReadAsStreamAsync()",
          "M:HttpContent.ReadAsStreamAsync(CancellationToken)",
          "M:HttpContent.ReadAsStringAsync()",
          "M:HttpContent.ReadAsStringAsync(CancellationToken)",
          "T:HttpClient",
          "T:HttpContent"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33006,
          "Title": "Add List\u003CT\u003E.CopyTo(Span\u003CT\u003E) overloads",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-24T16:19:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27721",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553078596",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33006#issuecomment-553078596",
        "FeedbackMarkdown": "Wow, that took quoit a bit \uD83D\uDE04 \r\n\r\n* Makes sense. We should just make sure that \u0060List\u003CT\u003E.CopyTo(someInt, someArray, anotherInt)\u0060 doesn\u0027t magically bind to the span version.\r\n    - While not a breaking having the third parameter having different behavior is bad (\u0060arrayIndex\u0060 vs. \u0060count\u0060)\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class List\u003CT\u003E\r\n{\r\n    // public void CopyTo(int index, T[] array, int arrayIndex, int count);\r\n    // public void CopyTo(T[] array, int arrayIndex);\r\n    // public void CopyTo(T[] array);\r\n\r\n    public void CopyTo(Span\u003CT\u003E destination);\r\n    public void CopyTo(int sourceIndex, int count, Span\u003CT\u003E destination);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24290000000,
        "Apis": [
          "M:List\u003CT\u003E.CopyTo(int,int,Span\u003CT\u003E)",
          "M:List\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "T:List\u003CT\u003E"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33543,
          "Title": "Expose the match length when using String.IndexOf in culture specific mode",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-16T13:03:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27935",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553082487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33543#issuecomment-553082487",
        "FeedbackMarkdown": "@GrabYourPitchforks mentioned that he\u0027s planning on addressing this issue in UTF8 string. He\u0027s thinking of exposing something like \u0060TryFind\u0060 that outputs a \u0060Range\u0060. We should make sure the work aligns.",
        "TimeCode": 53490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33701,
          "Title": "Proposal: Hide Thread.VolatileRead and Thread.VolatileWrite",
          "Author": "carlreinke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-27T06:01:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27997",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553086736",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33701#issuecomment-553086736",
        "FeedbackMarkdown": "* This seems like a good candidate for a code fixer that replaces the call site.\r\n* Usage of these APIs is low.\r\n* We should consider this API in our plan for obsoletion.\r\n* Hiding these APIs seems fine.",
        "TimeCode": 58410000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36068,
          "Title": "ComputeHash Async required",
          "Author": "mgardi85",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-15T04:23:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28978",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-12T00:00:00-08:00",
        "FeedbackId": "553088815",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36068#issuecomment-553088815",
        "FeedbackMarkdown": "* Makes sense. We shouldn\u0027t make the API virtual though because it just does an async read and then forwards to the existing sync API\r\n* Without \u0060virtual\u0060, we don\u0027t need \u0060HashCoreAsync\u0060\r\n\r\n\r\n\u0060\u0060\u0060C#\r\npublic class HashAlgorithm\r\n{\r\n    public Task\u003Cbyte[]\u003E ComputeHashAsync(Stream inputStream, CancellationToken cancellationToken = default);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64910000000,
        "Apis": [
          "M:HashAlgorithm.ComputeHashAsync(Stream,CancellationToken)",
          "T:HashAlgorithm"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "b509D73mmGc",
      "StartDateTime": "2019-11-26T10:06:54.661-08:00",
      "EndDateTime": "2019-11-26T12:03:51-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/b509D73mmGc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 24977,
          "Title": "Add asynchronous overload of WindowsIdentity.RunImpersonated ",
          "Author": "Tratcher",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-31T18:37:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24009",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558756052",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/24977#issuecomment-558756052",
        "FeedbackMarkdown": "* These APIs can be simply implemented over the existing one, thanks for generics.\r\n* However, it\u0027s not obvious that is in fact supported. Adding explicit overload that are named with the \u0060Async\u0060 suffix would make sense\r\n* We considered adding a cancellation token, but given callers likely have to allocate a closure anyway, this doesn\u0027t save anything and impersonation is already expensive.\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Security.Principal\r\n{\r\n    public partial class WindowsIdentity\r\n    {\r\n        public static Task\u003CT\u003E RunImpersonatedAsync\u003CT\u003E(SafeAccessTokenHandle safeAccessTokenHandle, Func\u003CTask\u003CT\u003E\u003E func)\r\n            =\u003E RunImpersonated(safeAccessTokenHandle, func);\r\n\r\n        public static Task RunImpersonatedAsync(SafeAccessTokenHandle safeAccessTokenHandle, Func\u003CTask\u003E func)\r\n            =\u003E RunImpersonated(safeAccessTokenHandle, func);    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:WindowsIdentity.RunImpersonatedAsync(SafeAccessTokenHandle,Func\u003CTask\u003E)",
          "M:WindowsIdentity.RunImpersonatedAsync\u003CT\u003E(SafeAccessTokenHandle,Func\u003CTask\u003CT\u003E\u003E)",
          "T:WindowsIdentity"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 27643,
          "Title": "Consider Socket.OSSupportsUnixDomainSockets property",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-02T04:15:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/863",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558760298",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/27643#issuecomment-558760298",
        "FeedbackMarkdown": "* Some version of Windows 10 supports Unix domain sockets; having a capability API to check this without having to know the exact OS version\r\n* Only concern is that there are more capability APIs we might have to expose in the future. It\u0027s debatable whether a Boolean properties on this type are the correct pattern, but it seems consistent with prior art and domain sockets are reasonably common.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        public static bool OSSupportsUnixDomainSockets { get; }\r\n        // Existing APIs\r\n        // public static bool OSSupportsIPv4 { get; }\r\n        // public static bool OSSupportsIPv6 { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7500000000,
        "Apis": [
          "P:Socket.OSSupportsUnixDomainSockets",
          "T:Socket"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 30852,
          "Title": "System.Threading.Channels : Expose Channel.EstimatedCount",
          "Author": "mgravell",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-05T21:08:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26706",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Channels",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558762980",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/30852#issuecomment-558762980",
        "FeedbackMarkdown": "* We considered naming the property with \u0060EstimatedCount\u0060 but that seems overkill because you never get an exact count unless you freeze the world, but that\u0027s the nature of concurrent APIs.\r\n* We can\u0027t make the API abstract, but most of us believe that the API guideline is to use the Tester-Doer pattern (capability API \u002B API).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Channels\r\n{\r\n    public abstract partial class ChannelReader\u003CT\u003E\r\n    {\r\n        public virtual bool CanCount =\u003E false;\r\n        public virtual int Count { get; }\r\n    }\r\n    public abstract partial class ChannelWriter\u003CT\u003E\r\n    {\r\n        public virtual bool CanCount =\u003E false;\r\n        public virtual int Count { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14160000000,
        "Apis": [
          "P:ChannelReader\u003CT\u003E.CanCount",
          "P:ChannelReader\u003CT\u003E.Count",
          "P:ChannelWriter\u003CT\u003E.CanCount",
          "P:ChannelWriter\u003CT\u003E.Count",
          "T:ChannelReader\u003CT\u003E",
          "T:ChannelWriter\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 42684,
          "Title": "Support Rfc3279 signature format for DSA and EcDSA",
          "Author": "krwq",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-22T21:34:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31548",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558782564",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/42684#issuecomment-558782564",
        "FeedbackMarkdown": "* The APIs cannot be resumed, thus no \u0060OperationStatus\u0060 or \u0060bytesConsumed\u0060 outputs\r\n* The naming is slightly different between \u0060DSA\u0060 and \u0060ECDsa\u0060 but this mirrors existing conventions\r\n* \u0060out\u0060 should go last\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Security.Cryptography\r\n{\r\n    public enum DSASignatureFormat\r\n    {\r\n        IeeeP1363FixedFieldConcatenation,\r\n        Rfc3279DerSequence\r\n    }\r\n\r\n    public abstract partial class DSA : AsymmetricAlgorithm\r\n    {\r\n        public byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool TrySignData(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignDataCore(ReadOnlySpan\u003Cbyte\u003E data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n\r\n        public byte[] CreateSignature(byte[] rgbHash, DSASignatureFormat signatureFormat);\r\n        public bool TryCreateSignature(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] CreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TryCreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifySignature(byte[] rgbHash, byte[] rgbSignature, DSASignatureFormat signatureFormat);\r\n        public bool VerifySignature(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifySignatureCore(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n\r\n        public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);\r\n    }\r\n\r\n    public abstract partial class ECDsa : AsymmetricAlgorithm\r\n    {\r\n        public byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool TrySignData(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignDataCore(ReadOnlySpan\u003Cbyte\u003E data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual byte[] SignDataCore(Stream data, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cbyte\u003E destination, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        public bool VerifyData(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyDataCore(Stream data, ReadOnlySpan\u003Cbyte\u003E signature, HashAlgorithmName hashAlgorithm, DSASignatureFormat signatureFormat);\r\n\r\n        public byte[] SignHash(byte[] hash, DSASignatureFormat signatureFormat);\r\n        public bool TrySignHash(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n        protected virtual byte[] SignHashCore(ReadOnlySpan\u003Cbyte\u003E hash, DSASignatureFormat signatureFormat);\r\n        protected virtual bool TrySignHashCore(ReadOnlySpan\u003Cbyte\u003E hash, Span\u003Cbyte\u003E destination, DSASignatureFormat signatureFormat, out int bytesWritten);\r\n\r\n        public bool VerifyHash(byte[] hash, byte[] signature, DSASignatureFormat signatureFormat);\r\n        public bool VerifyHash(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n        protected virtual bool VerifyHashCore(ReadOnlySpan\u003Cbyte\u003E hash, ReadOnlySpan\u003Cbyte\u003E signature, DSASignatureFormat signatureFormat);\r\n\r\n        public int GetMaxSignatureSize(DSASignatureFormat signatureFormat);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 36740000000,
        "Apis": [
          "F:DSASignatureFormat.IeeeP1363FixedFieldConcatenation",
          "F:DSASignatureFormat.Rfc3279DerSequence",
          "M:DSA.CreateSignature(byte[],DSASignatureFormat)",
          "M:DSA.CreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:DSA.GetMaxSignatureSize(DSASignatureFormat)",
          "M:DSA.SignData(byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignData(byte[],int,int,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignData(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignDataCore(ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.SignDataCore(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.TryCreateSignature(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:DSA.TryCreateSignatureCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:DSA.TrySignData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:DSA.TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:DSA.VerifyData(byte[],byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(byte[],int,int,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyData(Stream,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifyDataCore(Stream,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:DSA.VerifySignature(byte[],byte[],DSASignatureFormat)",
          "M:DSA.VerifySignature(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:DSA.VerifySignatureCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.GetMaxSignatureSize(DSASignatureFormat)",
          "M:ECDsa.SignData(byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignData(byte[],int,int,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignData(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignDataCore(ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignDataCore(Stream,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.SignHash(byte[],DSASignatureFormat)",
          "M:ECDsa.SignHashCore(ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.TrySignData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignDataCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:ECDsa.TrySignHashCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,DSASignatureFormat,out int)",
          "M:ECDsa.VerifyData(byte[],byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(byte[],int,int,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyData(Stream,byte[],HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyDataCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyDataCore(Stream,ReadOnlySpan\u003Cbyte\u003E,HashAlgorithmName,DSASignatureFormat)",
          "M:ECDsa.VerifyHash(byte[],byte[],DSASignatureFormat)",
          "M:ECDsa.VerifyHash(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "M:ECDsa.VerifyHashCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,DSASignatureFormat)",
          "T:DSA",
          "T:DSASignatureFormat",
          "T:ECDsa"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33566,
          "Title": "Consider exposing a HWIntrinsic that allows efficient loading, regardless of encoding.",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-17T17:45:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/954",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "untriaged",
              "Color": "fbca04",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-11-26T00:00:00-08:00",
        "FeedbackId": "558793376",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33566#issuecomment-558793376",
        "FeedbackMarkdown": "* \u0060LoadAlignedVector128Unsafe\u0060 will throw an \u0060AccessViolationException\u0060 when optimizations are disabled when the data isn\u0027t aligned. When optimizations are on, it depends on the hardware. On newer hardware, the access will work but be slower. Older hardware will AV.\r\n* We should include the word \u0060Aligned\u0060 in the API\r\n* In general, \u0060Unsafe\u0060 should be a prefix, rather than a suffix (to make sure it pops) but to be consistent with other APIs we\u0027ll go with a suffix here.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public partial abstract class Sse\r\n    {\r\n        // New APIs:\r\n        public unsafe Vector128\u003Cfloat\u003E LoadAlignedVector128Unsafe(float* address);\r\n\r\n        // Existing APIs:\r\n        // public unsafe Vector128\u003Cfloat\u003E LoadVector128(float* address);\r\n        // public unsafe Vector128\u003Cfloat\u003E LoadAlignedVector128(float* address);\r\n    }\r\n\r\n    public partial abstract class Sse2\r\n    {\r\n        // New APIs:\r\n        public unsafe Vector128\u003Cdouble\u003E LoadAlignedVector128Unsafe(double* address);\r\n        public unsafe Vector128\u003Cbyte\u003E LoadAlignedVector128Unsafe(byte* address);\r\n        public unsafe Vector128\u003Csbyte\u003E LoadAlignedVector128Unsafe(sbyte* address);\r\n        public unsafe Vector128\u003Cshort\u003E LoadAlignedVector128Unsafe(short* address);\r\n        public unsafe Vector128\u003Cushort\u003E LoadAlignedVector128Unsafe(ushort* address);\r\n        public unsafe Vector128\u003Cint\u003E LoadAlignedVector128Unsafe(int* address);\r\n        public unsafe Vector128\u003Cuint\u003E LoadAlignedVector128Unsafe(uint* address);\r\n        public unsafe Vector128\u003Clong\u003E LoadAlignedVector128Unsafe(long* address);\r\n        public unsafe Vector128\u003Culong\u003E LoadAlignedVector128Unsafe(ulong* address);\r\n\r\n        // Existing APIs:\r\n        // public unsafe Vector128\u003Cdouble\u003E LoadVector128(double* address);\r\n        // public unsafe Vector128\u003Cbyte\u003E LoadVector128(byte* address);\r\n        // public unsafe Vector128\u003Csbyte\u003E LoadVector128(sbyte* address);\r\n        // public unsafe Vector128\u003Cshort\u003E LoadVector128(short* address);\r\n        // public unsafe Vector128\u003Cushort\u003E LoadVector128(ushort* address);\r\n        // public unsafe Vector128\u003Cint\u003E LoadVector128(int* address);\r\n        // public unsafe Vector128\u003Cuint\u003E LoadVector128(uint* address);\r\n        // public unsafe Vector128\u003Clong\u003E LoadVector128(long* address);\r\n        // public unsafe Vector128\u003Culong\u003E LoadVector128(ulong* address);\r\n        //\r\n        // public unsafe Vector128\u003Cdouble\u003E LoadAlignedVector128(double* address);\r\n        // public unsafe Vector128\u003Cbyte\u003E LoadAlignedVector128(byte* address);\r\n        // public unsafe Vector128\u003Csbyte\u003E LoadAlignedVector128(sbyte* address);\r\n        // public unsafe Vector128\u003Cshort\u003E LoadAlignedVector128(short* address);\r\n        // public unsafe Vector128\u003Cushort\u003E LoadAlignedVector128(ushort* address);\r\n        // public unsafe Vector128\u003Cint\u003E LoadAlignedVector128(int* address);\r\n        // public unsafe Vector128\u003Cuint\u003E LoadAlignedVector128(uint* address);\r\n        // public unsafe Vector128\u003Clong\u003E LoadAlignedVector128(long* address);\r\n        // public unsafe Vector128\u003Culong\u003E LoadAlignedVector128(ulong* address);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48660000000,
        "Apis": [
          "M:Sse.LoadAlignedVector128Unsafe(float*)",
          "M:Sse2.LoadAlignedVector128Unsafe(byte*)",
          "M:Sse2.LoadAlignedVector128Unsafe(double*)",
          "M:Sse2.LoadAlignedVector128Unsafe(int*)",
          "M:Sse2.LoadAlignedVector128Unsafe(long*)",
          "M:Sse2.LoadAlignedVector128Unsafe(sbyte*)",
          "M:Sse2.LoadAlignedVector128Unsafe(short*)",
          "M:Sse2.LoadAlignedVector128Unsafe(uint*)",
          "M:Sse2.LoadAlignedVector128Unsafe(ulong*)",
          "M:Sse2.LoadAlignedVector128Unsafe(ushort*)",
          "T:Sse",
          "T:Sse2"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "zTzY7iL34Hg",
      "StartDateTime": "2019-12-10T10:05:25.574-08:00",
      "EndDateTime": "2019-12-10T11:59:02-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/zTzY7iL34Hg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 576,
          "Title": "More cancellation overloads for HttpContent",
          "Author": "MihaZupan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-05T17:36:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/576",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564164757",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/576#issuecomment-564164757",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\npartial class HttpContent\r\n{\r\n    protected virtual Task\u003CStream\u003E CreateContentReadStreamAsync(); // Exists\r\n    protected virtual Task\u003CStream\u003E CreateContentReadStreamAsync(CancellationToken cancellationToken);\r\n\r\n    public Task CopyToAsync(Stream stream); // Exists\r\n    public Task CopyToAsync(Stream stream, TransportContext context); // Exists\r\n    public Task CopyToAsync(Stream stream, CancellationToken cancellationToken);\r\n    public Task CopyToAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpContent.CopyToAsync(Stream,CancellationToken)",
          "M:HttpContent.CopyToAsync(Stream,TransportContext,CancellationToken)",
          "M:HttpContent.CopyToAsync(Stream,TransportContext)",
          "M:HttpContent.CopyToAsync(Stream)",
          "M:HttpContent.CreateContentReadStreamAsync()",
          "M:HttpContent.CreateContentReadStreamAsync(CancellationToken)",
          "T:HttpContent"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 33791,
          "Title": "Option to allow HttpClient to follow HTTPS -\u003E HTTP redirects",
          "Author": "martin-heralecky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-01T22:05:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28039",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564169859",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/33791#issuecomment-564169859",
        "FeedbackMarkdown": "This needs work:\r\n\r\n* It\u0027s a dangerous API; the name seems OK, although we normally use the \u0060Unsafe\u0060 prefix.\r\n* We wonder whether instead of simple bool this should be callback that takes at least the URL or even the request message and return true whether it should be redirected or not.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler\r\n    {\r\n        public bool DangerousAllowHttpsToHttpRedirection { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8450000000,
        "Apis": [
          "P:SocketsHttpHandler.DangerousAllowHttpsToHttpRedirection",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34019,
          "Title": "Add ImmutableHashSet\u003CT\u003E.Builder.TryGetValue",
          "Author": "GeorgeAlexandria",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-12T13:08:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28160",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564172216",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34019#issuecomment-564172216",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\nHowever, we should review the API surface of all immutable types and make sure that the API surface of the builder is logically equivalent.\r\n\r\n@GeorgeAlexandria / @safern would one of you be willing to do that?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Immutable\r\n{\r\n    public partial class ImmutableHashSet\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        {\r\n            public bool TryGetValue(T equalValue, out T actualValue);\r\n        }\r\n    }\r\n\r\n    public partial class ImmutableSortedSet\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        {\r\n            public bool TryGetValue(T equalValue, out T actualValue);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15520000000,
        "Apis": [
          "M:ImmutableHashSet\u003CT\u003E.Builder.TryGetValue(T,out T)",
          "M:ImmutableSortedSet\u003CT\u003E.Builder.TryGetValue(T,out T)",
          "T:ImmutableHashSet\u003CT\u003E",
          "T:ImmutableHashSet\u003CT\u003E.Builder",
          "T:ImmutableSortedSet\u003CT\u003E",
          "T:ImmutableSortedSet\u003CT\u003E.Builder"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34144,
          "Title": "Create APIs to deal with processing ASCII text (as bytes)",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-18T18:15:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28230",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564176989",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34144#issuecomment-564176989",
        "FeedbackMarkdown": "Looks good but needs work:\r\n\r\n* We didn\u0027t like the name \u0060AsciiUtility\u0060\r\n* We felt the type should be in \u0060System.Buffers.Text\u0060 as that\u0027s the home for low-level span-based APIs for specific encodings\r\n* We should add other operations, such as:\r\n    - \u0060GetHashCode\u0060\r\n    - \u0060Compare\u0060\r\n    - ...\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Text\r\n{\r\n   public static class Ascii\r\n   {\r\n      public static bool EqualsOrdinalIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n      public static int ToLowerInvariant(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n      public static int ToUpperInvariant(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n      public static void ToLowerInvariantInPlace(Span\u003Cbyte\u003E buffer);\r\n      public static void ToUpperInvariantInPlace(Span\u003Cbyte\u003E buffer);\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19020000000,
        "Apis": [
          "M:Ascii.EqualsOrdinalIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInvariant(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInvariantInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInvariant(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInvariantInPlace(Span\u003Cbyte\u003E)",
          "T:Ascii"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34619,
          "Title": "Proposal: Add an atomic ToArray \u002B Clear method to ConcurrentDictionary\u003CTKey, TValue\u003E",
          "Author": "smourier",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-16T10:27:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28434",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564182556",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34619#issuecomment-564182556",
        "FeedbackMarkdown": "Maybe we don\u0027t understand the scenario but as stated it doesn\u0027t make sense to us:\r\n\r\n1. In order to be safe, dispose needs to stop any party that adds to the dictionary\r\n2. Once that\u0027s done, you can just drain the dictionary\r\n\r\n@stephentoub, any other thoughts?",
        "TimeCode": 26160000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 34689,
          "Title": "WaitForExitAsync for System.Diagnostics.Process",
          "Author": "MattKotsenas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-01-19T00:23:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28458",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564185885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/34689#issuecomment-564185885",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Process\r\n    {\r\n        public Task WaitForExitAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34170000000,
        "Apis": [
          "M:Process.WaitForExitAsync(CancellationToken)",
          "T:Process"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35400,
          "Title": "Implement IBufferWrite\u003Cbyte\u003E on MemoryStream",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-18T23:07:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28719",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564205625",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35400#issuecomment-564205625",
        "FeedbackMarkdown": "A couple of questions:\r\n\r\n* Why do you need it on \u0060MemoryStream\u0060? Why is \u0060ArrayBufferWriter\u003Cbyte\u003E\u0060 not sufficient for your scenarios?\r\n* Do you actually need an \u0060IBufferWriter\u003Cbyte\u003E\u0060 that is also a stream?\r\n* Any objection to us creating an allocation-free method on a stream type that returns an \u0060IBufferWriter\u003Cbyte\u003E\u0060?",
        "TimeCode": 39260000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35410,
          "Title": "Change NetworkStream.Socket property from protected to public",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-19T14:51:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28723",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564210981",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35410#issuecomment-564210981",
        "FeedbackMarkdown": "Seems fine. The only question is: @scalablecory mentioned that we might want to use \u0060NetworkStream\u0060 for non-socket based streams, e.g. QUIC. What would happen then?\r\n\r\n\u003E \u0060Socket\u0060 property is protected, but not virtual, which means we should be able to just change its visibility.\r\n\r\nThat\u0027s correct and we\u0027ve done this in the past.",
        "TimeCode": 49140000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35791,
          "Title": "Add Single and Double overloads to BinaryPrimitives",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-05T16:57:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2365",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564214440",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35791#issuecomment-564214440",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* Should we also add these methods for parity?\r\n    - \u0060ReverseEndianness(float)\u0060\r\n    - \u0060ReverseEndianness(double)\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Binary\r\n{\r\n    public static class BinaryPrimitives\r\n    {\r\n        public static float ReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static float ReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static double ReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static double ReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n\r\n        public static bool TryReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out float value);\r\n        public static bool TryReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out float value);\r\n        public static bool TryReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out double value);\r\n        public static bool TryReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E buffer, out double value);\r\n\r\n        public static bool TryWriteSingleBigEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static bool TryWriteSingleLittleEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static bool TryWriteDoubleBigEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n        public static bool TryWriteDoubleLittleEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n\r\n        public static void WriteSingleBigEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static void WriteSingleLittleEndian(System.Span\u003Cbyte\u003E destination, float value);\r\n        public static void WriteDoubleBigEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n        public static void WriteDoubleLittleEndian(System.Span\u003Cbyte\u003E destination, double value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 56400000000,
        "Apis": [
          "M:BinaryPrimitives.ReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.TryReadDoubleBigEndian(ReadOnlySpan\u003Cbyte\u003E,out double)",
          "M:BinaryPrimitives.TryReadDoubleLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out double)",
          "M:BinaryPrimitives.TryReadSingleBigEndian(ReadOnlySpan\u003Cbyte\u003E,out float)",
          "M:BinaryPrimitives.TryReadSingleLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out float)",
          "M:BinaryPrimitives.TryWriteDoubleBigEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.TryWriteDoubleLittleEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.TryWriteSingleBigEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.TryWriteSingleLittleEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.WriteDoubleBigEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.WriteDoubleLittleEndian(System.Span\u003Cbyte\u003E,double)",
          "M:BinaryPrimitives.WriteSingleBigEndian(System.Span\u003Cbyte\u003E,float)",
          "M:BinaryPrimitives.WriteSingleLittleEndian(System.Span\u003Cbyte\u003E,float)",
          "T:BinaryPrimitives"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 35861,
          "Title": "add Span overloads for Socket datagram functions",
          "Author": "wfurt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-07T18:09:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/938",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-10T00:00:00-08:00",
        "FeedbackId": "564217357",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/35861#issuecomment-564217357",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* However, should we stop adding async methods as extension and just make them proper public instance methods?\r\n* In fact we may want to hide the entire \u0060SocketTaskExtensions\u0060 because it was only used as a bridge pack for .NET Framework.\r\n* Remaining: we should have overloads for the method that take \u0060IList\u003CArraySegment\u003Cbyte\u003E\u003E\u0060 because they are more efficient.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // Open question: consider defaulting SocketFlags to SocketFlags.None to reduce API space? Might challenge IntelliSense.\r\n\r\n    public partial class Socket : IDisposable\r\n    {\r\n        // existing: public int SendTo(byte[] buffer, EndPoint remoteEP);\r\n        public int SendTo(ReadOnlySpan\u003Cbyte\u003E buffer, EndPoint remoteEP);\r\n\r\n        // existing: public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n        public int SendTo(ReadOnlySpan\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n\r\n        // existing: public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP);\r\n        public int ReceiveFrom(Span\u003Cbyte\u003E buffer, ref EndPoint remoteEP);\r\n\r\n        // existing: public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP);\r\n        public int ReceiveFrom(Span\u003Cbyte\u003E buffer, SocketFlags socketFlags, ref EndPoint remoteEP);\r\n    }\r\n\r\n    public static class SocketTaskExtensions\r\n    {\r\n        // existing: public static Task\u003Cint\u003E SendToAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n        public static ValueTask\u003Cint\u003E SendToAsync(this Socket socket, ReadOnlyMemory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003Cint\u003E SendToAsync(this Socket socket, ReadOnlyMemory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\r\n        // existing: public static Task\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public static ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n\r\n        // existing: public static Task\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public static ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n        public static ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(this Socket socket, Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61300000000,
        "Apis": [
          "M:Socket.ReceiveFrom(Span\u003Cbyte\u003E,ref EndPoint)",
          "M:Socket.ReceiveFrom(Span\u003Cbyte\u003E,SocketFlags,ref EndPoint)",
          "M:Socket.SendTo(ReadOnlySpan\u003Cbyte\u003E,EndPoint)",
          "M:Socket.SendTo(ReadOnlySpan\u003Cbyte\u003E,SocketFlags,EndPoint)",
          "M:SocketTaskExtensions.ReceiveFromAsync(this Socket,Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveFromAsync(this Socket,Memory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveMessageFromAsync(this Socket,Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ReceiveMessageFromAsync(this Socket,Memory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.SendToAsync(this Socket,ReadOnlyMemory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.SendToAsync(this Socket,ReadOnlyMemory\u003Cbyte\u003E,SocketFlags,EndPoint,CancellationToken)",
          "T:Socket",
          "T:SocketTaskExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "VRTCAkk7wKU",
      "StartDateTime": "2019-12-17T10:05:54.825-08:00",
      "EndDateTime": "2019-12-17T12:05:32-08:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VRTCAkk7wKU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36133,
          "Title": "MemoryMarshal.GetRawArrayData",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-18T23:39:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29003",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-17T00:00:00-08:00",
        "FeedbackId": "566723424",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36133#issuecomment-566723424",
        "FeedbackMarkdown": "We considered this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static class Unsafe\r\n    {\r\n        public static ref T GetRawArrayRef\u003CT\u003E(ref T source);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nbut we\u0027d prefer this:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static ref T GetReference\u003CT\u003E(T[] array);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n(Please not that\u0027s OK because the existing \u0060GetReference\u003CT\u003E()\u0060 method don\u0027t bind for arrays due to an ambiguous match, so the caller had to add a cast.)",
        "TimeCode": 0,
        "Apis": [
          "M:MemoryMarshal.GetReference\u003CT\u003E(T[])",
          "M:Unsafe.GetRawArrayRef\u003CT\u003E(ref T)",
          "T:MemoryMarshal",
          "T:Unsafe"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36348,
          "Title": "API request : CompressionLevel.Highest",
          "Author": "ericstj",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-25T21:05:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1549",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Compression",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2019-12-17T00:00:00-08:00",
        "FeedbackId": "566725990",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36348#issuecomment-566725990",
        "FeedbackMarkdown": "* We prefer \u0060SmallestSize\u0060 to make it more clear what the API does (\u0060Highest\u0060 or \u0060Best\u0060 seem ambiguous with \u0060Optimal\u0060).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Compression\r\n{\r\n    public partial enum CompressionLevel\r\n    {\r\n        SmallestSize\r\n\r\n        // Existing:\r\n        // Fastest,\r\n        // NoCompression,\r\n        // Optimal\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 65490000000,
        "Apis": [
          "F:CompressionLevel.SmallestSize",
          "T:CompressionLevel"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "lSB-ACeetRo",
      "StartDateTime": "2020-01-07T10:04:00-08:00",
      "EndDateTime": "2020-01-07T12:01:31-08:00",
      "Title": ".NET Design Reviews: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/lSB-ACeetRo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36925,
          "Title": "Expose Math.MaxNumber and Math.MinNumber functions that don\u0027t propagate NaN",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-16T16:15:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29279",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571721383",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36925#issuecomment-571721383",
        "FeedbackMarkdown": "* Should we have a wider discussion about putting future APIs on the primitive\r\n  types (\u0060double\u0060, \u0060half\u0060, etc.) instead of the \u0060Math\u0060 / \u0060MathF\u0060 / \u0060MathH\u0060\r\n  classes? Otherwise there\u0027s likely to be an explosion of \u0060Math*\u0060 types and APIs\r\n  on those types.\r\n* If we decide that putting these APIs on the primitive types isn\u0027t worthwhile\r\n  then the proposal as stated here seems viable. There was some discussion on\r\n  whether we should keep the \u0060Number\u0060 name and whether those APIs would be\r\n  discoverable enough, but: (a) these names match what IEEE uses; and (b) it\u0027s\r\n  ok if users keep using the old APIs instead of the new APIs for the majority\r\n  of use cases.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 939,
          "Title": "Add address family specific name resolution to Dns",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-22T21:20:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/939",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571705400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/939#issuecomment-571705400",
        "FeedbackMarkdown": "* Do we have some kind of guarantee that the supported OSes have a \u0022return\r\n  synchronously if you have the relevant data already cached\u0022 behavior? If so,\r\n  then it would make sense for these APIs to return \u0060ValueTask\u003CT\u003E\u0060. Without that\r\n  underlying OS support then we should keep these as \u0060Task\u003CT\u003E\u0060. It also helps\r\n  usability if callers want to maintain their own cache of returned values so\r\n  that they don\u0027t have to rely on the OS\u0027s underlying cache.\r\n* Aside from this, marking _approved_.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 861,
          "Title": "Happy Eyeballs support in Socket.ConnectAsync",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-15T08:16:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/861",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571712410",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/861#issuecomment-571712410",
        "FeedbackMarkdown": "* Take the new parameter and move it to the end of the parameter list of the new\r\n  overload.\r\n* Remove \u0060[Flags]\u0060 from the enum. We can add it later if necessary as long as we\r\n  only have 1 legal value on the enum right now.\r\n* Rename the zero value to _Default_.\r\n* Consider renaming the enum to \u0060ConnectionAlgorithm\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37220,
          "Title": "Add HashSet.AsReadOnly",
          "Author": "vanillajonathan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-26T13:13:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29387",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571732291",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37220#issuecomment-571732291",
        "FeedbackMarkdown": "* What are you actually trying to do here?\r\n* \u0060HashSet\u003CT\u003E\u0060 already implements \u0060IReadOnlyCollection\u003CT\u003E\u0060, so you can cast it\r\n  directly: \u0060IReadOnlyCollection\u003CT\u003E collection = myHashSet;\u0060.\r\n* If you want to create a \u0060ReadOnlyCollection\u003CT\u003E\u0060, it\u0027s one line:\r\n  \u0060ReadOnlyCollection\u003CT\u003E collection = new\r\n  ReadOnlyCollection\u003CT\u003E(myHashSet.ToArray());\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37149,
          "Title": "Proposal: Extension method to get value or default with creation function for Dictionary",
          "Author": "datvm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-24T16:46:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29358",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571729598",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37149#issuecomment-571729598",
        "FeedbackMarkdown": "* This would be a compile-time breaking change because there would be an\r\n  overload resolution conflict if the \u0060null\u0060 literal is provided as the last\r\n  parameter to the extension method.\r\n* Please modify the proposal and reopen if you still have a strong desire \u002B\r\n  justification for this and there\u0027s a solution to working around the breaking\r\n  change.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 37748,
          "Title": "One-shot PEM reader",
          "Author": "owlstead",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-17T14:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29588",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571743250",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/37748#issuecomment-571743250",
        "FeedbackMarkdown": "* Change _dataSize_ and _labelSize_ to have _*Length_ suffixes instead.\r\n * In \u0060TryWrite\u0060, move the _destination_ parameter toward the end of the\r\n   parameter list.\r\n * Rename struct\u0027s _Base64_ property to _Base64Data_. Rename _EncodedByteSize_\r\n   to _DecodedByteSize_.\r\n * Remove the base64-decoding helper method from the ref struct. Callers can use\r\n   the \u0060Convert\u0060 class instead.\r\n * Consider using a normal struct instead of a ref struct and use _Range_\r\n   properties instead of _ROS_ properties. If we do this, then we can get away\r\n   with not _out_ing a \u0060Range\u0060 from the \u0060Find\u0060 method, and instead just put\r\n   _Range location_ on the struct itself.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36133,
          "Title": "MemoryMarshal.GetRawArrayData",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-03-18T23:39:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29003",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571725298",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36133#issuecomment-571725298",
        "FeedbackMarkdown": "* Rename to \u0060GetArrayDataRef\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 36652,
          "Title": "\u0060ExcludeFromCodeCoverageAttribute(string reason)\u0060",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-06T10:27:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29185",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571726362",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/36652#issuecomment-571726362",
        "FeedbackMarkdown": "* Don\u0027t add the new ctor. Instead add a get\u002Bset property \u0060string? Justification\u0060. This mirrors the \u0060SuppressMessageAttribute\u0060 design.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 39555,
          "Title": "Expose CancellationTokenSource.CreateLinkedTokenSource(CancellationToken)",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-16T22:24:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30286",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-07T00:00:00-08:00",
        "FeedbackId": "571746847",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/39555#issuecomment-571746847",
        "FeedbackMarkdown": "* We discussed whether this would be necessary if we had a \u0060params ROS\u003CT\u003E\u0060\r\n  overload. But there\u0027s not even 100% consensus that we want to add that\r\n  overload, and the proposal in this issue has merit on its own regardless.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "dJLmN6u98Z4",
      "StartDateTime": "2020-01-14T10:04:00-08:00",
      "EndDateTime": "2020-01-14T11:57:44-08:00",
      "Title": ".NET Design Reviews: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/dJLmN6u98Z4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 941,
          "Title": "Port \u0060MemoryMappedFileSecurity\u0060 and add extensions for \u0060MemoryMappedFile\u0060",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-08T21:21:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/941",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574306474",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/941#issuecomment-574306474",
        "FeedbackMarkdown": "* We need to know a little more about the scenario. In particular, is the only\r\n  reason the \u0060FileStream\u0060 is accepted in the ctor is so that there\u0027s something\r\n  to dispose at the end of the operation? Can we instead dispose the\r\n  \u0060FileStream\u0060 and the memmapped handle at the same time through some clever ref\r\n  counting mechanism?\r\n* See if there\u0027s perhaps a way to enable this scenario without exposing this\r\n  particular ctor.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40693,
          "Title": "Add TimeSpan.Infinite",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-29T23:42:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30723",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574308350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40693#issuecomment-574308350",
        "FeedbackMarkdown": "This sentinel value would only be special-cased by specific APIs, and in some\r\ncontexts -1 is a perfectly valid value for \u0060TimeSpan\u0060 parameters. This really\r\nshould be a doc issue demonstrating correct use of the existing \u0060Timeout\u0060 API\r\nrather than a public API being added to \u0060TimeSpan\u0060.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 40504,
          "Title": "[System.Runtime.Intrinsics] API suggestion: Introduce an intrinsic all bits set field to Vector intrinsic types",
          "Author": "john-h-k",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-22T14:26:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30659",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574310177",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/40504#issuecomment-574310177",
        "FeedbackMarkdown": "* \u0060AllBitsSet\u0060 seems like a decent name given the scenario.\r\n* Also rename the internal member \u0060Vector\u003CT\u003E.AllOnes\u0060 at the same time so that\r\n  if it does become public in the future we have consistent naming already.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41131,
          "Title": "ExecutionContext.Run\u003CTContext\u003E overloads",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-16T04:27:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30867",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574312085",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41131#issuecomment-574312085",
        "FeedbackMarkdown": "Please match parameter names for the new overloads to parameter names for the existing overloads.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41487,
          "Title": "StringSplitOptions.TrimEntries",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-02T01:29:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31038",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574317661",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41487#issuecomment-574317661",
        "FeedbackMarkdown": "See if there\u0027s any usage of \u0060Split\u0060 followed by \u0060TrimStart\u0060 and \u0060TrimEnd\u0060 as\r\nopposed to just \u0060Trim\u0060. That\u0027ll inform us on whether these enum values being\r\nadded are sufficient for common use cases.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 41783,
          "Title": "Unsafe.NullRef, IsNullRef",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-15T13:09:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31170",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574325067",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/41783#issuecomment-574325067",
        "FeedbackMarkdown": "This really should be \u0060in\u0060 from a purity perspective, but should sit down with\r\nlanguage folks to figure out exactly what pitfalls might exist and whether the\r\nlanguage itself could be evolved to address any concerns. I\u0027ll punt this back to\r\nmyself.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 42372,
          "Title": "One-shot AES CBC and ECB",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-04T20:57:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2406",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574334307",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/42372#issuecomment-574334307",
        "FeedbackMarkdown": "* CBC padding mode should default to PKCS7, ECB padding modes should be\r\n  non-default (require explicit value at call site). For all methods, move\r\n  non-_out_ parameters before _out_ parameters.\r\n* @bartonjs - please document whether the newly introduced virtual members would\r\n  ever mutate the underlying instance (changing block mode or padding mode) or\r\n  throw.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 38395,
          "Title": "Ctor of sorted collection classes should support IReadOnlyDictionary or IEnumerable",
          "Author": "craigwardman",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-10T11:19:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29829",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574338733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/38395#issuecomment-574338733",
        "FeedbackMarkdown": "We can\u0027t add the desired ctor because it would conflict with the\r\n\u0060.ctor(IDictionary\u003CTKey, TValue\u003E, ...)\u0060 ctor and would be a compile-time\r\nbreaking change. We might be able to get away with using one of the existing\r\nctors and instead adding a method \u0060AddRange(IEnumerable\u003CKeyValuePair\u003CTKey,\r\nTValue\u003E\u003E)\u0060, so the call site would look like:\r\n\r\n\u0060\u0060\u0060C#\r\nIReadOnlyDictionary\u003CTKey, TValue\u003E myDict = GetDictionary();\r\nvar sortedDictionary = new SortedDictionary\u003CTKey, TValue\u003E(comparer);\r\nsortedDictionary.AddRange(myDict);\r\n\u0060\u0060\u0060\r\n\r\nPerhaps a ctor that takes a capacity would also benefit here, that way the\r\ninstance is already sized appropriately for the data that will be added to it.\r\n\r\nWould this proposed API be sufficient for your scenarios?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1210,
          "Title": "ObjectDisposedException missing constructor with all: objectName, message, innerException",
          "Author": "dmitriyse",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-29T23:04:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1210",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574342594",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1210#issuecomment-574342594",
        "FeedbackMarkdown": "* Per @scalablecory\u0027s comments, what\u0027s the scenario for this? Why not match the\r\n  existing constructors in your own subclassed type?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 836,
          "Title": "Mark Value and HasValue of System.Nullable\u003CT\u003E as readonly",
          "Author": "bernd5",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-13T15:09:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/836",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-14T00:00:00-08:00",
        "FeedbackId": "574346202",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/836#issuecomment-574346202",
        "FeedbackMarkdown": "* It looks like the Roslyn compiler already special-cases this, so perf is\r\n  already in a good way. But we should probably do this anyway for non-Roslyn\r\n  compiler scenarios, and so that the API surface matches the expectation.\r\n* Approved for these APIs specifically:\r\n    - \u0060get_Value\u0060\r\n    - \u0060get_HasValue\u0060\r\n    - \u0060GetValueOrDefault\u0060 (both overloads)",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "keHv3W-2-Q4",
      "StartDateTime": "2020-01-28T10:28:16.778-08:00",
      "EndDateTime": "2020-01-28T11:07:32-08:00",
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/keHv3W-2-Q4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 7864,
          "Title": "Add StringContent ctor providing tighter control over charset",
          "Author": "guardrex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-19T16:57:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17036",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-28T00:00:00-08:00",
        "FeedbackId": "579398933",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/7864#issuecomment-579398933",
        "FeedbackMarkdown": "We believe the correct API is this:\r\n\r\n\u0060\u0060\u0060C#\r\npublic StringContent(string content, MediaTypeHeaderValue mediaType)\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "corefx",
          "Id": 15708,
          "Title": "Is there a function to copy directories?",
          "Author": "akcorp2003",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-02T00:55:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20078",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-01-28T00:00:00-08:00",
        "FeedbackId": "579405459",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/corefx/issues/15708#issuecomment-579405459",
        "FeedbackMarkdown": "We generally have avoided IO APIs with complex policy (such as, cancellation, error handling, recovery, permissions etc). The API shape would work, but we\u0027re concerned about the complexity in implementation and don\u0027t think it\u0027s worth it.",
        "TimeCode": 14370000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "nD5kZ2aXjdM",
      "StartDateTime": "2020-02-04T10:08:00.906-08:00",
      "EndDateTime": "2020-02-04T12:01:03-08:00",
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nD5kZ2aXjdM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30260,
          "Title": "Add an API to perform streaming transcoding",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-15T16:46:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30260",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encoding",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582050875",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30260#issuecomment-582050875",
        "FeedbackMarkdown": "* We\u0027ll likely need this ourselves for the \u0060HttpClient\u0060 extension methods for JSON, so putting it in the BCL seems more reasonable than an ASP.NET/networking specific helper\r\n* Instead of exposing a concrete type, we\u0027d prefer a factory because we\u0027ll likely want to have dedicated implementations for specific encodings in order to speed things up.\r\n* Putting the factory on \u0060Encoding\u0060 seems most sensible because that\u0027s the array based helpers are too\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class Encoding\r\n    {\r\n        public static Stream CreateTranscodingStream(Stream innerStream, Encoding innerStreamEncoding, Encoding outerStreamEncoding, bool leaveOpen = false);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Encoding.CreateTranscodingStream(Stream,Encoding,Encoding,bool)",
          "T:Encoding"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20234,
          "Title": "SetCreationTime, SetLastAccessTime, SetLastWriteTime Should not open a new stream to obtain a SafeFileHandle",
          "Author": "TrabacchinLuigi",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-15T15:06:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20234",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582053400",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20234#issuecomment-582053400",
        "FeedbackMarkdown": "* The scenario makes sense, but defining them as extension methods on \u0060SafeFileHandle\u0060 seems odd\r\n* It seems more logical to define them as overloads to the \u0060string\u0060 based APIs on \u0060File\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n        public static DateTime GetCreationTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastAccessTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastWriteTime(SafeFileHandle fileHandle);\r\n        public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle);\r\n\r\n        public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime);\r\n        public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creatinTimeUtc);\r\n        public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime);\r\n        public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc);\r\n        public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime);\r\n        public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc);\r\n\r\n        // Seems we should be adding support for these too.\r\n        // If we can\u0027t make it work, dropping is fine.\r\n        public static FileAttributes GetAttributes(SafeFileHandle fileHandle);\r\n        public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14140000000,
        "Apis": [
          "M:File.GetAttributes(SafeFileHandle)",
          "M:File.GetCreationTime(SafeFileHandle)",
          "M:File.GetCreationTimeUtc(SafeFileHandle)",
          "M:File.GetLastAccessTime(SafeFileHandle)",
          "M:File.GetLastAccessTimeUtc(SafeFileHandle)",
          "M:File.GetLastWriteTime(SafeFileHandle)",
          "M:File.GetLastWriteTimeUtc(SafeFileHandle)",
          "M:File.SetAttributes(SafeFileHandle,FileAttributes)",
          "M:File.SetCreationTime(SafeFileHandle,DateTime)",
          "M:File.SetCreationTimeUtc(SafeFileHandle,DateTime)",
          "M:File.SetLastAccessTime(SafeFileHandle,DateTime)",
          "M:File.SetLastAccessTimeUtc(SafeFileHandle,DateTime)",
          "M:File.SetLastWriteTime(SafeFileHandle,DateTime)",
          "M:File.SetLastWriteTimeUtc(SafeFileHandle,DateTime)",
          "T:File"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 23819,
          "Title": "Add bit manipulation methods to Interlocked class",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-10-12T00:33:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582059179",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/23819#issuecomment-582059179",
        "FeedbackMarkdown": "* Makes sense, the naming \u0060location1\u0060 matches the existing methods\r\n* We\u0027ll review support for unsigned in a separate issue (#24694)\r\n* @GrabYourPitchforks will file a separate issue for test and clear/reset\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        public static int And(ref int location1, int value);\r\n        public static long And(ref long location1, long value);\r\n        public static int Or(ref int location1, int value);\r\n        public static long Or(ref long location1, long value);\r\n        public static int Xor(ref int location1, int value);\r\n        public static long Xor(ref long location1, long value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17780000000,
        "Apis": [
          "M:Interlocked.And(ref int,int)",
          "M:Interlocked.And(ref long,long)",
          "M:Interlocked.Or(ref int,int)",
          "M:Interlocked.Or(ref long,long)",
          "M:Interlocked.Xor(ref int,int)",
          "M:Interlocked.Xor(ref long,long)",
          "T:Interlocked"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24694,
          "Title": "Interlocked.CompareExchange missing for uint, ulong and (if possible) general structs.",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-17T01:20:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24694",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582063204",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24694#issuecomment-582063204",
        "FeedbackMarkdown": "* Makes sense, we added unsigned for the APIs approved in #23819\r\n* Let\u0027s ignore the generic struct here; this should be a separate proposal\r\n* We should probably add \u0060Interlocked\u0060 support for \u0060nint\u0060 and \u0060nuint\u0060 support on Interlocked. @tannergooding, could you file a tracking item for this?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class Interlocked\r\n    {\r\n        // New proposed APIs, pretty much a carbon copy of the above but unsigned\r\n        // All of these would be marked [CLSCompliant(false)]\r\n\r\n        public static uint Add(ref uint location1, uint value);\r\n        public static ulong Add(ref ulong location1, ulong value);\r\n        public static uint CompareExchange(ref uint location1, uint value, uint comparand);\r\n        public static ulong CompareExchange(ref ulong location1, ulong value, ulong comparand);\r\n        public static UIntPtr CompareExchange(ref UIntPtr location1, UIntPtr value, UIntPtr comparand);\r\n        public static uint Decrement(ref uint location);\r\n        public static ulong Decrement(ref ulong location);\r\n        public static uint Exchange(ref uint location1, uint value);\r\n        public static ulong Exchange(ref ulong location1, ulong value);\r\n        public static UIntPtr Exchange(ref UIntPtr location1, UIntPtr value);\r\n        public static uint Increment(ref uint location);\r\n        public static ulong Increment(ref ulong location);\r\n        public static ulong Read(ref ulong location);\r\n\r\n        // Since these were approved in #23819 we should add them:\r\n        // All of these would be marked [CLSCompliant(false)]\r\n\r\n        public static int And(ref uint location1, uint value);\r\n        public static long And(ref ulong location1, ulong value);\r\n        public static int Or(ref uint location1, uint value);\r\n        public static long Or(ref ulong location1, ulong value);\r\n        public static int Xor(ref uint location1, uint value);\r\n        public static long Xor(ref ulong location1, ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25840000000,
        "Apis": [
          "M:Interlocked.Add(ref uint,uint)",
          "M:Interlocked.Add(ref ulong,ulong)",
          "M:Interlocked.And(ref uint,uint)",
          "M:Interlocked.And(ref ulong,ulong)",
          "M:Interlocked.CompareExchange(ref uint,uint,uint)",
          "M:Interlocked.CompareExchange(ref UIntPtr,UIntPtr,UIntPtr)",
          "M:Interlocked.CompareExchange(ref ulong,ulong,ulong)",
          "M:Interlocked.Decrement(ref uint)",
          "M:Interlocked.Decrement(ref ulong)",
          "M:Interlocked.Exchange(ref uint,uint)",
          "M:Interlocked.Exchange(ref UIntPtr,UIntPtr)",
          "M:Interlocked.Exchange(ref ulong,ulong)",
          "M:Interlocked.Increment(ref uint)",
          "M:Interlocked.Increment(ref ulong)",
          "M:Interlocked.Or(ref uint,uint)",
          "M:Interlocked.Or(ref ulong,ulong)",
          "M:Interlocked.Read(ref ulong)",
          "M:Interlocked.Xor(ref uint,uint)",
          "M:Interlocked.Xor(ref ulong,ulong)",
          "T:Interlocked"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29588,
          "Title": "One-shot PEM reader",
          "Author": "owlstead",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-17T14:10:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29588",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582069797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29588#issuecomment-582069797",
        "FeedbackMarkdown": "* The constructor on \u0060PemFields\u0060 isn\u0027t public to avoid having to validate well-formedness\r\n* Should \u0060PemFields\u0060 implement IEquatable\u003CPemFields\u003E\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public static class PemEncoding\r\n    {\r\n        public static bool TryFind(ReadOnlySpan\u003Cchar\u003E pemData, out PemFields fields);\r\n        public static PemFields Find(ReadOnlySpan\u003Cchar\u003E pemData);\r\n\r\n        public static int GetEncodedSize(int labelLength, int dataLength);\r\n        public static bool TryWrite(ReadOnlySpan\u003Cchar\u003E label, ReadOnlySpan\u003Cbyte\u003E data, Span\u003Cchar\u003E destination, out int charsWritten);\r\n        public static char[] Write(ReadOnlySpan\u003Cchar\u003E label, ReadOnlySpan\u003Cbyte\u003E data);\r\n    }\r\n\r\n    public readonly struct PemFields\r\n    {\r\n        public Range Location { get; }\r\n        public Range Label { get; }\r\n        public Range Base64Data { get; }\r\n        public int DecodedDataLength { get; }\r\n    }\r\n }\r\n \u0060\u0060\u0060",
        "TimeCode": 31310000000,
        "Apis": [
          "M:PemEncoding.Find(ReadOnlySpan\u003Cchar\u003E)",
          "M:PemEncoding.GetEncodedSize(int,int)",
          "M:PemEncoding.TryFind(ReadOnlySpan\u003Cchar\u003E,out PemFields)",
          "M:PemEncoding.TryWrite(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cchar\u003E,out int)",
          "M:PemEncoding.Write(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "P:PemFields.Base64Data",
          "P:PemFields.DecodedDataLength",
          "P:PemFields.Label",
          "P:PemFields.Location",
          "T:PemEncoding",
          "T:PemFields"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24473,
          "Title": "Mark Write7BitEncodedInt and Read7BitEncodedInt as public",
          "Author": "vermorel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-15T19:45:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24473",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582076029",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24473#issuecomment-582076029",
        "FeedbackMarkdown": "* We should reuse the existing methods, which are protected (since the method isn\u0027t virtual, making it public isn\u0027t a breaking change).\r\n* We don\u0027t want to add \u0060BigInteger\u0060 support because reader/writer has no support for \u0060BigInteger\u0060. This should be a separate proposal.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class BinaryReader\r\n    {\r\n        public int Read7BitEncodedInt();\r\n        public long Read7BitEncodedInt64();\r\n    }\r\n    public class BinaryWriter\r\n    {\r\n        public int Write7BitEncodedInt(int value);\r\n        public int Write7BitEncodedInt64(long value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40510000000,
        "Apis": [
          "M:BinaryReader.Read7BitEncodedInt()",
          "M:BinaryReader.Read7BitEncodedInt64()",
          "M:BinaryWriter.Write7BitEncodedInt(int)",
          "M:BinaryWriter.Write7BitEncodedInt64(long)",
          "T:BinaryReader",
          "T:BinaryWriter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27683,
          "Title": "Easy reference equality comparer API",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-20T18:51:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27683",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-04T00:00:00-08:00",
        "FeedbackId": "582080375",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27683#issuecomment-582080375",
        "FeedbackMarkdown": "* Let\u0027s put it in \u0060System.Collections.Generic\u0060 (because \u0060System.Collections\u0060 doesn\u0027t have a \u0060EqualityComparer\u0060 anyway).\r\n* We don\u0027t want to put it on \u0060EqualityComparer\u003CT\u003E\u0060 because it wouldn\u0027t vary by \u0060T\u0060\r\n* Based on Internet search, it seems most folks calls their implementation \u0060ReferenceEqualityComparer\u0060. We considered introducing a non-generic \u0060EqualityComparer\u0060 with a property \u0060ReferenceEquality\u0060 that felt odd. Also, having a dedicated sealed type allows implementations to check whether it\u0027s the special reference equality comparer. The field would have to guarantee that it\u0027s the same instance, which we might not want.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public sealed class ReferenceEqualityComparer : IEqualityComparer, IEqualityComparer\u003Cobject\u003E\r\n    {\r\n        private ReferenceEqualityComparer();\r\n        public static ReferenceEqualityComparer Instance { get; }\r\n\r\n        // Plus inherited members from IEqualityComparer, IEqualityComparer\u003Cobject\u003E\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49350000000,
        "Apis": [
          "M:ReferenceEqualityComparer.ReferenceEqualityComparer()",
          "P:ReferenceEqualityComparer.Instance",
          "T:ReferenceEqualityComparer"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "kGIsqCyWqa0",
      "StartDateTime": "2020-02-11T10:11:53.104-08:00",
      "EndDateTime": "2020-02-11T12:03:15-08:00",
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/kGIsqCyWqa0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 911,
          "Title": "Proposal: HttpRequestException w/ Status Code",
          "Author": "yaakov-h",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-20T11:25:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/911",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584780389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/911#issuecomment-584780389",
        "FeedbackMarkdown": "* Looks good\r\n* At the minimum we\u0027ll need to remove the nullable annotation fromt he first constructor, otherwise passing null as the second argument would be a source breaking change\r\n* However, we concluded we can just remove it.\r\n\r\n\u0060\u0060\u0060C#\r\npublic class HttpRequestException : Exception\r\n{\r\n    // Existing:\r\n    // public HttpRequestException(string message);\r\n    // public HttpRequestException(string message, Exception inner);\r\n\r\n    public HttpRequestException(string message, Exception inner, HttpStatusCode? statusCode);\r\n    public HttpStatusCode? StatusCode { get; }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpRequestException.HttpRequestException(string,Exception,HttpStatusCode?)",
          "P:HttpRequestException.StatusCode",
          "T:HttpRequestException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2043,
          "Title": "Make System.Security.Cryptography.Oid write-once (initializable read-only)",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-22T21:45:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2043",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584786046",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2043#issuecomment-584786046",
        "FeedbackMarkdown": "* Looks good. It\u0027s a runtime breaking change but we believe the value is high and the risk is low (enough)\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class Oid\r\n{\r\n    public string Value\r\n    {\r\n        get =\u003E _value;\r\n        set\r\n        {\r\n            if (_value != null \u0026\u0026 !_value.Equals(value))\r\n                throw new PlatformNotSupportedException(...);\r\n\r\n            _value = value;\r\n        }\r\n    }\r\n\r\n    public string FriendlyName\r\n    {\r\n        get =\u003E _friendlyName ??= LookupFriendlyName(_value);\r\n        set\r\n        {\r\n            if (_friendlyName != null \u0026\u0026 !_friendlyName.Equals(value))\r\n                throw new PlatformNotSupportedException(...);\r\n\r\n            _friendlyName = value;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7300000000,
        "Apis": [
          "P:Oid.FriendlyName",
          "P:Oid.Value",
          "T:Oid"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27935,
          "Title": "Expose the match length when using String.IndexOf in culture specific mode",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-11-16T13:03:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27935",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584799296",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27935#issuecomment-584799296",
        "FeedbackMarkdown": "* We shoulnd\u0027t invent new names for \u0060IndexOf\u0060 and \u0060LastIndexOf\u0060\r\n* While our guidance says we should be adding \u0060string\u0060-based version of the new range returning APIs, we don\u0027t believe they are common enough to be warranted. We can add them later if necessary.\r\n* Given the programming model for \u0060IndexOf\u0060, we decided against using the \u0060Try\u0060-pattern.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial class CompareInfo\r\n    {\r\n        public bool IsPrefix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E prefix, CompareOptions options, out Range match);\r\n        public bool IsSuffix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E suffix, CompareOptions options, out Range match);\r\n        public int IndexOf(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E value, CompareOptions options, out int matchLength);\r\n        public int LastIndexOf(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E value, CompareOptions options, out int matchLength);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14720000000,
        "Apis": [
          "M:CompareInfo.IndexOf(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out int)",
          "M:CompareInfo.IsPrefix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out Range)",
          "M:CompareInfo.IsSuffix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out Range)",
          "M:CompareInfo.LastIndexOf(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions,out int)",
          "T:CompareInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1968,
          "Title": "Incremental Hash, allowing to continue to hash",
          "Author": "Drawaes",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-21T16:57:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1968",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584806878",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1968#issuecomment-584806878",
        "FeedbackMarkdown": "* There don\u0027t seem to be any scenarios for \u0060DuplicateHash\u0060, so let\u0027s remove it for now. If we were to do it, we should probably name it \u0060Clone\u0060 though.\r\n* Rest looks good as proposed.\r\n* We should add a \u0060HashSizeInBytes\u0060 property so that callers don\u0027t have to call \u0060TryGetCurrentHash\u0060 in a loop\r\n* While we\u0027re at it, we should also add overloads for the new \u0060TryGetCurrentHash\u0060 and the existing \u0060TryGetHashAndReset\u0060 to return the length instead of returning a \u0060bool\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class IncrementalHash\r\n    {\r\n        public bool TryGetCurrentHash(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetCurrentHash(Span\u003Cbyte\u003E destination);\r\n        // public bool TryGetHashAndReset(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetHashAndReset(Span\u003Cbyte\u003E destination);\r\n        public byte[] GetCurrentHash();\r\n        public int HashLengthInBytes { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32270000000,
        "Apis": [
          "M:IncrementalHash.GetCurrentHash()",
          "M:IncrementalHash.GetCurrentHash(Span\u003Cbyte\u003E)",
          "M:IncrementalHash.GetHashAndReset(Span\u003Cbyte\u003E)",
          "M:IncrementalHash.TryGetCurrentHash(Span\u003Cbyte\u003E,out int)",
          "P:IncrementalHash.HashLengthInBytes",
          "T:IncrementalHash"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1946,
          "Title": "Async parallel foreach",
          "Author": "tomesendam",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-24T10:18:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1946",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1946#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 42850000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29222,
          "Title": "BinaryPrimitives.ToLittleEndian / FromLittleEndian",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-09T22:00:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29222",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-11T00:00:00-08:00",
        "FeedbackId": "584820663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29222#issuecomment-584820663",
        "FeedbackMarkdown": "We need a more compelling reason. Sorry Levi :-)",
        "TimeCode": 49630000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "DWt2Dh5L-C0",
      "StartDateTime": "2020-02-20T10:04:49.344-08:00",
      "EndDateTime": "2020-02-20T12:00:07-08:00",
      "Title": ".NET Design Review: Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/DWt2Dh5L-C0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 921,
          "Title": "Add CancellationToken overloads to Socket.ConnectAsync and Socket.AcceptAsync",
          "Author": "tmds",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-23T15:10:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/921",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589234342",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/921#issuecomment-589234342",
        "FeedbackMarkdown": "* We should file an issue to cover the remaining APIs \u0060ReceiveAsync\u0060, \u0060ReceiveFromAsync\u0060, \u0060ReceiveMessageFromAsync\u0060, \u0060SendToAsync (@scalablecory)\r\n* Otherwise looks good\r\n\r\n\u0060\u0060\u0060C#\r\nclass SocketTaskExtensions\r\n{\r\n   public static ValueTask ConnectAsync (this Socket socket, EndPoint remoteEP, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, IPAddress address, int port, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, IPAddress[] addresses, int port, CancellationToken cancellationToken);\r\n   public static ValueTask ConnectAsync (this Socket socket, string host, int port, CancellationToken cancellationToken);\r\n   public static ValueTask\u003CSocket\u003E AcceptAsync (this Socket socket, CancellationToken cancellationToken);\r\n   public static ValueTask\u003CSocket\u003E AcceptAsync (this Socket socket, Socket acceptSocket, CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public static Task ConnectAsync (this Socket socket, EndPoint remoteEP);\r\n   // public static Task ConnectAsync (this Socket socket, IPAddress address, int port);\r\n   // public static Task ConnectAsync (this Socket socket, IPAddress[] addresses, int port);\r\n   // public static Task ConnectAsync (this Socket socket, string host, int port);\r\n   // public static Task\u003CSocket\u003E AcceptAsync (this Socket socket);\r\n   // public static Task\u003CSocket\u003E AcceptAsync (this Socket socket, Socket acceptSocket);\r\n}\r\n\r\nclass Socket\r\n{\r\n   public static void CancelAcceptAsync(SocketAsyncEventArgs e);\r\n\r\n   // existing methods:\r\n   // public bool AcceptAsync (SocketAsyncEventArgs e);\r\n   // public bool ConnectAsync (SocketAsyncEventArgs e);\r\n   // public static void CancelConnectAsync (SocketAsyncEventArgs e);\r\n}\r\n\r\nclass TcpClient\r\n{\r\n   public ValueTask ConnectAsync (string host, int port, CancellationToken cancellationToken);\r\n   public ValueTask ConnectAsync (IPAddress address, int port, CancellationToken cancellationToken);\r\n   public ValueTask ConnectAsync (IPAddress[] addresses, int port, CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public Task ConnectAsync (string host, int port);\r\n   // public Task ConnectAsync (IPAddress address, int port);\r\n   // public Task ConnectAsync (IPAddress[] addresses, int port);\r\n}\r\n\r\nclass TcpListener\r\n{\r\n   public ValueTask\u003CSocket\u003E AcceptSocketAsync (CancellationToken cancellationToken);\r\n   public ValueTask\u003CTcpClient\u003E AcceptTcpClientAsync (CancellationToken cancellationToken);\r\n\r\n   // existing methods:\r\n   // public Task\u003CSocket\u003E AcceptSocketAsync ();\r\n   // public Task\u003CTcpClient\u003E AcceptTcpClientAsync ();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Socket.CancelAcceptAsync(SocketAsyncEventArgs)",
          "M:SocketTaskExtensions.AcceptAsync(this Socket,CancellationToken)",
          "M:SocketTaskExtensions.AcceptAsync(this Socket,Socket,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,EndPoint,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,IPAddress,int,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,IPAddress[],int,CancellationToken)",
          "M:SocketTaskExtensions.ConnectAsync(this Socket,string,int,CancellationToken)",
          "M:TcpClient.ConnectAsync(IPAddress,int,CancellationToken)",
          "M:TcpClient.ConnectAsync(IPAddress[],int,CancellationToken)",
          "M:TcpClient.ConnectAsync(string,int,CancellationToken)",
          "M:TcpListener.AcceptSocketAsync(CancellationToken)",
          "M:TcpListener.AcceptTcpClientAsync(CancellationToken)",
          "T:Socket",
          "T:SocketTaskExtensions",
          "T:TcpClient",
          "T:TcpListener"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 865,
          "Title": "API Socket.SetRawSocketOption",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-23T17:21:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/865",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589239349",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/865#issuecomment-589239349",
        "FeedbackMarkdown": "* We considered making it \u0060TryGetRawSocketOption\u0060 but we can\u0027t think of a case where the size of the option would change/is not known.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class Socket\r\n{\r\n    // existing: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);\r\n    public void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan\u003Cbyte\u003E optionValue);\r\n\r\n    // existing: public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);\r\n    public int GetRawSocketOption(int optionLevel, int optionName, Span\u003Cbyte\u003E optionValue);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6670000000,
        "Apis": [
          "M:Socket.GetRawSocketOption(int,int,Span\u003Cbyte\u003E)",
          "M:Socket.SetRawSocketOption(int,int,ReadOnlySpan\u003Cbyte\u003E)",
          "T:Socket"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30543,
          "Title": "Update Encoder, EncoderParameterValueType to match GDI\u002B",
          "Author": "qmfrederik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-09T12:51:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30543",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589242229",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30543#issuecomment-589242229",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing.Imaging\r\n{\r\n    public sealed partial class Encoder\r\n    {\r\n        // Existing:\r\n        // public static readonly Encoder ChrominanceTable;\r\n        // public static readonly Encoder ColorDepth;\r\n        // public static readonly Encoder Compression;\r\n        // public static readonly Encoder LuminanceTable;\r\n        // public static readonly Encoder Quality;\r\n        // public static readonly Encoder RenderMethod;\r\n        // public static readonly Encoder SaveFlag;\r\n        // public static readonly Encoder ScanMethod;\r\n        // public static readonly Encoder Transformation;\r\n        // public static readonly Encoder Version;\r\n        public static readonly Encoder ColorSpace;\r\n        public static readonly Encoder ImageItems;\r\n        public static readonly Encoder SaveAsCmyk;\r\n    }\r\n\r\n    public enum EncoderParameterValueType\r\n    {\r\n        // Existing:\r\n        // ValueTypeByte = 1,\r\n        // ValueTypeAscii = 2,\r\n        // ValueTypeShort = 3,\r\n        // ValueTypeLong = 4,\r\n        // ValueTypeRational = 5,\r\n        // ValueTypeLongRange = 6,\r\n        // ValueTypeUndefined = 7,\r\n        // ValueTypeRationalRange = 8,\r\n        ValueTypePointer = 9,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13420000000,
        "Apis": [
          "F:Encoder.ColorSpace",
          "F:Encoder.ImageItems",
          "F:Encoder.SaveAsCmyk",
          "F:EncoderParameterValueType.ValueTypePointer",
          "T:Encoder",
          "T:EncoderParameterValueType"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30652,
          "Title": "Add ParallelOptions constructor with MaxDegreeOfParallelism parameter",
          "Author": "SnakyBeaky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-22T10:16:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30652",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "area-System.Linq.Parallel",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589246889",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30652#issuecomment-589246889",
        "FeedbackMarkdown": "* After more discussion, it seems we prefer the current state because it\u0027s less ambiguous.",
        "TimeCode": 17520000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30778,
          "Title": "SequenceReader\u003CT\u003E.TryRead overloads to read a specified number of elements",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-06T05:30:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30778",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589257975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30778#issuecomment-589257975",
        "FeedbackMarkdown": "* The first API will have to allocate when \u0060count\u0060 causes spanning blocks in the sequence. The bigger the \u0060count\u0060, the more likely it is to cross such a boundary. This could be changed to allow the caller to pass in a pre-allocated span or we could change the semantics to only succeed if the data is available contiguously. This API will need more design.\r\n* The second overload is fine but we should change the name to \u0060TryReadExact\u0060 to make it clear that returning less or more is both not possible.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial ref struct SequenceReader\u003CT\u003E\r\n{\r\n    bool TryReadExact(int count, out ReadOnlySequence\u003CT\u003E value);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27910000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.TryReadExact(int,out ReadOnlySequence\u003CT\u003E)",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30779,
          "Title": "SequenceReader\u003CT\u003E.TryPeek overloads to read a specified number of elements from any position",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-06T05:33:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30779",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589267066",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30779#issuecomment-589267066",
        "FeedbackMarkdown": "* The two \u0060TryPeek\u0060 APIs that out a span need more work because they silently allocate. Either allow for the caller to pass in a pre-allocated span or make it clear in the name that it will only return true if the data is in contiguous memory.\r\n* The \u0060TryPeek\u0060 overloads involving sequences look fine, except that \u0060count\u0060 changes position due to \u0060skip\u0060. We should either remove the one that doesn\u0027t take \u0060skip\u0060 (callers would have to pass in \u00600\u0060) or we should change order of \u0060skip\u0060 which might be weird.\r\n* \u0060TryCopyTo\u0060 seems fine as proposed, but it seems we might want to change it based on what we do for \u0060TryPeek\u0060.\r\n\r\n@davidfowl looks like we should meet and discuss this.",
        "TimeCode": 39230000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30800,
          "Title": "Add generic overloads for MethodInfo.CreateDelegate",
          "Author": "YairHalberstadt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-09T12:28:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30800",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589273550",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30800#issuecomment-589273550",
        "FeedbackMarkdown": "* We discussed dropping the generic constraint (because it makes the new API less useful to code that is generic and not constrained, because the constraint is recent).\r\n* We\u0027ll keep it for now and will drop it if we see issues with the constraint.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MethodInfo\r\n{\r\n    // Current\r\n    public virtual Delegate CreateDelegate(Type delegateType);\r\n    public virtual Delegate CreateDelegate(Type delegateType, object target);\r\n\r\n    // New\r\n    public T CreateDelegate\u003CT\u003E() where T : Delegate =\u003E (T)CreateDelegate(typeof(T));\r\n    public T CreateDelegate\u003CT\u003E(object? target) where T : Delegate =\u003E (T)CreateDelegate(typeof(T), target);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50780000000,
        "Apis": [
          "M:MethodInfo.CreateDelegate(Type,object)",
          "M:MethodInfo.CreateDelegate(Type)",
          "M:MethodInfo.CreateDelegate\u003CT\u003E()",
          "M:MethodInfo.CreateDelegate\u003CT\u003E(object?)",
          "T:MethodInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30862,
          "Title": "Add TaskCompletionSource.SetCanceled(CancellationToken)",
          "Author": "Frassle",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-15T09:28:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30862",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589274248",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30862#issuecomment-589274248",
        "FeedbackMarkdown": "* Looks good as proposed and follows the guidelines for \u0060Try\u0060-APIs\r\n\r\n\u0060\u0060\u0060C#\r\npublic class TaskCompletionSource\u003CTResult\u003E\r\n{\r\n    ...\r\n    public void SetCanceled(CancellationToken cancellationToken);\r\n    ...\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59790000000,
        "Apis": [
          "M:TaskCompletionSource\u003CTResult\u003E.SetCanceled(CancellationToken)",
          "T:TaskCompletionSource\u003CTResult\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31179,
          "Title": "Sse2.StoreScalar(int*)",
          "Author": "saucecontrol",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-16T06:14:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31179",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589275674",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31179#issuecomment-589275674",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Sse2 : Sse\r\n    {\r\n        public static unsafe void StoreScalar(int* address, Vector128\u003Cint\u003E source);\r\n        public static unsafe void StoreScalar(uint* address, Vector128\u003Cuint\u003E source);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 60720000000,
        "Apis": [
          "M:Sse2.StoreScalar(int*,Vector128\u003Cint\u003E)",
          "M:Sse2.StoreScalar(uint*,Vector128\u003Cuint\u003E)",
          "T:Sse2"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31184,
          "Title": "API: long Math.BigMul(long, long, out long)",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-16T11:23:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31184",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589278166",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31184#issuecomment-589278166",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Math\r\n    {\r\n        public ulong BigMul(ulong a, ulong b, out ulong low);\r\n        public long BigMul(long a, long b, out long low);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62740000000,
        "Apis": [
          "M:Math.BigMul(long,long,out long)",
          "M:Math.BigMul(ulong,ulong,out ulong)",
          "T:Math"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31193,
          "Title": "Avx.CompareXXX convenience methods for float/double",
          "Author": "saucecontrol",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-16T23:38:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31193",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-02-20T00:00:00-08:00",
        "FeedbackId": "589280411",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31193#issuecomment-589280411",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Avx : Sse42\r\n    {\r\n        public static Vector256\u003Cfloat\u003E CompareEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareGreaterThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareGreaterThan(Vector256\u003Cdouble\u003E left,  Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareGreaterThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareGreaterThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareLessThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareLessThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareLessThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareLessThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotGreaterThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotGreaterThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotGreaterThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotGreaterThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotLessThan(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotLessThan(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareNotLessThanOrEqual(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareNotLessThanOrEqual(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        // The justification for these is questionable as the equivalent FloatComparisonMode is obvious.\r\n        public static Vector256\u003Cfloat\u003E CompareOrdered(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareOrdered(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E CompareUnordered(Vector256\u003Cfloat\u003E left, Vector256\u003Cfloat\u003E right);\r\n        public static Vector256\u003Cdouble\u003E CompareUnordered(Vector256\u003Cdouble\u003E left, Vector256\u003Cdouble\u003E right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 66050000000,
        "Apis": [
          "M:Avx.CompareEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareGreaterThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareGreaterThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareGreaterThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareGreaterThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareLessThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareLessThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareLessThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareLessThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotGreaterThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotGreaterThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotGreaterThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotGreaterThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotLessThan(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotLessThan(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareNotLessThanOrEqual(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareNotLessThanOrEqual(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareOrdered(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareOrdered(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "M:Avx.CompareUnordered(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E)",
          "M:Avx.CompareUnordered(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E)",
          "T:Avx"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "3qXvVF9n0kQ",
      "StartDateTime": "2020-03-03T10:04:12.136-08:00",
      "EndDateTime": "2020-03-03T12:30:12-08:00",
      "Title": ".NET Design Review: ARM Intrinsics",
      "ThumbnailUrl": "https://i.ytimg.com/vi/3qXvVF9n0kQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31324,
          "Title": "API Proposal : Arm Shift and Permute intrinsics",
          "Author": "TamarChristinaArm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-28T17:21:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31324",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594124186",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31324#issuecomment-594124186",
        "FeedbackMarkdown": "* Confirm that \u0060ShiftLeftLogicalAndInsert\u0060 under \u0060ArmBase\u0060 should move under \u0060AdvSimd\u0060, but is it 32 bit or 64 bit?\r\n* Some of instructions are destructive on ARM32 and non-destructive on ARM64. Should we split these up into a 32-bit version with a different shape?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class ArmBase\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// vslid_n_[su]64\r\n        ///\r\n        /// A64: SLI\r\n        /// A32: VSLI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Clong\u003E  ShiftLeftLogicalAndInsertScalar(Vector64\u003Clong\u003E  left, Vector64\u003Clong\u003E  right, byte shift);\r\n        public static Vector64\u003Culong\u003E ShiftLeftLogicalAndInsertScalar(Vector64\u003Culong\u003E left, Vector64\u003Culong\u003E right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vsrid_n_[su]64\r\n        ///\r\n        /// A64: SRI\r\n        /// A32: VSRI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Clong\u003E  ShiftRightLogicalAndInsertScalar(Vector64\u003Clong\u003E  left, Vector64\u003Clong\u003E  right, byte shift);\r\n        public static Vector64\u003Culong\u003E ShiftRightLogicalAndInsertScalar(Vector64\u003Culong\u003E left, Vector64\u003Culong\u003E right, byte shift);\r\n    }\r\n    public partial class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// vsli[q]_n_[su][8,16,32,64]\r\n        //\r\n        /// A64: SLI\r\n        /// A32: VSLI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Cbyte\u003E   ShiftLeftLogicalAndInsert(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector64\u003Cushort\u003E ShiftLeftLogicalAndInsert(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right, byte shift);\r\n        public static Vector64\u003Cuint\u003E   ShiftLeftLogicalAndInsert(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right, byte shift);\r\n        public static Vector64\u003Csbyte\u003E  ShiftLeftLogicalAndInsert(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector64\u003Cshort\u003E  ShiftLeftLogicalAndInsert(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte shift);\r\n        public static Vector64\u003Cint\u003E    ShiftLeftLogicalAndInsert(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte shift);\r\n\r\n        public static Vector128\u003Cbyte\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector128\u003Cushort\u003E ShiftLeftLogicalAndInsert(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right, byte shift);\r\n        public static Vector128\u003Cuint\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right, byte shift);\r\n        public static Vector128\u003Culong\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right, byte shift);\r\n        public static Vector128\u003Csbyte\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector128\u003Cshort\u003E  ShiftLeftLogicalAndInsert(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right, byte shift);\r\n        public static Vector128\u003Cint\u003E    ShiftLeftLogicalAndInsert(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right, byte shift);\r\n        public static Vector128\u003Clong\u003E   ShiftLeftLogicalAndInsert(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vsri[q]_n_[su][8,16,32,64]\r\n        ///\r\n        /// A64: SRI\r\n        /// A32: VSRI\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Cbyte\u003E   ShiftRightAndInsert(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector64\u003Cushort\u003E ShiftRightAndInsert(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right, byte shift);\r\n        public static Vector64\u003Cuint\u003E   ShiftRightAndInsert(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right, byte shift);\r\n        public static Vector64\u003Csbyte\u003E  ShiftRightAndInsert(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector64\u003Cshort\u003E  ShiftRightAndInsert(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte shift);\r\n        public static Vector64\u003Cint\u003E    ShiftRightAndInsert(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte shift);\r\n\r\n        public static Vector128\u003Cbyte\u003E   ShiftRightAndInsert(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right, byte shift);\r\n        public static Vector128\u003Cushort\u003E ShiftRightAndInsert(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right, byte shift);\r\n        public static Vector128\u003Cuint\u003E   ShiftRightAndInsert(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right, byte shift);\r\n        public static Vector128\u003Culong\u003E  ShiftRightAndInsert(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right, byte shift);\r\n        public static Vector128\u003Csbyte\u003E  ShiftRightAndInsert(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right, byte shift);\r\n        public static Vector128\u003Cshort\u003E  ShiftRightAndInsert(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right, byte shift);\r\n        public static Vector128\u003Cint\u003E    ShiftRightAndInsert(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right, byte shift);\r\n        public static Vector128\u003Clong\u003E   ShiftRightAndInsert(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right, byte shift);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vmovn_[su][16,32,64]\r\n        ///\r\n        /// A64: XTN\r\n        /// A32: VMOVN\r\n        /// \u003C/summary\u003E\r\n        public static Vector64\u003Csbyte\u003E  ExtractAndNarrowLow(Vector128\u003Cshort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E  ExtractAndNarrowLow(Vector128\u003Cint\u003E    value);\r\n        public static Vector64\u003Cint\u003E    ExtractAndNarrowLow(Vector128\u003Clong\u003E   value);\r\n        public static Vector64\u003Cbyte\u003E   ExtractAndNarrowLow(Vector128\u003Cushort\u003E value);\r\n        public static Vector64\u003Cushort\u003E ExtractAndNarrowLow(Vector128\u003Cuint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E   ExtractAndNarrowLow(Vector128\u003Culong\u003E  value);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// vmovn_high_[su][16,32,64]\r\n        //\r\n        /// A64: XTN2\r\n        /// A32: VMOVN\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Csbyte\u003E  ExtractAndNarrowHigh(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  value);\r\n        public static Vector128\u003Cshort\u003E  ExtractAndNarrowHigh(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    value);\r\n        public static Vector128\u003Cint\u003E    ExtractAndNarrowHigh(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractAndNarrowHigh(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractAndNarrowHigh(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractAndNarrowHigh(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  value);\r\n\r\n        public partial class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// vtrn1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: UZP1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  UnzipEven(Vector64\u003Csbyte\u003E  lower, Vector64\u003Csbyte\u003E  upper);\r\n            public static Vector64\u003Cshort\u003E  UnzipEven(Vector64\u003Cshort\u003E  lower, Vector64\u003Cshort\u003E  upper);\r\n            public static Vector64\u003Cint\u003E    UnzipEven(Vector64\u003Cint\u003E    lower, Vector64\u003Cint\u003E    upper);\r\n            public static Vector64\u003Cbyte\u003E   UnzipEven(Vector64\u003Cbyte\u003E   lower, Vector64\u003Cbyte\u003E   upper);\r\n            public static Vector64\u003Cushort\u003E UnzipEven(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper);\r\n            public static Vector64\u003Cuint\u003E   UnzipEven(Vector64\u003Cuint\u003E   lower, Vector64\u003Cuint\u003E   upper);\r\n            public static Vector64\u003Cfloat\u003E  UnzipEven(Vector64\u003Cfloat\u003E  lower, Vector64\u003Cfloat\u003E  upper);\r\n\r\n            public static Vector128\u003Csbyte\u003E  UnzipEven(Vector128\u003Csbyte\u003E  lower, Vector128\u003Csbyte\u003E  upper);\r\n            public static Vector128\u003Cshort\u003E  UnzipEven(Vector128\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E  upper);\r\n            public static Vector128\u003Cint\u003E    UnzipEven(Vector128\u003Cint\u003E    lower, Vector128\u003Cint\u003E    upper);\r\n            public static Vector128\u003Clong\u003E   UnzipEven(Vector128\u003Clong\u003E   lower, Vector128\u003Clong\u003E   upper);\r\n            public static Vector128\u003Cbyte\u003E   UnzipEven(Vector128\u003Cbyte\u003E   lower, Vector128\u003Cbyte\u003E   upper);\r\n            public static Vector128\u003Cushort\u003E UnzipEven(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper);\r\n            public static Vector128\u003Cuint\u003E   UnzipEven(Vector128\u003Cuint\u003E   lower, Vector128\u003Cuint\u003E   upper);\r\n            public static Vector128\u003Culong\u003E  UnzipEven(Vector128\u003Culong\u003E  lower, Vector128\u003Culong\u003E  upper);\r\n            public static Vector128\u003Cfloat\u003E  UnzipEven(Vector128\u003Cfloat\u003E  lower, Vector128\u003Cfloat\u003E  upper);\r\n            public static Vector128\u003Cdouble\u003E UnzipEven(Vector128\u003Cdouble\u003E lower, Vector128\u003Cdouble\u003E upper);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: UZP2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  UnzipOdd(Vector64\u003Csbyte\u003E  lower, Vector64\u003Csbyte\u003E  upper);\r\n            public static Vector64\u003Cshort\u003E  UnzipOdd(Vector64\u003Cshort\u003E  lower, Vector64\u003Cshort\u003E  upper);\r\n            public static Vector64\u003Cint\u003E    UnzipOdd(Vector64\u003Cint\u003E    lower, Vector64\u003Cint\u003E    upper);\r\n            public static Vector64\u003Cbyte\u003E   UnzipOdd(Vector64\u003Cbyte\u003E   lower, Vector64\u003Cbyte\u003E   upper);\r\n            public static Vector64\u003Cushort\u003E UnzipOdd(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper);\r\n            public static Vector64\u003Cuint\u003E   UnzipOdd(Vector64\u003Cuint\u003E   lower, Vector64\u003Cuint\u003E   upper);\r\n            public static Vector64\u003Cfloat\u003E  UnzipOdd(Vector64\u003Cfloat\u003E  lower, Vector64\u003Cfloat\u003E  upper);\r\n\r\n            public static Vector128\u003Csbyte\u003E  UnzipOdd(Vector128\u003Csbyte\u003E  lower, Vector128\u003Csbyte\u003E  upper);\r\n            public static Vector128\u003Cshort\u003E  UnzipOdd(Vector128\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E  upper);\r\n            public static Vector128\u003Cint\u003E    UnzipOdd(Vector128\u003Cint\u003E    lower, Vector128\u003Cint\u003E    upper);\r\n            public static Vector128\u003Clong\u003E   UnzipOdd(Vector128\u003Clong\u003E   lower, Vector128\u003Clong\u003E   upper);\r\n            public static Vector128\u003Cbyte\u003E   UnzipOdd(Vector128\u003Cbyte\u003E   lower, Vector128\u003Cbyte\u003E   upper);\r\n            public static Vector128\u003Cushort\u003E UnzipOdd(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper);\r\n            public static Vector128\u003Cuint\u003E   UnzipOdd(Vector128\u003Cuint\u003E   lower, Vector128\u003Cuint\u003E   upper);\r\n            public static Vector128\u003Culong\u003E  UnzipOdd(Vector128\u003Culong\u003E  lower, Vector128\u003Culong\u003E  upper);\r\n            public static Vector128\u003Cfloat\u003E  UnzipOdd(Vector128\u003Cfloat\u003E  lower, Vector128\u003Cfloat\u003E  upper);\r\n            public static Vector128\u003Cdouble\u003E UnzipOdd(Vector128\u003Cdouble\u003E lower, Vector128\u003Cdouble\u003E upper);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vzip1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: ZIP1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  ZipLow(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  ZipLow(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    ZipLow(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   ZipLow(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E ZipLow(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   ZipLow(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  ZipLow(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  ZipLow(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  ZipLow(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    ZipLow(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   ZipLow(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   ZipLow(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E ZipLow(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   ZipLow(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  ZipLow(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  ZipLow(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E ZipLow(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vzip2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: ZIP2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  ZipHigh(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  ZipHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    ZipHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   ZipHigh(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E ZipHigh(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   ZipHigh(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  ZipHigh(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  ZipHigh(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  ZipHigh(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    ZipHigh(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   ZipHigh(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   ZipHigh(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E ZipHigh(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   ZipHigh(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  ZipHigh(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  ZipHigh(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E ZipHigh(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn1[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: TRN1\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  TransposeEven(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  TransposeEven(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    TransposeEven(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   TransposeEven(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E TransposeEven(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   TransposeEven(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  TransposeEven(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  TransposeEven(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  TransposeEven(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    TransposeEven(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   TransposeEven(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   TransposeEven(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E TransposeEven(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   TransposeEven(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  TransposeEven(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  TransposeEven(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E TransposeEven(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// vtrn2[q]_[suf][8,16,32,64]\r\n            ///\r\n            /// A64: TRN2\r\n            /// \u003C/summary\u003E\r\n            public static Vector64\u003Csbyte\u003E  TransposeOdd(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector64\u003Cshort\u003E  TransposeOdd(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector64\u003Cint\u003E    TransposeOdd(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector64\u003Cbyte\u003E   TransposeOdd(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector64\u003Cushort\u003E TransposeOdd(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector64\u003Cuint\u003E   TransposeOdd(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector64\u003Cfloat\u003E  TransposeOdd(Vector64\u003Cfloat\u003E  left, Vector64\u003Cfloat\u003E  right);\r\n\r\n            public static Vector128\u003Csbyte\u003E  TransposeOdd(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cshort\u003E  TransposeOdd(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cint\u003E    TransposeOdd(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Clong\u003E   TransposeOdd(Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public static Vector128\u003Cbyte\u003E   TransposeOdd(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E TransposeOdd(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   TransposeOdd(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  TransposeOdd(Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n            public static Vector128\u003Cfloat\u003E  TransposeOdd(Vector128\u003Cfloat\u003E  left, Vector128\u003Cfloat\u003E  right);\r\n            public static Vector128\u003Cdouble\u003E TransposeOdd(Vector128\u003Cdouble\u003E left, Vector128\u003Cdouble\u003E right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractAndNarrowHigh(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractAndNarrowLow(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndInsert(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:ArmBase.ShiftLeftLogicalAndInsertScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:ArmBase.ShiftLeftLogicalAndInsertScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:ArmBase.ShiftRightLogicalAndInsertScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:ArmBase.ShiftRightLogicalAndInsertScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64",
          "T:ArmBase"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33089,
          "Title": "Extend ObsoleteAttribute",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-03T01:26:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33089",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33089#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 48790000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 32462,
          "Title": "NativeCallableAttribute should be a public API",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-18T01:41:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/32462",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594132248",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/32462#issuecomment-594132248",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We modelled it off of \u0060DllImportAttribute\u0060, which is why it\u0027s named \u0060EntryPoint\u0060 and those are fields.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed class NativeCallableAttribute : Attribute\r\n    {\r\n        public NativeCallableAttribute();\r\n\r\n        public CallingConvention CallingConvention;\r\n        public string? EntryPoint;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52610000000,
        "Apis": [
          "F:NativeCallableAttribute.CallingConvention",
          "F:NativeCallableAttribute.EntryPoint",
          "M:NativeCallableAttribute.NativeCallableAttribute()",
          "T:NativeCallableAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1845,
          "Title": "Low level API support for RCW and CCW management",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-17T02:01:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1845",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-03T00:00:00-08:00",
        "FeedbackId": "594151682",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1845#issuecomment-594151682",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should align the naming \u0060Vtable\u0060 vs. \u0060vftbl\u0060\r\n* Some comments are out sync\r\n* The design should be validated by people who are wrapping COM objects\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58970000000,
        "Apis": [
          "F:ComWrappers.ComInterfaceDispatch.vftbl",
          "F:ComWrappers.ComInterfaceEntry.IID",
          "F:ComWrappers.ComInterfaceEntry.Vtable",
          "F:CreateComInterfaceFlags.CallerDefinedIUnknown",
          "F:CreateComInterfaceFlags.None",
          "F:CreateComInterfaceFlags.TrackerSupport",
          "F:CreateObjectFlags.None",
          "F:CreateObjectFlags.TrackerObject",
          "F:CreateObjectFlags.UniqueInstance",
          "M:ComWrappers.ComInterfaceDispatch.GetInstance\u003CT\u003E(ComInterfaceDispatch*)",
          "M:ComWrappers.ComputeVtables(object,CreateComInterfaceFlags,out int)",
          "M:ComWrappers.CreateObject(IntPtr,CreateObjectFlags)",
          "M:ComWrappers.GetIUnknownImpl(out IntPtr,out IntPtr,out IntPtr)",
          "M:ComWrappers.GetOrCreateComInterfaceForObject(object,CreateComInterfaceFlags)",
          "M:ComWrappers.GetOrCreateObjectForComInstance(IntPtr,CreateObjectFlags,object?)",
          "M:ComWrappers.RegisterAsGlobalInstance()",
          "M:ComWrappers.ReleaseObjects(IEnumerable)",
          "M:RuntimeHelpers.AllocateTypeAssociatedMemory(Type,int)",
          "T:ComWrappers",
          "T:ComWrappers.ComInterfaceDispatch",
          "T:ComWrappers.ComInterfaceEntry",
          "T:CreateComInterfaceFlags",
          "T:CreateObjectFlags",
          "T:RuntimeHelpers"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "gwXkFHKPKok",
      "StartDateTime": "2020-03-05T14:06:28.999-08:00",
      "EndDateTime": "2020-03-05T15:30:01-08:00",
      "Title": ".NET Design Review: WinForms Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/gwXkFHKPKok/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2858,
          "Title": "Proposal to expose FileDialog.ClientGuid",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-15T17:01:34+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2858",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595474869",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2858#issuecomment-595474869",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class FileDialog\r\n    {\r\n        public System.Guid? ClientGuid { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:FileDialog.ClientGuid",
          "T:FileDialog"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2656,
          "Title": "Add support for tasks to ListViewGroup",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-07T12:03:39+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2656",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595478125",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2656#issuecomment-595478125",
        "FeedbackMarkdown": "* Let\u0027s stop creating new delegates for the basic event pattern and just use \u0060EventHandler\u003CT\u003E\u0060\r\n* Is \u0060GroupLink\u0060 the best name for the concept? Or is it some kind of index? If so, the name should reflect that.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public class GroupLinkClickEventArgs : EventArgs\r\n    {\r\n        public GroupLinkClickEventArgs(int groupLink);\r\n        public int GroupLink { get; }\r\n    }\r\n    public partial class ListView\r\n    {\r\n        public event EventHandler\u003CGroupLinkClickEventArgs\u003E GroupLinkClick;\r\n        protected void OnGroupLinkClick(GroupEventArgs e);\r\n    }\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Task { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6010000000,
        "Apis": [
          "M:GroupLinkClickEventArgs.GroupLinkClickEventArgs(int)",
          "M:ListView.OnGroupLinkClick(GroupEventArgs)",
          "P:GroupLinkClickEventArgs.GroupLink",
          "P:ListViewGroup.Task",
          "T:GroupLinkClickEventArgs",
          "T:ListView",
          "T:ListViewGroup"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2655,
          "Title": "Add support for subtitles in ListViewGroup",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-07T11:58:51+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2655",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "design-discussion",
              "Color": "f7b7ee",
              "Description": "Ongoing discussion about design without consensus"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595479361",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2655#issuecomment-595479361",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Subtitle { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 11530000000,
        "Apis": [
          "P:ListViewGroup.Subtitle",
          "T:ListViewGroup"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2653,
          "Title": "Add support for footers to ListViewGroup",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-07T10:50:31+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2653",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595480175",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2653#issuecomment-595480175",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ListViewGroup\r\n    {\r\n        public string Footer { get; set; }\r\n        public HorizontalAlignment FooterAlignment { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13600000000,
        "Apis": [
          "P:ListViewGroup.Footer",
          "P:ListViewGroup.FooterAlignment",
          "T:ListViewGroup"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2627,
          "Title": "Discussion/proposal: add more LVCOLUMN ComCtl 6.0 features",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-04T21:18:42+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2627",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595483352",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2627#issuecomment-595483352",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We think the individual booleans seems easier than the flags, given that it\u0027s a single use\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ColumnHeader\r\n    {\r\n        public int MinimumWidth { get; set; }\r\n        public bool FixedWidth { get; set; }\r\n        public bool SplitButton { get; set; }\r\n    }\r\n    public class ColumnDropDownClickEventArgs : ColumnClickEventArgs\r\n    {\r\n        public ColumnDropDownClickEventArgs(int column, Point screenLocation);\r\n        public Point ScreenLocation { get; set; }\r\n    }\r\n    public partial class ListView\r\n    {\r\n        public event EventHandler\u003CColumnDropDownClickEventArgs\u003E ColumnDropDownClicked;\r\n        protected void OnColumnDropDownClicked(ColumnDropDownClickEventArgs e);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14710000000,
        "Apis": [
          "M:ColumnDropDownClickEventArgs.ColumnDropDownClickEventArgs(int,Point)",
          "M:ListView.OnColumnDropDownClicked(ColumnDropDownClickEventArgs)",
          "P:ColumnDropDownClickEventArgs.ScreenLocation",
          "P:ColumnHeader.FixedWidth",
          "P:ColumnHeader.MinimumWidth",
          "P:ColumnHeader.SplitButton",
          "T:ColumnDropDownClickEventArgs",
          "T:ColumnHeader",
          "T:ListView"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2642,
          "Title": "Proposal: add SelectionStart and SelectionEnd to TrackBar",
          "Author": "hughbe",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-06T16:41:29+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2642",
          "Milestone": "5.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "design-discussion",
              "Color": "f7b7ee",
              "Description": "Ongoing discussion about design without consensus"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595486672",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2642#issuecomment-595486672",
        "FeedbackMarkdown": "* We should probably follow \u0060TextBoxBase\u0060 and use \u0060SelectionStart\u0060 and \u0060SelectionLength\u0060, because that avoids ordering issues and the need for sentinel values. @RussKie, it would be good to check what the throw behavior is for \u0060TextBoxBase\u0060.\r\n* We considered making it method like \u0060SetSelection(int start, int length)\u0060 but that would mean you can\u0027t set the selection using the designer, which feels odd\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class TrackBar\r\n    {\r\n        public bool ShowSelectionRange { get; set; }\r\n        public int SelectionStart { get; set; }\r\n        public int SelectionLength { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n@hughbe What the other properties you show in your UI? Like \u0060ShowThumb\u0060 and \u0060ThumbWidth\u0060?",
        "TimeCode": 20520000000,
        "Apis": [
          "P:TrackBar.SelectionLength",
          "P:TrackBar.SelectionStart",
          "P:TrackBar.ShowSelectionRange",
          "T:TrackBar"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 2788,
          "Title": "Add Bold Property to TreeNode",
          "Author": "jmairboeck",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-30T11:13:18+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/2788",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "200dff",
              "Description": "(3) API needs work before it is approved, it is NOT ready for implementation; applied by repo owners"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-05T00:00:00-08:00",
        "FeedbackId": "595496212",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/2788#issuecomment-595496212",
        "FeedbackMarkdown": "* We prefer \u0060IsBold\u0060 is nicer than \u0060Bold\u0060\r\n* Assuming \u0060IsBold\u0060 is independent of the \u0060NodeFont\u0060 we like it.\r\n* If there is a weird relationship between \u0060IsBold\u0060 and \u0060NodeFont\u0060, e.g. when setting \u0060IsBold\u0060 modifies the \u0060NodeFont\u0060, then we don\u0027t like it because it creates referential integrity issues where setting a boolean in one place suddenly causes the node to use a different font when the font was meant to be shared across multiple nodes. We should investigate that before we approve the API.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class TreeNode\r\n    {\r\n        public bool IsBold { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27450000000,
        "Apis": [
          "P:TreeNode.IsBold",
          "T:TreeNode"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "gGjTgHAHAKA",
      "StartDateTime": "2020-03-17T10:07:19.63-07:00",
      "EndDateTime": "2020-03-17T12:07:34-07:00",
      "Title": ".NET Design Review: ARM Intrinsics",
      "ThumbnailUrl": "https://i.ytimg.com/vi/gGjTgHAHAKA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 32512,
          "Title": "ARM additional arithmetic intrinsics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-18T22:46:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/32512",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-17T00:00:00-07:00",
        "FeedbackId": "600227857",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/32512#issuecomment-600227857",
        "FeedbackMarkdown": "* Looks good\r\n* We made some substantial changing in order of words\r\n* ~~\u0060AbsoluteDifferenceAdd\u0060 in #24794 should take \u0060Vector128\u003CT\u003E\u0060 rather than \u0060Vector64\u003CT\u003E\u0060~~\r\n    - Actually it\u0027s correct\r\n* The \u0060Halving\u0060 methods are fused, so we should prefix them with \u0060Fused\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class AdvSimd\r\n    {\r\n        public Vector64\u003Cbyte\u003E   AddLowerReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  AddLowerReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  AddLowerReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E AddLowerReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    AddLowerReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   AddLowerReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003Cbyte\u003E   AddLowerRoundedReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  AddLowerRoundedReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  AddLowerRoundedReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E AddLowerRoundedReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    AddLowerRoundedReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   AddLowerRoundedReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003CT\u003E  FusedAddHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedAddHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  FusedAddRoundedHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedAddRoundedHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  AddSaturate(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E AddSaturate(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003Cbyte\u003E   SubtractLowerReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  SubtractLowerReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  SubtractLowerReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E SubtractLowerReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    SubtractLowerReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   SubtractLowerReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003Cbyte\u003E   SubtractLowerRoundedReturningUpper(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n        public Vector64\u003Csbyte\u003E  SubtractLowerRoundedReturningUpper(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public Vector64\u003Cshort\u003E  SubtractLowerRoundedReturningUpper(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public Vector64\u003Cushort\u003E SubtractLowerRoundedReturningUpper(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n        public Vector64\u003Cint\u003E    SubtractLowerRoundedReturningUpper(Vector64\u003Clong\u003E   left, Vector64\u003Clong\u003E   right);\r\n        public Vector64\u003Cuint\u003E   SubtractLowerRoundedReturningUpper(Vector64\u003Culong\u003E  left, Vector64\u003Culong\u003E  right);\r\n\r\n        public Vector64\u003CT\u003E  FusedSubtractHalving(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E FusedSubtractHalving(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public Vector64\u003CT\u003E  SubtractSaturate(Vector64\u003CT\u003E  left, Vector64\u003CT\u003E  right);\r\n        public Vector128\u003CT\u003E SubtractSaturate(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public partial class Arm64\r\n        {\r\n            public Vector128\u003Cbyte\u003E   AddUpperReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  AddUpperReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  AddUpperReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E AddUpperReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    AddUpperReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   AddUpperReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector128\u003Cbyte\u003E   AddUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  AddUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  AddUpperRoundedReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E AddUpperRoundedReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    AddUpperRoundedReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   AddUpperRoundedReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector64\u003CT\u003E AddSaturateScalar(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n            public Vector128\u003Cbyte\u003E   SubtractUpperReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  SubtractUpperReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  SubtractUpperReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E SubtractUpperReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    SubtractUpperReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   SubtractUpperReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector128\u003Cbyte\u003E   SubtractUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E   lower, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public Vector128\u003Csbyte\u003E  SubtractUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E  lower, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public Vector128\u003Cshort\u003E  SubtractUpperRoundedReturningUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public Vector128\u003Cushort\u003E SubtractUpperRoundedReturningUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public Vector128\u003Cint\u003E    SubtractUpperRoundedReturningUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Clong\u003E   left, Vector128\u003Clong\u003E   right);\r\n            public Vector128\u003Cuint\u003E   SubtractUpperRoundedReturningUpper(Vector64\u003Cuint\u003E   lower, Vector128\u003Culong\u003E  left, Vector128\u003Culong\u003E  right);\r\n\r\n            public Vector64\u003CT\u003E SubtractSaturateScalar(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddPairwiseWidening(Vector64\u003Csbyte\u003E  value);\r\n            public static Vector128\u003Cushort\u003E AddPairwiseWidening(Vector64\u003Cbyte\u003E   value);\r\n            public static Vector128\u003Cint\u003E    AddPairwiseWidening(Vector64\u003Cshort\u003E  value);\r\n            public static Vector128\u003Cuint\u003E   AddPairwiseWidening(Vector64\u003Cushort\u003E value);\r\n            public static Vector128\u003Clong\u003E   AddPairwiseWidening(Vector64\u003Cint\u003E    value);\r\n            public static Vector128\u003Culong\u003E  AddPairwiseWidening(Vector64\u003Cuint\u003E   value);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddPairwiseWideningAndAdd(Vector128\u003Cshort\u003E  addend, Vector64\u003Csbyte\u003E  value);\r\n            public static Vector128\u003Cushort\u003E AddPairwiseWideningAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   value);\r\n            public static Vector128\u003Cint\u003E    AddPairwiseWideningAndAdd(Vector128\u003Cint\u003E    addend, Vector64\u003Cshort\u003E  value);\r\n            public static Vector128\u003Cuint\u003E   AddPairwiseWideningAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E value);\r\n            public static Vector128\u003Clong\u003E   AddPairwiseWideningAndAdd(Vector128\u003Clong\u003E   addend, Vector64\u003Cint\u003E    value);\r\n            public static Vector128\u003Culong\u003E  AddPairwiseWideningAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   value);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLower(Vector128\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLower(Vector128\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLower(Vector128\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLower(Vector128\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLower(Vector128\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLower(Vector128\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cushort\u003E AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Cuint\u003E   AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n            public static Vector128\u003Culong\u003E  AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningLower(Vector128\u003Cshort\u003E   left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningLower(Vector128\u003Cushort\u003E  left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningLower(Vector128\u003Cint\u003E     left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningLower(Vector128\u003Cuint\u003E    left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningLower(Vector128\u003Clong\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningLower(Vector128\u003Culong\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  AddWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E AddWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    AddWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   AddWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   AddWideningUpper(Vector128\u003Clong\u003E   left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  AddWideningUpper(Vector128\u003Culong\u003E  left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningLower(Vector128\u003Cshort\u003E   left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningLower(Vector128\u003Cushort\u003E  left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningLower(Vector128\u003Cint\u003E     left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningLower(Vector128\u003Cuint\u003E    left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningLower(Vector128\u003Clong\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningLower(Vector128\u003Culong\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  SubtractWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E SubtractWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    SubtractWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   SubtractWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   SubtractWideningUpper(Vector128\u003Clong\u003E   left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  SubtractWideningUpper(Vector128\u003Culong\u003E  left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLower(Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLower(Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLower(Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLower(Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpper(Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpper(Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpper(Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpper(Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpper(Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpper(Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLowerAndAdd(Vector128\u003Cshort\u003E  addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLowerAndAdd(Vector128\u003Cushort\u003E addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLowerAndAdd(Vector128\u003Cint\u003E    addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLowerAndAdd(Vector128\u003Cuint\u003E   addend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLowerAndAdd(Vector128\u003Clong\u003E   addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLowerAndAdd(Vector128\u003Culong\u003E  addend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpperAndAdd(Vector128\u003Cshort\u003E  addend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpperAndAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpperAndAdd(Vector128\u003Cint\u003E    addend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpperAndAdd(Vector128\u003Cuint\u003E   addend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpperAndAdd(Vector128\u003Clong\u003E   addend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpperAndAdd(Vector128\u003Culong\u003E  addend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningLowerAndSubtract(Vector128\u003Cshort\u003E  minuend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningLowerAndSubtract(Vector128\u003Cushort\u003E minuend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningLowerAndSubtract(Vector128\u003Cint\u003E    minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningLowerAndSubtract(Vector128\u003Cuint\u003E   minuend, Vector64\u003Cushort\u003E left, Vector64\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningLowerAndSubtract(Vector128\u003Clong\u003E   minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningLowerAndSubtract(Vector128\u003Culong\u003E  minuend, Vector64\u003Cuint\u003E   left, Vector64\u003Cuint\u003E   right);\r\n\r\n            public static Vector128\u003Cshort\u003E  MultiplyWideningUpperAndSubtract(Vector128\u003Cshort\u003E  minuend, Vector128\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E  right);\r\n            public static Vector128\u003Cushort\u003E MultiplyWideningUpperAndSubtract(Vector128\u003Cushort\u003E minuend, Vector128\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E   right);\r\n            public static Vector128\u003Cint\u003E    MultiplyWideningUpperAndSubtract(Vector128\u003Cint\u003E    minuend, Vector128\u003Cshort\u003E  left, Vector128\u003Cshort\u003E  right);\r\n            public static Vector128\u003Cuint\u003E   MultiplyWideningUpperAndSubtract(Vector128\u003Cuint\u003E   minuend, Vector128\u003Cushort\u003E left, Vector128\u003Cushort\u003E right);\r\n            public static Vector128\u003Clong\u003E   MultiplyWideningUpperAndSubtract(Vector128\u003Clong\u003E   minuend, Vector128\u003Cint\u003E    left, Vector128\u003Cint\u003E    right);\r\n            public static Vector128\u003Culong\u003E  MultiplyWideningUpperAndSubtract(Vector128\u003Culong\u003E  minuend, Vector128\u003Cuint\u003E   left, Vector128\u003Cuint\u003E   right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10200000000,
        "Apis": [
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.AddLowerReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.AddLowerRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.AddSaturate(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.AddSaturate(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AbsoluteDifferenceWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWidening(Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddPairwiseWideningAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddSaturateScalar(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.AddUpperReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.AddUpperRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.AddWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndAdd(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningLowerAndSubtract(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndAdd(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.MultiplyWideningUpperAndSubtract(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractSaturateScalar(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.Arm64.SubtractUpperRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cint\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Clong\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cshort\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cuint\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Culong\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector128\u003Cushort\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningLower(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Clong\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cuint\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Culong\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.SubtractWideningUpper(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.FusedAddHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedAddHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.FusedAddRoundedHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedAddRoundedHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.FusedSubtractHalving(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.FusedSubtractHalving(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.SubtractLowerReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:AdvSimd.SubtractLowerRoundedReturningUpper(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1277,
          "Title": "API Proposal : Arm TableVectorLookup and TableVectorExtension intrinsics",
          "Author": "TamarChristinaArm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-03T17:34:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1277",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-17T00:00:00-07:00",
        "FeedbackId": "600244479",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1277#issuecomment-600244479",
        "FeedbackMarkdown": "* We should consider using a custom type rather than a tuple to repesent lists, because we can expose more operations later. It also means people can\u0027t do things like taking the address of the tuple field. However, the nice thing about using tuples is language syntax. But we can probably get the same benefits if we were to define implicit conversion between the two. We can also a \u0060Deconstruct\u0060 directly on the custom type, allowing for tuple-style deconstructing into locals.\r\n* We don\u0027t think we\u0027re ready for the overloads that take multiple lists with more than value for .NET 5, due to necessary JIT implementation work\r\n* We approved the \u0060Arm32\u0060 version but commented them out b/c we won\u0027t be shipping them in .NET 5\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public partial class AdvSimd\r\n    {\r\n        public static Vector64\u003Cbyte\u003E  VectorTableLookup(Vector128\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        public static Vector64\u003Csbyte\u003E VectorTableLookup(Vector128\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n\r\n        public static Vector64\u003Cbyte\u003E  VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector128\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        public static Vector64\u003Csbyte\u003E VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector128\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n\r\n        // public partial class Arm32\r\n        // {\r\n        //    public static Vector64\u003Cbyte\u003E  VectorTableLookup(Vector64\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E  byteIndexes);\r\n        //    public static Vector64\u003Csbyte\u003E VectorTableLookup(Vector64\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n        //\r\n        //    public static Vector64\u003Cbyte\u003E  VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector64\u003Cbyte\u003E  table, Vector64\u003Cbyte\u003E byteIndexes);\r\n        //    public static Vector64\u003Csbyte\u003E VectorTableLookupExtension(Vector64\u003Cbyte\u003E defaultValues, Vector64\u003Csbyte\u003E table, Vector64\u003Csbyte\u003E byteIndexes);\r\n        // }\r\n\r\n        public partial class Arm64\r\n        {\r\n           public static Vector128\u003Cbyte\u003E  VectorTableLookup(Vector128\u003Cbyte\u003E  table, Vector128\u003Cbyte\u003E byteIndexes);\r\n           public static Vector128\u003Csbyte\u003E VectorTableLookup(Vector128\u003Csbyte\u003E table, Vector128\u003Csbyte\u003E byteIndexes);\r\n\r\n           public static Vector128\u003Cbyte\u003E  VectorTableLookupExtension(Vector128\u003Cbyte\u003E defaultValues, Vector128\u003Cbyte\u003E  table, Vector128\u003Cbyte\u003E  byteIndexes);\r\n           public static Vector128\u003Csbyte\u003E VectorTableLookupExtension(Vector128\u003Cbyte\u003E defaultValues, Vector128\u003Csbyte\u003E table, Vector128\u003Csbyte\u003E byteIndexes);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 47100000000,
        "Apis": [
          "M:AdvSimd.Arm64.VectorTableLookup(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookup(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookupExtension(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:AdvSimd.Arm64.VectorTableLookupExtension(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.VectorTableLookup(Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.VectorTableLookup(Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.VectorTableLookupExtension(Vector64\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:AdvSimd.VectorTableLookupExtension(Vector64\u003Cbyte\u003E,Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "IcE-wGQC_eM",
      "StartDateTime": "2020-03-24T10:03:58.488-07:00",
      "EndDateTime": "2020-03-24T12:34:33-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/IcE-wGQC_eM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 987,
          "Title": "HTTP version selection",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-17T19:00:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/987",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603384663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/987#issuecomment-603384663",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - We may want to change \u0060HttpVersionPolicy.RequestXxx\u0060 to \u0060HttpVersionPolicy.RequestedXxx\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class HttpClient\r\n    {\r\n        // Exists today - will be interpreted as Min or Max based on new API below.\r\n        // Version DefaultVersion { get; set; }\r\n        public HttpVersionPolicy DefaultVersionPolicy { get; set; } = HttpVersionPolicy.RequestVersionOrLower;\r\n    }\r\n\r\n    public partial class HttpRequestMessage\r\n    {\r\n        // Exists today - will be interpreted as Min or Max based on new API below.\r\n        // Version Version { get; set; }\r\n        public HttpVersionPolicy VersionPolicy { get; set; } = HttpVersionPolicy.RequestVersionOrLower;\r\n    }\r\n\r\n    public enum HttpVersionPolicy\r\n    {\r\n        RequestVersionOrLower,\r\n        RequestVersionOrHigher,\r\n        RequestVersionExact\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:HttpVersionPolicy.RequestVersionExact",
          "F:HttpVersionPolicy.RequestVersionOrHigher",
          "F:HttpVersionPolicy.RequestVersionOrLower",
          "P:HttpClient.DefaultVersionPolicy",
          "P:HttpRequestMessage.VersionPolicy",
          "T:HttpClient",
          "T:HttpRequestMessage",
          "T:HttpVersionPolicy"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28230,
          "Title": "Create APIs to deal with processing ASCII text (as bytes)",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-18T18:15:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28230",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603439786",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28230#issuecomment-603439786",
        "FeedbackMarkdown": "* \u0060Equals\u0060 ignores non-ASCII characters. Should it return \u0060false\u0060 or even throw?\r\n* \u0060IndexOf\u0060 et. al. should return \u0060-1\u0060 if the \u0022needle\u0022 contains non-ASCII characters; it\u0027s acceptable to return a successful match if the \u0022needle\u0022 is found in the \u0022haystack\u0022 and the haystack has non-ASCII anywhere (to the left or right of the match). IOW, only the \u0022needle\u0022 is validated, not the \u0022haystack\u0022.\r\n* It seems a bit odd that some APIs have both \u0060ReadOnlySpan\u003Cchar\u003E\u0060 and \u0060string\u0060 and some only have \u0060ReadOnlySpan\u003Cchar\u003E\u0060. We should make it consistent.\r\n* \u0060IsAllAscii\u0060, \u0060IsAsciiChar\u0060, \u0060IsAsciiByte\u0060 should be an overloaded \u0060IsAscii\u0060 method\r\n* We should drop \u0060Invariant\u0060 suffix (for the same reason we dropped \u0060Ordinal\u0060, it\u0027s all ASCII here)\r\n* \u0060ToLower()\u0060 / \u0060ToUpper()\u0060 should throw when destination is too small (returning the \u0060int\u0060 is still fine)\r\n* \u0060GetHashCodeOrdinalIgnoreCase()\u0060 should be \u0060GetHashCodeIgnoreCase()\u0060\r\n* \u0060ToString()\u0060 should be dropped in favor of \u0060Encoding.Ascii.GetString()\u0060\r\n* \u0060Trim\u0060, \u0060TrimStart\u0060, \u0060TrimEnd\u0060 should return \u0060Range\u0060 so that callers can do the right thing\r\n* \u0060GetTrimmedRange()\u0060 suggest that it returns the whitespace\r\n* Several parameters were renamed from \u0060buffer\u0060 to \u0060value\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Text\r\n{\r\n    public static class Ascii\r\n    {\r\n        // Compares two ASCII buffers for equality, optionally treating [A-Z] and [a-z] as equal.\r\n        // All non-ASCII bytes / chars are compared for pure binary equivalence.\r\n\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n        public static bool Equals(ReadOnlySpan\u003Cchar\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cbyte\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cchar\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n\r\n        // Compares an ASCII byte buffer and an ASCII char buffer for equality, optionally treating\r\n        // [A-Z] and [a-z] as equal. Returns false if the ASCII byte buffer contains any non-ASCII\r\n        // data or if the char buffer contains any element in the range [ 0080 .. FFFF ], as we\r\n        // wouldn\u0027t know what encoding to use to perform the transcode-then-compare operation.\r\n\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool Equals(ReadOnlySpan\u003Cbyte\u003E left, string right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, ReadOnlySpan\u003Cchar\u003E right);\r\n        public static bool EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E left, string right);\r\n\r\n        // Searches for the first occurrence of the target substring within the search space,\r\n        // optionally treating [A-Z] and [a-z] as equal. All non-ASCII bytes are compared for pure\r\n        // binary equivalence. Returns the index of where the first match is found, else returns -1.\r\n        // ADDENDUM: Also assume there are *Last equivalents of the following.\r\n\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cbyte\u003E value);\r\n\r\n        // Searches for the first occurrence of the target substring within the search space,\r\n        // optionally treating [A-Z] and [a-z] as equal. Returns the index of where the first match\r\n        // is found, else returns -1. If the target string contains any non-ASCII chars ([ 0080 .. FFFF ]),\r\n        // the search is assume to have failed, and the method returns -1.\r\n        // ADDENDUM: Also assume there are *Last equivalents of the following.\r\n\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int IndexOf(ReadOnlySpan\u003Cbyte\u003E text, string value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E text, string value);\r\n\r\n        // Given a buffer, returns the index of the first element in the buffer which\r\n        // is a non-ASCII byte, or -1 if the buffer is empty or all-ASCII. The bool-\r\n        // returning method is a convenience shortcut to perform the same check.\r\n\r\n        public static int GetIndexOfFirstNonAsciiByte(ReadOnlySpan\u003Cbyte\u003E buffer);\r\n        public static int GetIndexOfFirstNonAsciiChar(ReadOnlySpan\u003Cchar\u003E buffer);\r\n        public static bool IsAscii(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static bool IsAscii(ReadOnlySpan\u003Cchar\u003E value);\r\n\r\n        // Returns true iff the provided byte is an ASCII byte; i.e., in the range [ 00 .. 7F ];\r\n        // or if the provided char is in the range [ 0000 .. 007F ].\r\n\r\n        public static bool IsAscii(byte value);\r\n        public static bool IsAscii(char value);\r\n\r\n        // Copies source to destination, converting [A-Z] -\u003E [a-z] or vice versa during\r\n        // the copy. All values outside [A-Za-z] - including non-ASCII values - are unchanged\r\n        // during the copy.\r\n        //\r\n        // If source.Length \u003C= destination.Length, succeeds and returns source.Length (# bytes copied).\r\n        // If source.Length \u003E destination.Length, returns -1.\r\n\r\n        public static int ToLower(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n        public static int ToLower(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n        public static int ToUpper(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n        public static int ToUpper(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cchar\u003E destination);\r\n\r\n        // Performs case conversion ([A-Z] -\u003E [a-z] or vice versa) in-place. All values\r\n        // outside [A-Za-z] - including non-ASCII values - are unchanged.\r\n\r\n        public static void ToLowerInPlace(Span\u003Cbyte\u003E value);\r\n        public static void ToLowerInPlace(Span\u003Cchar\u003E value);\r\n        public static void ToUpperInPlace(Span\u003Cbyte\u003E value);\r\n        public static void ToUpperInPlace(Span\u003Cchar\u003E value);\r\n\r\n        // Performs case conversion on a single value, converting [A-Z] -\u003E [a-z] or vice versa.\r\n        // All values outside [A-Za-z] - including non-ASCII values - are unchanged.\r\n\r\n        public static byte ToLower(byte value);\r\n        public static byte ToLower(char value);\r\n        public static byte ToUpper(byte value);\r\n        public static byte ToUpper(char value);\r\n\r\n        // Returns a hash code for the provided buffer suitable for use in a dictionary or\r\n        // other keyed collection. For the OrdinalIgnoreCase method, the values [A-Z] and [a-z]\r\n        // are treated as equivalent during hash code computation. All non-ASCII values\r\n        // are treated as opaque data. The hash code is randomized but is not guaranteed to\r\n        // implement any particular algorithm, nor is it guaranteed to be a member of the same\r\n        // PRF family as other GetHashCode routines in the framework.\r\n\r\n        public static int GetHashCode(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int GetHashCode(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static int GetHashCodeIgnoreCase(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static int GetHashCodeIgnoreCase(ReadOnlySpan\u003Cchar\u003E value);\r\n\r\n        // Widens an ASCII buffer to UTF-16 or narrows a UTF-16 buffer to ASCII.\r\n        // Returns OperationStatus.InvalidData if the source buffer contains a non-ASCII byte\r\n        // or a char in the range [ 0080 .. FFFF ].\r\n        // OPEN QUESTION: Should we have an equivalent with Latin-1 semantics? Probably doesn\u0027t\r\n        // belong on the ASCII class if we do that.\r\n\r\n        public static OperationStatus WidenToUtf16(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cchar\u003E destination, out int bytesConsumed, out int charsWritten);\r\n        public static OperationStatus NarrowFromUTf16(ReadOnlySpan\u003Cchar\u003E source, Span\u003Cbyte\u003E destination, out int charsConsumed, out int bytesWritten);\r\n\r\n        // Trims only ASCII whitespace values from the buffer, returning the trimmed buffer.\r\n\r\n        public static Range Trim(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range Trim(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static Range TrimStart(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range TrimStart(ReadOnlySpan\u003Cchar\u003E value);\r\n        public static Range TrimEnd(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static Range TrimEnd(ReadOnlySpan\u003Cchar\u003E value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10100000000,
        "Apis": [
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.Equals(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.EqualsIgnoreCase(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetHashCode(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetHashCode(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetHashCodeIgnoreCase(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetHashCodeIgnoreCase(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.GetIndexOfFirstNonAsciiByte(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.GetIndexOfFirstNonAsciiChar(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOf(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.IndexOfIgnoreCase(ReadOnlySpan\u003Cbyte\u003E,string)",
          "M:Ascii.IsAscii(byte)",
          "M:Ascii.IsAscii(char)",
          "M:Ascii.IsAscii(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.IsAscii(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.NarrowFromUTf16(ReadOnlySpan\u003Cchar\u003E,Span\u003Cbyte\u003E,out int,out int)",
          "M:Ascii.ToLower(byte)",
          "M:Ascii.ToLower(char)",
          "M:Ascii.ToLower(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToLower(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:Ascii.ToLowerInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToLowerInPlace(Span\u003Cchar\u003E)",
          "M:Ascii.ToUpper(byte)",
          "M:Ascii.ToUpper(char)",
          "M:Ascii.ToUpper(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpper(ReadOnlySpan\u003Cchar\u003E,Span\u003Cchar\u003E)",
          "M:Ascii.ToUpperInPlace(Span\u003Cbyte\u003E)",
          "M:Ascii.ToUpperInPlace(Span\u003Cchar\u003E)",
          "M:Ascii.Trim(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.Trim(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.TrimEnd(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.TrimEnd(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.TrimStart(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Ascii.TrimStart(ReadOnlySpan\u003Cchar\u003E)",
          "M:Ascii.WidenToUtf16(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cchar\u003E,out int,out int)",
          "T:Ascii"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 26780,
          "Title": "Move appropriate parts of Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment into the shared framework",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-11T21:43:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26780",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603448231",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/26780#issuecomment-603448231",
        "FeedbackMarkdown": "* Looks good\r\n    - We like that we don\u0027t duplicate code between the native and the managed implementation\r\n    - However, we should make sure that other hosts can access the logic in the hosting APIs, so it seems they should expose an easy API to compute the current RID and set the \u0060AppContext\u0060 value (or make sure they are automatically set)\r\n* We should make it a property\r\n* It shouldn\u0027t return a nullable string, rather it should do a sensible fallback (either in the host or the managed side)\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enabled\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class RuntimeInformation\r\n    {\r\n        // The current OS RID, e.g.: win7-x64, osx.10.11-x64, ubuntu.18.04-arm64, rhel.7-x64\r\n        public static string RuntimeIdentifier { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61270000000,
        "Apis": [
          "P:RuntimeInformation.RuntimeIdentifier",
          "T:RuntimeInformation"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30820,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603451353",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30820#issuecomment-603451353",
        "FeedbackMarkdown": "It sounds like you need to design an extension point by making it class instead. That sounds reasonable, so we bumped it back to \u0060api-needs-work\u0060. Once you have a proposal, we can re-review.",
        "TimeCode": 69150000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30445,
          "Title": "Add a copy constructor to JsonSerializerOptions",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-01T01:07:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30445",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603455704",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30445#issuecomment-603455704",
        "FeedbackMarkdown": "* Looks good\r\n* This will only copy settings, no cache information\r\n* Converters that were added automatically (e.g. factories) should not be copied.\r\n* Let\u0027s use \u0060options\u0060 for the parameter name\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public sealed partial class JsonSerializerOptions\r\n    {\r\n        public JsonSerializerOptions(JsonSerializerOptions options)\r\n        {\r\n            /* Copy all options from source to a new JsonSerializerOptions instance. */\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 74900000000,
        "Apis": [
          "M:JsonSerializerOptions.JsonSerializerOptions(JsonSerializerOptions)",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30687,
          "Title": "System.Text.Json ignore only when null API enhancement",
          "Author": "CodeBlanch",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-27T00:56:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30687",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-03-24T00:00:00-07:00",
        "FeedbackId": "603461964",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30687#issuecomment-603461964",
        "FeedbackMarkdown": "* Looks good\r\n* We should have a follow-up for \u0060JsonSerializerOptions.IgnoreDefault\u0060 to support skipping value types.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public enum JsonIgnoreCondition\r\n    {\r\n        Always,\r\n        WhenNull,\r\n        Never\r\n    }\r\n\r\n    public partial class JsonIgnoreAttribute\r\n    {\r\n        public JsonIgnoreCondition Condition { get; set; };\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 81160000000,
        "Apis": [
          "F:JsonIgnoreCondition.Always",
          "F:JsonIgnoreCondition.Never",
          "F:JsonIgnoreCondition.WhenNull",
          "P:JsonIgnoreAttribute.Condition",
          "T:JsonIgnoreAttribute",
          "T:JsonIgnoreCondition"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "jQw5hiePju0",
      "StartDateTime": "2020-04-01T11:06:53.986-07:00",
      "EndDateTime": "2020-04-01T12:07:23-07:00",
      "Title": ".NET Design Review: WasmHttpHandler",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jQw5hiePju0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-wasm",
              "Color": "eb6420",
              "Description": "WebAssembly architecture"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-01T00:00:00-07:00",
        "FeedbackId": "607439446",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-607439446",
        "FeedbackMarkdown": "* **Shipping vehicle**. Which assembly should this go in? Should this be shipped out-of-band?\r\n* **Namespace**. We should consider either having a prefix for all types or introduce a new namespace.\r\n* **Scoping**. It seems those are really per request, having them on the handler seems problematic unless we say they are just defaults. But we\u0027d still need a way to pass them in per request.\r\n* **Mechanics**. It seems we all like the concept of a loose property bag over message that a handler can inspect to perform request specific operations. However, we don\u0027t like the loose typing of \u0060HttpRequestMessage.Properties\u0060 which is \u0060IDictionary\u003Cstring, object\u003E\u0060. It seems the easiest short term solution is an extension methods over \u0060HttpRequestMessage\u0060 like \u0060SetRequestCache\u0060/\u0060GetRequestCache\u0060 that will set/get the value in the property bag. Alternatively, we could expose a new type, such as \u0060HttpMessageOptions\u0060 that people can pass around and that we can be stored in \u0060HttpRequestMessage.Properties\u0060. This way, libraries can accept an \u0060HttpMessageOptions\u0060 and use that in case they are constructing HTTP messages themselves. @scalablecory also had [this idea](https://github.com/dotnet/runtime/issues/1793#issuecomment-607085294).\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nnamespace System.Net.Http\r\n{\r\n    public class WebAssemblyHttpHandler : HttpMessageHandler\r\n    {\r\n        public WebAssemblyHttpHandler();\r\n        public string? Integrity { get; set; }\r\n        public RequestCache? RequestCache { get; set; }\r\n        public RequestCredentials? RequestCredentials { get; set; }\r\n        public RequestMode? RequestMode { get; set; }\r\n        public bool StreamingEnabled { get; set; }\r\n    }\r\n    public enum RequestCache\r\n    {\r\n        Default = 0,\r\n        NoStore = 1,\r\n        Reload = 2,\r\n        NoCache = 3,\r\n        ForceCache = 4,\r\n        OnlyIfCached = 5,\r\n    }\r\n    public enum RequestCredentials\r\n    {\r\n        Omit = 0,\r\n        SameOrigin = 1,\r\n        Include = 2,\r\n    }\r\n    public enum RequestMode\r\n    {\r\n        SameOrigin = 0,\r\n        NoCors = 1,\r\n        Cors = 2,\r\n        Navigate = 3,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:RequestCache.Default",
          "F:RequestCache.ForceCache",
          "F:RequestCache.NoCache",
          "F:RequestCache.NoStore",
          "F:RequestCache.OnlyIfCached",
          "F:RequestCache.Reload",
          "F:RequestCredentials.Include",
          "F:RequestCredentials.Omit",
          "F:RequestCredentials.SameOrigin",
          "F:RequestMode.Cors",
          "F:RequestMode.Navigate",
          "F:RequestMode.NoCors",
          "F:RequestMode.SameOrigin",
          "M:WebAssemblyHttpHandler.WebAssemblyHttpHandler()",
          "P:WebAssemblyHttpHandler.Integrity",
          "P:WebAssemblyHttpHandler.RequestCache",
          "P:WebAssemblyHttpHandler.RequestCredentials",
          "P:WebAssemblyHttpHandler.RequestMode",
          "P:WebAssemblyHttpHandler.StreamingEnabled",
          "T:RequestCache",
          "T:RequestCredentials",
          "T:RequestMode",
          "T:WebAssemblyHttpHandler"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "POdrqNOlY5g",
      "StartDateTime": "2020-04-07T10:04:11.783-07:00",
      "EndDateTime": "2020-04-07T12:19:30-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/POdrqNOlY5g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 862,
          "Title": "Consider exposing Socket(SafeSocketHandle fd) constructor",
          "Author": "dmirmilshteyn",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-11-27T22:33:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/862",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610520669",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/862#issuecomment-610520669",
        "FeedbackMarkdown": "Looks good as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        public Socket(SafeSocketHandle handle);\r\n    }\r\n}\r\n\u0060\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Socket.Socket(SafeSocketHandle)",
          "T:Socket"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33206,
          "Title": "MemoryMappedFile constructor",
          "Author": "carlossanlop",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-05T02:00:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33206",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610526663",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33206#issuecomment-610526663",
        "FeedbackMarkdown": "* We\u0027re fine with taking the \u0060handle\u0060 parameter but we have concerns with the \u0060fileStream\u0060 parameter because it seems plumbing, not part of a sensible API.\r\n  * Option 1: Move the implementation from the higher level assembly to the assembly containing \u0060MemoryMappedFile\u0060 (while the ref assembly setup)\r\n  * Option 2.1 \u0022Smuggle\u0022 the file stream via the \u0060SafeMemoryMappedFileHandle\u0060 via a field\r\n  * Option 2.2 \u0022Smuggle\u0022 the file stream via the \u0060SafeMemoryMappedFileHandle\u0060 unsealing \u0026 deriving from \u0060SafeMemoryMappedFileHandle\u0060\r\n  * Option 3: do what\u0027s proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.MemoryMappedFiles\r\n{\r\n    public partial class MemoryMappedFile\r\n    {\r\n        public MemoryMappedFile(SafeMemoryMappedFileHandle handle, IDisposable fileStream);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15950000000,
        "Apis": [
          "M:MemoryMappedFile.MemoryMappedFile(SafeMemoryMappedFileHandle,IDisposable)",
          "T:MemoryMappedFile"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33618,
          "Title": "Implement IAsyncDisposable for XmlWriter and XmlReader",
          "Author": "buyaa-n",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-16T05:41:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33618",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Xml",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610535975",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33618#issuecomment-610535975",
        "FeedbackMarkdown": "* We should not make \u0060XmlReader\u0060 implement \u0060IAsyncDisposable\u0060\r\n* We should not have a \u0060CloseAsync\u0060\r\n* We don\u0027t want a cancelable \u0060DisposeAsync\u0060, for scenarios that need that we add an overload to \u0060FlushAsync\u0060 that accepts a cancellation token. We generally want to dispose resources even when you\u0027re cancelled.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Xml\r\n{\r\n    public partial class XmlWriter : IAsyncDisposable\r\n    {\r\n        public ValueTask DisposeAsync();\r\n        protected virtual ValueTask DisposeAsyncCore();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23060000000,
        "Apis": [
          "M:XmlWriter.DisposeAsync()",
          "M:XmlWriter.DisposeAsyncCore()",
          "T:XmlWriter"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34439,
          "Title": "Provide opt-in for custom converters to handle null",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-02T04:20:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34439",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610556104",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34439#issuecomment-610556104",
        "FeedbackMarkdown": "* In this proposal the converter is only called when a \u0060null\u0060 value is included in the payload. If the property is missing in the payload, the the convert still won\u0027t be called. Does this satisfy the customer request? While this should probably be an independent feature it seems we\u0027ll want to make sure the design for both will work well together.\r\n* Should this be on the non-generic base \u0060JsonConverter\u0060?\r\n  * We concluded no, because the \u0060Read\u0060/\u0060Write\u0060 methods are also only on \u0060JsonConverter\u003CT\u003E\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class JsonConverter\u003CT\u003E\r\n    {\r\n        public virtual bool HandleNull { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34330000000,
        "Apis": [
          "P:JsonConverter\u003CT\u003E.HandleNull",
          "T:JsonConverter\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34558,
          "Title": "JsonSerializer support for fields \u0026 non-public accessors",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-05T05:20:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34558",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-07T00:00:00-07:00",
        "FeedbackId": "610571471",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34558#issuecomment-610571471",
        "FeedbackMarkdown": "* Let\u0027s rename \u0060JsonMemberAttribute\u0060 to \u0060JsonIncludeAttribute\u0060\r\n* We should change \u0060JsonIgnoreAttribute\u0060 to include fields\r\n* We don\u0027t see a need for \u0060JsonObjectAttribute\u0060 it should be a per property/field decisions\r\n* We should treat read-only fields like get-only properties\r\n* We can decide to support private/internal fields/properties by applying \u0060JsonInclude\u0060, but we need think through implications for AOT (generating the serialzier as part of the type would make this possible tho)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public bool IncludeFields { get; set; }\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    [AttributeUsage(AttributeTargets.Property |\r\n                    Attributes.Field, AllowMultiple = false)]\r\n    public sealed class JsonIncludeAttribute : JsonAttribute\r\n    {\r\n        public JsonIncludeAttribute();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59750000000,
        "Apis": [
          "M:JsonIncludeAttribute.JsonIncludeAttribute()",
          "P:JsonSerializerOptions.IncludeFields",
          "T:JsonIncludeAttribute",
          "T:JsonSerializerOptions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Ttscz2mBl-c",
      "StartDateTime": "2020-04-16T10:06:06.298-07:00",
      "EndDateTime": "2020-04-16T12:30:25-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Ttscz2mBl-c/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34626,
          "Title": "Don\u0027t forget about JsonSerializerOptions.CreateForWeb()",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-07T04:33:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34626",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34626#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33328,
          "Title": "OSPlatform support for WASM/Blazor",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-07T05:04:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33328",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-wasm",
              "Color": "eb6420",
              "Description": "WebAssembly architecture"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614802442",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33328#issuecomment-614802442",
        "FeedbackMarkdown": "* We considered expanding \u0060Wasm\u0060 to \u0060WebAssembly\u0060, but the RIDs will use \u0060wasm\u0060, so it makes more sense to aling the names.\r\n* Should \u0060OSPlatform.IsOSPlatform(OSPlatform.Windows)\u0060 return \u0060true\u0060 when running inside a browser on Windows. We concluded no, because that would likely break more people. Parties who care, need to use a more specific API that returns, for example, the user agent string.\r\n* @marek-safar what are the plans for the RIDs? It would be logical to call the RID \u0060browser-wasm\u0060, akin to \u0060win-x86\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial enum Architecture\r\n    {\r\n         Wasm\r\n    }\r\n    public partial struct OSPlatform\r\n    {\r\n         public static OSPlatform Browser { get; } = new OSPlatform(nameof(Browser));\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 4570000000,
        "Apis": [
          "F:Architecture.Wasm",
          "P:OSPlatform.Browser",
          "T:Architecture",
          "T:OSPlatform"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33331,
          "Title": "Guarding calls to platform-specific APIs",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-07T06:36:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33331",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614826740",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33331#issuecomment-614826740",
        "FeedbackMarkdown": "Some notes:\r\n\r\n* Right now \u0060OSPlatform\u0060 compares \u0060Ordinal\u0060, not \u0060OrdinalIgnoreCase\u0060. Unfortuantely, the field names don\u0027t match the strings passed to the constructor, which means \u0060nameof(OSPlaform.Windows)\u0060 and \u0060OSPlatform.Windows.ToString()\u0060 return different values. We should make the comparisons \u0060OrdinalIgnoreCase\u0060.\r\n* We shouldn\u0027t add \u0060macOS\u0060 and reuse \u0060OSX\u0060\r\n* We should allow multiple attributes to be applied\r\n* Maybe we should move \u0060Url\u0060 to \u0060OSPlatformVersionAttribute\u0060?",
        "TimeCode": 28360000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34978,
          "Title": "\u0060InitOnlyAttribute\u0060",
          "Author": "jcouv",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-15T00:08:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34978",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-16T00:00:00-07:00",
        "FeedbackId": "614845405",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34978#issuecomment-614845405",
        "FeedbackMarkdown": "* Seems like we should think about how reflections work with this feature\r\n    - Reflection doesn\u0027t honor \u0060modreq.\r\n    - Should we have a reflection feature for init only? It would construct, init, and call the validator. \u0060PropertyInfo.SetValue\u0060 could block setting init only.\r\n* Serializers probably need to handle \u0060init\u0060 setters (as in, they shoud be able to call them)\r\n* ModReqs and ModOpts are usually plain marker types, not attributes. The reason this was made an attribute was to make reflection easier, but it seems we should have a reflection API anyway in which case it doesn\u0027t matter. We should be consistent with existing modifier types and not derive from attribute.\r\n* We should prefix it with \u0060Is\u0060 to be consistent with the other modifier types\r\n* It was asked whether it only applies to properties and the answer is no, it might apply to fields and methods in the future, so the name should be generic\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public sealed class IsInitOnly\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54850000000,
        "Apis": [
          "T:IsInitOnly"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1GkjoDSR7dE",
      "StartDateTime": "2020-04-23T10:00:16-07:00",
      "EndDateTime": "2020-04-23T12:17:23-07:00",
      "Title": ".NET Design Review: GitHub Quick Reviews (Apr 23)",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1GkjoDSR7dE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33861,
          "Title": "Add DynamicallyAccessedMembersAttribute",
          "Author": "MichalStrehovsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-20T14:32:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33861",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618548274",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33861#issuecomment-618548274",
        "FeedbackMarkdown": "* What about \u0060MetadataLoadContext\u0060?\r\n\t- Will need to make use of supressions, there is a separate attribute for that\r\n* It feels the defaults are flipped\r\n\t- We should have \u0060PublicMethods\u0060 and \u0060NonPublicMethods\u0060 to make it clear what\u0027s being returned\r\n\t- The semantics should match \u0060BindingFlags\u0060\r\n* Are attributes kept?\r\n\t- Depends, but there is a discussion on trimming those too\r\n* Should the enum have an \u0022All\u0022 member?\r\n* We should have a \u0060None\u0060 member with value \u00600\u0060\r\n* We should make sure the attribute can only be applied once is not inherited\r\n* The linker tooling should warn if the attribute is applied to things that aren\u0027t \u0060System.Type\u0060 or \u0060System.String\u0060, the linker should warn\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(\r\n        AttributeTargets.Field |\r\n        AttributeTargets.ReturnValue |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property)]\r\n    public sealed class DynamicallyAccessedMembersAttribute : Attribute\r\n    {\r\n        public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberKinds memberKinds)\r\n        {\r\n            MemberKinds = memberKinds;\r\n        }\r\n\r\n        public DynamicallyAccessedMemberKinds MemberKinds { get; }\r\n    }\r\n\r\n    [Flags]\r\n    public enum DynamicallyAccessedMemberKinds\r\n    {\r\n        DefaultConstructor  = 0b00000000_00000001,\r\n        PublicConstructors  = 0b00000000_00000011,\r\n        Constructors        = 0b00000000_00000111,\r\n        PublicMethods       = 0b00000000_00001000,\r\n        Methods             = 0b00000000_00011000,\r\n        PublicFields        = 0b00000000_00100000,\r\n        Fields              = 0b00000000_01100000,\r\n        PublicNestedTypes   = 0b00000000_10000000,\r\n        NestedTypes         = 0b00000001_10000000,\r\n        PublicProperties    = 0b00000010_00000000,\r\n        Properties          = 0b00000110_00000000,\r\n        PublicEvents        = 0b00001000_00000000,\r\n        Events              = 0b00011000_00000000,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:DynamicallyAccessedMemberKinds.Constructors",
          "F:DynamicallyAccessedMemberKinds.DefaultConstructor",
          "F:DynamicallyAccessedMemberKinds.Events",
          "F:DynamicallyAccessedMemberKinds.Fields",
          "F:DynamicallyAccessedMemberKinds.Methods",
          "F:DynamicallyAccessedMemberKinds.NestedTypes",
          "F:DynamicallyAccessedMemberKinds.Properties",
          "F:DynamicallyAccessedMemberKinds.PublicConstructors",
          "F:DynamicallyAccessedMemberKinds.PublicEvents",
          "F:DynamicallyAccessedMemberKinds.PublicFields",
          "F:DynamicallyAccessedMemberKinds.PublicMethods",
          "F:DynamicallyAccessedMemberKinds.PublicNestedTypes",
          "F:DynamicallyAccessedMemberKinds.PublicProperties",
          "M:DynamicallyAccessedMembersAttribute.DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberKinds)",
          "P:DynamicallyAccessedMembersAttribute.MemberKinds",
          "T:DynamicallyAccessedMemberKinds",
          "T:DynamicallyAccessedMembersAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35339,
          "Title": "Add SuppressLinkerWarningAttribute",
          "Author": "MichalStrehovsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-23T14:23:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35339",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            },
            {
              "Name": "untriaged",
              "Color": "fbca04",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618570506",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35339#issuecomment-618570506",
        "FeedbackMarkdown": "* We should position it as a peer to \u0060SuppressMessageAttribute\u0060, \u0060UnconditionalSuppressMessageAttribute\u0060\r\n* It should be \u0060System.Diagnostics.CodeAnalysis\u0060\r\n* The behavior is the same, except it\u0027s not marked \u0060[Conditonal]\u0060 and thus will always remain in metadata \r\n* We considered establishing an inheritance relationshop with \u0060SuppressMessageAttribute\u0060 but concluded we don\u0027t need it (neither for docs nor for consumption)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]\r\n    public sealed class UnconditionalSuppressMessageAttribute : Attribute\r\n    {\r\n    \t// Same API as SuppressMessageAttribute\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28950000000,
        "Apis": [
          "T:UnconditionalSuppressMessageAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30902,
          "Title": "Consider PreserveDependencyAttribute to help linker",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-19T16:08:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30902",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-04-23T00:00:00-07:00",
        "FeedbackId": "618601805",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30902#issuecomment-618601805",
        "FeedbackMarkdown": "* It seems wild cards are also supported, which raises a few questions:\r\n\t- Does it include private and public APIs or just public?\r\n\t- How hard is it for upstream dependencies to implement (e.g. ILSpy or VS Find All Usages)\r\n\t- Do we need them? We\u0027d like because it seems [there are places](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Linq.Expressions/src/System/Runtime/CompilerServices/CallSite.cs#L278-L319) where we have a lot.\r\n* The linker should at least warn when the strings can\u0027t be matched\r\n* \u0060typeName\u0060 and \u0060assemblyName\u0060 are optional because they default to same and same assembly\r\n* Looks like \u0060memberSignature\u0060 should be non-nullable\r\n* Condition is some specific string that is interpreted by the linker, today that\u0027s only \u0060DEBUG\u0060 (which unfortunately doesn\u0027t map to the C# notion of compiling a debug build)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.Method |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Field,\r\n                    AllowMultiple = true,\r\n                    Inherited = false)]\r\n    public sealed class DynamicDependencyAttribute : Attribute\r\n    {\r\n        public DynamicDependencyAttribute(string memberSignature);\r\n        public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);\r\n        public DynamicDependencyAttribute(DynamicallyAccessedMemberKinds memberKinds, string typeName, string assemblyName);\r\n\r\n        public DynamicDependencyAttribute(string memberSignature, Type type);\r\n        public DynamicDependencyAttribute(DynamicallyAccessedMemberKinds memberKinds, Type type);\r\n\r\n        public DynamicallyAccessedMemberKinds? MemberKinds { get; }\r\n        public string? MemberSignature { get; }\r\n        public string? TypeName { get; }\r\n        public string? AssemblyName { get; }\r\n        public string? Condition { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50620000000,
        "Apis": [
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(DynamicallyAccessedMemberKinds,string,string)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(DynamicallyAccessedMemberKinds,Type)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string,string,string)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string,Type)",
          "M:DynamicDependencyAttribute.DynamicDependencyAttribute(string)",
          "P:DynamicDependencyAttribute.AssemblyName",
          "P:DynamicDependencyAttribute.Condition",
          "P:DynamicDependencyAttribute.MemberKinds",
          "P:DynamicDependencyAttribute.MemberSignature",
          "P:DynamicDependencyAttribute.TypeName",
          "T:DynamicDependencyAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34587,
          "Title": "Add empty X64/Arm64 nested classes to some System.Runtime.Intrinsics",
          "Author": "EgorBo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-06T14:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34587",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624197774",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34587#issuecomment-624197774",
        "FeedbackMarkdown": "* The problem makes sense, but instead of giving \u0060IsSupported\u0060 behavior, it might be better to hide the nested classes entirely and make calling \u0060IsSupported\u0060 a compile-time error:\r\n\r\n\u0060\u0060\u0060C#\r\n    partial class Sha1 : ArmBase\r\n    {\r\n        [EditorBrowsable(Never)]\r\n        public abstract class Arm64            \r\n        {\r\n            // No inheritance, no IsSupported\r\n        }\r\n    }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:Sha1",
          "T:Sha1.Arm64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34929,
          "Title": "Consider adding Vector64\u003Cdouble\u003E.CreateScalar, Vector64\u003Culong\u003ECreateScalar and Vector64\u003Clong\u003E.CreateScalar or renaming Create",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-14T00:24:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34929",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624200505",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34929#issuecomment-624200505",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public partial class Vector64\r\n    {\r\n        public static unsafe Vector64\u003Cdouble\u003E CreateScalar(double value);\r\n        public static unsafe Vector64\u003Clong\u003E   CreateScalar(long value);\r\n        public static unsafe Vector64\u003Culong\u003E  CreateScalar(ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Vector64.CreateScalar(double)",
          "M:Vector64.CreateScalar(long)",
          "M:Vector64.CreateScalar(ulong)",
          "T:Vector64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35037,
          "Title": "[Arm64] \u0022Move\u0022 Intrinsics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-16T02:04:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35037",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624211066",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35037#issuecomment-624211066",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* Should there be an \u0060InsertSelectedScalar\u0060 that returns \u0060Vector64\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Duplicate general-purpose register to vector\r\n        /// For each element result[elem] = value\r\n        /// Corresponds to vector forms of DUP and VDUP\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E    DuplicateToVector64(byte value);\r\n        Vector64\u003Cshort\u003E   DuplicateToVector64(short value);\r\n        Vector64\u003Cint\u003E     DuplicateToVector64(int value);\r\n        Vector64\u003Csbyte\u003E   DuplicateToVector64(sbyte value);\r\n        Vector64\u003Cushort\u003E  DuplicateToVector64(ushort value);\r\n        Vector64\u003Cuint\u003E    DuplicateToVector64(uint value);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateToVector128(byte value);\r\n        Vector128\u003Cshort\u003E  DuplicateToVector128(short value);\r\n        Vector128\u003Cint\u003E    DuplicateToVector128(int value);\r\n        Vector128\u003Csbyte\u003E  DuplicateToVector128(sbyte value);\r\n        Vector128\u003Cushort\u003E DuplicateToVector128(ushort value);\r\n        Vector128\u003Cuint\u003E   DuplicateToVector128(uint value);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Duplicate vector element to vector\r\n        /// For each element result[elem] = value[index]\r\n        /// Corresponds to vector forms of DUP and VDUP\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E    DuplicateSelectedScalarToVector64(Vector64\u003Cbyte\u003E value,     byte index);\r\n        Vector64\u003Cshort\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Cshort\u003E value,    byte index);\r\n        Vector64\u003Cint\u003E     DuplicateSelectedScalarToVector64(Vector64\u003Cint\u003E value,      byte index);\r\n        Vector64\u003Cfloat\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Cfloat\u003E value,    byte index);\r\n        Vector64\u003Csbyte\u003E   DuplicateSelectedScalarToVector64(Vector64\u003Csbyte\u003E value,    byte index);\r\n        Vector64\u003Cushort\u003E  DuplicateSelectedScalarToVector64(Vector64\u003Cushort\u003E value,   byte index);\r\n        Vector64\u003Cuint\u003E    DuplicateSelectedScalarToVector64(Vector64\u003Cuint\u003E value,     byte index);\r\n\r\n        Vector64\u003Cbyte\u003E    DuplicateSelectedScalarToVector64(Vector128\u003Cbyte\u003E value,     byte index);\r\n        Vector64\u003Cshort\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Cshort\u003E value,    byte index);\r\n        Vector64\u003Cint\u003E     DuplicateSelectedScalarToVector64(Vector128\u003Cint\u003E value,      byte index);\r\n        Vector64\u003Cfloat\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Cfloat\u003E value,    byte index);\r\n        Vector64\u003Csbyte\u003E   DuplicateSelectedScalarToVector64(Vector128\u003Csbyte\u003E value,    byte index);\r\n        Vector64\u003Cushort\u003E  DuplicateSelectedScalarToVector64(Vector128\u003Cushort\u003E value,   byte index);\r\n        Vector64\u003Cuint\u003E    DuplicateSelectedScalarToVector64(Vector128\u003Cuint\u003E value,     byte index);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateSelectedScalarToVector128(Vector64\u003Cbyte\u003E value,    byte index);\r\n        Vector128\u003Cshort\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Cshort\u003E value,   byte index);\r\n        Vector128\u003Cint\u003E    DuplicateSelectedScalarToVector128(Vector64\u003Cint\u003E value,     byte index);\r\n        Vector128\u003Cfloat\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Cfloat\u003E value,   byte index);\r\n        Vector128\u003Csbyte\u003E  DuplicateSelectedScalarToVector128(Vector64\u003Csbyte\u003E value,   byte index);\r\n        Vector128\u003Cushort\u003E DuplicateSelectedScalarToVector128(Vector64\u003Cushort\u003E value,  byte index);\r\n        Vector128\u003Cuint\u003E   DuplicateSelectedScalarToVector128(Vector64\u003Cuint\u003E value,    byte index);\r\n\r\n        Vector128\u003Cbyte\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Cbyte\u003E value,   byte index);\r\n        Vector128\u003Cdouble\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cdouble\u003E value, byte index);\r\n        Vector128\u003Cshort\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Cshort\u003E value,  byte index);\r\n        Vector128\u003Cint\u003E    DuplicateSelectedScalarToVector128(Vector128\u003Cint\u003E value,    byte index);\r\n        Vector128\u003Clong\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Clong\u003E value,   byte index);\r\n        Vector128\u003Cfloat\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Cfloat\u003E value,  byte index);\r\n        Vector128\u003Csbyte\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Csbyte\u003E value,  byte index);\r\n        Vector128\u003Cushort\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cushort\u003E value, byte index);\r\n        Vector128\u003Cuint\u003E   DuplicateSelectedScalarToVector128(Vector128\u003Cuint\u003E value,   byte index);\r\n        Vector128\u003Culong\u003E  DuplicateSelectedScalarToVector128(Vector128\u003Culong\u003E value,  byte index);\r\n\r\n        public abstract class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Duplicate general-purpose register to vector\r\n            /// For each element result[elem] = value\r\n            /// Corresponds to vector forms of DUP\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Clong\u003E   DuplicateToVector64(long value);\r\n            Vector128\u003Culong\u003E  DuplicateToVector64(ulong value);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Insert vector element from another vector element\r\n            /// result[resultIndex] = value[valueIndex]\r\n            /// Corresponds to vector forms of INS\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E   InsertSelectedScalar(Vector128\u003Cbyte\u003E result,   byte resultIndex, Vector64\u003Cbyte\u003E value,    byte valueIndex);\r\n            Vector128\u003Cshort\u003E  InsertSelectedScalar(Vector128\u003Cshort\u003E result,  byte resultIndex, Vector64\u003Cshort\u003E value,   byte valueIndex);\r\n            Vector128\u003Cint\u003E    InsertSelectedScalar(Vector128\u003Cint\u003E result,    byte resultIndex, Vector64\u003Cint\u003E value,     byte valueIndex);\r\n            Vector128\u003Cfloat\u003E  InsertSelectedScalar(Vector128\u003Cfloat\u003E result,  byte resultIndex, Vector64\u003Cfloat\u003E value,   byte valueIndex);\r\n            Vector128\u003Csbyte\u003E  InsertSelectedScalar(Vector128\u003Csbyte\u003E result,  byte resultIndex, Vector64\u003Csbyte\u003E value,   byte valueIndex);\r\n            Vector128\u003Cushort\u003E InsertSelectedScalar(Vector128\u003Cushort\u003E result, byte resultIndex, Vector64\u003Cushort\u003E value,  byte valueIndex);\r\n            Vector128\u003Cuint\u003E   InsertSelectedScalar(Vector128\u003Cuint\u003E result,   byte resultIndex, Vector64\u003Cuint\u003E value,    byte valueIndex);\r\n\r\n            Vector128\u003Cbyte\u003E   InsertSelectedScalar(Vector128\u003Cbyte\u003E result,   byte resultIndex, Vector128\u003Cbyte\u003E value,   byte valueIndex);\r\n            Vector128\u003Cdouble\u003E InsertSelectedScalar(Vector128\u003Cdouble\u003E result, byte resultIndex, Vector128\u003Cdouble\u003E value, byte valueIndex);\r\n            Vector128\u003Cshort\u003E  InsertSelectedScalar(Vector128\u003Cshort\u003E result,  byte resultIndex, Vector128\u003Cshort\u003E value,  byte valueIndex);\r\n            Vector128\u003Cint\u003E    InsertSelectedScalar(Vector128\u003Cint\u003E result,    byte resultIndex, Vector128\u003Cint\u003E value,    byte valueIndex);\r\n            Vector128\u003Clong\u003E   InsertSelectedScalar(Vector128\u003Clong\u003E result,   byte resultIndex, Vector128\u003Clong\u003E value,   byte valueIndex);\r\n            Vector128\u003Cfloat\u003E  InsertSelectedScalar(Vector128\u003Cfloat\u003E result,  byte resultIndex, Vector128\u003Cfloat\u003E value,  byte valueIndex);\r\n            Vector128\u003Csbyte\u003E  InsertSelectedScalar(Vector128\u003Csbyte\u003E result,  byte resultIndex, Vector128\u003Csbyte\u003E value,  byte valueIndex);\r\n            Vector128\u003Cushort\u003E InsertSelectedScalar(Vector128\u003Cushort\u003E result, byte resultIndex, Vector128\u003Cushort\u003E value, byte valueIndex);\r\n            Vector128\u003Cuint\u003E   InsertSelectedScalar(Vector128\u003Cuint\u003E result,   byte resultIndex, Vector128\u003Cuint\u003E value,   byte valueIndex);\r\n            Vector128\u003Culong\u003E  InsertSelectedScalar(Vector128\u003Culong\u003E result,  byte resultIndex, Vector128\u003Culong\u003E value,  byte valueIndex);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.DuplicateToVector64(long)",
          "M:AdvSimd.Arm64.DuplicateToVector64(ulong)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cbyte\u003E,byte,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cbyte\u003E,byte,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cdouble\u003E,byte,Vector128\u003Cdouble\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cfloat\u003E,byte,Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cfloat\u003E,byte,Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cint\u003E,byte,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cint\u003E,byte,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Clong\u003E,byte,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Csbyte\u003E,byte,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Csbyte\u003E,byte,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cshort\u003E,byte,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cshort\u003E,byte,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cuint\u003E,byte,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cuint\u003E,byte,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Culong\u003E,byte,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cushort\u003E,byte,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cushort\u003E,byte,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cdouble\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cfloat\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.DuplicateToVector128(byte)",
          "M:AdvSimd.DuplicateToVector128(int)",
          "M:AdvSimd.DuplicateToVector128(sbyte)",
          "M:AdvSimd.DuplicateToVector128(short)",
          "M:AdvSimd.DuplicateToVector128(uint)",
          "M:AdvSimd.DuplicateToVector128(ushort)",
          "M:AdvSimd.DuplicateToVector64(byte)",
          "M:AdvSimd.DuplicateToVector64(int)",
          "M:AdvSimd.DuplicateToVector64(sbyte)",
          "M:AdvSimd.DuplicateToVector64(short)",
          "M:AdvSimd.DuplicateToVector64(uint)",
          "M:AdvSimd.DuplicateToVector64(ushort)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33398,
          "Title": "ARM additional shifting intrinsics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-09T19:45:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33398",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-05T00:00:00-07:00",
        "FeedbackId": "624242885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33398#issuecomment-624242885",
        "FeedbackMarkdown": "* We should rename the \u0060shift\u0060 parameter to \u0060count\u0060\r\n* What happens when the vector-based counts are too large?\r\n* Some of the upper variants under \u0060Arm64\u0060 seem to belong to \u0060AdvSimd\u0060\r\n* Do we need \u0060SignExtendAndWidenLower\u0060, \u0060ZeroExtendAndWidenLower\u0060, \u0060SignExtendAndWidenUpper\u0060, SignExtendAndWidenUpper\u0060 at all?\r\n    - If we expose them, we need to drop the \u0060count\u0060 parameter\r\n* Should we change the encoding of methods and instead of making up Markov-chain-like method names take arguments (e.g. \u0060bool round\u0060 or \u0060SomeFlags flags\u0060)? The concern is metadata size.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of USHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogical(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogical(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogical(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogical(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogical(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogical(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogical(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogical(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogical(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogical(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogical(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogical(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogical(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogical(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of URSHL and VRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalRounded(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalRounded(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalRounded(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalRounded(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalRounded(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalRounded(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalRounded(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalRounded(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalRounded(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalRounded(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalRounded(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalRounded(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalRounded(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalRounded(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalRoundedScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalRoundedScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SSHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmetic(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmetic(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmetic(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmetic(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmetic(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmetic(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmetic(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SRSHL and VRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticRounded(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticRounded(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticRounded(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticRounded(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticRounded(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticRounded(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticRounded(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticRoundedScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of UQSHL and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalSaturate(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalSaturate(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalSaturate(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalSaturate(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalSaturate(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalSaturate(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalSaturate(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalSaturateScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of UQRSHL and VQRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Csbyte\u003E ShiftLogicalRoundedSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cushort\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector64\u003Cuint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Cbyte\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftLogicalRoundedSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cushort\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cushort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Cuint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cuint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftLogicalRoundedSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n        Vector128\u003Culong\u003E ShiftLogicalRoundedSaturate(Vector128\u003Culong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n        Vector64\u003Culong\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Culong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SQSHL and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Rounding Shift Left\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n        /// Corresponds to vector forms of SQRSHL and VQRSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n        Vector64\u003Cshort\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n        Vector64\u003Cint\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n        Vector128\u003Csbyte\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Csbyte\u003E value, Vector128\u003Csbyte\u003E count);\r\n        Vector128\u003Cshort\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Cshort\u003E value, Vector128\u003Cshort\u003E count);\r\n        Vector128\u003Cint\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Cint\u003E value, Vector128\u003Cint\u003E count);\r\n        Vector128\u003Clong\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Clong\u003E value, Vector128\u003Clong\u003E count);\r\n\r\n        Vector64\u003Clong\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Clong\u003E value, Vector64\u003Clong\u003E count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Left Immediate\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SHL and VSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogical(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftLeftLogical(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftLeftLogical(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogical(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftLeftLogical(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogical(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogical(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftLeftLogical(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftLeftLogical(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogical(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogical(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogical(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogical(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogical(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLeftLogicalScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Right Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of USHR and VSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogical(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogical(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogical(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogical(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogical(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogical(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogical(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogical(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogical(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogical(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogical(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogical(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogical(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogical(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Right Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of URSHR and VRSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalRounded(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalRounded(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalRounded(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalRounded(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalRounded(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalRounded(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalRounded(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalRounded(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalRounded(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalRounded(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalRounded(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalRounded(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalRounded(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalRounded(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalRoundedScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalRoundedScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Right Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SSHR and VSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmetic(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmetic(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmetic(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmetic(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmetic(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmetic(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmetic(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Right Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of SRSHR and VRSHR\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticRounded(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticRounded(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticRounded(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticRounded(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticRounded(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticRounded(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticRounded(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticRoundedScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E shift)\r\n        /// Corresponds to vector forms of USRA and VSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAdd(Vector64\u003Cbyte\u003E addend, Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAdd(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAdd(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAdd(Vector64\u003Cushort\u003E addend, Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAdd(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAdd(Vector64\u003Cuint\u003E addend, Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalAdd(Vector128\u003Cbyte\u003E addend, Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalAdd(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalAdd(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalAdd(Vector128\u003Cushort\u003E addend, Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalAdd(Vector128\u003Cuint\u003E addend, Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalAdd(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalAdd(Vector128\u003Culong\u003E addend, Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalAddScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalAddScalar(Vector64\u003Culong\u003E addend, Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E shift)\r\n        /// Corresponds to vector forms of SSRA and VSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAdd(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAdd(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAdd(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticAdd(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticAdd(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticAdd(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticAddScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Rounding Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E RoundedShift)\r\n        /// Corresponds to vector forms of URSRA and VRSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAddRounded(Vector64\u003Cbyte\u003E addend, Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAddRounded(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAddRounded(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAddRounded(Vector64\u003Cushort\u003E addend, Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAddRounded(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAddRounded(Vector64\u003Cuint\u003E addend, Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftRightLogicalAddRounded(Vector128\u003Cbyte\u003E addend, Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightLogicalAddRounded(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightLogicalAddRounded(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftRightLogicalAddRounded(Vector128\u003Cushort\u003E addend, Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightLogicalAddRounded(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftRightLogicalAddRounded(Vector128\u003Cuint\u003E addend, Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightLogicalAddRounded(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftRightLogicalAddRounded(Vector128\u003Culong\u003E addend, Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightLogicalAddRoundedScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftRightLogicalAddRoundedScalar(Vector64\u003Culong\u003E addend, Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Rounding Shift Right and Accumulate\r\n        /// For each element result[elem] = addend[elem] \u002B (value[elem] \u003E\u003E RoundedShift)\r\n        /// Corresponds to vector forms of SRSRA and VRSRA\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAddRounded(Vector64\u003Csbyte\u003E addend, Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAddRounded(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAddRounded(Vector64\u003Cint\u003E addend, Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftRightArithmeticAddRounded(Vector128\u003Csbyte\u003E addend, Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftRightArithmeticAddRounded(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftRightArithmeticAddRounded(Vector128\u003Cint\u003E addend, Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftRightArithmeticAddRounded(Vector128\u003Clong\u003E addend, Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftRightArithmeticAddRoundedScalar(Vector64\u003Clong\u003E addend, Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left and Unsigned Saturating Shift Left\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SQSHL, UQSHL, and VQSHL\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogicalSaturate(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector64\u003Csbyte\u003E ShiftLeftLogicalSaturate(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftLeftLogicalSaturate(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogicalSaturate(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogicalSaturate(Vector128\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Csbyte\u003E ShiftLeftLogicalSaturate(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cshort\u003E ShiftLeftLogicalSaturate(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalSaturate(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogicalSaturate(Vector128\u003Clong\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalSaturate(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        Vector64\u003Clong\u003E ShiftLeftLogicalSaturateScalar(Vector64\u003Clong\u003E value, byte count);\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalSaturateScalar(Vector64\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Left Unsigned\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SQSHLU and VQSHLU\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Cbyte\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Cbyte\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cint\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        Vector64\u003Culong\u003E ShiftLeftLogicalSaturateUnsignedScalar(Vector64\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SHRN and VSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Rounding Shift Right Narrow Immediate\r\n        /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n        /// Corresponds to vector forms of RSHRN and VRSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Shift Left Long\r\n        /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n        /// Corresponds to vector forms of SHLL and VSHLL\r\n        /// \u003C/summary\u003E\r\n        Vector128\u003Cshort\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n        Vector128\u003Cushort\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cbyte\u003E value, byte count);\r\n        Vector128\u003Cint\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n        Vector128\u003Cuint\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cushort\u003E value, byte count);\r\n        Vector128\u003Clong\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n        Vector128\u003Culong\u003E ShiftLeftLogicalAndWidenLower(Vector64\u003Cuint\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of UQSHRN and VQSHRUN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Unsigned Saturating Rounded Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of UQRSHRN and VQRSHRUN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cushort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cuint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n        Vector64\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Culong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SQSHRN and VQSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Signed Saturating Rounded Shift Right Narrow Immediate\r\n        /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n        /// Corresponds to vector forms of SQRSHRN and VQRSHRN\r\n        /// \u003C/summary\u003E\r\n        Vector64\u003Csbyte\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n        Vector64\u003Cshort\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n        Vector64\u003Cint\u003E ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n        public abstract class Arm64\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SQRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SQSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticRoundedScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticRoundedScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticRoundedScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of SSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Csbyte\u003E ShiftArithmeticScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftArithmeticScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftArithmeticScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(ShiftLogical[elem] \u0026 0xFF) - 1))) \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of UQRSHL and VQRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalRoundedSaturateScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (ShiftLogical[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of UQSHL and VQSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalSaturateScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalSaturateScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalSaturateScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalSaturateScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalSaturateScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalSaturateScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Rounding Shift Left\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (-(shift[elem] \u0026 0xFF) - 1))) \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of URSHL and VRSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalRoundedScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalRoundedScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalRoundedScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalRoundedScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalRoundedScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalRoundedScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Shift Left\r\n            /// For each element result[elem] = value[elem] \u003C\u003C (shift[elem] \u0026 0xFF)\r\n            /// Corresponds to vector forms of USHL and VSHL\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftLogicalScalar(Vector64\u003Cbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Csbyte\u003E ShiftLogicalScalar(Vector64\u003Csbyte\u003E value, Vector64\u003Csbyte\u003E count);\r\n            Vector64\u003Cshort\u003E ShiftLogicalScalar(Vector64\u003Cshort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cushort\u003E ShiftLogicalScalar(Vector64\u003Cushort\u003E value, Vector64\u003Cshort\u003E count);\r\n            Vector64\u003Cint\u003E ShiftLogicalScalar(Vector64\u003Cint\u003E value, Vector64\u003Cint\u003E count);\r\n            Vector64\u003Cuint\u003E ShiftLogicalScalar(Vector64\u003Cuint\u003E value, Vector64\u003Cint\u003E count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SXTL\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E SignExtendAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E SignExtendAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E SignExtendAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of UXTL\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ZeroExtendAndWidenLower(Vector64\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ZeroExtendAndWidenLower(Vector64\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ZeroExtendAndWidenLower(Vector64\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ZeroExtendAndWidenLower(Vector64\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ZeroExtendAndWidenLower(Vector64\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ZeroExtendAndWidenLower(Vector64\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRUN\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector64\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n            Vector64\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRUN\r\n            /// \u003C/summary\u003E\r\n            Vector64\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector64\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E value, byte count);\r\n            Vector64\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Rounding Shift Right Narrow Immediate\r\n            /// For each element result[elem] = (value[elem] \u002B (1 \u003C\u003C (shift - 1))) \u003E\u003E shift\r\n            /// Corresponds to vector forms of RSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Shift Left Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SHLL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ShiftLeftLogicalAndWidenUpper(Vector128\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of SXTL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E SignExtendAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E SignExtendAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E SignExtendAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Extend Long\r\n            /// For each element result[elem] = value[elem] \u003C\u003C shift\r\n            /// Corresponds to vector forms of UXTL2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cshort\u003E ZeroExtendAndWidenUpper(Vector128\u003Csbyte\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ZeroExtendAndWidenUpper(Vector128\u003Cbyte\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ZeroExtendAndWidenUpper(Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ZeroExtendAndWidenUpper(Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Clong\u003E ZeroExtendAndWidenUpper(Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Culong\u003E ZeroExtendAndWidenUpper(Vector128\u003Cuint\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of UQSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Unsigned Saturating Rounded Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of UQRSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cbyte\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cbyte\u003E lower, Vector128\u003Cushort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cushort\u003E lower, Vector128\u003Cuint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cuint\u003E lower, Vector128\u003Culong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Csbyte\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cshort\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cint\u003E ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQSHRUN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Signed Saturating Rounded Shift Right Unsigned Narrow Immediate\r\n            /// For each element result[elem] = value[elem] \u003E\u003E shift\r\n            /// Corresponds to vector forms of SQRSHRUN2\r\n            /// \u003C/summary\u003E\r\n            Vector128\u003Cbyte\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E lower, Vector128\u003Cshort\u003E value, byte count);\r\n            Vector128\u003Cushort\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E lower, Vector128\u003Cint\u003E value, byte count);\r\n            Vector128\u003Cuint\u003E ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E lower, Vector128\u003Clong\u003E value, byte count);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticRoundedScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftArithmeticScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLeftLogicalAndWidenUpper(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedSaturateScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalRoundedScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalSaturateScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.Arm64.ShiftLogicalScalar(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightArithmeticUnsignedAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowRoundedUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cbyte\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Csbyte\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cshort\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cuint\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.Arm64.ShiftRightLogicalAndNarrowUpper(Vector64\u003Cushort\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.SignExtendAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenLower(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.Arm64.ZeroExtendAndWidenUpper(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftArithmeticScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalAndWidenLower(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsignedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturateScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cuint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Culong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cushort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cuint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cushort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ShiftLogicalSaturateScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalSaturateScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftLogicalScalar(Vector64\u003Culong\u003E,Vector64\u003Clong\u003E)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAddScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRoundedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRounded(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRoundedScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddRoundedScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddScalar(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAddScalar(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowRoundedSaturateLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAndNarrowSaturateLower(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Csbyte\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cushort\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedScalar(Vector64\u003Culong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalScalar(Vector64\u003Clong\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalScalar(Vector64\u003Culong\u003E,byte)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "CmF8g030Hno",
      "StartDateTime": "2020-05-07T10:11:03-07:00",
      "EndDateTime": "2020-05-07T12:12:21-07:00",
      "Title": ".NET Design Review: AsnReader/Writer update",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CmF8g030Hno/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35649,
          "Title": "Extend default value handling in JsonSerializer",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-30T03:47:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35649",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-07T00:00:00-07:00",
        "FeedbackId": "625418116",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35649#issuecomment-625418116",
        "FeedbackMarkdown": "* Looks great. Only suggestion is to change \u0060WhenWritingDefaultValues\u0060 to \u0060WhenWritingDefault\u0060.\r\n* \u0060JsonSerializerOptions.DefaultIgnoreCondition\u0060 should throw \u0060ArgumentException\u0060 rather than \u0060InvalidOperationException\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public enum JsonIgnoreCondition\r\n    {\r\n        Never = 0,\r\n        Always = 1,\r\n        WhenWritingDefault = 2\r\n    }    \r\n}\r\n\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public JsonIgnoreCondition DefaultIgnoreCondition { get; set; } = JsonIgnoreCondition.Never;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:JsonIgnoreCondition.Always",
          "F:JsonIgnoreCondition.Never",
          "F:JsonIgnoreCondition.WhenWritingDefault",
          "P:JsonSerializerOptions.DefaultIgnoreCondition",
          "T:JsonIgnoreCondition",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30820,
          "Title": "Proposal: Add mechanism to handle circular references when serializing",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-10T22:13:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30820",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-07T00:00:00-07:00",
        "FeedbackId": "625444164",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30820#issuecomment-625444164",
        "FeedbackMarkdown": "* The problem with taking a func is that people might accidentally close over a local variable that now becomes a static. Since the resolver is supposed to hold a dictionary this might result in two errors: (1) concurrency issues when multiple threads serialize and (2) a memory leak because the dictionary gets never eligible for GC6\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public ReferenceHandler ReferenceHandler { get; set; }\r\n    }\r\n    public abstract class ReferenceHandler\r\n    {\r\n        public static ReferenceHandler Default { get; }\r\n        public static ReferenceHandler Preserve { get; }\r\n        public abstract ReferenceResolver CreateResolver();\r\n    }\r\n    public sealed partial class ReferenceHandler\u003CT\u003E : ReferenceHandler\r\n        where T: ReferenceResolver, new()\r\n    {\r\n        public override ReferenceResolver CreateResolver() =\u003E new T();\r\n    }\r\n    public abstract class ReferenceResolver\r\n    {\r\n        public abstract void AddReference(string referenceId, object value);\r\n        public abstract string GetReference(object value, out bool alreadyExists);\r\n        public abstract object ResolveReference(string referenceId);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40280000000,
        "Apis": [
          "M:ReferenceHandler.CreateResolver()",
          "M:ReferenceHandler\u003CT\u003E.CreateResolver()",
          "M:ReferenceResolver.AddReference(string,object)",
          "M:ReferenceResolver.GetReference(object,out bool)",
          "M:ReferenceResolver.ResolveReference(string)",
          "P:JsonSerializerOptions.ReferenceHandler",
          "P:ReferenceHandler.Default",
          "P:ReferenceHandler.Preserve",
          "T:JsonSerializerOptions",
          "T:ReferenceHandler",
          "T:ReferenceHandler\u003CT\u003E",
          "T:ReferenceResolver"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "I7whBbUrMcc",
      "StartDateTime": "2020-05-26T10:02:41-07:00",
      "EndDateTime": "2020-05-26T12:06:04-07:00",
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/I7whBbUrMcc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35315,
          "Title": "RequireMethodImplToRemainInEffectAttribute",
          "Author": "fadimounir",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-22T23:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35315",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634163634",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35315#issuecomment-634163634",
        "FeedbackMarkdown": "A few questions:\r\n\r\n* We\u0027re not entirely sure what this attribute does:\r\n\t- The issue talks about covariant returns but all samples use \u0060void\u0060\r\n\t- None of the methdos use \u0060virtual\u0060 functions\r\n\t- What are the behavior differences of with and without the attribute? If this can\u0027t be expressed in C#, then ILDASM code would help too\r\n* \u0060RequireMethodImplToRemainInEffectAttribute\u0060 this name seems a bit abstract. Can make this a bit clearer, like \u0060PreserveBaseOverridesAttribute\u0060?\r\n* Does it have to be a new attribute or could be a new flag on \u0060MethodImplAttributes\u0060?\r\n* How does this attribute play with default interface methods?\r\n* How does this play with versioning where overrides are added to the middle of the hierarchy later?",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34305,
          "Title": "Add activity Ids and Context to all logs ",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-02T00:13:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34305",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634181323",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34305#issuecomment-634181323",
        "FeedbackMarkdown": "* We should remove \u0060ActivityTrackingOptions.Default\u0060 because we can\u0027t change its value ever. Instead, we should just set the value in the \u0060LoggerFactoryOptions\u0060 contructor\r\n* We should make sure that default parameters in constructors are part of the spec that 3rd party DI containers have to support\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [Flags]\r\n    public enum ActivityTrackingOptions\r\n    {\r\n        None        = 0x0000,\r\n        SpanId      = 0x0001,\r\n        TraceId     = 0x0002,\r\n        ParentId    = 0x0004,\r\n        TraceState  = 0x0008,\r\n        TraceFlags  = 0x0010\r\n    }\r\n    public class LoggerFactoryOptions\r\n    {\r\n        public LoggerFactoryOptions();\r\n        public ActivityTrackingOptions ActivityTrackingOptions  { get; set; }\r\n    }\r\n    public partial class LoggerFactory\r\n    {\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers,\r\n                             IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption,\r\n                             IOptions\u003CLoggerFactoryOptions\u003E options = null);\r\n    }\r\n    public static partial class LoggingBuilderExtensions\r\n    {\r\n        public static ILoggingBuilder Configure(this ILoggingBuilder builder,\r\n                                                Action\u003CLoggerFactoryOptions\u003E action);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12700000000,
        "Apis": [
          "F:ActivityTrackingOptions.None",
          "F:ActivityTrackingOptions.ParentId",
          "F:ActivityTrackingOptions.SpanId",
          "F:ActivityTrackingOptions.TraceFlags",
          "F:ActivityTrackingOptions.TraceId",
          "F:ActivityTrackingOptions.TraceState",
          "M:LoggerFactory.LoggerFactory(IEnumerable\u003CILoggerProvider\u003E,IOptionsMonitor\u003CLoggerFilterOptions\u003E,IOptions\u003CLoggerFactoryOptions\u003E)",
          "M:LoggerFactoryOptions.LoggerFactoryOptions()",
          "M:LoggingBuilderExtensions.Configure(this ILoggingBuilder,Action\u003CLoggerFactoryOptions\u003E)",
          "P:LoggerFactoryOptions.ActivityTrackingOptions",
          "T:ActivityTrackingOptions",
          "T:LoggerFactory",
          "T:LoggerFactoryOptions",
          "T:LoggingBuilderExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 25819,
          "Title": "Add a GetEncodings method to System.Text.EncodingProvider to support enumerating available character encodings",
          "Author": "mklement0",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-04-09T20:59:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25819",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encoding",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634199380",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/25819#issuecomment-634199380",
        "FeedbackMarkdown": "* \u0060EncodingProvider.GetEncodings()\u0060 should be \u0060IEnumerable\u003CEncodingInfo\u003E\u0060\r\n* \u0060EncodingProvider.GetEncodings()\u0060 should be virtual and return an \u0060Enumerable.Empty\u003CEncodingInfo\u003E()\u0060 (instead of throwing). While this isn\u0027t correct it means that one provider that isn\u0027t updated doesn\u0027t spoil the enumeration for everyone else.\r\n* \u0060Encoding.GetEncodings()\u0060 should return all registered encodings across all providers and de-dupe them if necessary.\r\n* \u0060EncodingInfo.GetEncoding()\u0060 calls the static \u0060Encoding.GetEncoding()\u0060 method, which means getting encoding infos and using \u0060EncodingInfo.GetEncoding()\u0060 might create an encoding that isn\u0027t tied to that encoding provider.\r\n    - \u0060EncodingInfo\u0060 should take an \u0060EncodingProvider\u0060 that we\u0027ll use in \u0060EncodingInfo.GetEncoding()\u0060 and call \u0060EncodingProvider.GetEncoding(codePage)\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class EncodingProvider\r\n    {\r\n        public virtual IEnumerable\u003CEncodingInfo\u003E GetEncodings();\r\n    }\r\n    \r\n    public partial class EncodingInfo\r\n    {\r\n        public EncodingInfo(EncodingProvider provider, int codePage, string name, string displayName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32980000000,
        "Apis": [
          "M:EncodingInfo.EncodingInfo(EncodingProvider,int,string,string)",
          "M:EncodingProvider.GetEncodings()",
          "T:EncodingInfo",
          "T:EncodingProvider"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31038,
          "Title": "StringSplitOptions.TrimEntries",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-02T01:29:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31038",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634204949",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31038#issuecomment-634204949",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    [Flags]\r\n    public enum StringSplitOptions\r\n    {\r\n        // Existing:\r\n        // None = 0,\r\n        //RemoveEmptyEntries = 1,\r\n\r\n        // New:\r\n        TrimEntries = 2\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52180000000,
        "Apis": [
          "F:StringSplitOptions.TrimEntries",
          "T:StringSplitOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31406,
          "Title": "Obsolete RuntimeHelpers.OffsetToStringData",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-06T05:43:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31406",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634212546",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31406#issuecomment-634212546",
        "FeedbackMarkdown": "* Looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public sealed class RuntimeHelpers\r\n    {\r\n        [Obsolete(\u0022Use string.GetPinnableReference() instead.\u0022)]\r\n        public static int OffsetToStringData { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58790000000,
        "Apis": [
          "P:RuntimeHelpers.OffsetToStringData",
          "T:RuntimeHelpers"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31549,
          "Title": "expose System.Text.Encoding.Latin1 getter publicly",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-22T22:47:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31549",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encoding",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-26T00:00:00-07:00",
        "FeedbackId": "634217668",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31549#issuecomment-634217668",
        "FeedbackMarkdown": "* Looks good.\r\n* We won\u0027t be exposing the \u0060Latin1Encoding\u0060 type, because it\u0027s not necessary\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial class Encoding\r\n    {\r\n        public static Encoding Latin1 =\u003E Encoding.GetEncoding(\u0022iso-8859-1\u0022);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 67430000000,
        "Apis": [
          "P:Encoding.Latin1",
          "T:Encoding"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "jhibZCgzB9o",
      "StartDateTime": "2020-05-29T10:06:18-07:00",
      "EndDateTime": "2020-05-29T12:05:54-07:00",
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/jhibZCgzB9o/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35315,
          "Title": "RequireMethodImplToRemainInEffectAttribute",
          "Author": "fadimounir",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-22T23:30:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35315",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636093159",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35315#issuecomment-636093159",
        "FeedbackMarkdown": "Let\u0027s go with PreserveBaseOverridesAttribute then.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n    public sealed class PreserveBaseOverridesAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:PreserveBaseOverridesAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 720,
          "Title": "Use of \u0060EditorBrowsableState.Never\u0060 leads language service to claim it\u0027s gone",
          "Author": "AArnott",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-10T04:19:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/720",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636098716",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/720#issuecomment-636098716",
        "FeedbackMarkdown": "\u0060\u0060\u0060diff\r\n public enum ComInterfaceType \r\n { \r\n-    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)] \r\n-    [System.ObsoleteAttribute(\u0022Support for IDispatch may be unavailable in future releases.\u0022)] \r\n     InterfaceIsDual = 0, \r\n     InterfaceIsIUnknown = 1, \r\n-    [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)] \r\n-    [System.ObsoleteAttribute(\u0022Support for IDispatch may be unavailable in future releases.\u0022)] \r\n     InterfaceIsIDispatch = 2, \r\n     InterfaceIsIInspectable = 3, \r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 13470000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35749,
          "Title": "ModuleInitializerAttribute",
          "Author": "jnm2",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-02T17:19:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35749",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "untriaged",
              "Color": "fbca04",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636105051",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35749#issuecomment-636105051",
        "FeedbackMarkdown": "@jaredpar presumably this feature won\u0027t have language syntax. Normally we don\u0027t use \u0060S.R.CompilerServices\u0060 for stuff that developers are expected to use directly. Normally, the namespace is for stuff the compiler generates calls for. However, in this case it seems on par with other very advanced features that we don\u0027t want the general public to use, this feels OK.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\r\n    public sealed class ModuleInitializerAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21080000000,
        "Apis": [
          "T:ModuleInitializerAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36708,
          "Title": "Allow DynamicallyAccessedMembersAttribute on methods",
          "Author": "vitek-karas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-19T15:59:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36708",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            },
            {
              "Name": "untriaged",
              "Color": "fbca04",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636106955",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36708#issuecomment-636106955",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\r\n\u0060\u0060\u0060diff\r\n [AttributeUsage(\r\n        AttributeTargets.Field |\r\n        AttributeTargets.ReturnValue |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property |\r\n\u002B       AttributeTargets.Method,\r\n        Inherited = false)]\r\n    public sealed class DynamicallyAccessedMembersAttribute : Attribute\r\n    {\r\n    }\r\n\u0060\u0060\u0060",
        "TimeCode": 29590000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36972,
          "Title": "PrincipalPermissionAttribute ctor should be obsolete as error",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-25T07:31:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36972",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636122871",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36972#issuecomment-636122871",
        "FeedbackMarkdown": "* Looks good as proposed, but we should be adding an URL\r\n* We should also provide a fixer(er) with the potential suggestions (apply ASP.NET Core attribute, using the thread\u0027s principal).\r\n* We should consider a generic analyzer that warns on \u0060SecurityAction.Deny\u0060 usage across all attributes\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Permissions\r\n{\r\n    public partial class PrincipalPermissionAttribute\r\n    {\r\n        [Obsolete(\u0022\u003Cmessage goes here\u003E\u0022, error: true, DiagnosticId=\u0022\u003Cdiagnostic ID\u003E\u0022, UrlFormat=\u0022\u003CURL goes here\u003E\u0022)]\r\n        public PrincipalPermissionAttribute(SecurityAction action);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32110000000,
        "Apis": [
          "M:PrincipalPermissionAttribute.PrincipalPermissionAttribute(SecurityAction)",
          "T:PrincipalPermissionAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 14336,
          "Title": "Use TimeSpan everywhere we use an int for seconds, milliseconds, and timeouts",
          "Author": "briangru",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-03-11T01:39:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14336",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-05-29T00:00:00-07:00",
        "FeedbackId": "636135854",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/14336#issuecomment-636135854",
        "FeedbackMarkdown": "* We\u0027re happy to approve the first group, i.e. a set of overloads to existing methods where \u0060int\u0060 is replaced with \u0060TimeSpan\u0060.\r\n* We don\u0027t believe properties or using DIMs for interfaces is worth it.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System {\r\n    public static class GC {\r\n\u002B       public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout);\r\n\u002B       public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.ComponentModel.DataAnnotations {\r\n    public class RegularExpressionAttribute {\r\n!       This one might not end up being that useful, since people generally don\u0027t ever manipulate an instance of this attribute.\r\n\u002B       public TimeSpan MatchTimeout { get; }\r\n    }\r\n}\r\n\r\nnamespace System.Diagnostics {\r\n    public class Process {\r\n\u002B       public bool WaitForExit(TimeSpan timeout);\r\n\u002B       public bool WaitForInputIdle(TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.IO {\r\n    public class FileSystemWatcher {\r\n\u002B       public WaitForChangedResult WaitForChanged(WatcherChangeTypes changeType, TimeSpan timeout);\r\n    }\r\n\r\n    public sealed class NamedPipeClientStream : PipeStream {\r\n\u002B       public void Connect(TimeSpan timeout);\r\n\u002B       public Task ConnectAsync(TimeSpan timeout, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace System.Net.NetworkInformation {\r\n    public class Ping {\r\n\u002B       public PingReply Send(IPAddress address, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null);\r\n\u002B       public PingReply Send(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null);\r\n\r\n!       Skipped EAP based methods; if they are desired, they can be added back in\r\n\r\n!       I added CancellationToken because it is probably worth it. If you don\u0027t want it you can remove it.\r\n\u002B       public Task\u003CPingReply\u003E SendPingAsync(IPAddress address, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null, CancellationToken cancellationToken = default);\r\n\u002B       public Task\u003CPingReply\u003E SendPingAsync(string hostNameOrAddress, TimeSpan timeout, byte[]? buffer = null, PingOptions? options = null, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\r\nnamespace System.Net.Sockets {\r\n    public class NetworkStream : Stream {\r\n\u002B       public void Close(TimeSpan timeout);\r\n    }\r\n\r\n    public class Socket {\r\n\u002B       public bool Poll(TimeSpan timeout, SelectMode mode);\r\n\u002B       public static void Select(IList checkRead, IList checkWrite, IList checkError, TimeSpan timeout);\r\n    }\r\n}\r\n\r\nnamespace System.ServiceProcess {\r\n    public class ServiceBase {\r\n\u002B       public void RequestAdditionalTime(TimeSpan time);\r\n    }\r\n}\r\n\r\nnamespace System.Threading.Tasks {\r\n    public class Task {\r\n\u002B       public bool Wait(TimeSpan timeout, CancellationToken cancellationToken); \r\n    } \r\n} \r\n\r\nnamespace System.Timers {\r\n    public class Timer {\r\n\u002B       public Timer(TimeSpan interval);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51300000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "P1w3Tc7Oyqk",
      "StartDateTime": "2020-06-02T09:55:54-07:00",
      "EndDateTime": "2020-06-02T11:59:48-07:00",
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/P1w3Tc7Oyqk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-wasm",
              "Color": "eb6420",
              "Description": "WebAssembly architecture"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-02T00:00:00-07:00",
        "FeedbackId": "637712249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-637712249",
        "FeedbackMarkdown": "* It doesn\u0027t seem we need the \u0060IHttpRequestOptions\u0060\r\n* We should combine the options with the \u0060Properties\u0060 collection the message\r\n* We don\u0027t believe we need the overloads on \u0060HttpClient\u0060 that take options; it feels like an advanced scenario which people can achieve by constructing the message\r\n* Users can store mismatched types via \u0060IDictionary\u003Cstring, object\u003E\u0060, but we should verify types on retrieval and throw an exception\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class HttpRequestOptions : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Explicit interface implementation\r\n        public bool TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, out TValue value);\r\n        public void Set(HttpRequestOptionsKey\u003CTValue\u003E key, TValue value);\r\n    }\r\n\r\n    public class HttpRequestMessage : IDisposable\r\n    {\r\n        [Obsolete(\u0022Use Options instead.\u0022)]\r\n        public IDictionary\u003Cstring, object\u003E Properties =\u003E Options;\r\n\r\n        public HttpRequestOptions Options { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpRequestOptions.Set(HttpRequestOptionsKey\u003CTValue\u003E,TValue)",
          "M:HttpRequestOptions.TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,out TValue)",
          "P:HttpRequestMessage.Options",
          "P:HttpRequestMessage.Properties",
          "T:HttpRequestMessage",
          "T:HttpRequestOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36654,
          "Title": "IDynamicInterfaceCastable interface",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-18T15:33:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36654",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-02T00:00:00-07:00",
        "FeedbackId": "637742472",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36654#issuecomment-637742472",
        "FeedbackMarkdown": "* Looks good, but we should make the type name less attractive, such as \u0060IDynamicInterfaceCastable\u0060\r\n* The implementer of \u0060IDynamicInterfaceCastable\u0060 has to abide to the contract of only throwing when \u0060throwIfNotFound\u0060 is \u0060true\u0060 and even then should only throw \u0060InvalidCastException\u0060. However, the runtime doesn\u0027t handle the throwing so that implementers can tweak the message\r\n* However, it is valid for the implementer to return \u0060default\u0060 and the let the runtime throw\r\n* It would be nice if \u0060throwIfNotFound\u0060 would be renamed to indicate whether it\u0027s an \u0060is\u0060/\u0060as\u0060 or a hard cast\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public interface IDynamicInterfaceCastable\r\n    {\r\n        RuntimeTypeHandle GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound);\r\n    }\r\n    [AttributeUsage(AttributeTargets.Interface,\r\n                    AllowMultiple = false,\r\n                    Inherited = false)]\r\n    public sealed class DynamicInterfaceCastableImplementationAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39100000000,
        "Apis": [
          "M:IDynamicInterfaceCastable.GetInterfaceImplementation(RuntimeTypeHandle,bool)",
          "T:DynamicInterfaceCastableImplementationAttribute",
          "T:IDynamicInterfaceCastable"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "H3obznO9_uo",
      "StartDateTime": "2020-06-04T10:02:08-07:00",
      "EndDateTime": "2020-06-04T12:05:04-07:00",
      "Title": ".NET Design Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/H3obznO9_uo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 14386,
          "Title": "Add overloads to string trimming",
          "Author": "ChrisEelmaa",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-03-25T17:47:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/14386",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639002448",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/14386#issuecomment-639002448",
        "FeedbackMarkdown": "We made minor adjustments:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class String\r\n    {\r\n        public string RemoveStart(string value, StringComparison comparisonType);\r\n        public string RemoveEnd(string value, StringComparison comparisonType);\r\n    }\r\n\r\n    public static partial class MemoryExtensions\r\n    {\r\n        public static ReadOnlySpan\u003Cchar\u003E RemoveStart(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparisonType);\r\n        public static ReadOnlySpan\u003Cchar\u003E RemoveEnd(this ReadOnlySpan\u003Cchar\u003E span, ReadOnlySpan\u003Cchar\u003E value, StringComparison comparisonType);\r\n    }\r\n}\r\nnamespace System.Globalization\r\n{\r\n     public class CompareInfo\r\n     {\r\n        public Range RemovePrefix(string source, string prefix, CompareOptions options = CompareOptions.None);\r\n        public Range RemovePrefix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E prefix, CompareOptions options = CompareOptions.None);\r\n\r\n        public Range RemoveSuffix(string source, string suffix, CompareOptions options = CompareOptions.None);\r\n        public Range RemoveSuffix(ReadOnlySpan\u003Cchar\u003E source, ReadOnlySpan\u003Cchar\u003E suffix, CompareOptions options = CompareOptions.None);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CompareInfo.RemovePrefix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions)",
          "M:CompareInfo.RemovePrefix(string,string,CompareOptions)",
          "M:CompareInfo.RemoveSuffix(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,CompareOptions)",
          "M:CompareInfo.RemoveSuffix(string,string,CompareOptions)",
          "M:MemoryExtensions.RemoveEnd(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:MemoryExtensions.RemoveStart(this ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,StringComparison)",
          "M:String.RemoveEnd(string,StringComparison)",
          "M:String.RemoveStart(string,StringComparison)",
          "T:CompareInfo",
          "T:MemoryExtensions",
          "T:String"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17393,
          "Title": "Non value returning TaskCompletionSource",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-05-24T17:58:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17393",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639004797",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17393#issuecomment-639004797",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public class TaskCompletionSource\r\n    {\r\n        public TaskCompletionSource();\r\n        public TaskCompletionSource(object? state);\r\n        public TaskCompletionSource(TaskCreationOptions creationOptions);\r\n        public TaskCompletionSource(object? state, TaskCreationOptions creationOptions);\r\n        public Task Task { get; }\r\n        public void SetCanceled();\r\n        public void SetException(IEnumerable\u003CException\u003E exceptions);\r\n        public void SetException(Exception exception);\r\n        public void SetResult();\r\n        public bool TrySetCanceled();\r\n        public bool TrySetCanceled(CancellationToken cancellationToken);\r\n        public bool TrySetException(IEnumerable\u003CException\u003E exceptions);\r\n        public bool TrySetException(Exception exception);\r\n        public bool TrySetResult();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22620000000,
        "Apis": [
          "M:TaskCompletionSource.SetCanceled()",
          "M:TaskCompletionSource.SetException(Exception)",
          "M:TaskCompletionSource.SetException(IEnumerable\u003CException\u003E)",
          "M:TaskCompletionSource.SetResult()",
          "M:TaskCompletionSource.TaskCompletionSource()",
          "M:TaskCompletionSource.TaskCompletionSource(object?,TaskCreationOptions)",
          "M:TaskCompletionSource.TaskCompletionSource(object?)",
          "M:TaskCompletionSource.TaskCompletionSource(TaskCreationOptions)",
          "M:TaskCompletionSource.TrySetCanceled()",
          "M:TaskCompletionSource.TrySetCanceled(CancellationToken)",
          "M:TaskCompletionSource.TrySetException(Exception)",
          "M:TaskCompletionSource.TrySetException(IEnumerable\u003CException\u003E)",
          "M:TaskCompletionSource.TrySetResult()",
          "P:TaskCompletionSource.Task",
          "T:TaskCompletionSource"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17837,
          "Title": "Add methods to convert between hexadecimal strings and bytes",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-07-12T15:50:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17837",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639018813",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17837#issuecomment-639018813",
        "FeedbackMarkdown": "* We decided to go with a simpler route.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class Convert\r\n    {\r\n        public static byte[] FromHexString(string s);\r\n        public static byte[] FromHexString(ReadOnlySpan\u003Cchar\u003E chars);\r\n\r\n        public static string ToHexString(byte[] inArray);\r\n        public static string ToHexString(byte[] inArray, int offset, int length);\r\n        public static string ToHexString(ReadOnlySpan\u003Cbyte\u003E bytes);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25280000000,
        "Apis": [
          "M:Convert.FromHexString(ReadOnlySpan\u003Cchar\u003E)",
          "M:Convert.FromHexString(string)",
          "M:Convert.ToHexString(byte[],int,int)",
          "M:Convert.ToHexString(byte[])",
          "M:Convert.ToHexString(ReadOnlySpan\u003Cbyte\u003E)",
          "T:Convert"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1476,
          "Title": "TCP Fast Open implementation?",
          "Author": "icylogic",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-22T07:35:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1476",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639025242",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1476#issuecomment-639025242",
        "FeedbackMarkdown": "* We need to decide wether we throw or whether we do a softwar fallback, but naming looks fine:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public enum SocketOptionName\r\n    {\r\n        FastOpen = 15\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41400000000,
        "Apis": [
          "F:SocketOptionName.FastOpen",
          "T:SocketOptionName"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 23021,
          "Title": "Proposal: Add Task.WhenAny(Task,Task) overload to avoid Task[] allocation",
          "Author": "clrjunkie",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-08-02T11:40:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/23021",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639034041",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/23021#issuecomment-639034041",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic class Task\r\n{\r\n    // existing\r\n    //public static Task\u003CTask\u003E WhenAny(params Task[] tasks);\r\n    //public static Task\u003CTask\u003E WhenAny(IEnumerable\u003CTask\u003E tasks);\r\n    //public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(params Task\u003CTResult\u003E[] tasks);\r\n    //public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(IEnumerable\u003CTask\u003CTResult\u003E\u003E tasks);\r\n\r\n    // new\r\n    public static Task\u003CTask\u003E WhenAny(Task task1, Task task2);\r\n    public static Task\u003CTask\u003CTResult\u003E\u003E WhenAny\u003CTResult\u003E(Task\u003CTResult\u003E task1, Task\u003CTResult\u003E task2);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48410000000,
        "Apis": [
          "M:Task.WhenAny(Task,Task)",
          "M:Task.WhenAny\u003CTResult\u003E(Task\u003CTResult\u003E,Task\u003CTResult\u003E)",
          "T:Task"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 936,
          "Title": "Add System.Numerics.Half 16 bit floating point number conforming to IEEE 754:2008 binary16",
          "Author": "4creators",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-04T23:39:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/936",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639050110",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/936#issuecomment-639050110",
        "FeedbackMarkdown": "* Type looks good as proposed\r\n* But we decided to put it in \u0060System\u0060 to align with the other primitves\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public readonly struct Half : IComparable, IFormattable, IComparable\u003CHalf\u003E, IEquatable\u003CHalf\u003E, IConvertible, ISpanFormattable\r\n    {\r\n        public static readonly Half MinValue;\r\n        public static readonly Half Epsilon;\r\n        public static readonly Half MaxValue;\r\n        public static readonly Half PositiveInfinity;\r\n        public static readonly Half NegativeInfinity;\r\n        public static readonly Half NaN;\r\n        public static bool IsInfinity(Half h);\r\n        public static bool IsFinite(Half value);\r\n        public static bool IsNaN(Half h);\r\n        public static bool IsNegativeInfinity(Half h);\r\n        public static bool IsPositiveInfinity(Half h);\r\n        public static bool IsNormal(Half h);\r\n        public static bool IsSubnormal(Half h);\r\n        public static bool IsNegative(Half h);\r\n        public static Half Parse(string s);\r\n        public static Half Parse(string s, NumberStyles style);\r\n        public static Half Parse(string s, NumberStyles style, IFormatProvider provider);\r\n        public static Half Parse(string s, IFormatProvider provider);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider provider);\r\n        public static Half Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider provider);\r\n        public static bool TryParse(string s, out Half result);\r\n        public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, out Half result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out Half result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider provider, out Half result);\r\n        public int CompareTo(object value);\r\n        public int CompareTo(Half value);\r\n        public bool Equals(Half obj);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n        public TypeCode GetTypeCode();\r\n        public string ToString(IFormatProvider provider);\r\n        public string ToString(string format);\r\n        public string ToString(string format, IFormatProvider provider);\r\n        public override string ToString();\r\n        public static explicit operator Half(float value);\r\n        public static explicit operator Half(double value);\r\n        public static explicit operator float(Half value);\r\n        public static explicit operator double(Half value);\r\n        public static bool operator ==(Half left, Half right);\r\n        public static bool operator !=(Half left, Half right);\r\n        public static bool operator \u003C(Half left, Half right);\r\n        public static bool operator \u003E(Half left, Half right);\r\n        public static bool operator \u003C=(Half left, Half right);\r\n        public static bool operator \u003E=(Half left, Half right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54090000000,
        "Apis": [
          "F:Half.Epsilon",
          "F:Half.MaxValue",
          "F:Half.MinValue",
          "F:Half.NaN",
          "F:Half.NegativeInfinity",
          "F:Half.PositiveInfinity",
          "M:Half.!=(Half,Half)",
          "M:Half.\u003C(Half,Half)",
          "M:Half.\u003C=(Half,Half)",
          "M:Half.==(Half,Half)",
          "M:Half.\u003E(Half,Half)",
          "M:Half.\u003E=(Half,Half)",
          "M:Half.CompareTo(Half)",
          "M:Half.CompareTo(object)",
          "M:Half.Equals(Half)",
          "M:Half.Equals(object)",
          "M:Half.explicit(double)",
          "M:Half.explicit(float)",
          "M:Half.explicit(Half)",
          "M:Half.GetHashCode()",
          "M:Half.GetTypeCode()",
          "M:Half.IsFinite(Half)",
          "M:Half.IsInfinity(Half)",
          "M:Half.IsNaN(Half)",
          "M:Half.IsNegative(Half)",
          "M:Half.IsNegativeInfinity(Half)",
          "M:Half.IsNormal(Half)",
          "M:Half.IsPositiveInfinity(Half)",
          "M:Half.IsSubnormal(Half)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles)",
          "M:Half.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:Half.Parse(string,IFormatProvider)",
          "M:Half.Parse(string,NumberStyles,IFormatProvider)",
          "M:Half.Parse(string,NumberStyles)",
          "M:Half.Parse(string)",
          "M:Half.ToString()",
          "M:Half.ToString(IFormatProvider)",
          "M:Half.ToString(string,IFormatProvider)",
          "M:Half.ToString(string)",
          "M:Half.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider)",
          "M:Half.TryParse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider,out Half)",
          "M:Half.TryParse(ReadOnlySpan\u003Cchar\u003E,out Half)",
          "M:Half.TryParse(string,NumberStyles,IFormatProvider,out Half)",
          "M:Half.TryParse(string,out Half)",
          "T:Half"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24460,
          "Title": "Add \u0022Create\u0022 method to EqualityComparer\u003C\u003E class",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-14T21:49:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24460",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-04T00:00:00-07:00",
        "FeedbackId": "639054509",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24460#issuecomment-639054509",
        "FeedbackMarkdown": "Can someone update the sample to make a compelling case for the currently proposed API? The sample code was for a different proposal.\r\n\r\nIf \u0060Distinct\u0060 is the only use case, then maybe we should fix \u0060Distinct\u0060 itself.",
        "TimeCode": 64490000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "4sksWrrgXJg",
      "StartDateTime": "2020-06-12T10:03:24-07:00",
      "EndDateTime": "2020-06-12T12:08:33-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/4sksWrrgXJg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37495,
          "Title": "HttpContent.ReadAsStream sync API ",
          "Author": "ManickaP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-05T16:46:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37495",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37495#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37612,
          "Title": "Update UnmanagedCallersOnlyAttribute to align with C# function pointers",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-08T21:22:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37612",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37612#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 4350000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30863,
          "Title": "TPL Dataflow TransformManyBlock support for IAsyncEnumerable",
          "Author": "onionhammer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-15T18:27:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30863",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30863#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 13410000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31297,
          "Title": "Consider introducing BitOperations.IsPow2 or Math.IsPow2",
          "Author": "john-h-k",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-25T11:10:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31297",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643407800",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31297#issuecomment-643407800",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static class BitOperations\r\n    {\r\n        public static bool IsPow2(int value);\r\n        public static bool IsPow2(uint value);\r\n        public static bool IsPow2(long value);\r\n        public static bool IsPow2(ulong value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18460000000,
        "Apis": [
          "M:BitOperations.IsPow2(int)",
          "M:BitOperations.IsPow2(long)",
          "M:BitOperations.IsPow2(uint)",
          "M:BitOperations.IsPow2(ulong)",
          "T:BitOperations"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31308,
          "Title": "Add API to get bit length of BigInteger",
          "Author": "andrew-boyarshin",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-26T13:33:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31308",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643406480",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31308#issuecomment-643406480",
        "FeedbackMarkdown": "* Makes sense as proposed\r\n* We considered \u0060GetBitCount()\u0060 to be consistent with \u0060GetByteLength()\u0060 but it seems confusing because it sounds like \u0060GetPopCount()\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public struct BigInteger\r\n    {\r\n        public int GetBitLength();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21570000000,
        "Apis": [
          "M:BigInteger.GetBitLength()",
          "T:BigInteger"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31354,
          "Title": "Add [CallerMustBeUnsafe] attribute to denote APIs which should be called in an unsafe block",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-31T02:33:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31354",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643417759",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31354#issuecomment-643417759",
        "FeedbackMarkdown": "* The idea is interesting, but we have concerns:\r\n    - Which kind of APIs would we apply this too? Every p/Invoke? \u0060CollectionMarshal.GetSpanForList()\u0060?\r\n    - The name should reflect what the method does, rather than what mechanically has to happen on the call side.\r\n    - Would we turn this on for existing APIs? If so, it seems this analyzer needs to opt-in. If it\u0027s opt-in, is it still useful?\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Property,\r\n                    AllowMultiple = false,\r\n                    Inherited = true)]\r\n    public sealed class CallerMustBeUnsafeAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28090000000,
        "Apis": [
          "T:CallerMustBeUnsafeAttribute"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31355,
          "Title": "SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E sequence, ReadOnlySpan\u003CT\u003E delimiter)",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-31T03:20:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31355",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643421064",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31355#issuecomment-643421064",
        "FeedbackMarkdown": "* We have an existing API that returns the sequence.\r\n* We don\u0027t want to offer an API that might allocate unexpectedly, especially on a type that is about avoiding allocations.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers\r\n{\r\n    public ref struct SequenceReader\u003CT\u003E\r\n    {\r\n        // Existing API\r\n        // public bool TryReadTo(out ReadOnlySequence\u003CT\u003E sequence, T delimiter, bool advancePastDelimiter = true);\r\n\r\n        public bool TryReadTo(out ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E delimiter, bool advancePastDelimiter = true);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42870000000,
        "Apis": [
          "M:SequenceReader\u003CT\u003E.TryReadTo(out ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,bool)",
          "T:SequenceReader\u003CT\u003E"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31357,
          "Title": "Utf8Parser overloads for ReadOnlySequence\u003Cbyte\u003E",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-31T05:02:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31357",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643427770",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31357#issuecomment-643427770",
        "FeedbackMarkdown": "@davidfowl have tried using APIs like this in Kestrel or is this API proposal a hypothetical? The question is whether you can the perf, because parsers should really be over spans, not sequences.  We already said we won\u0027t do parsers of \u0060Memory\u003CT\u003E\u0060 because accessing the span is not free. Doing it over sequences would be even worse.",
        "TimeCode": 47730000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31362,
          "Title": "Proposal: ChannelReader\u003CT\u003E.TryPeek",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-01T02:12:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31362",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Channels",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-12T00:00:00-07:00",
        "FeedbackId": "643438552",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31362#issuecomment-643438552",
        "FeedbackMarkdown": "* We should add a virtual \u0060CanPeek\u0060 that returns \u0060false\u0060\r\n* We\u0027ll want more feedback so we should punt this to .NET 6.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Channels\r\n{\r\n    public abstract partial class ChannelReader\u003CT\u003E\r\n    {\r\n        public virtual bool CanPeek =\u003E false;\r\n\r\n        public virtual bool TryPeek([MaybeNullWhen(false)] out T item)\r\n        {\r\n            item = default!;\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57550000000,
        "Apis": [
          "M:ChannelReader\u003CT\u003E.TryPeek(out T)",
          "P:ChannelReader\u003CT\u003E.CanPeek",
          "T:ChannelReader\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "t-X09mGPvNM",
      "StartDateTime": "2020-06-18T10:04:46-07:00",
      "EndDateTime": "2020-06-18T12:11:47-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/t-X09mGPvNM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37933,
          "Title": "SslStream API improvements for enhanced use cases ",
          "Author": "wfurt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-15T22:20:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37933",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646228075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37933#issuecomment-646228075",
        "FeedbackMarkdown": "* ServerOptionsSelectionCallback should use a context object instead of the hostname for future expansion\r\n* Rename \u0060sender\u0060 to \u0060stream\u0060 in \u0060ServerOptionsSelectionCallback\u0060\r\n* Why is \u0060SslStream.HostName\u0060 \u0060virtual\u0060?\r\n* Rename \u0060HostName\u0060 to \u0060TargetHostName\u0060\r\n* Rename \u0060SslStreamCertificateContext.CreateForServer\u0060 to \u0060SslStreamCertificateContext.Create\u0060 to unify with client usage (and drop the usage type check)\r\n* Add an \u0060offline\u0060 parameter to the SslStreamCertificateContext Create method\r\n* Add a debugger proxy to show the target cert.\r\n\r\n\u0060\u0060\u0060C#\r\npublic readonly struct SslClientHelloInfo\r\n{\r\n    public string ServerName { get; }\r\n    public SslProtocols SslProtocols { get; }\r\n}\r\n\r\npublic delegate ValueTask\u003CSslServerAuthenticationOptions\u003E ServerOptionsSelectionCallback(SslStream stream, SslClientHelloInfo clientHelloInfo, object? state, CancellationToken cancellationToken);\r\n\r\npartial class SslStream\r\n{\r\n    public string TargetHostName { get; }\r\n    public Task AuthenticateAsServerAsync(\r\n        ServerOptionsSelectionCallback optionCallback,\r\n        object? state,\r\n        CancellationToken cancellationToken = default);      \r\n}\r\n\r\npublic sealed class SslStreamCertificateContext\r\n{\r\n    public static SslStreamCertificateContext Create(\r\n        X509Certificate2 target,\r\n        X509Certificate2Collection? additionalCertificates,\r\n        bool offline = false);\r\n}\r\n\r\npartial class SslServerAuthenticationOptions\r\n{\r\n    SslStreamCertificateContext ServerCertificateContext  { get; set; };\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SslStream.AuthenticateAsServerAsync(ServerOptionsSelectionCallback,object?,CancellationToken)",
          "M:SslStreamCertificateContext.Create(X509Certificate2,X509Certificate2Collection?,bool)",
          "P:SslClientHelloInfo.ServerName",
          "P:SslClientHelloInfo.SslProtocols",
          "P:SslServerAuthenticationOptions.ServerCertificateContext",
          "P:SslStream.TargetHostName",
          "T:ServerOptionsSelectionCallback(SslStream,SslClientHelloInfo,object?,CancellationToken)",
          "T:SslClientHelloInfo",
          "T:SslServerAuthenticationOptions",
          "T:SslStream",
          "T:SslStreamCertificateContext"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29214,
          "Title": "CompareAttribute.Validate method does not create a ValidationResult with MemberNames",
          "Author": "ChrisJWoodcock",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-09T15:18:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.ComponentModel.DataAnnotations",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "bug",
              "Color": "f49cb1",
              "Description": "Product bug (most likely)"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29214#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 43740000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31400,
          "Title": "Add support for validating complex or collection properties using System.ComponentModel.DataAnnotations.Validator",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-05T14:07:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31400",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.ComponentModel.DataAnnotations",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646249648",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31400#issuecomment-646249648",
        "FeedbackMarkdown": "* The new attribute seems fine, but be careful in how it gets consumed so as to not surprise users who use the objects in multiple contexts (Blazor, EF6, etc).\r\n* It seems like some new data belongs on ValidationContext, instead of new overloads to (Try)ValidateObject, around memberName-path representations and other handling of [ValidateComplexType].",
        "TimeCode": 49010000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31944,
          "Title": "Add easy way to create a certificate from a multi-PEM or cert-PEM \u002B key-PEM",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-07T21:47:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31944",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-18T00:00:00-07:00",
        "FeedbackId": "646253846",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31944#issuecomment-646253846",
        "FeedbackMarkdown": "Approved without the byte-based password inputs.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates {\r\n    partial class X509Certificate2 {\r\n        public static X509Certificate2 CreateFromPemFile(string certPemFilePath, string keyPemFilePath = default);\r\n        public static X509Certificate2 CreateFromEncryptedPemFile(string certPemFilePath, ReadOnlySpan\u003Cchar\u003E password, string keyPemFilePath = default);\r\n\r\n        public static X509Certificate2 CreateFromPem(ReadOnlySpan\u003Cchar\u003E certPem, ReadOnlySpan\u003Cchar\u003E keyPem);\r\n        public static X509Certificate2 CreateFromEncryptedPem(ReadOnlySpan\u003Cchar\u003E certPem, ReadOnlySpan\u003Cchar\u003E keyPem, ReadOnlySpan\u003Cchar\u003E password);\r\n    }\r\n\r\n    partial class X509Certificate2Collection {\r\n        public void ImportFromPemFile(string certPemFilePath);\r\n        public void ImportFromPem(ReadOnlySpan\u003Cchar\u003E certPem);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 70580000000,
        "Apis": [
          "M:X509Certificate2.CreateFromEncryptedPem(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2.CreateFromEncryptedPemFile(string,ReadOnlySpan\u003Cchar\u003E,string)",
          "M:X509Certificate2.CreateFromPem(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2.CreateFromPemFile(string,string)",
          "M:X509Certificate2Collection.ImportFromPem(ReadOnlySpan\u003Cchar\u003E)",
          "M:X509Certificate2Collection.ImportFromPemFile(string)",
          "T:X509Certificate2",
          "T:X509Certificate2Collection"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "rx_098IdZU0",
      "StartDateTime": "2020-06-25T09:54:00-07:00",
      "EndDateTime": "2020-06-25T12:02:22-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/rx_098IdZU0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34587,
          "Title": "Add empty X64/Arm64 nested classes to some System.Runtime.Intrinsics",
          "Author": "EgorBo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-06T14:11:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34587",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649714324",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34587#issuecomment-649714324",
        "FeedbackMarkdown": "* Good point\r\n* When inheriting, we always should also define all nested types and define \u0060IsSupported\u0060 the appropriately, even if they don\u0027t define any other members.\r\n* (this will probably require more nested types than listed below)\r\n\r\n\u0060\u0060\u0060C#\r\n[Intrinsic]\r\n[CLSCompliant(false)]\r\npublic partial class Sha1 : ArmBase\r\n{\r\n    public abstract class Arm64 : ArmBase.Arm64;\r\n    {\r\n        public static new bool IsSupported =\u003E Sha1.IsSupported \u0026\u0026 IntPtr.Size == 8;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:Sha1.IsSupported",
          "T:Sha1",
          "T:Sha1.Arm64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 936,
          "Title": "Add System.Numerics.Half 16 bit floating point number conforming to IEEE 754:2008 binary16",
          "Author": "4creators",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-04T23:39:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/936",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/936#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 16980000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33532,
          "Title": "[Arm64] Store Pair of SIMD\u0026FP registers",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-12T21:33:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33532",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649724378",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33532#issuecomment-649724378",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    partial class AdvSimd.Arm64\r\n    {\r\n        public static unsafe void StorePair(byte* address, Vector64\u003Cbyte\u003E value1, Vector64\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePair(double* address, Vector64\u003Cdouble\u003E value1, Vector64\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePair(short* address, Vector64\u003Cshort\u003E value1, Vector64\u003Cshort\u003E value2);\r\n        public static unsafe void StorePair(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePair(long* address, Vector64\u003Clong\u003E value1, Vector64\u003Clong\u003E value2);\r\n        public static unsafe void StorePair(sbyte* address, Vector64\u003Csbyte\u003E value1, Vector64\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePair(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePair(ushort* address, Vector64\u003Cushort\u003E value1, Vector64\u003Cushort\u003E value2);\r\n        public static unsafe void StorePair(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n        public static unsafe void StorePair(ulong* address, Vector64\u003Culong\u003E value1, Vector64\u003Culong\u003E value2);\r\n        public static unsafe void StorePair(byte* address, Vector128\u003Cbyte\u003E value1, Vector128\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePair(double* address, Vector128\u003Cdouble\u003E value1, Vector128\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePair(short* address, Vector128\u003Cshort\u003E value1, Vector128\u003Cshort\u003E value2);\r\n        public static unsafe void StorePair(int* address, Vector128\u003Cint\u003E value1, Vector128\u003Cint\u003E value2);\r\n        public static unsafe void StorePair(long* address, Vector128\u003Clong\u003E value1, Vector128\u003Clong\u003E value2);\r\n        public static unsafe void StorePair(sbyte* address, Vector128\u003Csbyte\u003E value1, Vector128\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePair(float* address, Vector128\u003Cfloat\u003E value1, Vector128\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePair(ushort* address, Vector128\u003Cushort\u003E value1, Vector128\u003Cushort\u003E value2);\r\n        public static unsafe void StorePair(uint* address, Vector128\u003Cuint\u003E value1, Vector128\u003Cuint\u003E value2);\r\n        public static unsafe void StorePair(ulong* address, Vector128\u003Culong\u003E value1, Vector128\u003Culong\u003E value2);\r\n\r\n        public static unsafe void StorePairScalar(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairScalar(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairScalar(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n\r\n        public static unsafe void StorePairNonTemporal(byte* address, Vector64\u003Cbyte\u003E value1, Vector64\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(double* address, Vector64\u003Cdouble\u003E value1, Vector64\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(short* address, Vector64\u003Cshort\u003E value1, Vector64\u003Cshort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(long* address, Vector64\u003Clong\u003E value1, Vector64\u003Clong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(sbyte* address, Vector64\u003Csbyte\u003E value1, Vector64\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ushort* address, Vector64\u003Cushort\u003E value1, Vector64\u003Cushort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ulong* address, Vector64\u003Culong\u003E value1, Vector64\u003Culong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(byte* address, Vector128\u003Cbyte\u003E value1, Vector128\u003Cbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(double* address, Vector128\u003Cdouble\u003E value1, Vector128\u003Cdouble\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(short* address, Vector128\u003Cshort\u003E value1, Vector128\u003Cshort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(int* address, Vector128\u003Cint\u003E value1, Vector128\u003Cint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(long* address, Vector128\u003Clong\u003E value1, Vector128\u003Clong\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(sbyte* address, Vector128\u003Csbyte\u003E value1, Vector128\u003Csbyte\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(float* address, Vector128\u003Cfloat\u003E value1, Vector128\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ushort* address, Vector128\u003Cushort\u003E value1, Vector128\u003Cushort\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(uint* address, Vector128\u003Cuint\u003E value1, Vector128\u003Cuint\u003E value2);\r\n        public static unsafe void StorePairNonTemporal(ulong* address, Vector128\u003Culong\u003E value1, Vector128\u003Culong\u003E value2);\r\n\r\n        public static unsafe void StorePairScalarNonTemporal(int* address, Vector64\u003Cint\u003E value1, Vector64\u003Cint\u003E value2);\r\n        public static unsafe void StorePairScalarNonTemporal(float* address, Vector64\u003Cfloat\u003E value1, Vector64\u003Cfloat\u003E value2);\r\n        public static unsafe void StorePairScalarNonTemporal(uint* address, Vector64\u003Cuint\u003E value1, Vector64\u003Cuint\u003E value2);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26510000000,
        "Apis": [
          "M:.StorePair(byte*,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:.StorePair(byte*,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:.StorePair(double*,Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:.StorePair(double*,Vector64\u003Cdouble\u003E,Vector64\u003Cdouble\u003E)",
          "M:.StorePair(float*,Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:.StorePair(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePair(int*,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:.StorePair(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePair(long*,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:.StorePair(long*,Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:.StorePair(sbyte*,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:.StorePair(sbyte*,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:.StorePair(short*,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:.StorePair(short*,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:.StorePair(uint*,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:.StorePair(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePair(ulong*,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:.StorePair(ulong*,Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:.StorePair(ushort*,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:.StorePair(ushort*,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:.StorePairNonTemporal(byte*,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:.StorePairNonTemporal(byte*,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:.StorePairNonTemporal(double*,Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E)",
          "M:.StorePairNonTemporal(double*,Vector64\u003Cdouble\u003E,Vector64\u003Cdouble\u003E)",
          "M:.StorePairNonTemporal(float*,Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E)",
          "M:.StorePairNonTemporal(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairNonTemporal(int*,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:.StorePairNonTemporal(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairNonTemporal(long*,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:.StorePairNonTemporal(long*,Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:.StorePairNonTemporal(sbyte*,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:.StorePairNonTemporal(sbyte*,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:.StorePairNonTemporal(short*,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:.StorePairNonTemporal(short*,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:.StorePairNonTemporal(uint*,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:.StorePairNonTemporal(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePairNonTemporal(ulong*,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:.StorePairNonTemporal(ulong*,Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:.StorePairNonTemporal(ushort*,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:.StorePairNonTemporal(ushort*,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:.StorePairScalar(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairScalar(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairScalar(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:.StorePairScalarNonTemporal(float*,Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E)",
          "M:.StorePairScalarNonTemporal(int*,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:.StorePairScalarNonTemporal(uint*,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36696,
          "Title": "ARM Doubling Multiply intrinsics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-19T13:58:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36696",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649730379",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36696#issuecomment-649730379",
        "FeedbackMarkdown": "* The TODO versions are also approved\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class AdvSimd\r\n    {\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSaturateHighScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSaturateHighScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningSaturateLower(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningSaturateLower(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningSaturateLower(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningSaturateLower(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E   MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cint\u003E   addend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cshort\u003E minuend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cint\u003E   minuend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n    }\r\n\r\n    public abstract class Rdm : AdvSimd\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E   right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E     right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E  right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E    right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  addend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    addend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   addend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cshort\u003E addend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cint\u003E   addend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E right);\r\n\r\n        // TODO: Scalar BySelectedScalar variant\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E  minuend, Vector64\u003Cshort\u003E  left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E    minuend, Vector64\u003Cint\u003E    left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector64\u003Cshort\u003E  right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector64\u003Cint\u003E    right, byte rightIndex);\r\n        public static Vector128\u003Cshort\u003E MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E minuend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right, byte rightIndex);\r\n        public static Vector128\u003Cint\u003E   MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E   minuend, Vector128\u003Cint\u003E   left, Vector128\u003Cint\u003E   right, byte rightIndex);\r\n\r\n        public static Vector64\u003Cshort\u003E  MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cshort\u003E minuend, Vector64\u003Cshort\u003E left, Vector64\u003Cshort\u003E right);\r\n        public static Vector64\u003Cint\u003E    MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cint\u003E   minuend, Vector64\u003Cint\u003E   left, Vector64\u003Cint\u003E   right);    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28530000000,
        "Apis": [
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingAddWideningLowerSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingSubtractWideningLowerSaturateScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningLowerBySelectedScalarSaturate(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLower(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyDoublingWideningSaturateLowerScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:AdvSimd.MultiplyRoundedDoublingSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingAddSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractBySelectedScalarSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,byte)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHigh(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Rdm.MultiplyRoundedDoublingSubtractSaturateHighScalar(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "P:Rdm.IsSupported",
          "T:AdvSimd",
          "T:Rdm"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37014,
          "Title": "Remaining ARM Intrinsics",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-26T15:41:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37014",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649746313",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37014#issuecomment-649746313",
        "FeedbackMarkdown": "label:blocking \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public static class AdvSimd\r\n    {\r\n        public static unsafe (Vector64\u003Cbyte\u003E Value1,    Vector64\u003Cbyte\u003E Value2)    LoadPairVector64(byte*   address);\r\n        public static unsafe (Vector64\u003Csbyte\u003E Value1,   Vector64\u003Csbyte\u003E Value2)   LoadPairVector64(sbyte*  address);\r\n        public static unsafe (Vector64\u003Cshort\u003E Value1,   Vector64\u003Cshort\u003E Value2)   LoadPairVector64(short*  address);\r\n        public static unsafe (Vector64\u003Cushort\u003E Value1,  Vector64\u003Cushort\u003E Value2)  LoadPairVector64(ushort* address);\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairVector64(int*    address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairVector64(uint*   address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairVector64(float*  address);\r\n\r\n        public static unsafe (Vector128\u003Cbyte\u003E Value1,   Vector128\u003Cbyte\u003E Value2)   LoadPairVector128(byte*   address);\r\n        public static unsafe (Vector128\u003Csbyte\u003E Value1,  Vector128\u003Csbyte\u003E Value2)  LoadPairVector128(sbyte*  address);\r\n        public static unsafe (Vector128\u003Cshort\u003E Value1,  Vector128\u003Cshort\u003E Value2)  LoadPairVector128(short*  address);\r\n        public static unsafe (Vector128\u003Cushort\u003E Value1, Vector128\u003Cushort\u003E Value2) LoadPairVector128(ushort* address);\r\n        public static unsafe (Vector128\u003Cint\u003E Value1,    Vector128\u003Cint\u003E Value2)    LoadPairVector128(int*    address);\r\n        public static unsafe (Vector128\u003Cuint\u003E Value1,   Vector128\u003Cuint\u003E Value2)   LoadPairVector128(uint*   address);\r\n        public static unsafe (Vector128\u003Clong\u003E Value1,   Vector128\u003Clong\u003E Value2)   LoadPairVector128(long*   address);\r\n        public static unsafe (Vector128\u003Culong\u003E Value1,  Vector128\u003Culong\u003E Value2)  LoadPairVector128(ulong*  address);\r\n        public static unsafe (Vector128\u003Cfloat\u003E Value1,  Vector128\u003Cfloat\u003E Value2)  LoadPairVector128(float*  address);\r\n\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairScalarVector64(int*  address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairScalarVector64(uint* address);\r\n        public static unsafe (Vector64\u003Clong\u003E Value1,    Vector64\u003Clong\u003E Value2)    LoadPairScalarVector64(long*  address);\r\n        public static unsafe (Vector64\u003Culong\u003E Value1,   Vector64\u003Culong\u003E Value2)   LoadPairScalarVector64(ulong* address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairScalarVector64(float* address);\r\n        public static unsafe (Vector64\u003Cdouble\u003E Value1,  Vector64\u003Cdouble\u003E Value2)  LoadPairScalarVector64(double* address);\r\n\r\n        public static unsafe (Vector64\u003Cbyte\u003E Value1,    Vector64\u003Cbyte\u003E Value2)    LoadPairVector64NonTemporal(byte*   address);\r\n        public static unsafe (Vector64\u003Csbyte\u003E Value1,   Vector64\u003Csbyte\u003E Value2)   LoadPairVector64NonTemporal(sbyte*  address);\r\n        public static unsafe (Vector64\u003Cshort\u003E Value1,   Vector64\u003Cshort\u003E Value2)   LoadPairVector64NonTemporal(short*  address);\r\n        public static unsafe (Vector64\u003Cushort\u003E Value1,  Vector64\u003Cushort\u003E Value2)  LoadPairVector64NonTemporal(ushort* address);\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairVector64NonTemporal(int*    address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairVector64NonTemporal(uint*   address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairVector64NonTemporal(float*  address);\r\n\r\n        public static unsafe (Vector128\u003Cbyte\u003E Value1,   Vector128\u003Cbyte\u003E Value2)   LoadPairVector128NonTemporal(byte*   address);\r\n        public static unsafe (Vector128\u003Csbyte\u003E Value1,  Vector128\u003Csbyte\u003E Value2)  LoadPairVector128NonTemporal(sbyte*  address);\r\n        public static unsafe (Vector128\u003Cshort\u003E Value1,  Vector128\u003Cshort\u003E Value2)  LoadPairVector128NonTemporal(short*  address);\r\n        public static unsafe (Vector128\u003Cushort\u003E Value1, Vector128\u003Cushort\u003E Value2) LoadPairVector128NonTemporal(ushort* address);\r\n        public static unsafe (Vector128\u003Cint\u003E Value1,    Vector128\u003Cint\u003E Value2)    LoadPairVector128NonTemporal(int*    address);\r\n        public static unsafe (Vector128\u003Cuint\u003E Value1,   Vector128\u003Cuint\u003E Value2)   LoadPairVector128NonTemporal(uint*   address);\r\n        public static unsafe (Vector128\u003Clong\u003E Value1,   Vector128\u003Clong\u003E Value2)   LoadPairVector128NonTemporal(long*   address);\r\n        public static unsafe (Vector128\u003Culong\u003E Value1,  Vector128\u003Culong\u003E Value2)  LoadPairVector128NonTemporal(ulong*  address);\r\n        public static unsafe (Vector128\u003Cfloat\u003E Value1,  Vector128\u003Cfloat\u003E Value2)  LoadPairVector128NonTemporal(float*  address);\r\n\r\n        public static unsafe (Vector64\u003Cint\u003E Value1,     Vector64\u003Cint\u003E Value2)     LoadPairScalarVector64NonTemporal(int*  address);\r\n        public static unsafe (Vector64\u003Cuint\u003E Value1,    Vector64\u003Cuint\u003E Value2)    LoadPairScalarVector64NonTemporal(uint* address);\r\n        public static unsafe (Vector64\u003Clong\u003E Value1,    Vector64\u003Clong\u003E Value2)    LoadPairScalarVector64NonTemporal(long*  address);\r\n        public static unsafe (Vector64\u003Culong\u003E Value1,   Vector64\u003Culong\u003E Value2)   LoadPairScalarVector64NonTemporal(ulong* address);\r\n        public static unsafe (Vector64\u003Cfloat\u003E Value1,   Vector64\u003Cfloat\u003E Value2)   LoadPairScalarVector64NonTemporal(float* address);\r\n        public static unsafe (Vector64\u003Cdouble\u003E Value1,  Vector64\u003Cdouble\u003E Value2)  LoadPairScalarVector64NonTemporal(double* address);\r\n\r\n        public static Vector64\u003Csbyte\u003E   ExtractNarrowingSaturateLower(Vector128\u003Cshort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E   ExtractNarrowingSaturateLower(Vector128\u003Cint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ExtractNarrowingSaturateLower(Vector128\u003Clong\u003E   value);\r\n        public static Vector128\u003Csbyte\u003E  ExtractNarrowingSaturateUpper(Vector64\u003Cshort\u003E   lower, Vector128\u003Cshort\u003E  value);\r\n        public static Vector128\u003Cshort\u003E  ExtractNarrowingSaturateUpper(Vector64\u003Cint\u003E     lower, Vector128\u003Cint\u003E    value);\r\n        public static Vector128\u003Cint\u003E    ExtractNarrowingSaturateUpper(Vector64\u003Clong\u003E    lower, Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector64\u003Cbyte\u003E    ExtractNarrowingSaturateLower(Vector128\u003Cushort\u003E value);\r\n        public static Vector64\u003Cushort\u003E  ExtractNarrowingSaturateLower(Vector128\u003Cuint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E    ExtractNarrowingSaturateLower(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractNarrowingSaturateUpper(Vector64\u003Cushort\u003E  lower, Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractNarrowingSaturateUpper(Vector64\u003Cuint\u003E    lower, Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractNarrowingSaturateUpper(Vector64\u003Culong\u003E   lower, Vector128\u003Culong\u003E  value);\r\n\r\n        public static Vector64\u003Cbyte\u003E    ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cshort\u003E value);\r\n        public static Vector64\u003Cushort\u003E  ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cint\u003E   value);\r\n        public static Vector64\u003Cuint\u003E    ExtractNarrowingSaturateUnsignedLower(Vector128\u003Clong\u003E  value);\r\n        public static Vector128\u003Cbyte\u003E   ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E value);\r\n        public static Vector128\u003Cushort\u003E ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cint\u003E    lower, Vector128\u003Cint\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Clong\u003E   lower, Vector128\u003Clong\u003E  value);\r\n\r\n        public static Vector64\u003Cushort\u003E  ReverseElement8(Vector64\u003Cushort\u003E  value);\r\n        public static Vector64\u003Cshort\u003E   ReverseElement8(Vector64\u003Cshort\u003E   value);\r\n        public static Vector128\u003Cushort\u003E ReverseElement8(Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cshort\u003E  ReverseElement8(Vector128\u003Cshort\u003E  value);\r\n\r\n        public static Vector64\u003Cuint\u003E    ReverseElement8(Vector64\u003Cuint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ReverseElement8(Vector64\u003Cint\u003E     value);\r\n        public static Vector64\u003Cfloat\u003E   ReverseElement8(Vector64\u003Cfloat\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ReverseElement8(Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cint\u003E    ReverseElement8(Vector128\u003Cint\u003E    value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement8(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement8(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement8(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement8(Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector64\u003Cuint\u003E    ReverseElement16(Vector64\u003Cuint\u003E    value);\r\n        public static Vector64\u003Cint\u003E     ReverseElement16(Vector64\u003Cint\u003E     value);\r\n        public static Vector64\u003Cfloat\u003E   ReverseElement16(Vector64\u003Cfloat\u003E   value);\r\n        public static Vector128\u003Cuint\u003E   ReverseElement16(Vector128\u003Cuint\u003E   value);\r\n        public static Vector128\u003Cint\u003E    ReverseElement16(Vector128\u003Cint\u003E    value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement16(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement16(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement16(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement16(Vector128\u003Clong\u003E   value);\r\n\r\n        public static Vector128\u003Culong\u003E  ReverseElement32(Vector64\u003Culong\u003E   value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement32(Vector64\u003Clong\u003E    value);\r\n        public static Vector128\u003Culong\u003E  ReverseElement32(Vector128\u003Culong\u003E  value);\r\n        public static Vector128\u003Clong\u003E   ReverseElement32(Vector128\u003Clong\u003E   value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38280000000,
        "Apis": [
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateLower(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedLower(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUnsignedUpper(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:AdvSimd.ExtractNarrowingSaturateUpper(Vector64\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:AdvSimd.LoadPairScalarVector64(double*)",
          "M:AdvSimd.LoadPairScalarVector64(float*)",
          "M:AdvSimd.LoadPairScalarVector64(int*)",
          "M:AdvSimd.LoadPairScalarVector64(long*)",
          "M:AdvSimd.LoadPairScalarVector64(uint*)",
          "M:AdvSimd.LoadPairScalarVector64(ulong*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(double*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(float*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(int*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(long*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(uint*)",
          "M:AdvSimd.LoadPairScalarVector64NonTemporal(ulong*)",
          "M:AdvSimd.LoadPairVector128(byte*)",
          "M:AdvSimd.LoadPairVector128(float*)",
          "M:AdvSimd.LoadPairVector128(int*)",
          "M:AdvSimd.LoadPairVector128(long*)",
          "M:AdvSimd.LoadPairVector128(sbyte*)",
          "M:AdvSimd.LoadPairVector128(short*)",
          "M:AdvSimd.LoadPairVector128(uint*)",
          "M:AdvSimd.LoadPairVector128(ulong*)",
          "M:AdvSimd.LoadPairVector128(ushort*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(byte*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(float*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(int*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(long*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(sbyte*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(short*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(uint*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(ulong*)",
          "M:AdvSimd.LoadPairVector128NonTemporal(ushort*)",
          "M:AdvSimd.LoadPairVector64(byte*)",
          "M:AdvSimd.LoadPairVector64(float*)",
          "M:AdvSimd.LoadPairVector64(int*)",
          "M:AdvSimd.LoadPairVector64(sbyte*)",
          "M:AdvSimd.LoadPairVector64(short*)",
          "M:AdvSimd.LoadPairVector64(uint*)",
          "M:AdvSimd.LoadPairVector64(ushort*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(byte*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(float*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(int*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(sbyte*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(short*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(uint*)",
          "M:AdvSimd.LoadPairVector64NonTemporal(ushort*)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cshort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cushort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cfloat\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Clong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cshort\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Culong\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cushort\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38137,
          "Title": "[Arm64] ASIMD InsertScalar",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-19T00:49:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38137",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649751957",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38137#issuecomment-649751957",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public static class AdvSimd\r\n    {\r\n        public static Vector128\u003Cdouble\u003E InsertScalar(Vector128\u003Cdouble\u003E result, byte resultIndex, Vector64\u003Cdouble\u003E value);\r\n        public static Vector128\u003Clong\u003E   InsertScalar(Vector128\u003Clong\u003E   result, byte resultIndex, Vector64\u003Clong\u003E   value);\r\n        public static Vector128\u003Culong\u003E  InsertScalar(Vector128\u003Culong\u003E  result, byte resultIndex, Vector64\u003Culong\u003E  value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57040000000,
        "Apis": [
          "M:AdvSimd.InsertScalar(Vector128\u003Cdouble\u003E,byte,Vector64\u003Cdouble\u003E)",
          "M:AdvSimd.InsertScalar(Vector128\u003Clong\u003E,byte,Vector64\u003Clong\u003E)",
          "M:AdvSimd.InsertScalar(Vector128\u003Culong\u003E,byte,Vector64\u003Culong\u003E)",
          "T:AdvSimd"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37169,
          "Title": "[Arm64] SIMD dot product",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-29T18:14:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37169",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649754359",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37169#issuecomment-649754359",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class Dp : AdvSimd\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        public static Vector64\u003Cint\u003E   DotProduct(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right);\r\n        public static Vector64\u003Cuint\u003E  DotProduct(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right);\r\n        public static Vector128\u003Cint\u003E  DotProduct(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector128\u003Csbyte\u003E right);\r\n        public static Vector128\u003Cuint\u003E DotProduct(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector128\u003Cbyte\u003E  right);\r\n\r\n        public static Vector64\u003Cint\u003E   DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector64\u003Csbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector64\u003Cint\u003E   DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E   addend, Vector64\u003Csbyte\u003E  left, Vector128\u003Csbyte\u003E right, byte rightScaledIndex);\r\n        public static Vector64\u003Cuint\u003E  DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector64\u003Cbyte\u003E   right, byte rightScaledIndex);\r\n        public static Vector64\u003Cuint\u003E  DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E  addend, Vector64\u003Cbyte\u003E   left, Vector128\u003Cbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cint\u003E  DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector128\u003Csbyte\u003E right, byte rightScaledIndex);\r\n        public static Vector128\u003Cint\u003E  DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E  addend, Vector128\u003Csbyte\u003E left, Vector64\u003Csbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cuint\u003E DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector128\u003Cbyte\u003E  right, byte rightScaledIndex);\r\n        public static Vector128\u003Cuint\u003E DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E addend, Vector128\u003Cbyte\u003E  left, Vector64\u003Cbyte\u003E   right, byte rightScaledIndex);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64730000000,
        "Apis": [
          "M:Dp.DotProduct(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:Dp.DotProduct(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Dp.DotProduct(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:Dp.DotProduct(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cint\u003E,Vector128\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector128\u003Cuint\u003E,Vector128\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cint\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Dp.DotProductBySelectedQuadruplet(Vector64\u003Cuint\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,byte)",
          "P:Dp.IsSupported",
          "T:Dp"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38348,
          "Title": "Allow creating more cryptographic objects from ReadOnlySpan\u003Cbyte\u003E",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-24T18:25:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38348",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649759447",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38348#issuecomment-649759447",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography\r\n{\r\n    partial class AsnEncodedData\r\n    {\r\n        protected AsnEncodedData() { }\r\n        public AsnEncodedData(byte[] rawData) { }\r\n\u002B       public AsnEncodedData(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n        public AsnEncodedData(System.Security.Cryptography.AsnEncodedData asnEncodedData) { }\r\n        public AsnEncodedData(System.Security.Cryptography.Oid? oid, byte[] rawData) { }\r\n\u002B       public AsnEncodedData(System.Security.Cryptography.Oid? oid, System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n        public AsnEncodedData(string oid, byte[] rawData) { }\r\n\u002B       public AsnEncodedData(string oid, System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n    }\r\n}\r\n\r\nnamespace System.Security.Cryptography.Pkcs\r\n{\r\n    partial class ContentInfo\r\n    {\r\n        public static System.Security.Cryptography.Oid GetContentType(byte[] encodedMessage) { throw null; }\r\n\u002B       public static System.Security.Cryptography.Oid GetContentType(ReadOnlySpan\u003Cbyte\u003E encodedMessage) { throw null; }\r\n    }\r\n\r\n    partial class EnvelopedCms\r\n    {\r\n        public void Decode(byte[] encodedMessage) { }\r\n\u002B       public void Decode(System.ReadOnlySpan\u003Cbyte\u003E encodedMessage) { }\r\n    }\r\n\r\n    partial class SignedCms\r\n    {\r\n        public void Decode(byte[] encodedMessage) { }\r\n\u002B       public void Decode(System.ReadOnlySpan\u003Cbyte\u003E encodedMessage) { }\r\n     }\r\n}\r\n\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    partial class CertificateRequest\r\n    {\r\n        public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedName issuerName,\r\n            System.Security.Cryptography.X509Certificates.X509SignatureGenerator generator,\r\n            System.DateTimeOffset notBefore,\r\n            System.DateTimeOffset notAfter,\r\n            byte[] serialNumber) { throw null; }\r\n\u002B       public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n\u002B           System.Security.Cryptography.X509Certificates.X500DistinguishedName issuerName,\r\n\u002B           System.Security.Cryptography.X509Certificates.X509SignatureGenerator generator,\r\n\u002B           System.DateTimeOffset notBefore,\r\n\u002B           System.DateTimeOffset notAfter,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E serialNumber) { throw null; }\r\n        public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n            System.Security.Cryptography.X509Certificates.X509Certificate2 issuerCertificate,\r\n            System.DateTimeOffset notBefore,\r\n            System.DateTimeOffset notAfter,\r\n            byte[] serialNumber) { throw null; }\r\n\u002B       public System.Security.Cryptography.X509Certificates.X509Certificate2 Create(\r\n\u002B           System.Security.Cryptography.X509Certificates.X509Certificate2 issuerCertificate,\r\n\u002B           System.DateTimeOffset notBefore,\r\n\u002B           System.DateTimeOffset notAfter,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E serialNumber) { throw null; }\r\n    }\r\n\r\n    partial class X500DistinguishedName : System.Security.Cryptography.AsnEncodedData\r\n    {\r\n        public X500DistinguishedName(byte[] encodedDistinguishedName) { }\r\n\u002B       public X500DistinguishedName(System.ReadOnlySpan\u003Cbyte\u003E encodedDistinguishedName) { }\r\n        public X500DistinguishedName(System.Security.Cryptography.AsnEncodedData encodedDistinguishedName) { }\r\n        public X500DistinguishedName(\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedName distinguishedName) { }\r\n        public X500DistinguishedName(string distinguishedName) { }\r\n        public X500DistinguishedName(\r\n            string distinguishedName,\r\n            System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags flag) { }\r\n    }\r\n\r\n    partial class X509Certificate2 : System.Security.Cryptography.X509Certificates.X509Certificate\r\n    {\r\n        public X509Certificate2() { }\r\n        public X509Certificate2(byte[] rawData) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(byte[] rawData, System.Security.SecureString? password) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(\r\n            byte[] rawData,\r\n            System.Security.SecureString? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(byte[] rawData, string? password) { }\r\n        public X509Certificate2(\r\n            byte[] rawData,\r\n            string? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(System.IntPtr handle) { }\r\n\u002B       public X509Certificate2(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n\u002B       public X509Certificate2(\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E rawData,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        protected X509Certificate2(\r\n            System.Runtime.Serialization.SerializationInfo info,\r\n            System.Runtime.Serialization.StreamingContext context) { }\r\n        public X509Certificate2(System.Security.Cryptography.X509Certificates.X509Certificate certificate) { }\r\n        public X509Certificate2(string fileName) { }\r\n\u002B       public X509Certificate2(\r\n\u002B           string fileName,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(string fileName, System.Security.SecureString? password) { }\r\n        [System.CLSCompliantAttribute(false)]\r\n        public X509Certificate2(\r\n            string fileName,\r\n            System.Security.SecureString? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public X509Certificate2(string fileName, string? password) { }\r\n        public X509Certificate2(\r\n            string fileName,\r\n            string? password,\r\n            System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags) { }\r\n        public static X509ContentType GetCertContentType(byte[] rawData) { throw null; }\r\n\u002B       public static X509ContentType GetCertContentType(System.ReadOnlySpan\u003Cbyte\u003E rawData) { throw null; }\r\n        public static X509ContentType GetCertContentType(string fileName) { throw null; }\r\n    }\r\n\r\n    partial class X509Certificate2Collection\r\n    {\r\n        public void Import(byte[] rawData) { }\r\n        public void Import(\r\n            byte[] rawData,\r\n            string? password,\r\n-           X509KeyStorageFlags keyStorageFlags) { }\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n\u002B       public void Import(System.ReadOnlySpan\u003Cbyte\u003E rawData) { }\r\n\u002B       public void Import(\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E rawData,\r\n\u002B           System.ReadOnlySpan\u003Cchar\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        public void Import(string fileName) { }\r\n\u002B       public void Import(\r\n\u002B           string fileName,\r\n\u002B           System.ReadOnlySpan\u003Cbyte\u003E password,\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n        public void Import(\r\n            string fileName,\r\n            string? password,\r\n-           X509KeyStorageFlags keyStorageFlags) { }\r\n\u002B           X509KeyStorageFlags keyStorageFlags = X509KeyStorageFlags.DefaultKeySet) { }\r\n    }\r\n\r\n    partial class X509Extension : System.Security.Cryptography.AsnEncodedData\r\n        protected X509Extension() { }\r\n        public X509Extension(System.Security.Cryptography.AsnEncodedData encodedExtension, bool critical) { }\r\n        public X509Extension(System.Security.Cryptography.Oid oid, byte[] rawData, bool critical) { }\r\n\u002B       public X509Extension(System.Security.Cryptography.Oid oid, System.ReadOnlySpan\u003Cbyte\u003E rawData, bool critical) { }\r\n        public X509Extension(string oid, byte[] rawData, bool critical) { }\r\n\u002B       public X509Extension(string oid, System.ReadOnlySpan\u003Cbyte\u003E rawData, bool critical) { }\r\n    }\r\n\r\n    partial class X509SubjectKeyIdentifierExtension : System.Security.Cryptography.X509Certificates.X509Extension\r\n    {\r\n        public X509SubjectKeyIdentifierExtension() { }\r\n        public X509SubjectKeyIdentifierExtension(byte[] subjectKeyIdentifier, bool critical) { }\r\n\u002B       public X509SubjectKeyIdentifierExtension(System.ReadOnlySpan\u003Cbyte\u003E subjectKeyIdentifier, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.AsnEncodedData encodedSubjectKeyIdentifier, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.X509Certificates.PublicKey key, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(System.Security.Cryptography.X509Certificates.PublicKey key, System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical) { }\r\n        public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical) { }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 67440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36105,
          "Title": "Implement CachedBitmap functionality in System.Drawing",
          "Author": "reflectronic",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-08T08:18:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36105",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-25T00:00:00-07:00",
        "FeedbackId": "649761495",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36105#issuecomment-649761495",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Drawing.Imaging\r\n{\r\n\u002B   public sealed class CachedBitmap : MarshalByRefObject, IDisposable\r\n\u002B   {\r\n\u002B       public CachedBitmap(Bitmap bitmap, Graphics graphics);\r\n\u002B       public void Dispose();  \r\n\u002B   }\r\n} \r\n\r\nnamespace System.Drawing\r\n{\r\n    public sealed class Graphics : MarshalByRefObject, IDisposable, IDeviceContext\r\n    {\r\n\u002B       public void DrawCachedBitmap(CachedBitmap cachedBitmap, int x, int y);   \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 74070000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "R5G4scTRRNQ",
      "StartDateTime": "2020-06-26T10:00:12-07:00",
      "EndDateTime": "2020-06-26T11:55:24-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/R5G4scTRRNQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33331,
          "Title": "Guarding calls to platform-specific APIs",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-07T06:36:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33331",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-26T00:00:00-07:00",
        "FeedbackId": "650326500",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33331#issuecomment-650326500",
        "FeedbackMarkdown": "* We should rename \u0060TargetPlatformMinVersion\u0060\r\n    - It\u0027s a runtime concept, not a targeting concept\r\n* Can we change \u0060Platform\u0060 to \u0060OS\u0060?\r\n* \u0060MinimumPlatform\u0060 -\u003E \u0060MinimumOSPlatform\u0060\r\n* \u0060PlatformAttribute\u0060 should have an internal constructor\r\n* Add \u0060ObsoletedInPlatformAttribute.Message\u0060\r\n* \u0060RuntimeInformation\u0060\r\n    - \u0060IsOSPlatformOrLater\u0060 should also take a \u0060string\u0060\r\n    - \u0060IsOSPlatformEarlierThan\u0060 should also take a \u0060string\u0060\r\n    - The \u0060IsPlatformXXx\u0060 methods should be recognized by the JIT to be constant\r\n* \u0060OSPlatform\u0060\r\n    - Hide \u0060OSX\u0060\r\n    - Add \u0060macOS\u0060\r\n* Analyzer\r\n    - The analyzer should handle \u0060Debug.Assert\u0060 for these methods\r\n    - Should we support helpers methods? We concluded we don\u0027t need it yet",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37359,
          "Title": "OS compatibility analyzer",
          "Author": "buyaa-n",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-03T17:43:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37359",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-26T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37359#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 48600000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "5w9Cbgr1HJY",
      "StartDateTime": "2020-06-30T11:04:39-07:00",
      "EndDateTime": "2020-06-30T12:16:26-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5w9Cbgr1HJY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38028,
          "Title": "Async System.Data resultset and database schema APIs",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-17T14:05:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38028",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651967965",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38028#issuecomment-651967965",
        "FeedbackMarkdown": "* Instead of adding an interface member, we\u0027d prefer exposing a new virtual on \u0060DbDataReader\u0060 directly\r\n    - @ajcvickers will follow up to see why we had the extension method calling through the interface instead.\r\n* We avoid having more than two optional parameters b/c we found in UX studies that optional parameters are confusing\r\n    - We should mirror the sync version which has had three overloads\r\n    - Sadly all three were virtual and no overload accepts null (thus can\u0027t be chained)\r\n    - For consistency, we should follow this pattern.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbConnection\r\n    {\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(string collectionName, CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CDataTable\u003E GetSchemaAsync(string collectionName, string[] restrictions, CancellationToken cancellationToken = default);\r\n    }\r\n\r\n    public partial class DbDataReader\r\n    {\r\n        public virtual Task\u003CDataTable\u003E GetSchemaTableAsync(CancellationToken cancellationToken = default);\r\n        public virtual Task\u003CReadOnlyCollection\u003CDbColumn\u003E\u003E GetColumnSchemaAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DbConnection.GetSchemaAsync(CancellationToken)",
          "M:DbConnection.GetSchemaAsync(string,CancellationToken)",
          "M:DbConnection.GetSchemaAsync(string,string[],CancellationToken)",
          "M:DbDataReader.GetColumnSchemaAsync(CancellationToken)",
          "M:DbDataReader.GetSchemaTableAsync(CancellationToken)",
          "T:DbConnection",
          "T:DbDataReader"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34817,
          "Title": "Database-agnostic way to detect transient database errors",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-10T11:37:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34817",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651987951",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34817#issuecomment-651987951",
        "FeedbackMarkdown": "* Makes sense as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbException\r\n    {\r\n        public virtual bool IsTransient =\u003E false;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15540000000,
        "Apis": [
          "P:DbException.IsTransient",
          "T:DbException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35601,
          "Title": "Introduce SqlState on DbException for standard cross-database errors",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-29T12:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35601",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-06-30T00:00:00-07:00",
        "FeedbackId": "651990751",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35601#issuecomment-651990751",
        "FeedbackMarkdown": "* Makes sense as proposed.\r\n* It seems if we had this, we could make the default implementation for \u0060DbException.IsTransient\u0060 (#34817) check whether \u0060SqlState\u0060 is not null and return true for transient SQLSTATE values.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public partial class DbException\r\n    {\r\n        public virtual string? SqlState { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38870000000,
        "Apis": [
          "P:DbException.SqlState",
          "T:DbException"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "eDDX05uBtFc",
      "StartDateTime": "2020-07-02T10:04:18-07:00",
      "EndDateTime": "2020-07-02T12:54:02-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/eDDX05uBtFc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38133,
          "Title": "Add a new \u0060unmanaged\u0060 calling convention bit for use with function pointers",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-19T00:27:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38133",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653130834",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38133#issuecomment-653130834",
        "FeedbackMarkdown": "Technically, the actual calling convention is expressed as modopt on the return type but we felt a vague name is good enough.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    public enum SignatureCallingConvention : byte\r\n    {\r\n        Unmanaged = 0x9\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:SignatureCallingConvention.Unmanaged",
          "T:SignatureCallingConvention"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38135,
          "Title": "\u0060System.Runtime.CompilerServices.RuntimeFeature.UnmanagedCallKind\u0060",
          "Author": "333fred",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-19T00:46:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38135",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653135036",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38135#issuecomment-653135036",
        "FeedbackMarkdown": "* We considered keying it off of the presence of the attribute but the attribute isn\u0027t the same feature. Also, the compiler would want the type to exist in corlib (to ensure it\u0027s not user defined). That would feel odd, considering all modifiers live in \u0060System.Runtime.InteropServices.dll\u0060.\r\n* We agree that making that \u0060RuntimeFeature\u0060 a dumping ground for all new compiler features would be bad, but it seems runtime type system constraints would be long to \u0060RuntimeFeature\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeFeature\r\n    {\r\n        public const string UnmanagedSignatureCallingConvention = nameof(UnmanagedSignatureCallingConvention);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10940000000,
        "Apis": [
          "F:RuntimeFeature.UnmanagedSignatureCallingConvention",
          "T:RuntimeFeature"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38683,
          "Title": "Add NativeIntegerAttribute",
          "Author": "cston",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-01T21:39:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38683",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653136856",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38683#issuecomment-653136856",
        "FeedbackMarkdown": "* We didn\u0027t add \u0060NullableAttribute\u0060. We only added attributes that we expect users to reference explicitly by manually adding custom attributes. It seems this attribute would only be emitted and read by the compiler, so unless there is a reason, we\u0027d not add it.\r\n* Please reopen otherwise.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(\r\n        AttributeTargets.Class |\r\n        AttributeTargets.Event |\r\n        AttributeTargets.Field |\r\n        AttributeTargets.GenericParameter |\r\n        AttributeTargets.Parameter |\r\n        AttributeTargets.Property |\r\n        AttributeTargets.ReturnValue,\r\n        AllowMultiple = false,\r\n        Inherited = false)]\r\n    public sealed class NativeIntegerAttribute : Attribute\r\n    {\r\n        public NativeIntegerAttribute()\r\n        {\r\n            TransformFlags = new[] { true };\r\n        }\r\n        public NativeIntegerAttribute(bool[] flags)\r\n        {\r\n            TransformFlags = flags;\r\n        }\r\n        public IList\u003Cbool\u003E TransformFlags { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16660000000,
        "Apis": [
          "M:NativeIntegerAttribute.NativeIntegerAttribute()",
          "M:NativeIntegerAttribute.NativeIntegerAttribute(bool[])",
          "P:NativeIntegerAttribute.TransformFlags",
          "T:NativeIntegerAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34742,
          "Title": "Flexible and efficient optionally-structured console logging out of the box",
          "Author": "jskeet",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-16T13:09:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34742",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653193414",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34742#issuecomment-653193414",
        "FeedbackMarkdown": "* Drop \u0060Log\u0060 from names\r\n* Rename \u0060Default\u0060 so something that doesn\u0027t imply a subset relationship, such as \u0060Simple\u0060\r\n* Implementers of \u0060IConsoleFormatter\u0060 should use VT100 for colors\r\n* On Windows 7 we still want to show colors, not VT100 escape sequences\r\n* On Windows 10\u002B we want to see colors, not VT100 escape sequences, even if VT100 processing is off\r\n* Should .NET 5 by default enable VT100 processing? @shirhatti will file an issue for that.\r\n\r\n**Assembly:** Microsoft.Extensions.Logging.Abstractions.dll\r\n\r\n\u0060\u0060\u0060diff\r\n namespace Microsoft.Extensions.Logging\r\n {\r\n\u002B    public readonly struct LogEntry\u003CTState\u003E\r\n\u002B    {\r\n\u002B       public LogEntry(LogLevel logLevel,\r\n\u002B                       string category,\r\n\u002B                       EventId eventId,\r\n\u002B                       TState state,\r\n\u002B                       Exception exception,\r\n\u002B                       Func\u003CTState, Exception, string\u003E formatter);\r\n\u002B       public LogLevel LogLevel { get; }\r\n\u002B       public string Category { get; }\r\n\u002B       public EventId EventId { get; }\r\n\u002B       public TState State { get; }\r\n\u002B       public Exception Exception { get; }\r\n\u002B       public Func\u003CTState, Exception, string\u003E Formatter { get; }\r\n\u002B    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Assembly:** Microsoft.Extensions.Logging.Console.dll\r\n\r\n\u0060\u0060\u0060diff\r\n namespace Microsoft.Extensions.Logging\r\n {\r\n     public static partial class ConsoleLoggerExtensions\r\n     {\r\n         public static ILoggingBuilder AddConsole(this ILoggingBuilder builder);\r\n         public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, Action\u003CConsoleLoggerOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddConsoleFormatter\u003CTFormatter, TOptions\u003E(this ILoggingBuilder builder)\r\n\u002B                                      where TFormatter : class, IConsoleFormatter where TOptions : ConsoleFormatterOptions;\r\n\u002B        public static ILoggingBuilder AddConsoleFormatter\u003CTFormatter, TOptions\u003E(this ILoggingBuilder builder, Action\u003CTOptions\u003E configure)\r\n\u002B                                      where TFormatter : class, IConsoleFormatter where TOptions : ConsoleFormatterOptions;\r\n\u002B        public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, Action\u003CSimpleConsoleFormatterOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder, Action\u003CJsonConsoleFormatterOptions\u003E configure);\r\n\u002B        public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder, Action\u003CConsoleFormatterOptions\u003E configure);\r\n     }\r\n }\r\n namespace Microsoft.Extensions.Logging.Console\r\n {\r\n\u002B    public static partial class ConsoleFormatterNames\r\n\u002B    {\r\n\u002B        public const string Simple = \u0022simple\u0022;\r\n\u002B        public const string Json = \u0022json\u0022;\r\n\u002B        public const string Systemd = \u0022systemd\u0022;\r\n\u002B    }\r\n\u002B    [ObsoleteAttribute(\u0022ConsoleLoggerFormat has been deprecated.\u0022, false)]\r\n     public enum ConsoleLoggerFormat\r\n     {\r\n         Default = 0,\r\n         Systemd = 1,\r\n     }\r\n     public partial class ConsoleLoggerOptions\r\n     {\r\n         public ConsoleLoggerOptions();\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.DisableColors has been deprecated. Please use ColoredConsoleFormatterOptions.DisableColors instead.\u0022, false)]\r\n         public bool DisableColors { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.Format has been deprecated. Please use ConsoleLoggerOptions.FormatterName instead.\u0022, false)]\r\n         public ConsoleLoggerFormat Format { get; set; }\r\n         public string FormatterName { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.IncludeScopes has been deprecated..\u0022, false)]\r\n         public bool IncludeScopes { get; set; }\r\n         public LogLevel LogToStandardErrorThreshold { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.TimestampFormat has been deprecated..\u0022, false)]\r\n         public string TimestampFormat { get; set; }\r\n\u002B        [ObsoleteAttribute(\u0022ConsoleLoggerOptions.UseUtcTimestamp has been deprecated..\u0022, false)]\r\n         public bool UseUtcTimestamp { get; set; }\r\n     }\r\n     [ProviderAliasAttribute(\u0022Console\u0022)]\r\n     public partial class ConsoleLoggerProvider : ILoggerProvider, ISupportExternalScope, IDisposable\r\n     {\r\n         public ConsoleLoggerProvider(IOptionsMonitor\u003CConsoleLoggerOptions\u003E options);\r\n\u002B        public ConsoleLoggerProvider(IOptionsMonitor\u003CConsoleLoggerOptions\u003E options, IEnumerable\u003CIConsoleFormatter\u003E formatters);\r\n         public ILogger CreateLogger(string name);\r\n         public void Dispose();\r\n         public void SetScopeProvider(IExternalScopeProvider scopeProvider);\r\n     }\r\n\u002B    public partial class SimpleConsoleFormatterOptions : ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public SimpleConsoleFormatterOptions();\r\n\u002B        public bool DisableColors { get; set; }\r\n\u002B        public bool SingleLine { get; set; }\r\n\u002B    }\r\n\u002B    public partial abstract ConsoleFormatter\r\n\u002B    {\r\n\u002B        protected ConsoleFormatter(string name);\r\n\u002B        public string Name { get; }\r\n\u002B        public abstract void Write\u003CTState\u003E(in LogEntry\u003CTState\u003E logEntry,\r\n\u002B                                           IExternalScopeProvider scopeProvider,\r\n\u002B                                           TextWriter textWriter);\r\n\u002B    }\r\n\u002B    public partial class JsonConsoleFormatterOptions : ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public JsonConsoleFormatterOptions();\r\n\u002B        public JsonWriterOptions JsonWriterOptions { get; set; }\r\n\u002B    }\r\n\u002B    public partial class ConsoleFormatterOptions\r\n\u002B    {\r\n\u002B        public ConsoleFormatterOptions();\r\n\u002B        public bool IncludeScopes { get; set; }\r\n\u002B        public string TimestampFormat { get; set; }\r\n\u002B        public bool UseUtcTimestamp { get; set; }\r\n\u002B    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35088,
          "Title": "HTTP2: Create additional connections when maximum active streams is reached",
          "Author": "JamesNK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-17T01:20:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35088",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-02T00:00:00-07:00",
        "FeedbackId": "653248184",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35088#issuecomment-653248184",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public int MaxHttp2ConnectionsPerServer { get; set; }\r\n    }   \r\n    public partial class WinHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.MaxHttp2ConnectionsPerServer",
          "P:WinHttpHandler.EnableMultipleHttp2Connections",
          "T:SocketsHttpHandler",
          "T:WinHttpHandler"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9sjP8x1L93w",
      "StartDateTime": "2020-07-07T10:05:29-07:00",
      "EndDateTime": "2020-07-07T12:16:21-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9sjP8x1L93w/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38419,
          "Title": "Improve Activity API usability and OpenTelemetry integration (Part 2)",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-26T00:34:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38419",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-07T00:00:00-07:00",
        "FeedbackId": "655054487",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38419#issuecomment-655054487",
        "FeedbackMarkdown": "[Spec](https://github.com/dotnet/designs/pull/134)\r\n\r\n* \u0060ActivityContext.IsRemote\u0060 sounds like the instance is remoted, which isn\u0027t the case, but we can\u0027t think of a better name.\r\n* Making \u0060Activity.Kind\u0060 settable seems very unfortunate. Given we do this backward compat only, we should find another way of doing this without making one of the key properties mutable. One option is to disallow changing after it was observed (whatever that means). The preferred option would be to find a way that doesn\u0027t require mutation (constructor parameter, factory method etc). This part requries more design.\r\n* \u0060Activity.Attributes\u0060 seems unfortunate b/c it adds more concepts.\r\n    - Add \u0060SetTag(string, object)\u0060\r\n    - Add \u0060AddTag(string, object)\u0060\r\n    - Add \u0060TagObjects\u0060\r\n    - The existing \u0060Tags\u0060 property should probably be marked as obsolete and return all convert all objects to string.\r\n* \u0060ActivityAttributesCollection\u0060 should be renamed to something \u0060ActivityTagsCollection\u0060\r\n* \u0060ActivityListener.PregenerateNewRootId\u0060 has complex policy so be it\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public readonly partial struct ActivityContext\r\n    {\r\n        // This constructor already exist but we are adding extra defaulted parameter for isRemote.\r\n        public ActivityContext(ActivityTraceId traceId, ActivitySpanId spanId, ActivityTraceFlags traceFlags, string? traceState = null, isRemote = false);\r\n\r\n        // This is the new property\r\n        public bool IsRemote { get; }\r\n    }\r\n    public partial class Activity\r\n    {\r\n        public void AddTag(string key, object value);\r\n        public void SetTag(string key, object value);\r\n        public IEnumerable\u003CKeyValuePair\u003Cstring, object\u003E\u003E TagObjects { get; }\r\n    }\r\n    public readonly struct ActivityEvent\r\n    {\r\n        public ActivityEvent(string name);\r\n        public ActivityEvent(string name, DateTimeOffset? timestamp = null, ActivityTagsCollection? tags = null);\r\n    }\r\n    public readonly partial struct ActivityLink  : IEquatable\u003CActivityLink\u003E\r\n    {\r\n        public ActivityLink(ActivityContext context, ActivityTagsCollection? tags = null);\r\n    }\r\n    public class ActivityTagsCollection : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Implements this[key] = value as deleting the key\r\n        // Add(key, null) should throw if key already exists, otherwise no-op\r\n        // Should meant that this[key] returns null for-non existing keys too\r\n    }\r\n    public sealed class ActivityListener\r\n    {\r\n        public bool AutoGenerateRootContextTraceId { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Activity.AddTag(string,object)",
          "M:Activity.SetTag(string,object)",
          "M:ActivityContext.ActivityContext(ActivityTraceId,ActivitySpanId,ActivityTraceFlags,string?,isRemote)",
          "M:ActivityEvent.ActivityEvent(string,DateTimeOffset?,ActivityTagsCollection?)",
          "M:ActivityEvent.ActivityEvent(string)",
          "M:ActivityLink.ActivityLink(ActivityContext,ActivityTagsCollection?)",
          "P:Activity.TagObjects",
          "P:ActivityContext.IsRemote",
          "P:ActivityListener.AutoGenerateRootContextTraceId",
          "T:Activity",
          "T:ActivityContext",
          "T:ActivityEvent",
          "T:ActivityLink",
          "T:ActivityListener",
          "T:ActivityTagsCollection"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 34168,
          "Title": "Configuring request options in Browser WebAssembly",
          "Author": "pranavkm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-26T23:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/34168",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-wasm",
              "Color": "eb6420",
              "Description": "WebAssembly architecture"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-07T00:00:00-07:00",
        "FeedbackId": "655067469",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/34168#issuecomment-655067469",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public readonly struct HttpRequestOptionsKey\u003CTValue\u003E\r\n    {\r\n        public HttpRequestOptionsKey(string key);\r\n        public string Key { get; }\r\n    }\r\n    public sealed class HttpRequestOptions : IDictionary\u003Cstring, object\u003E\r\n    {\r\n        // Explicit interface implementation\r\n        public bool TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, out TValue value);\r\n        public void Set\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E key, TValue value);\r\n    }\r\n    public class HttpRequestMessage : IDisposable\r\n    {\r\n        [Obsolete(\u0022Use Options instead.\u0022)]\r\n        public IDictionary\u003Cstring, object\u003E Properties =\u003E Options;\r\n\r\n        public HttpRequestOptions Options { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62560000000,
        "Apis": [
          "M:HttpRequestOptions.Set\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,TValue)",
          "M:HttpRequestOptions.TryGetValue\u003CTValue\u003E(HttpRequestOptionsKey\u003CTValue\u003E,out TValue)",
          "M:HttpRequestOptionsKey\u003CTValue\u003E.HttpRequestOptionsKey(string)",
          "P:HttpRequestMessage.Options",
          "P:HttpRequestMessage.Properties",
          "P:HttpRequestOptionsKey\u003CTValue\u003E.Key",
          "T:HttpRequestMessage",
          "T:HttpRequestOptions",
          "T:HttpRequestOptionsKey\u003CTValue\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Uu-vtMorrC0",
      "StartDateTime": "2020-07-09T10:09:30-07:00",
      "EndDateTime": "2020-07-09T12:17:58-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Uu-vtMorrC0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38467,
          "Title": "System.Formats.Cbor: Add Reader and Writer methods for System.Half.",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-26T19:45:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38467",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38467#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38984,
          "Title": "Add PlatformID.Unknown value",
          "Author": "marek-safar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-09T07:10:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38984",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-wasm",
              "Color": "eb6420",
              "Description": "WebAssembly architecture"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656250578",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38984#issuecomment-656250578",
        "FeedbackMarkdown": "API review suggests that \u0022Other\u0022 is a better name, since it is \u0022known\u0022 to not be one of the other values.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System\r\n{\r\n    public enum PlatformID\r\n    {\r\n        MacOSX = 6,\r\n\u002B       Other = 7,\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nAdditionally, if we haven\u0027t already done obsoletion plans for this enum and the things related to it, it\u0027s probably a good idea.",
        "TimeCode": 920000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35060,
          "Title": "Request for Logging Internals to be public again",
          "Author": "JakenVeina",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-24T03:32:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35060",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656257152",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35060#issuecomment-656257152",
        "FeedbackMarkdown": "Adding the DefineScope T4-T6 for parity is approved.  If you want to add further ones, that\u0027s also approved, but in the review the comments were \u0022why stop at 8?\u0022 and \u0022do we need 7 and 8?\u0022.  If there\u0027s need for this, then they\u0027re approved.  If not, then maybe hold off.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\n    public static partial class LoggerMessage\r\n    {\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4\u003E(string formatString) { throw null; }\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4, T5\u003E(string formatString) { throw null; }\r\n        public static System.Func\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, T6, System.IDisposable\u003E DefineScope\u003CT1, T2, T3, T4, T5, T6\u003E(string formatString) { throw null; }\r\n    }",
        "TimeCode": 3570000000,
        "Apis": [
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4, T5, T6\u003E(string)",
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4, T5\u003E(string)",
          "M:LoggerMessage.DefineScope\u003CT1, T2, T3, T4\u003E(string)",
          "T:LoggerMessage"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38711,
          "Title": "Http header value Encoding selection",
          "Author": "MihaZupan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-02T16:11:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38711",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656265904",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38711#issuecomment-656265904",
        "FeedbackMarkdown": "* ResponseHeaderEncodingSelector changed to using the request message, not the response, because of complexities of mutation across calls.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    // \u0022RequestHeaderEncodingSelector\u0022 in Kestrel\r\n\r\n    public sealed class SocketsHttpHandler\r\n    {\r\n        public Func\u003Cstring, HttpRequestMessage, Encoding?\u003E? RequestHeaderEncodingSelector { get; set; }\r\n        public Func\u003Cstring, HttpRequestMessage, Encoding?\u003E? ResponseHeaderEncodingSelector { get; set; }\r\n    }\r\n    \r\n    public class MultipartContent\r\n    {\r\n        public Func\u003Cstring, HttpContent, Encoding?\u003E? HeaderEncodingSelector { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nSince the \u0060string\u0060 argument in the Func is not obviously a headerName value, consider using a custom delegate to name the parameter:\r\n\r\n\u0060\u0060\u0060C#\r\npublic delegate Encoding? HeaderEncodingSelector\u003CTContext\u003E(string headerName, TContext context);\r\n\u0060\u0060\u0060",
        "TimeCode": 14010000000,
        "Apis": [
          "P:MultipartContent.HeaderEncodingSelector",
          "P:SocketsHttpHandler.RequestHeaderEncodingSelector",
          "P:SocketsHttpHandler.ResponseHeaderEncodingSelector",
          "T:HeaderEncodingSelector\u003CTContext\u003E(string,TContext)",
          "T:MultipartContent",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17590,
          "Title": "Add static hash helper methods",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-06-12T13:24:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17590",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656269790",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17590#issuecomment-656269790",
        "FeedbackMarkdown": "Approved as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MD5\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA1\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA256\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA384\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA512\r\n{\r\n    public static byte[] Hash(byte[] source) =\u003E throw null;\r\n    public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25490000000,
        "Apis": [
          "M:MD5.Hash(byte[])",
          "M:MD5.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:MD5.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:MD5.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA1.Hash(byte[])",
          "M:SHA1.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA1.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA1.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA256.Hash(byte[])",
          "M:SHA256.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA256.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA256.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA384.Hash(byte[])",
          "M:SHA384.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA384.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA384.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA512.Hash(byte[])",
          "M:SHA512.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA512.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA512.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "T:MD5",
          "T:SHA1",
          "T:SHA256",
          "T:SHA384",
          "T:SHA512"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27655,
          "Title": "Add EnumMemberAttribute constructor",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-17T16:15:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27655",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656275959",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27655#issuecomment-656275959",
        "FeedbackMarkdown": "Since the property is already settable, our guidelines say that it can\u0027t also be a constructor parameter -- largely because it makes reading attributes harder via metadata readers.\r\n\r\n\u003E DO NOT provide constructor parameters to initialize properties corresponding to the optional arguments.",
        "TimeCode": 30490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29400,
          "Title": "Proposal: Inject existing object into MEF2",
          "Author": "gthvidsten",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-04-27T18:08:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29400",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Composition",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656282604",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29400#issuecomment-656282604",
        "FeedbackMarkdown": "After some discussion on the name of the methods, the use of defaults parameters, and the name of the generic, it\u0027s approved as\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Composition.Hosting\r\n{\r\n    public class ContainerConfiguration\r\n    {\r\n        public ContainerConfiguration WithExport\u003CTExport\u003E(TExport exportedInstance);\r\n        public ContainerConfiguration WithExport\u003CTExport\u003E(TExport exportedInstance, string? contractName = null, IDictionary\u003Cstring, object\u003E? metadata = null);\r\n\r\n        public ContainerConfiguration WithExport(Type contractType, object exportedInstance);\r\n        public ContainerConfiguration WithExport(Type contractType, object exportedInstance, string? contractName = null, IDictionary\u003Cstring, object\u003E? metadata = null);\r\n    }\r\n} \r\n\u0060\u0060\u0060\r\n\r\nWe also think it would be valueable to add an analyzer that warns when generic inference was used.  (e.g. \u0060WithExport(new SomeExportedType())\u0060)",
        "TimeCode": 38390000000,
        "Apis": [
          "M:ContainerConfiguration.WithExport(Type,object,string?,IDictionary\u003Cstring, object\u003E?)",
          "M:ContainerConfiguration.WithExport(Type,object)",
          "M:ContainerConfiguration.WithExport\u003CTExport\u003E(TExport,string?,IDictionary\u003Cstring, object\u003E?)",
          "M:ContainerConfiguration.WithExport\u003CTExport\u003E(TExport)",
          "T:ContainerConfiguration"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31355,
          "Title": "SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E sequence, ReadOnlySpan\u003CT\u003E delimiter)",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-31T03:20:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31355",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-09T00:00:00-07:00",
        "FeedbackId": "656291313",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31355#issuecomment-656291313",
        "FeedbackMarkdown": "After much debate, approved as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial ref struct SequenceReader\r\n{\r\n    public bool TryReadTo(out ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E delimiter, bool advancePastDelimiter = true);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 47200000000,
        "Apis": [
          "M:SequenceReader.TryReadTo(out ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,bool)",
          "T:SequenceReader"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "PlhWVNciJm4",
      "StartDateTime": "2020-07-10T10:08:05-07:00",
      "EndDateTime": "2020-07-10T11:59:53-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/PlhWVNciJm4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 138,
          "Title": "Mark Windows-specific APIs",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-10T04:20:05+00:00",
          "Url": "https://github.com/dotnet/designs/pull/138",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/138#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17590,
          "Title": "Add static hash helper methods",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-06-12T13:24:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17590",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656829666",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17590#issuecomment-656829666",
        "FeedbackMarkdown": "We discussed this again, and accepted HashData.\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class MD5\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA1\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA256\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA384\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\npublic partial class SHA512\r\n{\r\n    public static byte[] HashData(byte[] source) =\u003E throw null;\r\n    public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n    public static int HashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n    public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61450000000,
        "Apis": [
          "M:MD5.HashData(byte[])",
          "M:MD5.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:MD5.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:MD5.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA1.HashData(byte[])",
          "M:SHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA1.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA1.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA256.HashData(byte[])",
          "M:SHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA256.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA256.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA384.HashData(byte[])",
          "M:SHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA384.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA384.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:SHA512.HashData(byte[])",
          "M:SHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:SHA512.HashData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:SHA512.TryHashData(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "T:MD5",
          "T:SHA1",
          "T:SHA256",
          "T:SHA384",
          "T:SHA512"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37681,
          "Title": "Expose a ValueRef property on LinkedListNode\u003CT\u003E",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-10T00:43:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37681",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656831777",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37681#issuecomment-656831777",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public partial class LinkedListNode\u003CT\u003E\r\n    {\r\n        public ref T ValueRef { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61550000000,
        "Apis": [
          "P:LinkedListNode\u003CT\u003E.ValueRef",
          "T:LinkedListNode\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35869,
          "Title": "Make IncrementalHash.CreateHMAC ReadOnlySpan\u003Cbyte\u003E key public",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-05T23:36:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35869",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-10T00:00:00-07:00",
        "FeedbackId": "656833490",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35869#issuecomment-656833490",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n     public partial class IncrementalHash\r\n     {\r\n        public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, ReadOnlySpan\u003Cbyte\u003E key);\r\n     }\r\n }",
        "TimeCode": 64080000000,
        "Apis": [
          "M:IncrementalHash.CreateHMAC(HashAlgorithmName,ReadOnlySpan\u003Cbyte\u003E)",
          "T:IncrementalHash"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Cw-kYXQ7Sw8",
      "StartDateTime": "2020-07-14T10:10:21-07:00",
      "EndDateTime": "2020-07-14T12:06:22-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Cw-kYXQ7Sw8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30255,
          "Title": "System.Text.Json: (De)serialization support for quoted numbers ",
          "Author": "NickCraver",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-15T00:32:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30255",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-14T00:00:00-07:00",
        "FeedbackId": "658313884",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30255#issuecomment-658313884",
        "FeedbackMarkdown": "* Looks good.\r\n* We should have a discussion around defaults for .NET 5, especially web.\r\n* We decided to rename \u0060JsonNumberHandling.None\u0060 an \u0060JsonNumberHandling.Strict\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial sealed class JsonSerializerOptions\r\n    {\r\n        public JsonNumberHandling NumberHandling { get; set; }\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    [Flags]\r\n    public enum JsonNumberHandling\r\n    {\r\n        Strict = 0x0,\r\n        AllowReadingFromString = 0x1,\r\n        WriteAsString = 0x2,\r\n        AllowNamedFloatingPointLiterals = 0x4\r\n    }\r\n\r\n    [AttributeUsage(\r\n        AttributeTargets.Class |\r\n        AttributeTargets.Struct |\r\n        AttributeTargets.Property |\r\n        AttributeTargets.Field, AllowMultiple = false)]\r\n    public partial sealed class JsonNumberHandlingAttribute : JsonAttribute\r\n    {\r\n        public JsonNumberHandlingAttribute(JsonNumberHandling handling);\r\n        public JsonNumberHandling Handling { get; }    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:JsonNumberHandling.AllowNamedFloatingPointLiterals",
          "F:JsonNumberHandling.AllowReadingFromString",
          "F:JsonNumberHandling.Strict",
          "F:JsonNumberHandling.WriteAsString",
          "M:JsonNumberHandlingAttribute.JsonNumberHandlingAttribute(JsonNumberHandling)",
          "P:JsonNumberHandlingAttribute.Handling",
          "P:JsonSerializerOptions.NumberHandling",
          "T:JsonNumberHandling",
          "T:JsonNumberHandlingAttribute",
          "T:JsonSerializerOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39152,
          "Title": "System.Text.Json: Ignore null values while serializing",
          "Author": "molinch",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-12T06:29:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39152",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-14T00:00:00-07:00",
        "FeedbackId": "658319929",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39152#issuecomment-658319929",
        "FeedbackMarkdown": "* Makes perfect sense.\r\n\r\n\u0060\u0060\u0060C#\r\npublic enum JsonIgnoreCondition\r\n{\r\n    // Never = 0,\r\n    // Always = 1,\r\n    // WhenWritingDefault = 2,\r\n    WhenWritingNull = 3\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14760000000,
        "Apis": [
          "F:JsonIgnoreCondition.WhenWritingNull",
          "T:JsonIgnoreCondition"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "7YpDyRMaDKE",
      "StartDateTime": "2020-07-16T10:00:51-07:00",
      "EndDateTime": "2020-07-16T12:11:04-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7YpDyRMaDKE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2214,
          "Title": "File.ReadLinesAsync",
          "Author": "khellang",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-27T10:03:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2214",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659551371",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2214#issuecomment-659551371",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* The \u0060[EnumeratorCancellation]\u0060 attribute might be needed in the implementation if we use \u0060yield return\u0060, but it doesn\u0027t have to be part of the ref.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n        public static IAsyncEnumerable\u003Cstring\u003E ReadLinesAsync(string path, CancellationToken cancellationToken = default);\r\n        public static IAsyncEnumerable\u003Cstring\u003E ReadLinesAsync(string path, System.Text.Encoding encoding, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:File.ReadLinesAsync(string,CancellationToken)",
          "M:File.ReadLinesAsync(string,System.Text.Encoding,CancellationToken)",
          "T:File"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 3570,
          "Title": "Add \u0060IDeviceContext\u0060 to events that hold \u0060Graphics\u0060",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-13T19:00:24+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/3570",
          "Milestone": "5.0 RC1",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659555018",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/3570#issuecomment-659555018",
        "FeedbackMarkdown": "* We should implement \u0060IDisposable\u0060 following the dispose pattern if (1) the type doesn\u0027t already implement \u0060IDisposable\u0060 and (2) the type isn\u0027t sealed.\r\n* \u0060IDeviceContext\u0060 should be implemented explicitly.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class PaintEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawItemEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DataGridViewRowPostPaintEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawListViewItemEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawToolTipEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class DrawTreeNodeEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripArrowRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripContentPanelRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripItemRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripPanelRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n    public partial class ToolStripRenderEventArgs : IDisposable, IDeviceContext\r\n    { \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8380000000,
        "Apis": [
          "T:DataGridViewRowPostPaintEventArgs",
          "T:DrawItemEventArgs",
          "T:DrawListViewItemEventArgs",
          "T:DrawToolTipEventArgs",
          "T:DrawTreeNodeEventArgs",
          "T:PaintEventArgs",
          "T:ToolStripArrowRenderEventArgs",
          "T:ToolStripContentPanelRenderEventArgs",
          "T:ToolStripItemRenderEventArgs",
          "T:ToolStripPanelRenderEventArgs",
          "T:ToolStripRenderEventArgs"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 138,
          "Title": "Mark Windows-specific APIs",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-10T04:20:05+00:00",
          "Url": "https://github.com/dotnet/designs/pull/138",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659561716",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/138#issuecomment-659561716",
        "FeedbackMarkdown": "* The [proposal](https://github.com/dotnet/designs/pull/138) looks good.\r\n* We should consider a diagnostic to warn on typos in the OS name, e.g. \u0060[MinimumOSPlatform(\u0022windos7.0\u0022)]\u0060",
        "TimeCode": 12490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 13788,
          "Title": "Expose CLong, CULong, and NFloat interchange types",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-12T21:17:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/13788",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659573076",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/13788#issuecomment-659573076",
        "FeedbackMarkdown": "* Looks good\r\n* We should add ctors for the smaller sizes.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public readonly struct CLong : IEquatable\u003CCLong\u003E\r\n    {\r\n        public CLong(int value);\r\n        public CLong(nint value);\r\n        public nint Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(CLong other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public readonly struct CULong : IEquatable\u003CCULong\u003E\r\n    {\r\n        public CULong(uint value);\r\n        public CULong(nuint value);\r\n        public nuint Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(CULong other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public readonly struct NFloat : IEquatable\u003CNFloat\u003E\r\n    {\r\n        public NFloat(float value);\r\n        public NFloat(double value);\r\n        public double Value { get; }\r\n        public override bool Equals(object o);\r\n        public bool Equals(NFloat other);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19570000000,
        "Apis": [
          "M:CLong.CLong(int)",
          "M:CLong.CLong(nint)",
          "M:CLong.Equals(CLong)",
          "M:CLong.Equals(object)",
          "M:CLong.GetHashCode()",
          "M:CLong.ToString()",
          "M:CULong.CULong(nuint)",
          "M:CULong.CULong(uint)",
          "M:CULong.Equals(CULong)",
          "M:CULong.Equals(object)",
          "M:CULong.GetHashCode()",
          "M:CULong.ToString()",
          "M:NFloat.Equals(NFloat)",
          "M:NFloat.Equals(object)",
          "M:NFloat.GetHashCode()",
          "M:NFloat.NFloat(double)",
          "M:NFloat.NFloat(float)",
          "M:NFloat.ToString()",
          "P:CLong.Value",
          "P:CULong.Value",
          "P:NFloat.Value",
          "T:CLong",
          "T:CULong",
          "T:NFloat"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 413,
          "Title": "ECDiffieHellman X509 certificate management gaps",
          "Author": "CodeBlanch",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-30T20:24:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/413",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659580892",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/413#issuecomment-659580892",
        "FeedbackMarkdown": "* Makes sense, but we should make them proper instance methods, especially because the implementation private state of \u0060X509Certificate2\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public partial class X509Certificate2\r\n    {\r\n        public X509Certificate2 CopyWithPrivateKey(ECDiffieHellman privateKey);\r\n        public ECDiffieHellman GetECDiffieHellmanPrivateKey();\r\n        public ECDiffieHellman GetECDiffieHellmanPublicKey();\r\n    }\r\n    public partial class PublicKey\r\n    {\r\n        public PublicKey(AsymmetricAlgorithm key);\r\n        public bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public byte[] ExportSubjectPublicKeyInfo();\r\n        public static PublicKey CreateFromSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 32050000000,
        "Apis": [
          "M:PublicKey.CreateFromSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E,out int)",
          "M:PublicKey.ExportSubjectPublicKeyInfo()",
          "M:PublicKey.PublicKey(AsymmetricAlgorithm)",
          "M:PublicKey.TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E,out int)",
          "M:X509Certificate2.CopyWithPrivateKey(ECDiffieHellman)",
          "M:X509Certificate2.GetECDiffieHellmanPrivateKey()",
          "M:X509Certificate2.GetECDiffieHellmanPublicKey()",
          "T:PublicKey",
          "T:X509Certificate2"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 587,
          "Title": "export SPKI on ECDiffieHellmanPublicKey",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-05T20:45:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/587",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659582856",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/587#issuecomment-659582856",
        "FeedbackMarkdown": "* Makes sense. The implementation will throw \u0060NotSupportedException\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public abstract partial class ECDiffieHellmanPublicKey\r\n    {\r\n        public virtual bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public virtual byte[] ExportSubjectPublicKeyInfo();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40380000000,
        "Apis": [
          "M:ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo()",
          "M:ECDiffieHellmanPublicKey.TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E,out int)",
          "T:ECDiffieHellmanPublicKey"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 783,
          "Title": "New custom attribute required to support C\u002B\u002B inline namespaces",
          "Author": "tgani-msft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-12T00:55:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/783",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659584823",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/783#issuecomment-659584823",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* @jkotas pointed out that you may no longer need it. If you don\u0027t, please close this issue. If you do, consider it approved.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=true)]\r\n    public sealed class CppInlineNamespaceAttribute : Attribute\r\n    {\r\n        public CppInlineNamespaceAttribute(string dottedName);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42700000000,
        "Apis": [
          "M:CppInlineNamespaceAttribute.CppInlineNamespaceAttribute(string)",
          "T:CppInlineNamespaceAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2236,
          "Title": "Add support for zlib data format (RFC 1950)",
          "Author": "Ryder25",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-27T18:01:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2236",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Compression",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659590517",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2236#issuecomment-659590517",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Compression\r\n{\r\n    public class ZLibStream : Stream\r\n    {\r\n        public ZLibStream(Stream stream, CompressionLevel compressionLevel);\r\n        public ZLibStream(Stream stream, CompressionMode mode);\r\n        public ZLibStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);\r\n        public ZLibStream(Stream stream, CompressionMode mode, bool leaveOpen);\r\n        public Stream BaseStream { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45110000000,
        "Apis": [
          "M:ZLibStream.ZLibStream(Stream,CompressionLevel,bool)",
          "M:ZLibStream.ZLibStream(Stream,CompressionLevel)",
          "M:ZLibStream.ZLibStream(Stream,CompressionMode,bool)",
          "M:ZLibStream.ZLibStream(Stream,CompressionMode)",
          "P:ZLibStream.BaseStream",
          "T:ZLibStream"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2340,
          "Title": "IComparable for Rune",
          "Author": "Entomy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-29T14:01:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2340",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659592809",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2340#issuecomment-659592809",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We should consider doing an analyzer that flags that. @terrajobst to file a request.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text\r\n{\r\n    public partial struct Rune : IComparable\u003CRune\u003E, IComparable\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51730000000,
        "Apis": [
          "T:Rune"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35692,
          "Title": "Do not use [Out] string for P/Invokes",
          "Author": "elinor-fung",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-01T02:19:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35692",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659595195",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35692#issuecomment-659595195",
        "FeedbackMarkdown": "The analyzer/fixer makes sense.",
        "TimeCode": 53830000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35693,
          "Title": "Avoid StringBuilder parameters for P/Invokes",
          "Author": "elinor-fung",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-01T02:21:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35693",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659597092",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35693#issuecomment-659597092",
        "FeedbackMarkdown": "Shipping this as a warning and off by default makes sense. Setting the severity as suggestion would likely mean that nobody will ever see this.",
        "TimeCode": 57280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35695,
          "Title": "Prefer ExactSpelling=true on [DllImport] for known APIs",
          "Author": "elinor-fung",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-01T02:29:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35695",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659601306",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35695#issuecomment-659601306",
        "FeedbackMarkdown": "Looks good as proposed.",
        "TimeCode": 59230000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38076,
          "Title": "CryptoStream.FlushFinalBlockAsync method missing",
          "Author": "rupertsciamenna89",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-18T09:12:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38076",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659602801",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38076#issuecomment-659602801",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    partial class CryptoStream\r\n    {\r\n        public ValueTask FlushFinalBlockAsync(CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64570000000,
        "Apis": [
          "M:CryptoStream.FlushFinalBlockAsync(CancellationToken)",
          "T:CryptoStream"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38238,
          "Title": "Attribute and analyzer for \u0022soft abstract\u0022",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-22T22:25:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38238",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-16T00:00:00-07:00",
        "FeedbackId": "659610010",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38238#issuecomment-659610010",
        "FeedbackMarkdown": "* We like the analzyer and we\u0027re OK with that not being handled by all languages\r\n    - @terrajobst to fill in more details after the meeting\r\n* The analyzer should only consider missing overrides in the direct base type. Warning on more derived base types isn\u0027t useful because the base type is most likely the one that would need to provide behavior.\r\n* We should do a scan for all types that have virtuals that throw\r\n* We should think about how and if we differentiate \u0022this always throw\u0022, \u0022this is an optional feature\u0022, \u0022this a less performant implementation, please provide a better one\u0022 so that we can differentiate the diagnostic ID/severity accordingly.",
        "TimeCode": 66310000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "n4Pq8e9OlpI",
      "StartDateTime": "2020-07-17T10:04:39-07:00",
      "EndDateTime": "2020-07-17T12:08:04-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/n4Pq8e9OlpI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1793,
          "Title": "Connection Abstractions",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-16T01:12:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1793",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-17T00:00:00-07:00",
        "FeedbackId": "660289247",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1793#issuecomment-660289247",
        "FeedbackMarkdown": "* Approved. We\u0027re done with it!\r\n\r\n\u0060\u0060\u0060C#\r\npublic abstract class ConnectionBase : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionBase();\r\n    public abstract IConnectionProperties ConnectionProperties { get; }\r\n    public abstract EndPoint? LocalEndPoint { get; }\r\n    public abstract EndPoint? RemoteEndPoint { get; }\r\n    public ValueTask CloseAsync(ConnectionCloseMethod method = ConnectionCloseMethod.GracefulShutdown, CancellationToken cancellationToken = default);\r\n    protected abstract ValueTask CloseAsyncCore(System.Net.Connections.ConnectionCloseMethod method, CancellationToken cancellationToken);\r\n}\r\n\r\npublic enum ConnectionCloseMethod\r\n{\r\n    GracefulShutdown,\r\n    Abort,\r\n    Immediate,\r\n}\r\n\r\n// needs review: FromPipe with disposable.\r\npublic abstract class Connection : ConnectionBase\r\n{\r\n    protected Connection();\r\n    public IDuplexPipe Pipe { get; }\r\n    public Stream Stream { get; }\r\n    protected virtual IDuplexPipe CreatePipe();\r\n    protected virtual Stream CreateStream();\r\n    public static Connection FromPipe(IDuplexPipe pipe, bool leaveOpen = false, IConnectionProperties? properties = null, EndPoint? localEndPoint = null, EndPoint? remoteEndPoint = null);\r\n    public static Connection FromStream(Stream stream, bool leaveOpen = false, IConnectionProperties? properties = null, EndPoint? localEndPoint = null, EndPoint? remoteEndPoint = null);\r\n}\r\n\r\npublic static class ConnectionExtensions\r\n{\r\n    public static ConnectionFactory Filter(this ConnectionFactory factory, Func\u003CConnection, IConnectionProperties?, CancellationToken, ValueTask\u003CConnection\u003E\u003E filter);\r\n    public static bool TryGet\u003CT\u003E(this IConnectionProperties properties, [MaybeNullWhenAttribute(false)] out T property);\r\n}\r\n\r\npublic abstract class ConnectionFactory : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionFactory();\r\n    public abstract ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic abstract class ConnectionListener : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionListener();\r\n    public abstract IConnectionProperties ListenerProperties { get; }\r\n    public abstract EndPoint? LocalEndPoint { get; }\r\n    public abstract ValueTask\u003CConnection\u003E AcceptAsync(IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic abstract class ConnectionListenerFactory : IAsyncDisposable, IDisposable\r\n{\r\n    protected ConnectionListenerFactory();\r\n    public abstract ValueTask\u003CConnectionListener\u003E BindAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual void Dispose(bool disposing);\r\n    protected virtual ValueTask DisposeAsyncCore();\r\n}\r\n\r\npublic interface IConnectionProperties\r\n{\r\n    bool TryGet(Type propertyKey, [NotNullWhenAttribute(true)] out object? property);\r\n}\r\n\r\n// needs review. adding to existing class.\r\npublic class SocketsHttpHandler\r\n{\r\n    public ConnectionFactory? ConnectionFactory { get; set; }\r\n    public Func\u003CHttpRequestMessage, Connection, CancellationToken, ValueTask\u003CConnection\u003E\u003E? PlaintextFilter { get; set; }\r\n}\r\n\r\n// needs review\r\npublic class SocketsHttpConnectionFactory : ConnectionFactory\r\n{\r\n    public SocketsHttpConnectionFactory();\r\n    public sealed override ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n    protected virtual Socket CreateSocket(HttpRequestMessage message, EndPoint? endPoint, IConnectionProperties options);\r\n    protected virtual ValueTask\u003CConnection\u003E EstablishConnectionAsync(HttpRequestMessage message, EndPoint? endPoint, IConnectionProperties options, CancellationToken cancellationToken);\r\n}\r\n\r\n// needs review.\r\nclass SocketsConnectionFactory : ConnectionFactory\r\n{\r\n    // dual-mode IPv6 socket. See Socket(SocketType socketType, ProtocolType protocolType)\r\n    public SocketsConnectionFactory(SocketType socketType, ProtocolType protocolType);\r\n\r\n    // See Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)\r\n    public SocketsConnectionFactory(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);\r\n\r\n    public override ValueTask\u003CConnection\u003E ConnectAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n\r\n    // These exist to provide an easy way to shim the default behavior.\r\n    // A more idiomatic (but more API-heavy) way to do this would be to pass some sort of ISocketConfiguration that has all the pre-connect socket options one could want.\r\n    protected virtual Socket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, EndPoint? endPoint, IConnectionProperties? options);\r\n    protected virtual Stream CreateStream(Socket socket, IConnectionProperties? options);\r\n    protected virtual IDuplexPipe CreatePipe(Socket socket, IConnectionProperties? options);\r\n}\r\n\r\n// needs review.\r\nclass SocketsListenerFactory : ConnectionListenerFactory\r\n{\r\n    // dual-mode IPv6 socket. See Socket(SocketType socketType, ProtocolType protocolType)\r\n    public SocketsListenerFactory(SocketType socketType, ProtocolType protocolType);\r\n\r\n    // See Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)\r\n    public SocketsListenerFactory(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);\r\n\r\n    public override ValueTask\u003CConnectionListener\u003E BindAsync(EndPoint? endPoint, IConnectionProperties? options = null, CancellationToken cancellationToken = default);\r\n\r\n    // These exist to provide an easy way for users to override default behavior.\r\n    // A more idiomatic (but more API-heavy) way to do this would be to pass some sort of ISocketConfiguration that has all the pre-connect socket options one could want.\r\n    protected virtual Socket CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, EndPoint? endPoint, IConnectionProperties? options);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ConnectionCloseMethod.Abort",
          "F:ConnectionCloseMethod.GracefulShutdown",
          "F:ConnectionCloseMethod.Immediate",
          "M:Connection.Connection()",
          "M:Connection.CreatePipe()",
          "M:Connection.CreateStream()",
          "M:Connection.FromPipe(IDuplexPipe,bool,IConnectionProperties?,EndPoint?,EndPoint?)",
          "M:Connection.FromStream(Stream,bool,IConnectionProperties?,EndPoint?,EndPoint?)",
          "M:ConnectionBase.CloseAsync(ConnectionCloseMethod,CancellationToken)",
          "M:ConnectionBase.CloseAsyncCore(System.Net.Connections.ConnectionCloseMethod,CancellationToken)",
          "M:ConnectionBase.ConnectionBase()",
          "M:ConnectionExtensions.Filter(this ConnectionFactory,Func\u003CConnection, IConnectionProperties?, CancellationToken, ValueTask\u003CConnection\u003E\u003E)",
          "M:ConnectionExtensions.TryGet\u003CT\u003E(this IConnectionProperties,out T)",
          "M:ConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:ConnectionFactory.ConnectionFactory()",
          "M:ConnectionFactory.Dispose(bool)",
          "M:ConnectionFactory.DisposeAsyncCore()",
          "M:ConnectionListener.AcceptAsync(IConnectionProperties?,CancellationToken)",
          "M:ConnectionListener.ConnectionListener()",
          "M:ConnectionListener.Dispose(bool)",
          "M:ConnectionListener.DisposeAsyncCore()",
          "M:ConnectionListenerFactory.BindAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:ConnectionListenerFactory.ConnectionListenerFactory()",
          "M:ConnectionListenerFactory.Dispose(bool)",
          "M:ConnectionListenerFactory.DisposeAsyncCore()",
          "M:IConnectionProperties.TryGet(Type,out object?)",
          "M:SocketsConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsConnectionFactory.CreatePipe(Socket,IConnectionProperties?)",
          "M:SocketsConnectionFactory.CreateSocket(AddressFamily,SocketType,ProtocolType,EndPoint?,IConnectionProperties?)",
          "M:SocketsConnectionFactory.CreateStream(Socket,IConnectionProperties?)",
          "M:SocketsConnectionFactory.SocketsConnectionFactory(AddressFamily,SocketType,ProtocolType)",
          "M:SocketsConnectionFactory.SocketsConnectionFactory(SocketType,ProtocolType)",
          "M:SocketsHttpConnectionFactory.ConnectAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsHttpConnectionFactory.CreateSocket(HttpRequestMessage,EndPoint?,IConnectionProperties)",
          "M:SocketsHttpConnectionFactory.EstablishConnectionAsync(HttpRequestMessage,EndPoint?,IConnectionProperties,CancellationToken)",
          "M:SocketsHttpConnectionFactory.SocketsHttpConnectionFactory()",
          "M:SocketsListenerFactory.BindAsync(EndPoint?,IConnectionProperties?,CancellationToken)",
          "M:SocketsListenerFactory.CreateSocket(AddressFamily,SocketType,ProtocolType,EndPoint?,IConnectionProperties?)",
          "M:SocketsListenerFactory.SocketsListenerFactory(AddressFamily,SocketType,ProtocolType)",
          "M:SocketsListenerFactory.SocketsListenerFactory(SocketType,ProtocolType)",
          "P:Connection.Pipe",
          "P:Connection.Stream",
          "P:ConnectionBase.ConnectionProperties",
          "P:ConnectionBase.LocalEndPoint",
          "P:ConnectionBase.RemoteEndPoint",
          "P:ConnectionListener.ListenerProperties",
          "P:ConnectionListener.LocalEndPoint",
          "P:SocketsHttpHandler.ConnectionFactory",
          "P:SocketsHttpHandler.PlaintextFilter",
          "T:Connection",
          "T:ConnectionBase",
          "T:ConnectionCloseMethod",
          "T:ConnectionExtensions",
          "T:ConnectionFactory",
          "T:ConnectionListener",
          "T:ConnectionListenerFactory",
          "T:IConnectionProperties",
          "T:SocketsConnectionFactory",
          "T:SocketsHttpConnectionFactory",
          "T:SocketsHttpHandler",
          "T:SocketsListenerFactory"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "bGFsZSISlZ0",
      "StartDateTime": "2020-07-21T10:03:13-07:00",
      "EndDateTime": "2020-07-21T12:01:05-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bGFsZSISlZ0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33397,
          "Title": "Expose transaction savepoints in ADO.NET",
          "Author": "roji",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-09T19:17:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33397",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Data",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662004505",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33397#issuecomment-662004505",
        "FeedbackMarkdown": "* Looks good, but we\u0027d prefer \u0060SupportsSavepoints\u0060\r\n* We considered exposing a new type \u0060DbSavepoint\u0060 but we felt it\u0027s overkill for a niche feature like this\r\n* The \u0060System.SqlClient\u0060 and \u0060Microsoft.SqlClient\u0060 APIs should be updated to override these new base methods (instead of just hiding them) as well as \u0060SupportsSavepoints\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Data.Common\r\n{\r\n    public class DbTransaction\r\n    {\r\n        public virtual Task SaveAsync(string savepointName, CancellationToken cancellationToken = default);\r\n        public virtual Task RollbackAsync(string savepointName, CancellationToken cancellationToken = default);\r\n        public virtual Task ReleaseAsync(string savepointName, CancellationToken cancellationToken = default);\r\n\r\n        public virtual void Save(string savepointName);\r\n        public virtual void Rollback(string savepointName);\r\n        public virtual void Release(string savepointName);\r\n\r\n        public virtual bool SupportsSavepoints { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DbTransaction.Release(string)",
          "M:DbTransaction.ReleaseAsync(string,CancellationToken)",
          "M:DbTransaction.Rollback(string)",
          "M:DbTransaction.RollbackAsync(string,CancellationToken)",
          "M:DbTransaction.Save(string)",
          "M:DbTransaction.SaveAsync(string,CancellationToken)",
          "P:DbTransaction.SupportsSavepoints",
          "T:DbTransaction"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39631,
          "Title": "Add new overloads for AddSystemdConsole and AddJsonConsole not needing configure argument",
          "Author": "maryamariyan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-20T15:31:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39631",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662009556",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39631#issuecomment-662009556",
        "FeedbackMarkdown": "* Makes sense\r\n* We should also add \u0060AddSimpleConsole\u0060 without \u0060configure\u0060, just for consistency\r\n\r\n\u0060\u0060\u0060C#\r\n\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    public static class ConsoleLoggerExtensions\r\n    {\r\n        // Existing APIs:\r\n        // public static ILoggingBuilder AddConsole(this ILoggingBuilder builder);\r\n        // public static ILoggingBuilder AddConsole(this ILoggingBuilder builder, System.Action\u003CConsoleLoggerOptions\u003E configure);\r\n        // public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder, System.Action\u003CJsonConsoleFormatterOptions\u003E configure);\r\n        // public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder, System.Action\u003CSimpleConsoleFormatterOptions\u003E configure);\r\n        // public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder, System.Action\u003CConsoleFormatterOptions\u003E configure);\r\n        public static ILoggingBuilder AddJsonConsole(this ILoggingBuilder builder);\r\n        public static ILoggingBuilder AddSimpleConsole(this ILoggingBuilder builder);\r\n        public static ILoggingBuilder AddSystemdConsole(this ILoggingBuilder builder);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20640000000,
        "Apis": [
          "M:ConsoleLoggerExtensions.AddJsonConsole(this ILoggingBuilder)",
          "M:ConsoleLoggerExtensions.AddSimpleConsole(this ILoggingBuilder)",
          "M:ConsoleLoggerExtensions.AddSystemdConsole(this ILoggingBuilder)",
          "T:ConsoleLoggerExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 142,
          "Title": "Add additional Windows-specific APIs",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-18T03:05:32+00:00",
          "Url": "https://github.com/dotnet/designs/pull/142",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662020828",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/142#issuecomment-662020828",
        "FeedbackMarkdown": "Needs some tuning and review from area owners, but otherwise looks fine.",
        "TimeCode": 25910000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2127,
          "Title": "ConsoleKeyInfo does not implement IEquatable",
          "Author": "fghzxm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-24T02:50:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2127",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Console",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662022231",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2127#issuecomment-662022231",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial readonly struct ConsoleKeyInfo : IEquatable\u003CConsoleKeyInfo\u003E\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38460000000,
        "Apis": [
          "T:ConsoleKeyInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31996,
          "Title": "Implement IEquatable\u003CT\u003E for AsyncFlowControl",
          "Author": "reflectronic",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-02-09T15:20:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31996",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662023094",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31996#issuecomment-662023094",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial struct AsyncFlowControl : IEquatable\u003CAsyncFlowControl\u003E\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40470000000,
        "Apis": [
          "T:AsyncFlowControl"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38244,
          "Title": "System.Drawing.Color is possibly missing 8 colors",
          "Author": "HumanEquivalentUnit",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-22T23:52:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38244",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662030348",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38244#issuecomment-662030348",
        "FeedbackMarkdown": "* For better or worse, framework spelling is en-us.\r\n* If this would be parsing, supporting both \u0060grey\u0060 and \u0060gray\u0060 seems reasonable, but duplicating API surface to offer AE and BE feels wrong, so we don\u0027t feel we should be exposing those.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    public enum KnownColor\r\n    {\r\n        RebeccaPurple\r\n    }\r\n    public readonly struct Color : IEquatable\u003CColor\u003E\r\n    {\r\n        public static Color RebeccaPurple;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41440000000,
        "Apis": [
          "F:Color.RebeccaPurple",
          "F:KnownColor.RebeccaPurple",
          "T:Color",
          "T:KnownColor"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36209,
          "Title": "Add BindConfiguration extension method for OptionsBuilder",
          "Author": "fredrikhr",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-11T11:04:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36209",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Options",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662034563",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36209#issuecomment-662034563",
        "FeedbackMarkdown": "* Looks reasonable\r\n* \u0060configPath\u0060 looks like a file system path; we should name it \u0060configSectionPath\u0060, unless we use \u0060configPath\u0060 elsewhere already.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static class OptionsBuilderConfigurationExtensions\r\n    {\r\n        public static OptionsBuilder\u003CTOptions\u003E BindConfiguration\u003CTOptions\u003E(\r\n            this OptionsBuilder\u003CTOptions\u003E optionsBuilder,\r\n            string configSectionPath,\r\n            Action\u003CBinderOptions\u003E configureBinder = null)\r\n            where TOptions : class =\u003E null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49400000000,
        "Apis": [
          "M:OptionsBuilderConfigurationExtensions.BindConfiguration\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E,string,Action\u003CBinderOptions\u003E)",
          "T:OptionsBuilderConfigurationExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28114,
          "Title": "Extend ProcessStartInfo to allow setting ",
          "Author": "SteveL-MSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-09T21:47:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28114",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662039350",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28114#issuecomment-662039350",
        "FeedbackMarkdown": "* The existing API already deviated from the Win32 naming convention (\u0060Load\u0060)\r\n* We should give it a better name, to make it clear what it does\r\n* We should mark the API as Windows-specific. We should check which API version this was introduced in, but it\u0027s probably Win7 or earlier anyways.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Process\r\n{\r\n    public class ProcessStartInfo\r\n    {\r\n        public bool LoadUserProfile { get; set; }\r\n        public bool UseCredentialsForNetworkingOnly { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 53850000000,
        "Apis": [
          "P:ProcessStartInfo.LoadUserProfile",
          "P:ProcessStartInfo.UseCredentialsForNetworkingOnly",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28198,
          "Title": "Add EnumMember API",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-13T20:14:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28198",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-21T00:00:00-07:00",
        "FeedbackId": "662047560",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28198#issuecomment-662047560",
        "FeedbackMarkdown": "We should add this API:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Enum\r\n    {\r\n        public static T[] GetValues\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nSo this code:\r\n\r\n\u0060\u0060\u0060C#\r\nvar values = (MyEnum[])Enum.GetValues(typeof(MyEnum));\r\nvar names = Enum.GetNames(typeof(MyEnum));\r\nfor (int i = 0; i \u003C values.Length; \u002B\u002Bi)\r\n{\r\n    MyEnum value = values[i];\r\n    string name = names[i];\r\n}\r\n\u0060\u0060\u0060\r\n\r\nbecomes\r\n\r\n\u0060\u0060\u0060C#\r\nvar values = Enum.GetValues\u003CMyEnum\u003E();\r\nforeach (var value in values)\r\n{\r\n    var name = value.ToString();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWith respect to custom attributes, you can already do this:\r\n\r\n\u0060\u0060\u0060C#\r\nFieldInfo enumField = ...;\r\nvar description = enumField.GetCustomAttributes\u003CDescriptionAttribute\u003E()\r\n                           .SingleOrDefault()?.Description ?? \u0022\u0022;\r\n\u0060\u0060\u0060",
        "TimeCode": 59900000000,
        "Apis": [
          "M:Enum.GetValues\u003CT\u003E()",
          "T:Enum"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "WW65sGkDINQ",
      "StartDateTime": "2020-07-23T10:07:23-07:00",
      "EndDateTime": "2020-07-23T12:07:38-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/WW65sGkDINQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35088,
          "Title": "HTTP2: Create additional connections when maximum active streams is reached",
          "Author": "JamesNK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-17T01:20:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35088",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663129527",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35088#issuecomment-663129527",
        "FeedbackMarkdown": "* Makes sense. We discussed pushing it down but decided against because people are not likely to code against these properties in a generic fashion.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }   \r\n    public partial class WinHttpHandler : HttpMessageHandler\r\n    {\r\n        public bool EnableMultipleHttp2Connections { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.EnableMultipleHttp2Connections",
          "P:WinHttpHandler.EnableMultipleHttp2Connections",
          "T:SocketsHttpHandler",
          "T:WinHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31198,
          "Title": "configurable HTTP/2 PING timeouts in HttpClient",
          "Author": "chrisdot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-17T12:25:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31198",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663134549",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31198#issuecomment-663134549",
        "FeedbackMarkdown": "* Makes sense, but we propose to change \u0060Interval\u0060 to \u0060Delay\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class SocketsHttpHandler\r\n    {\r\n        public TimeSpan KeepAlivePingDelay { get; set; }\r\n        public TimeSpan KeepAlivePingTimeout { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6660000000,
        "Apis": [
          "P:SocketsHttpHandler.KeepAlivePingDelay",
          "P:SocketsHttpHandler.KeepAlivePingTimeout",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 141,
          "Title": "BinaryFormatter long-term obsoletion plan",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-14T16:37:31+00:00",
          "Url": "https://github.com/dotnet/designs/pull/141",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/141#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 12760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39489,
          "Title": "SocketsHttpHandler feature flag",
          "Author": "JamesNK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-17T00:15:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39489",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663144249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39489#issuecomment-663144249",
        "FeedbackMarkdown": "We should consider a factory method like:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class HttpMessageHandler\r\n    {\r\n        public static HttpMessageHandler CreateDefault();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would allow library code to write code like this:\r\n\r\n\u0060\u0060\u0060C#\r\nprivate HttpMessageHandler CreateHandler()\r\n{\r\n    var handler = HttpMessageHandler.CreateDefault();\r\n    if (handler is SocketsHttpHandler socketsHttpHandler)\r\n    {\r\n        // This property will throw PlatformNotSupportedException\r\n        socketsHttpHandler.MaxHttp2ConnectionsPerServer = int.MaxValue;\r\n    }\r\n\r\n    return handler;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHowever, the proposed API also makes sense:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler\r\n    {\r\n        public static bool IsSupported { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n@scalablecory, please discuss this with your networking folks and file a separate feature, likely for 6.0.",
        "TimeCode": 13340000000,
        "Apis": [
          "M:HttpMessageHandler.CreateDefault()",
          "P:SocketsHttpHandler.IsSupported",
          "T:HttpMessageHandler",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36617,
          "Title": "API to provide the current system time",
          "Author": "YohDeadfall",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-17T19:17:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36617",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Primitives",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663156337",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36617#issuecomment-663156337",
        "FeedbackMarkdown": "@maryamariyan @davidfowl would we be OK with a breaking change to reconcile the \u0060ISystemClock\u0060 types into a single core type? If not, we shouldn\u0027t do this. If yes, then I think we can make progress.",
        "TimeCode": 24640000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31170,
          "Title": "Unsafe.NullRef, IsNullRef",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-15T13:09:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31170",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663159454",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31170#issuecomment-663159454",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public class Unsafe\r\n    {\r\n        public bool IsNullRef\u003CT\u003E(ref T);\r\n        public ref T NullRef\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39930000000,
        "Apis": [
          "M:Unsafe.IsNullRef\u003CT\u003E(ref T)",
          "M:Unsafe.NullRef\u003CT\u003E()",
          "T:Unsafe"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 256,
          "Title": "Support for Intel SHA extensions",
          "Author": "Thealexbarney",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-25T23:56:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/256",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-x64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663163817",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/256#issuecomment-663163817",
        "FeedbackMarkdown": "* Looks good as proposed:\r\n     - Add \u0060IsSupported\u0060\r\n     - Change the \u0060Round\u0060 methods to indicate number of rounds\r\n     - Change parameters to match C\u002B\u002B naming\r\n* We should have an analyzer that flags usages, [just like for the AES types](https://github.com/dotnet/roslyn-analyzers/issues/3646). @tannergooding, please file the request and label it with \u0060code-analyzer\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public class Sha1\r\n    {\r\n        public static bool IsSupported { get; }\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E NextE(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E FourRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, byte func);\r\n    }\r\n\r\n    public class Sha256\r\n    {\r\n        public static bool IsSupported { get; }\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b);\r\n        public static Vector128\u003Cbyte\u003E TwoRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, Vector128\u003Cbyte\u003E k);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43960000000,
        "Apis": [
          "M:Sha1.FourRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Sha1.MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha1.MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha1.NextE(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha256.TwoRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "P:Sha1.IsSupported",
          "P:Sha256.IsSupported",
          "T:Sha1",
          "T:Sha256"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 371,
          "Title": "New ArgumentList constructors for Process classes",
          "Author": "Artoria2e5",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-27T17:30:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/371",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663169715",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/371#issuecomment-663169715",
        "FeedbackMarkdown": "* The added constructor seems to add little value, the bigger gains would be \u0060Process.Start()\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Process\r\n    {\r\n        // Existing overloads:\r\n        // public static Process Start(string fileName);\r\n        // public static Process Start(string fileName, string arguments);\r\n        // public static Process Start(string fileName, string userName, SecureString password, string domain);\r\n        // public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain);\r\n        // public static Process Start(ProcessStartInfo startInfo);\r\n        public static Process Start(string fileName, IEnumerable\u003Cstring\u003E arguments);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49460000000,
        "Apis": [
          "M:Process.Start(string,IEnumerable\u003Cstring\u003E)",
          "T:Process"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 785,
          "Title": "Provide x86 CPUID related information",
          "Author": "damageboy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-12T07:27:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/785",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-x64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663178075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/785#issuecomment-663178075",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* All x86 types will extend X86Base (unless it already base type)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public class X86Base\r\n    {\r\n        public static bool IsSupported { get; }\r\n\r\n        public static (int Eax, int Ebx, int Ecx, int Edx) CpuId(int functionId, int subFunctionId = 0);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59310000000,
        "Apis": [
          "M:X86Base.CpuId(int,int)",
          "P:X86Base.IsSupported",
          "T:X86Base"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30612,
          "Title": "Obsolete the SecureString type",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-17T20:43:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30612",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-23T00:00:00-07:00",
        "FeedbackId": "663157607",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30612#issuecomment-663157607",
        "FeedbackMarkdown": "Updated proposal at https://github.com/dotnet/designs/pull/147.",
        "TimeCode": 67890000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "TofmrPLEeFI",
      "StartDateTime": "2020-07-24T10:05:54-07:00",
      "EndDateTime": "2020-07-24T12:07:01-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/TofmrPLEeFI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38288,
          "Title": "Consider adding HalfToInt16Bits and Int16BitsToHalf to BitConverter",
          "Author": "pgovind",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-23T17:18:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38288",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663641179",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38288#issuecomment-663641179",
        "FeedbackMarkdown": "Looks good\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public sealed class BitConverter\r\n    {\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static short HalfToInt16Bits(Half value);\r\n\r\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\r\n        public static Half Int16BitsToHalf(short value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BitConverter.HalfToInt16Bits(Half)",
          "M:BitConverter.Int16BitsToHalf(short)",
          "T:BitConverter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38456,
          "Title": "Consider adding Half support to the BinaryPrimitives class",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-26T17:13:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38456",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663643468",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38456#issuecomment-663643468",
        "FeedbackMarkdown": "* Looks good\r\n* But we should also do \u0060BinaryReader\u0060 and \u0060BinaryWriter\u0060 as they are the more high-level counterparts\r\n* @tannergooding, please scout the framework for support of \u0060float\u0060 and \u0060double\u0060 and see what makes sense for \u0060Half\u0060\r\n* We should consider \u0060Convert\u0060, but the interface dispatch due to lack of type code might be challenging.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers.Binary\r\n{\r\n    public static class BinaryPrimitives\r\n    {\r\n        public static Half ReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static Half ReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E source, out Half);\r\n        public static bool TryReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E source, out Half);\r\n\r\n        public static void WriteHalfLittleEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static void WriteHalfBigEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static bool TryWriteHalfLittleEndian(Span\u003Cbyte\u003E destination, Half value);\r\n        public static bool TryWriteHalfBigEndian(Span\u003Cbyte\u003E destination, Half value);\r\n    }\r\n}\r\nnamespace System.IO\r\n{\r\n    public partial class BinaryReader\r\n    {\r\n        public virtual Half ReadHalf();\r\n    }\r\n    public partial class BinaryWriter\r\n    {\r\n        public virtual Half Write(Half value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3360000000,
        "Apis": [
          "M:BinaryPrimitives.ReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.ReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryPrimitives.TryReadHalfBigEndian(ReadOnlySpan\u003Cbyte\u003E,out Half)",
          "M:BinaryPrimitives.TryReadHalfLittleEndian(ReadOnlySpan\u003Cbyte\u003E,out Half)",
          "M:BinaryPrimitives.TryWriteHalfBigEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.TryWriteHalfLittleEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.WriteHalfBigEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryPrimitives.WriteHalfLittleEndian(Span\u003Cbyte\u003E,Half)",
          "M:BinaryReader.ReadHalf()",
          "M:BinaryWriter.Write(Half)",
          "T:BinaryPrimitives",
          "T:BinaryReader",
          "T:BinaryWriter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 13943,
          "Title": "Make Process.Start have a option to change handle inheritance",
          "Author": "pdelvo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2014-12-19T21:45:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/13943",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Process",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663652191",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/13943#issuecomment-663652191",
        "FeedbackMarkdown": "* It shouldn\u0027t default to \u0060true\u0060, it should return the actual behavior of the underlying platform.\r\n* Marking the setter as platform specific makes sense, assuming we can\u0027t (or don\u0027t want to) implement the necessary gymnastics.\r\n* @adamsitnik @eiriktsarpalis please check what the possible behavior/desirable behavior for Linux/Unix/macOS is\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class ProcessStartInfo\r\n    {\r\n        public bool InheritHandles\r\n        {\r\n            get;\r\n            [MinimumOSPlatform(\u0022windows7.0\u0022)]\r\n            set;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6480000000,
        "Apis": [
          "P:ProcessStartInfo.InheritHandles",
          "T:ProcessStartInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29681,
          "Title": "Consider exposing \u0060System.Diagnostics.StackTraceHiddenAttribute\u0060 publicly",
          "Author": "john-h-k",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-28T18:50:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29681",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663656251",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29681#issuecomment-663656251",
        "FeedbackMarkdown": "* Since we can apply it to classes and structs, it seem one should be able to apply it to properties and events as well. Should we add \u0060Property\u0060, \u0060Event\u0060, \u0060Delegate\u0060?\r\n* We considered \u0060Interface\u0060 (DIM), but that seems ill-defined for non-DIMs. If people wanted them on DIMs, they can apply it to the method\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    [AttributeUsage(AttributeTargets.Class |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Struct, Inherited = false)]\r\n    public sealed class StackTraceHiddenAttribute : Attribute\r\n    {\r\n        public StackTraceHiddenAttribute();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18600000000,
        "Apis": [
          "M:StackTraceHiddenAttribute.StackTraceHiddenAttribute()",
          "T:StackTraceHiddenAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1235,
          "Title": "Add ReadOnlySpan\u003Cchar\u003E overloads to JsonSerializer.Deserialize",
          "Author": "ahsonkhan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-01T03:53:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1235",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663657309",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1235#issuecomment-663657309",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic static partial class JsonSerializer\r\n{\r\n    public static object? Deserialize(ReadOnlySpan\u003Cchar\u003E json, Type returnType, JsonSerializerOptions? options = null);\r\n    [return: MaybeNull]\r\n    public static TValue Deserialize\u003CTValue\u003E(ReadOnlySpan\u003Cchar\u003E json, JsonSerializerOptions? options = null);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24860000000,
        "Apis": [
          "M:JsonSerializer.Deserialize(ReadOnlySpan\u003Cchar\u003E,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(ReadOnlySpan\u003Cchar\u003E,JsonSerializerOptions?)",
          "T:JsonSerializer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1630,
          "Title": "Add the ability to parse/format a float/double from/to a hexadecimal literal",
          "Author": "dovisutu",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-11T13:07:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1630",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663670728",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1630#issuecomment-663670728",
        "FeedbackMarkdown": "* API wise, the only change is the \u0060NumberStyles\u0060 addition of \u0060HexFloat\u0060\r\n* Behavior wise, this changes parsing of \u0060float\u0060 and \u0060double\u0060 to support the \u0060x\u0060 format specifier. This isn\u0027t a breaking change because \u0060float\u0060 and \u0060double\u0060 throw when \u0060x\u0060 is passed.\r\n* We considered adding \u0060AllowHexPrefix\u0060 because integers don\u0027t allow \u00600x\u0060 as  the prefix, while \u0060float\u0060 and \u0060double\u0060 would. However, for floats we want the prefix to be required, so \u0060AllowHexPrefix\u0060 would necessary be a separate bit. Combining it with \u0060HexFloat\u0060 would make it optional. Thus, we can do it later.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial enum NumberStyles\r\n    {\r\n        HexFloat = AllowLeadingWhite | AllowTrailingWhite | AllowLeadingSign | AllowHexSpecifier | AllowDecimalPoint\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26350000000,
        "Apis": [
          "F:NumberStyles.HexFloat",
          "T:NumberStyles"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30657,
          "Title": "Provide an overload of float/double.ToString that allow precision greater than 99",
          "Author": "Gnbrkm41",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-22T14:15:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30657",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663675920",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30657#issuecomment-663675920",
        "FeedbackMarkdown": "* There are issues with supporting more thant 99 digits of precision, some are in parsing behavior as pointed out by the OP, some of them are in public data structures which are size limited, and some are likely in the implementation.\r\n* Normally, it would seem better to extend the existing format specifier because it works better with resource strings and localization\r\n* However, given that production code is very unlikely to ever use more than 99 digits, it seems acceptable to have separate overloads to override the precision for debugging purposes\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct Single\r\n    {\r\n        public string ToString(char format, int precision);\r\n    }\r\n    public struct Double\r\n    {\r\n        public string ToString(char format, int precision);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 44660000000,
        "Apis": [
          "M:Double.ToString(char,int)",
          "M:Single.ToString(char,int)",
          "T:Double",
          "T:Single"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1916,
          "Title": "Introduce overloads of Enum.Parse/TryParse that accept ReadOnlySpan\u003Cchar\u003E",
          "Author": "Gnbrkm41",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-19T06:38:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1916",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663679040",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1916#issuecomment-663679040",
        "FeedbackMarkdown": "* We should remove the \u0060Enum\u0060 constraint to match the other overloads\r\n* Otherwise, looks good\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Enum\r\n    {\r\n        public static TEnum Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value) where TEnum : struct;\r\n        public static TEnum Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase) where TEnum : struct;\r\n        public static bool TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, out TEnum result) where TEnum : struct;\r\n        public static bool TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase, out TEnum result) where TEnum : struct;\r\n\r\n        public static object Parse(Type enumType, ReadOnlySpan\u003Cchar\u003E value);\r\n        public static object Parse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase);\r\n        public static bool TryParse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, out object result);\r\n        public static bool TryParse(Type enumType, ReadOnlySpan\u003Cchar\u003E value, bool ignoreCase, out object result);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52910000000,
        "Apis": [
          "M:Enum.Parse(Type,ReadOnlySpan\u003Cchar\u003E,bool)",
          "M:Enum.Parse(Type,ReadOnlySpan\u003Cchar\u003E)",
          "M:Enum.Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,bool)",
          "M:Enum.Parse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E)",
          "M:Enum.TryParse(Type,ReadOnlySpan\u003Cchar\u003E,bool,out object)",
          "M:Enum.TryParse(Type,ReadOnlySpan\u003Cchar\u003E,out object)",
          "M:Enum.TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,bool,out TEnum)",
          "M:Enum.TryParse\u003CTEnum\u003E(ReadOnlySpan\u003Cchar\u003E,out TEnum)",
          "T:Enum"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1953,
          "Title": "Add a delegate for OnDirectoryFinished()",
          "Author": "iSazonov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-21T06:56:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1953",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-24T00:00:00-07:00",
        "FeedbackId": "663688012",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1953#issuecomment-663688012",
        "FeedbackMarkdown": "* It seems \u0060OnDirectoryFinishedDelegate\u0060 should include the \u0060FileSystemEntry entry\u0060\r\n* Should \u0060ContinueOnErrorPredicate\u0060 provide some context? It seems one would want the container and the name the child to do anything useful for logging. If we see potential for more state, we may want to allow a struct, such as \u0060FileSystemError\u0060 instead.\r\n* @carlossanlop you may want to sync with @JeremyKuhne on how to evolve this API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Enumeration\r\n{\r\n    public partial class FileSystemEnumerable\u003CTResult\u003E : IEnumerable\u003CTResult\u003E\r\n    {\r\n        public delegate void OnDirectoryFinishedDelegate(ref FileSystemEntry entry);\r\n        public delegate bool ContinueOnErrorPredicate(ref FileSystemEntry parent, ReadOnlySpan\u003Cchar\u003E entry, int error);\r\n\r\n        public OnDirectoryFinishedDelegate? OnDirectoryFinishedAction { get; set; }\r\n        public ContinueOnErrorPredicate? ShouldContinueOnErrorPredicate { get; set; }\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57650000000,
        "Apis": [
          "P:FileSystemEnumerable\u003CTResult\u003E.OnDirectoryFinishedAction",
          "P:FileSystemEnumerable\u003CTResult\u003E.ShouldContinueOnErrorPredicate",
          "T:FileSystemEnumerable\u003CTResult\u003E",
          "T:FileSystemEnumerable\u003CTResult\u003E.ContinueOnErrorPredicate(ref FileSystemEntry,ReadOnlySpan\u003Cchar\u003E,int)",
          "T:FileSystemEnumerable\u003CTResult\u003E.OnDirectoryFinishedDelegate(ref FileSystemEntry)"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Fe2BQCZ0Xdk",
      "StartDateTime": "2020-07-28T10:05:57-07:00",
      "EndDateTime": "2020-07-28T12:22:42-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Fe2BQCZ0Xdk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31198,
          "Title": "configurable HTTP/2 PING timeouts in HttpClient",
          "Author": "chrisdot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-17T12:25:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31198",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-28T00:00:00-07:00",
        "FeedbackId": "665169571",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31198#issuecomment-665169571",
        "FeedbackMarkdown": "* It seems the setting \u0060Always\u0060 is undesirable. Instead of adding this enum, we should just use \u0060WithActiveRequests\u0060 as the default\r\n* The API is reasonable an enum is preferred, but let\u0027s defer this until we know for we need a way to allow \u0060Always\u0060 (even though all other clients have it).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class SocketsHttpHandler\r\n    {\r\n        public TimeSpan KeepAlivePingDelay { get; set; }\r\n        public TimeSpan KeepAlivePingTimeout { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.KeepAlivePingDelay",
          "P:SocketsHttpHandler.KeepAlivePingTimeout",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 3651,
          "Title": "Add span overloads to \u0060TextRenderer\u0060",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-27T17:31:23+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/3651",
          "Milestone": "5.0 RC1",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Improve performance, flag performance regressions across core releases"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-28T00:00:00-07:00",
        "FeedbackId": "665176770",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/3651#issuecomment-665176770",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public sealed class TextRenderer\r\n    {\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, Color backColor);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, TextFormatFlags flags);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, Color backColor);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, TextFormatFlags flags);\r\n        public static Size MeasureText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font);\r\n        public static Size MeasureText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize);\r\n        public static Size MeasureText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags);\r\n        public static Size MeasureText(ReadOnlySpan\u003Cchar\u003E text, Font font);\r\n        public static Size MeasureText(ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize);\r\n        public static Size MeasureText(ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10070000000,
        "Apis": [
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Point,Color,Color,TextFormatFlags)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Point,Color,Color)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Point,Color,TextFormatFlags)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Point,Color)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Rectangle,Color,Color,TextFormatFlags)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Rectangle,Color,Color)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Rectangle,Color,TextFormatFlags)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Rectangle,Color)",
          "M:TextRenderer.MeasureText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Size,TextFormatFlags)",
          "M:TextRenderer.MeasureText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Size)",
          "M:TextRenderer.MeasureText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font)",
          "M:TextRenderer.MeasureText(ReadOnlySpan\u003Cchar\u003E,Font,Size,TextFormatFlags)",
          "M:TextRenderer.MeasureText(ReadOnlySpan\u003Cchar\u003E,Font,Size)",
          "M:TextRenderer.MeasureText(ReadOnlySpan\u003Cchar\u003E,Font)",
          "T:TextRenderer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39989,
          "Title": "Unify MinimumOSPlatformAttribute and UnsupportedOSPlatformAttribute",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-28T04:40:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39989",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-28T00:00:00-07:00",
        "FeedbackId": "665197220",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39989#issuecomment-665197220",
        "FeedbackMarkdown": "* We\u0027ll rename \u0060MinimumOSPlatformAttribute\u0060 and \u0060RemovedInOSPlatformAttribute\u0060 to \u0060SupportedOSPlatformAttribute\u0060 and \u0060UnsupportedOSPlatformAttribute\u0060 respectively\r\n* We\u0027ll move them (plus \u0060ObsoletedInOSPlatform\u0060) from \u0060System.Runtime.Versioning\u0060 to \u0060System.Runtime.InteropServices\u0060 to co-locate them with them guarding API \u0060RuntimeInformation\u0060\r\n* We don\u0027t like \u0060InteropServices\u0060. @terrajobst to follow up if w can have the guard methods on a type/namespace that isn\u0027t \u0060RuntimeInformation\u0060\r\n* We\u0027ll leave both \u0060OSPlatformAttribute\u0060 and \u0060TargetPlatformAttribute\u0060 in \u0060System.Runtime.Versioning\u0060\r\n* The difference between \u0060net5.0-windows\u0060 and \u0060[SupportedOSPlatform(\u0022windows)]\u0060 is that the TFM is expanded at build time to a concrete version, which for .NET 5 is \u0060windows7.0\u0060 while the platform name in the attribute means \u00600.0\u0060. The resulting behavior will be intuitive for the user, but it\u0027s an important distinction.\r\n* We generally don\u0027t use \u0060params\u0060 on attributes that can be applied multiple times\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Versioning\r\n{\r\n    public abstract class OSPlatformAttribute : Attribute\r\n    {\r\n        private protected OSPlatformAttribute(string platformName);\r\n        public string PlatformName { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Assembly,\r\n                    AllowMultiple=false, Inherited=false)]\r\n    public sealed class TargetPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public TargetPlatformAttribute(string platformName);\r\n    }\r\n}\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    // Renamed from MinimumOSPlatformAttribute\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Enum |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple = true, Inherited = false)]\r\n    public sealed class SupportedOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public SupportedOSPlatformAttribute(string platformName);\r\n    }\r\n\r\n    // RemovedInOSPlatformAttribute\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Enum |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple = true, Inherited = false)]\r\n    public sealed class UnsupportedOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public UnsupportedOSPlatformAttribute(string platformName);\r\n    }\r\n\r\n    // Same shape, but different namespace\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple=true, Inherited=false)]\r\n    public sealed class ObsoletedInOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public ObsoletedInPlatformAttribute(string platformName);\r\n        public ObsoletedInPlatformAttribute(string platformName, string message);\r\n        public string Message { get; }\r\n        public string Url { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18240000000,
        "Apis": [
          "M:ObsoletedInOSPlatformAttribute.ObsoletedInPlatformAttribute(string,string)",
          "M:ObsoletedInOSPlatformAttribute.ObsoletedInPlatformAttribute(string)",
          "M:OSPlatformAttribute.OSPlatformAttribute(string)",
          "M:SupportedOSPlatformAttribute.SupportedOSPlatformAttribute(string)",
          "M:TargetPlatformAttribute.TargetPlatformAttribute(string)",
          "M:UnsupportedOSPlatformAttribute.UnsupportedOSPlatformAttribute(string)",
          "P:ObsoletedInOSPlatformAttribute.Message",
          "P:ObsoletedInOSPlatformAttribute.Url",
          "P:OSPlatformAttribute.PlatformName",
          "T:ObsoletedInOSPlatformAttribute",
          "T:OSPlatformAttribute",
          "T:SupportedOSPlatformAttribute",
          "T:TargetPlatformAttribute",
          "T:UnsupportedOSPlatformAttribute"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 147,
          "Title": "SecureString obsoletions and shrouded buffer proposal",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-21T19:19:53+00:00",
          "Url": "https://github.com/dotnet/designs/pull/147",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-28T00:00:00-07:00",
        "FeedbackId": "665227008",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/147#issuecomment-665227008",
        "FeedbackMarkdown": "* We think we need to make decision whether or not the framework is interested in providing building blocks like \u0060ShroudedBuffer\u003CT\u003E\u0060 in order for a customer to build hygienic solutions around handling privileged information, which also includes enables customers to build a PCI compliant solution. This requires and end-to-end how privileged is read into a process and how it leaves the process (file I/O, networking API, ASP.NET buffer pools, etc). This also includes GC behavior around copying memory, crash dumps, and logging.\r\n* We should think through what it means to obsoleted \u0060SecureString\u0060 for APIs that can only be used be used with it, such as many PowerShell Cmdlets and some of our networking/crypto APIs.",
        "TimeCode": 42460000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31198,
          "Title": "configurable HTTP/2 PING timeouts in HttpClient",
          "Author": "chrisdot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-17T12:25:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31198",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-29T00:00:00-07:00",
        "FeedbackId": "665783930",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31198#issuecomment-665783930",
        "FeedbackMarkdown": "\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public class SocketsHttpHandler\r\n    {\r\n        public TimeSpan KeepAlivePingDelay { get; set; }\r\n        public TimeSpan KeepAlivePingTimeout { get; set; }\r\n        public HttpKeepAlivePingPolicy KeepAlivePingPolicy { get; set; }\r\n    }\r\n    public enum HttpKeepAlivePingPolicy\r\n    {\r\n        WithActiveRequests,\r\n        Always\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:HttpKeepAlivePingPolicy.Always",
          "F:HttpKeepAlivePingPolicy.WithActiveRequests",
          "P:SocketsHttpHandler.KeepAlivePingDelay",
          "P:SocketsHttpHandler.KeepAlivePingPolicy",
          "P:SocketsHttpHandler.KeepAlivePingTimeout",
          "T:HttpKeepAlivePingPolicy",
          "T:SocketsHttpHandler"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "7EBzsfHCQOM",
      "StartDateTime": "2020-07-30T11:02:53-07:00",
      "EndDateTime": "2020-07-30T12:09:39-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7EBzsfHCQOM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40046,
          "Title": "System.Diagnostics.ActivitySource API Addition",
          "Author": "CodeBlanch",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-28T21:06:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40046",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-30T00:00:00-07:00",
        "FeedbackId": "666588567",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40046#issuecomment-666588567",
        "FeedbackMarkdown": "* We should rename \u0060w3cid\u0060 to \u0060traceParent\u0060\r\n* We considered offering a span-based overload but right now the most common case for the use of the API starts with a header value which is currently only ever going to be a string. If the networking layer will give access in a span-based fashion we can add it.\r\n* We should have a corresponding \u0060Parse\u0060 method\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public readonly partial struct ActivityContext : IEquatable\u003CActivityContext\u003E\r\n    {\r\n        public static ActivityContext Parse(string traceParent, string? traceState);\r\n        public static bool TryParse(string traceParent, string? traceState, out ActivityContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ActivityContext.Parse(string,string?)",
          "M:ActivityContext.TryParse(string,string?,out ActivityContext)",
          "T:ActivityContext"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40095,
          "Title": "Mark existing Windows-specific APIs without a version number",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-29T18:24:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40095",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-30T00:00:00-07:00",
        "FeedbackId": "666600842",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40095#issuecomment-666600842",
        "FeedbackMarkdown": "* Looks good\r\n* We should consider re-baselining when we bump the minimum Windows version, for similar benefits for net-new code.\r\n* We should consider having an analyzer that flags checks for a higher version than what the guarded code actually needs.\r\n\r\n\u0060\u0060\u0060C#\r\n[SupportedOSPlatform(\u0022windows\u0022)]\r\npublic void TheRegistry() { ... }\r\n\r\npublic void DoSomething()\r\n{\r\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\r\n        TheRegistry();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19210000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40101,
          "Title": "Mark System.Security.Cryptography.OpenSsl as unsupported on Windows",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-29T20:23:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40101",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-30T00:00:00-07:00",
        "FeedbackId": "666606594",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40101#issuecomment-666606594",
        "FeedbackMarkdown": "* Looks good.\r\n* It seems the direction is that Windows will require a store package. That\u0027s not expressible in an OS check. If that becomes the case we can remove the attribute, build a one-off analyzer, or generalize this into a new attribute.\r\n\r\n**Assembly**: System.Security.Cryptography.OpenSsl\r\n\r\n\u0060\u0060\u0060C#\r\n[assembly: UnsupportedOSPlatform(\u0022windows\u0022)]\r\n\u0060\u0060\u0060",
        "TimeCode": 31240000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30657,
          "Title": "Provide an overload of float/double.ToString that allow precision greater than 99",
          "Author": "Gnbrkm41",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-22T14:15:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30657",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-30T00:00:00-07:00",
        "FeedbackId": "666609015",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30657#issuecomment-666609015",
        "FeedbackMarkdown": "* It was suggested to add support for custom cultures. New shape:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct Single\r\n    {\r\n        public string ToString(char format, int precision);\r\n        public string ToString(char format, int precision, IFormatProvider? provider);\r\n    }\r\n    public struct Double\r\n    {\r\n        public string ToString(char format, int precision);\r\n        public string ToString(char format, int precision, IFormatProvider? provider);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 36230000000,
        "Apis": [
          "M:Double.ToString(char,int,IFormatProvider?)",
          "M:Double.ToString(char,int)",
          "M:Single.ToString(char,int,IFormatProvider?)",
          "M:Single.ToString(char,int)",
          "T:Double",
          "T:Single"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "wOytg5ukJ2Y",
      "StartDateTime": "2020-07-31T10:10:55-07:00",
      "EndDateTime": "2020-07-31T12:40:48-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/wOytg5ukJ2Y/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37421,
          "Title": "ConsoleLogger output is garbled with color codes when redirected",
          "Author": "tmds",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-04T15:22:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37421",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-07-31T00:00:00-07:00",
        "FeedbackId": "667250129",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37421#issuecomment-667250129",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We considered exposing a setting on \u0060System.Console\u0060 instead but we want a setting that can be configured via the configuration system of \u0060Microsoft.Extensions\u0060.\r\n\r\n\u0060\u0060\u0060diff\r\n namespace Microsoft.Extensions.Logging.Console\r\n {\r\n\u002B    public enum LoggerColorBehavior\r\n\u002B    {\r\n\u002B        Default = 0,\r\n\u002B        Enabled = 1,\r\n\u002B        Disabled = 2,\r\n\u002B    }\r\n     public class SimpleConsoleFormatterOptions : ConsoleFormatterOptions\r\n     {\r\n         public SimpleConsoleFormatterOptions();\r\n-        public bool DisableColors { get; set; }\r\n\u002B        public LoggerColorBehavior ColorBehavior { get; set; }\r\n         public bool SingleLine { get; set; }\r\n     }\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "O6zAv29ak1g",
      "StartDateTime": "2020-08-04T10:08:02-07:00",
      "EndDateTime": "2020-08-04T12:04:44-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/O6zAv29ak1g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39941,
          "Title": "Exception types for System.Net.Connections",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-26T23:46:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39941",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-04T00:00:00-07:00",
        "FeedbackId": "668737191",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39941#issuecomment-668737191",
        "FeedbackMarkdown": "* We generally recommend against either extreme (one exception with lots of error codes or as many exceptions as error states) because it creates a mess.\r\n* Instead, we recommend to have one exception type per mainline scenario that the user is likely to write error handling for. It\u0027s OK if more advanced cases involve inspecting the exception\u0027s error code or inner exception.\r\n* It seems Option B is closest to that.\r\n* We can even introduce dedicated exception types for specific error codes later, so long they extend the generic type and have the proper error code. We should exposing a factory so that people can construct an exception given an error code. This means the constructor should be protected.\r\n* It seems *abort* and *reset* would be candidates for dedicated types.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class NetworkException : IOException\r\n    {\r\n        public static NetworkException Create(NetworkError error, Exception innerException = null, string message = null);\r\n        protected NetworkException(NetworkError error, Exception innerException = null, string message = null);\r\n        // serialization constructor as usual\r\n\r\n        public NetworkError NetworkError { get; }\r\n    }\r\n\r\n    public enum NetworkError\r\n    {\r\n        Unknown,\r\n\r\n        AddressInUse,       // SocketError.AddressAlreadyInUse\r\n        InvalidAddress,     // SocketError.AddressFamilyNotSupported, SocketError.AddressNotAvailable, etc\r\n        ConnectionRefused,  // SocketError.ConnectionRefused\r\n        HostNotFound,       // SocketError.HostNotFound, SocketError.HostUnreachable, etc\r\n\r\n        ConnectionAborted,\r\n        ConnectionReset,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:NetworkError.AddressInUse",
          "F:NetworkError.ConnectionAborted",
          "F:NetworkError.ConnectionRefused",
          "F:NetworkError.ConnectionReset",
          "F:NetworkError.HostNotFound",
          "F:NetworkError.InvalidAddress",
          "F:NetworkError.Unknown",
          "M:NetworkException.Create(NetworkError,Exception,string)",
          "M:NetworkException.NetworkException(NetworkError,Exception,string)",
          "P:NetworkException.NetworkError",
          "T:NetworkError",
          "T:NetworkException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40111,
          "Title": "Moving platform guards out of System.Runtime.InteropServices",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-29T23:42:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40111",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "untriaged",
              "Color": "fbca04",
              "Description": "New issue has not been triaged by the area owner"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-04T00:00:00-07:00",
        "FeedbackId": "668771421",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40111#issuecomment-668771421",
        "FeedbackMarkdown": "* We\u0027ll capitalize the first letter in Apple platforms when they are part of a longer name, such as \u0060IsTvOS\u0060 (instead of \u0060IstvOS\u0060).\r\n* We\u0027ve decided to move all members to \u0060OperatingSystem\u0060, which doesn\u0027t expose any statics today. This avoids creating a dumping ground in \u0060Environment\u0060.\r\n* We\u0027ll try to pull the members from \u0060OSPlatform\u0060 we added in the earlier .NET 5 preview\r\n* \u0060FreeBSD\u0060 has versions, so it should have \u0060IsFreeBSDVersionAtLeast\u0060\r\n* We agreed to move all attributes to \u0060System.Runtime.Versioning\u0060. Most developers will apply these attributes through code completion or code fixers, so namespace discoverability won\u0027t be a big issue, but polluting the \u0060System\u0060 namespace is a big concern.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class OperatingSystem\r\n    {\r\n        // Primary\r\n        public static bool IsOSPlatform(string platform);\r\n        public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        // Accelerators for platforms where versions don\u0027t make sense\r\n        public static bool IsBrowser();\r\n        public static bool IsLinux();\r\n\r\n        // Accelerators with version checks\r\n\r\n        public static bool IsFreeBSD();\r\n        public static bool IsFreeBSDVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsAndroid();\r\n        public static bool IsAndroidVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsIOS();\r\n        public static bool IsIOSVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsMacOS();\r\n        public static bool IsMacOSVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsTvOS();\r\n        public static bool IsTvOSVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsWatchOS();\r\n        public static bool IsWatchOSVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n\r\n        public static bool IsWindows();\r\n        public static bool IsWindowsVersionAtLeast(int major, int minor = 0, int build = 0, int revision = 0);\r\n    }\r\n}\r\nnamespace System.Runtime.Versioning\r\n{\r\n    public abstract class OSPlatformAttribute : Attribute\r\n    {\r\n        private protected OSPlatformAttribute(string platformName);\r\n        public string PlatformName { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Assembly,\r\n                    AllowMultiple=false, Inherited=false)]\r\n    public sealed class TargetPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public TargetPlatformAttribute(string platformName);\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Enum |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple = true, Inherited = false)]\r\n    public sealed class SupportedOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public SupportedOSPlatformAttribute(string platformName);\r\n    }\r\n  \r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Enum |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple = true, Inherited = false)]\r\n    public sealed class UnsupportedOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public UnsupportedOSPlatformAttribute(string platformName);\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Module |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Struct,\r\n                    AllowMultiple=true, Inherited=false)]\r\n    public sealed class ObsoletedInOSPlatformAttribute : OSPlatformAttribute\r\n    {\r\n        public ObsoletedInPlatformAttribute(string platformName);\r\n        public ObsoletedInPlatformAttribute(string platformName, string message);\r\n        public string Message { get; }\r\n        public string Url { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public readonly partial struct OSPlatform\r\n    {\r\n-       public static System.Runtime.InteropServices.OSPlatform Android { get; }\r\n-       public static System.Runtime.InteropServices.OSPlatform Browser { get; }\r\n        public static System.Runtime.InteropServices.OSPlatform FreeBSD { get; }\r\n-       public static System.Runtime.InteropServices.OSPlatform iOS { get; }\r\n        public static System.Runtime.InteropServices.OSPlatform Linux { get; }\r\n-       public static System.Runtime.InteropServices.OSPlatform macOS { get; }\r\n-       [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]\r\n        public static System.Runtime.InteropServices.OSPlatform OSX { get; }\r\n-       public static System.Runtime.InteropServices.OSPlatform tvOS { get; }\r\n-       public static System.Runtime.InteropServices.OSPlatform watchOS { get; }\r\n        public static System.Runtime.InteropServices.OSPlatform Windows { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28330000000,
        "Apis": [
          "M:ObsoletedInOSPlatformAttribute.ObsoletedInPlatformAttribute(string,string)",
          "M:ObsoletedInOSPlatformAttribute.ObsoletedInPlatformAttribute(string)",
          "M:OperatingSystem.IsAndroid()",
          "M:OperatingSystem.IsAndroidVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsBrowser()",
          "M:OperatingSystem.IsFreeBSD()",
          "M:OperatingSystem.IsFreeBSDVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsIOS()",
          "M:OperatingSystem.IsIOSVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsLinux()",
          "M:OperatingSystem.IsMacOS()",
          "M:OperatingSystem.IsMacOSVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsOSPlatform(string)",
          "M:OperatingSystem.IsOSPlatformVersionAtLeast(string,int,int,int,int)",
          "M:OperatingSystem.IsTvOS()",
          "M:OperatingSystem.IsTvOSVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsWatchOS()",
          "M:OperatingSystem.IsWatchOSVersionAtLeast(int,int,int,int)",
          "M:OperatingSystem.IsWindows()",
          "M:OperatingSystem.IsWindowsVersionAtLeast(int,int,int,int)",
          "M:OSPlatformAttribute.OSPlatformAttribute(string)",
          "M:SupportedOSPlatformAttribute.SupportedOSPlatformAttribute(string)",
          "M:TargetPlatformAttribute.TargetPlatformAttribute(string)",
          "M:UnsupportedOSPlatformAttribute.UnsupportedOSPlatformAttribute(string)",
          "P:ObsoletedInOSPlatformAttribute.Message",
          "P:ObsoletedInOSPlatformAttribute.Url",
          "P:OSPlatformAttribute.PlatformName",
          "T:ObsoletedInOSPlatformAttribute",
          "T:OperatingSystem",
          "T:OSPlatformAttribute",
          "T:SupportedOSPlatformAttribute",
          "T:TargetPlatformAttribute",
          "T:UnsupportedOSPlatformAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Ok1l1fODjzo",
      "StartDateTime": "2020-08-06T10:04:51-07:00",
      "EndDateTime": "2020-08-06T12:02:25-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Ok1l1fODjzo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40339,
          "Title": "Add a way to the ActivityListeners to add more data to the Activity when it gets created",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-04T20:42:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40339",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670076292",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40339#issuecomment-670076292",
        "FeedbackMarkdown": "* What happens when you remove the \u0060readonly\u0060 specifier? Does this potentially create defensive copies.\r\n* If the only reason is lazy initialization it seems better keep it \u0060readonly\u0060 and use \u0060Unsafe\u0060 and initialize\r\n\r\n\u0060\u0060\u0060diff\r\n namespace System.Diagnostics\r\n {\r\n     public readonly struct ActivityCreationOptions\u003CT\u003E\r\n     {\r\n\u002B        public ActivityTagsCollection SamplingTags { get; }\r\n\u002B        public ActivityTraceId TraceId { get; }\r\n     }\r\n     public sealed class ActivityListener : IDisposable\r\n     {\r\n-        public bool AutoGenerateRootContextTraceId { get; set;}\r\n         // Renames:\r\n-        public GetRequestedData\u003Cstring\u003E? GetRequestedDataUsingParentId { get; set; }\r\n-        public GetRequestedData\u003CActivityContext\u003E? GetRequestedDataUsingContext { get; set; }\r\n\u002B        public SampleActivity\u003Cstring\u003E? SampleUsingParentId { get; set; }\r\n\u002B        public SampleActivity\u003CActivityContext\u003E? Sample { get; set; }\r\n     }\r\n-    public delegate ActivityDataRequest GetRequestedData\u003CT\u003E(ref ActivityCreationOptions\u003CT\u003E options);\r\n\u002B    public delegate ActivitySamplingResult SampleActivity\u003CT\u003E(ref ActivityCreationOptions\u003CT\u003E options);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35126,
          "Title": "Non-validated HttpHeaders enumeration",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-17T19:32:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35126",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670095983",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35126#issuecomment-670095983",
        "FeedbackMarkdown": "* \u0060NonValidatedEnumerator\u0060 should be split into an enumerable and an enumerator\r\n* We should compare \u0060HeaderStringValues\u0060 to the one ASP.NET Core has\r\n* Should \u0060HeaderStringValues\u0060 have constructors for the single value/multiple values?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http.Headers\r\n{\r\n    public partial class HttpHeaders\r\n    {\r\n        public HttpHeadersNonValidated NonValidated { get; }\r\n    }\r\n\r\n    public readonly struct HttpHeadersNonValidated : IEnumerable\u003CKeyValuePair\u003Cstring, HeaderStringValues\u003E\u003E\r\n    {\r\n        public Enumerator GetEnumerator();\r\n        public readonly struct Enumerator : IEnumerator\u003CKeyValuePair\u003Cstring, HeaderStringValues\u003E\u003E\r\n        {\r\n            public bool MoveNext();\r\n            public KeyValuePair\u003Cstring, HeaderStringValues\u003E Current { get; }\r\n            public void Dispose();\r\n            // explicitly implemented interface members\r\n        }\r\n    }\r\n\r\n    public readonly struct HeaderStringValues : IEnumerable\u003Cstring\u003E\r\n    {\r\n        public HeaderStringValues(string value);\r\n        public HeaderStringValues(IEnumerable\u003Cstring\u003E value);\r\n        public Enumerator GetEnumerator();\r\n        public readonly struct Enumerator : IEnumerator\u003Cstring\u003E\r\n        {\r\n            public bool MoveNext();\r\n            public string Current { get; }\r\n            public void Dispose();\r\n            ... // explicitly implemented interface members\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20570000000,
        "Apis": [
          "M:HeaderStringValues.Enumerator.Dispose()",
          "M:HeaderStringValues.Enumerator.MoveNext()",
          "M:HeaderStringValues.GetEnumerator()",
          "M:HeaderStringValues.HeaderStringValues(IEnumerable\u003Cstring\u003E)",
          "M:HeaderStringValues.HeaderStringValues(string)",
          "M:HttpHeadersNonValidated.Enumerator.Dispose()",
          "M:HttpHeadersNonValidated.Enumerator.MoveNext()",
          "M:HttpHeadersNonValidated.GetEnumerator()",
          "P:HeaderStringValues.Enumerator.Current",
          "P:HttpHeaders.NonValidated",
          "P:HttpHeadersNonValidated.Enumerator.Current",
          "T:HeaderStringValues",
          "T:HeaderStringValues.Enumerator",
          "T:HttpHeaders",
          "T:HttpHeadersNonValidated",
          "T:HttpHeadersNonValidated.Enumerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40451,
          "Title": "Exception types for System.Net.Connections, Part 2",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-06T08:50:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40451",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670117109",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40451#issuecomment-670117109",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net\r\n{\r\n    public class NetworkException : IOException\r\n    {\r\n        public NetworkException(string message, NetworkError error, Exception innerException = null);\r\n        public NetworkException(NetworkError error, Exception innerException = null);\r\n        public NetworkError NetworkError { get; }\r\n    }\r\n    public enum NetworkError\r\n    {\r\n        Unknown,\r\n\r\n        EndPointInUse,         // SocketError.AddressAlreadyInUse\r\n        HostNotFound,          // SocketError.HostNotFound\r\n\r\n        ConnectionRefused,     // SocketError.ConnectionRefused\r\n        ConnectionAborted,     // SocketError.ConnectionAborted\r\n        ConnectionReset,       // SocketError.ConnectionReset\r\n\r\n        OperationAborted       // SocketError.OperationAborted\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 44970000000,
        "Apis": [
          "F:NetworkError.ConnectionAborted",
          "F:NetworkError.ConnectionRefused",
          "F:NetworkError.ConnectionReset",
          "F:NetworkError.EndPointInUse",
          "F:NetworkError.HostNotFound",
          "F:NetworkError.OperationAborted",
          "F:NetworkError.Unknown",
          "M:NetworkException.NetworkException(NetworkError,Exception)",
          "M:NetworkException.NetworkException(string,NetworkError,Exception)",
          "P:NetworkException.NetworkError",
          "T:NetworkError",
          "T:NetworkException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36160,
          "Title": "Consider expanding \u0060Vector\u003CT\u003E\u0060 to support \u0060nint\u0060 and \u0060nuint\u0060",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-09T05:34:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36160",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670131376",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36160#issuecomment-670131376",
        "FeedbackMarkdown": "* We should use \u0060NInt\u0060 and \u0060NUInt\u0060 as the the non-keyword types names for APIs that have to refer to \u0060nint\u0060 and \u0060nuint\u0060, as opposed to \u0060IntPtr\u0060 and \u0060UIntPtr\u0060,\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public partial struct Vector\u003CT\u003E\r\n    {\r\n        public static explicit operator Vector\u003Cnint\u003E(Vector\u003CT\u003E value);\r\n        public static explicit operator Vector\u003Cnuint\u003E(Vector\u003CT\u003E value);\r\n    }\r\n\r\n    public static partial class Vector\r\n    {\r\n        public static Vector\u003Cnint\u003E AsVectorNInt\u003CT\u003E(Vector\u003CT\u003E value);\r\n        public static Vector\u003Cnuint\u003E AsVectorNUInt\u003CT\u003E(Vector\u003CT\u003E value);\r\n\r\n        public static Vector\u003Cnint\u003E Equals(Vector\u003Cnint\u003E left, Vector\u003Cnint\u003E right);\r\n        public static Vector\u003Cnuint\u003E Equals(Vector\u003Cnuint\u003E left, Vector\u003Cnuint\u003E right);\r\n\r\n        public static Vector\u003Cnint\u003E GreaterThan(Vector\u003Cnint\u003E left, Vector\u003Cnint\u003E right);\r\n        public static Vector\u003Cnuint\u003E GreaterThan(Vector\u003Cnuint\u003E left, Vector\u003Cnuint\u003E right);\r\n\r\n        public static Vector\u003Cnint\u003E GreaterThanOrEqual(Vector\u003Cnint\u003E left, Vector\u003Cnint\u003E right);\r\n        public static Vector\u003Cnuint\u003E GreaterThanOrEqual(Vector\u003Cnuint\u003E left, Vector\u003Cnuint\u003E right);\r\n\r\n        public static Vector\u003Cnint\u003E LessThan(Vector\u003Cnint\u003E left, Vector\u003Cnint\u003E right);\r\n        public static Vector\u003Cnuint\u003E LessThan(Vector\u003Cnuint\u003E left, Vector\u003Cnuint\u003E right);\r\n\r\n        public static Vector\u003Cnint\u003E LessThanOrEqual(Vector\u003Cnint\u003E left, Vector\u003Cnint\u003E right);\r\n        public static Vector\u003Cnuint\u003E LessThanOrEqual(Vector\u003Cnuint\u003E left, Vector\u003Cnuint\u003E right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57240000000,
        "Apis": [
          "M:Vector.AsVectorNInt\u003CT\u003E(Vector\u003CT\u003E)",
          "M:Vector.AsVectorNUInt\u003CT\u003E(Vector\u003CT\u003E)",
          "M:Vector.Equals(Vector\u003Cnint\u003E,Vector\u003Cnint\u003E)",
          "M:Vector.Equals(Vector\u003Cnuint\u003E,Vector\u003Cnuint\u003E)",
          "M:Vector.GreaterThan(Vector\u003Cnint\u003E,Vector\u003Cnint\u003E)",
          "M:Vector.GreaterThan(Vector\u003Cnuint\u003E,Vector\u003Cnuint\u003E)",
          "M:Vector.GreaterThanOrEqual(Vector\u003Cnint\u003E,Vector\u003Cnint\u003E)",
          "M:Vector.GreaterThanOrEqual(Vector\u003Cnuint\u003E,Vector\u003Cnuint\u003E)",
          "M:Vector.LessThan(Vector\u003Cnint\u003E,Vector\u003Cnint\u003E)",
          "M:Vector.LessThan(Vector\u003Cnuint\u003E,Vector\u003Cnuint\u003E)",
          "M:Vector.LessThanOrEqual(Vector\u003Cnint\u003E,Vector\u003Cnint\u003E)",
          "M:Vector.LessThanOrEqual(Vector\u003Cnuint\u003E,Vector\u003Cnuint\u003E)",
          "M:Vector\u003CT\u003E.explicit(Vector\u003CT\u003E)",
          "T:Vector",
          "T:Vector\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38134,
          "Title": "Expose a new CallConvSuppressGCTransition so SuppressGCTransition works for function pointers",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-19T00:33:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38134",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670133996",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38134#issuecomment-670133996",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public class CallConvSuppressGCTransition\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62590000000,
        "Apis": [
          "T:CallConvSuppressGCTransition"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2036,
          "Title": "Expose general purpose Crc32 APIs",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-22T21:29:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2036",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-06T00:00:00-07:00",
        "FeedbackId": "670136776",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2036#issuecomment-670136776",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We can add overloads with custom polynomials later, but we should document the ones that we\u0027re using here.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static class BitOperations\r\n    {\r\n        public static uint Crc32(uint crc, byte data);\r\n        public static uint Crc32(uint crc, ushort data);\r\n        public static uint Crc32(uint crc, uint data);\r\n        public static uint Crc32(uint crc, ulong data);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 65980000000,
        "Apis": [
          "M:BitOperations.Crc32(uint,byte)",
          "M:BitOperations.Crc32(uint,uint)",
          "M:BitOperations.Crc32(uint,ulong)",
          "M:BitOperations.Crc32(uint,ushort)",
          "T:BitOperations"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ub-XaCUH1n0",
      "StartDateTime": "2020-08-07T10:06:19-07:00",
      "EndDateTime": "2020-08-07T11:59:58-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ub-XaCUH1n0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40202,
          "Title": "Span\u003Cchar\u003E from null-terminated char*",
          "Author": "fbrosseau",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-31T14:02:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40202",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670625737",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40202#issuecomment-670625737",
        "FeedbackMarkdown": "* Let\u0027s make it clear in the name what this method does.\r\n* Let\u0027s have an overload that deals with UTF8\r\n* Let\u0027s hold back UTF32 until we need it.\r\n* We should also provide \u0060strlen\u0060-like APIs\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial class MemoryMarshal\r\n    {\r\n        public static Span\u003Cchar\u003E CreateFromNullTerminated(char* value);\r\n        public static Span\u003Cbyte\u003E CreateFromNullTerminated(byte* value);\r\n    }\r\n}\r\nnamespace System\r\n{\r\n    public partial class Buffer\r\n    {\r\n        public unsafe static nuint GetStringLength(char* source);\r\n        public unsafe static nuint GetStringLength(char* source, nuint maxLength);\r\n        public unsafe static nuint GetStringLength(byte* source);\r\n        public unsafe static nuint GetStringLength(byte* source, nuint maxLength);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Buffer.GetStringLength(byte*,nuint)",
          "M:Buffer.GetStringLength(byte*)",
          "M:Buffer.GetStringLength(char*,nuint)",
          "M:Buffer.GetStringLength(char*)",
          "M:MemoryMarshal.CreateFromNullTerminated(byte*)",
          "M:MemoryMarshal.CreateFromNullTerminated(char*)",
          "T:Buffer",
          "T:MemoryMarshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 26741,
          "Title": "Support generating random 64-bit values.",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-07-10T02:57:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/26741",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670633590",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/26741#issuecomment-670633590",
        "FeedbackMarkdown": "* Makes sense\r\n* Let\u0027s also add \u0060NextSingle()\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public class Random\r\n    {\r\n        public virtual long NextInt64();\r\n        public virtual long NextInt64(long maxValue);\r\n        public virtual long NextInt64(long minValue, long maxValue);\r\n        public virtual float NextSingle();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12140000000,
        "Apis": [
          "M:Random.NextInt64()",
          "M:Random.NextInt64(long,long)",
          "M:Random.NextInt64(long)",
          "M:Random.NextSingle()",
          "T:Random"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35054,
          "Title": "Add File class method overloads for ReadOnlyMemory and ReadOnlySpan",
          "Author": "Tan90909090",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-16T13:26:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35054",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670642453",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35054#issuecomment-670642453",
        "FeedbackMarkdown": "* It seems odd to combine a low-level concept like span/memory with very high-level APIs like \u0022write all this data to file\u0022.\r\n* The goal is to make it very convenient to write some data to a file, not performance.\r\n* My concern is that these additions would \u0022pollute\u0022 a core API that is frequently used by beginners. The API is designed to grow to expose users to more concepts, such as \u0060StreamReader\u0060 and \u0060FileStream\u0060.\r\n* If the arugment is that creating a file stream is too hard, for example, opening it for async, I\u0027d rather we add dedicated methods for that, such as \u0060OpenForAsync\u0060.\r\n* Unless there is a compelling reason for those APIs, we\u0027re inclined to say no.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class File\r\n    {\r\n        public static ValueTask AppendAllLinesAsync(string path, IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E contents, CancellationToken cancellationToken = default);\r\n        public static ValueTask AppendAllLinesAsync(string path, IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E contents, Encoding encoding, CancellationToken cancellationToken = default);\r\n        public static void AppendAllText(string path, ReadOnlySpan\u003Cchar\u003E contents);\r\n        public static void AppendAllText(string path, ReadOnlySpan\u003Cchar\u003E contents, Encoding encoding);\r\n        public static ValueTask AppendAllTextAsync(string path, ReadOnlyMemory\u003Cchar\u003E contents, CancellationToken cancellationToken = default);\r\n        public static ValueTask AppendAllTextAsync(string path, ReadOnlyMemory\u003Cchar\u003E contents, Encoding encoding, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAllLinesAsync(string path, IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E contents, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAllLinesAsync(string path, IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E contents, Encoding encoding, CancellationToken cancellationToken = default);\r\n        public static void WriteAllText(string path, ReadOnlySpan\u003Cchar\u003E contents);\r\n        public static void WriteAllText(string path, ReadOnlySpan\u003Cchar\u003E contents, Encoding encoding);\r\n        public static ValueTask WriteAllTextAsync(string path, ReadOnlyMemory\u003Cchar\u003E contents, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAllTextAsync(string path, ReadOnlyMemory\u003Cchar\u003E contents, Encoding encoding, CancellationToken cancellationToken = default);\r\n        public static void WriteAllBytes(string path, ReadOnlySpan\u003Cbyte\u003E bytes);\r\n        public static ValueTask WriteAllBytesAsync(string path, ReadOnlyMemory\u003Cbyte\u003E bytes, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24490000000,
        "Apis": [
          "M:File.AppendAllLinesAsync(string,IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E,CancellationToken)",
          "M:File.AppendAllLinesAsync(string,IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E,Encoding,CancellationToken)",
          "M:File.AppendAllText(string,ReadOnlySpan\u003Cchar\u003E,Encoding)",
          "M:File.AppendAllText(string,ReadOnlySpan\u003Cchar\u003E)",
          "M:File.AppendAllTextAsync(string,ReadOnlyMemory\u003Cchar\u003E,CancellationToken)",
          "M:File.AppendAllTextAsync(string,ReadOnlyMemory\u003Cchar\u003E,Encoding,CancellationToken)",
          "M:File.WriteAllBytes(string,ReadOnlySpan\u003Cbyte\u003E)",
          "M:File.WriteAllBytesAsync(string,ReadOnlyMemory\u003Cbyte\u003E,CancellationToken)",
          "M:File.WriteAllLinesAsync(string,IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E,CancellationToken)",
          "M:File.WriteAllLinesAsync(string,IEnumerable\u003CReadOnlyMemory\u003Cchar\u003E\u003E,Encoding,CancellationToken)",
          "M:File.WriteAllText(string,ReadOnlySpan\u003Cchar\u003E,Encoding)",
          "M:File.WriteAllText(string,ReadOnlySpan\u003Cchar\u003E)",
          "M:File.WriteAllTextAsync(string,ReadOnlyMemory\u003Cchar\u003E,CancellationToken)",
          "M:File.WriteAllTextAsync(string,ReadOnlyMemory\u003Cchar\u003E,Encoding,CancellationToken)",
          "T:File"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35180,
          "Title": "[Uri] Add UriScheme Properties: SSH, FTPS, SFTP, WS, WSS",
          "Author": "ArthurHNL",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-19T18:29:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35180",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670645017",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35180#issuecomment-670645017",
        "FeedbackMarkdown": "* The names and API shape makes sense.\r\n* The only concern that we have is whether supporting those schemes has any implications on other parts of URI, such as in \u0060UriParser\u0060 and populating defaults, such as ports. Is there any extra work we\u0027d be signing up to support those? If so, we may want to be more selective what we support. @dotnet/ncl, could you double check?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Uri\r\n    {\r\n        public static readonly string UriSchemeWs;\r\n        public static readonly string UriSchemeWss;\r\n        public static readonly string UriSchemeSsh;\r\n        public static readonly string UriSchemeTelnet;\r\n        public static readonly string UriSchemeSftp;\r\n        public static readonly string UriSchemeFtps;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 37010000000,
        "Apis": [
          "F:Uri.UriSchemeFtps",
          "F:Uri.UriSchemeSftp",
          "F:Uri.UriSchemeSsh",
          "F:Uri.UriSchemeTelnet",
          "F:Uri.UriSchemeWs",
          "F:Uri.UriSchemeWss",
          "T:Uri"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35827,
          "Title": "Exposing plumbing for single instance application",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-05T04:57:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35827",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670647368",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35827#issuecomment-670647368",
        "FeedbackMarkdown": "* The namespace is an odd choice\r\n* It seems folks in this thread have concerns with the shape.\r\n* @KathleenDollard @cston if this is something we want to pursue for .NET 6/MAUI we should sit down and design this a bit further.",
        "TimeCode": 40740000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36232,
          "Title": "Add unsigned overloads for Unsafe Add/Subtract and Add/SubtractByteOffset",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-11T18:19:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36232",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-07T00:00:00-07:00",
        "FeedbackId": "670651996",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36232#issuecomment-670651996",
        "FeedbackMarkdown": "* This logically creates \u0060UIntPtr\u0060 overloads, but prefer \u0060nuint\u0060 for APIs like these.\r\n* We won\u0027t be adding \u0060uint\u0060\r\n* Looks good as proposed\r\n* @tannergooding would like to support other cases, such as refs to things that contain pointers and \u0060ref struct\u0060, could you file a separate issue for that?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class Unsafe\r\n    {\r\n        public static ref T AddByteOffset\u003CT\u003E(ref T source, nuint byteOffset);\r\n        public static ref T Add\u003CT\u003E(ref T source, nuint elementOffset);\r\n\r\n        public static ref T SubtractByteOffset\u003CT\u003E(ref T source, nuint byteOffset);\r\n        public static ref T Subtract\u003CT\u003E(ref T source, nuint elementOffset);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42870000000,
        "Apis": [
          "M:Unsafe.Add\u003CT\u003E(ref T,nuint)",
          "M:Unsafe.AddByteOffset\u003CT\u003E(ref T,nuint)",
          "M:Unsafe.Subtract\u003CT\u003E(ref T,nuint)",
          "M:Unsafe.SubtractByteOffset\u003CT\u003E(ref T,nuint)",
          "T:Unsafe"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "pgAFuCF6Kp8",
      "StartDateTime": "2020-08-11T10:06:13-07:00",
      "EndDateTime": "2020-08-11T12:07:50-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/pgAFuCF6Kp8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37539,
          "Title": "Add ability to perform zero byte reads in StreamPipeReader",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-06T06:58:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37539",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-11T00:00:00-07:00",
        "FeedbackId": "672127133",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37539#issuecomment-672127133",
        "FeedbackMarkdown": "* Zero byte reads are technically a violation of the \u0060Stream.Read()\u0060 contract, but granted many streams probably support it by accident.\r\n* We should have an API on \u0060Stream\u0060 instead\r\n* We should validate the \u0060SslStream\u0060, \u0060SocketListenerStream\u0060, \u0060NetworkStream\u0060, and other compression streams\r\n* This should be investigated and the API proposal should be updated\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipelines\r\n{\r\n    public class StreamPipeReaderOptions\r\n    {\r\n        public bool WaitForData { get; set; }\r\n    }\r\n}\r\nnamespace System.IO\r\n{\r\n    public partial class Stream\r\n    {\r\n        public virtual Task WaitForDataAsync() =\u003E return Task.CompletedTask;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Stream.WaitForDataAsync()",
          "P:StreamPipeReaderOptions.WaitForData",
          "T:Stream",
          "T:StreamPipeReaderOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38872,
          "Title": "Make enum RegexParseError and RegexParseException public",
          "Author": "abelbraaksma",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-07T14:58:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38872",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-11T00:00:00-07:00",
        "FeedbackId": "672176154",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38872#issuecomment-672176154",
        "FeedbackMarkdown": "* The type is currently serializable and people do serialize the exception by catching \u0060ArgumentException\u0060 (or \u0060Exception\u0060). To preserve cross-framework deserialization, like when someone deserializes this exception on .NET Framework (or earlier versions of .NET Core), we need to keep serializing as \u0060ArgumentException\u0060, not as \u0060RegexParseException\u0060.\r\n* This also means that \u0060Error\u0060 and \u0060Offset\u0060 are lost when crossing framework boundaries. Hence, we should also improve the message.\r\n* We don\u0027t want to have a separate public type from the internal one, but we should make sure that all enum members are actually used by the implementation/are reachable. If there are unused values, we should remove them.\r\n* We should probably preserve the current ordering, if only to discourage the urge to make future additions alphabetically sorted.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    [Serializable]\r\n    public sealed class RegexParseException : ArgumentException\r\n    {\r\n        public RegexParseException(RegexParseError error, int offset);\r\n        private RegexParseException(SerializationInfo info, StreamingContext context)\r\n        {\r\n            // It means someone modified the payload.\r\n            throw new NotImplementedException();\r\n        }\r\n        public override void GetObjectData(SerializationInfo info, StreamingContext context)\r\n        {\r\n            // We\u0027ll serialize as an instance of ArgumentException\r\n        }\r\n        public RegexParseError Error { get; }\r\n        public int Offset { get; }\r\n    }\r\n    public enum RegexParseError\r\n    {\r\n        Unknown,\r\n        AlternationHasComment,\r\n        AlternationHasMalformedCondition,\r\n        AlternationHasMalformedReference,\r\n        AlternationHasNamedCapture,\r\n        AlternationHasTooManyConditions,\r\n        AlternationHasUndefinedReference,\r\n        CaptureGroupNameInvalid,\r\n        CaptureGroupOfZero,\r\n        ExclusionGroupNotLast,\r\n        InsufficientClosingParentheses,\r\n        InsufficientOpeningParentheses,\r\n        InsufficientOrInvalidHexDigits,\r\n        InvalidGroupingConstruct,\r\n        InvalidUnicodePropertyEscape,\r\n        MalformedNamedReference,\r\n        MalformedUnicodePropertyEscape,\r\n        MissingControlCharacter,\r\n        NestedQuantifiersNotParenthesized,\r\n        QuantifierAfterNothing,\r\n        QuantifierOrCaptureGroupOutOfRange,\r\n        ReversedCharacterRange,\r\n        ReversedQuantifierRange,\r\n        ShorthandClassInCharacterRange,\r\n        UndefinedNamedReference,\r\n        UndefinedNumberedReference,\r\n        UnescapedEndingBackslash,\r\n        UnrecognizedControlCharacter,\r\n        UnrecognizedEscape,\r\n        UnrecognizedUnicodeProperty,\r\n        UnterminatedBracket,\r\n        UnterminatedComment\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21890000000,
        "Apis": [
          "F:RegexParseError.AlternationHasComment",
          "F:RegexParseError.AlternationHasMalformedCondition",
          "F:RegexParseError.AlternationHasMalformedReference",
          "F:RegexParseError.AlternationHasNamedCapture",
          "F:RegexParseError.AlternationHasTooManyConditions",
          "F:RegexParseError.AlternationHasUndefinedReference",
          "F:RegexParseError.CaptureGroupNameInvalid",
          "F:RegexParseError.CaptureGroupOfZero",
          "F:RegexParseError.ExclusionGroupNotLast",
          "F:RegexParseError.InsufficientClosingParentheses",
          "F:RegexParseError.InsufficientOpeningParentheses",
          "F:RegexParseError.InsufficientOrInvalidHexDigits",
          "F:RegexParseError.InvalidGroupingConstruct",
          "F:RegexParseError.InvalidUnicodePropertyEscape",
          "F:RegexParseError.MalformedNamedReference",
          "F:RegexParseError.MalformedUnicodePropertyEscape",
          "F:RegexParseError.MissingControlCharacter",
          "F:RegexParseError.NestedQuantifiersNotParenthesized",
          "F:RegexParseError.QuantifierAfterNothing",
          "F:RegexParseError.QuantifierOrCaptureGroupOutOfRange",
          "F:RegexParseError.ReversedCharacterRange",
          "F:RegexParseError.ReversedQuantifierRange",
          "F:RegexParseError.ShorthandClassInCharacterRange",
          "F:RegexParseError.UndefinedNamedReference",
          "F:RegexParseError.UndefinedNumberedReference",
          "F:RegexParseError.UnescapedEndingBackslash",
          "F:RegexParseError.Unknown",
          "F:RegexParseError.UnrecognizedControlCharacter",
          "F:RegexParseError.UnrecognizedEscape",
          "F:RegexParseError.UnrecognizedUnicodeProperty",
          "F:RegexParseError.UnterminatedBracket",
          "F:RegexParseError.UnterminatedComment",
          "M:RegexParseException.GetObjectData(SerializationInfo,StreamingContext)",
          "M:RegexParseException.RegexParseException(RegexParseError,int)",
          "M:RegexParseException.RegexParseException(SerializationInfo,StreamingContext)",
          "P:RegexParseException.Error",
          "P:RegexParseException.Offset",
          "T:RegexParseError",
          "T:RegexParseException"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "mM3_EF-E5H8",
      "StartDateTime": "2020-08-18T11:12:52-07:00",
      "EndDateTime": "2020-08-18T12:17:36-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/mM3_EF-E5H8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40978,
          "Title": "add GetRequiredSection on Configuration (raise exception if missing section) ",
          "Author": "michelcedric",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-18T10:50:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40978",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-18T00:00:00-07:00",
        "FeedbackId": "675639726",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40978#issuecomment-675639726",
        "FeedbackMarkdown": "* We should make this an extension method, yes, it would make more sense on \u0060IConfiguration\u0060, but that\u0027s not a strong reason enough to perform an API breaking change.\r\n* The \u0060InvalidOperationException\u0060 seems like a good choice\r\n* The implementation should probably use the \u0060ConfigurationExtensions.Exists()\u0060 instead of using a custom check\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public partial class ConfigurationExtensions\r\n    {\r\n        public static IConfigurationSection GetRequiredSection(this IConfiguration configuration, string key);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ConfigurationExtensions.GetRequiredSection(this IConfiguration,string)",
          "T:ConfigurationExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40862,
          "Title": "get full path of current process executable",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-14T21:55:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40862",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-18T00:00:00-07:00",
        "FeedbackId": "675664341",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40862#issuecomment-675664341",
        "FeedbackMarkdown": "* Similar to \u0060ApplicationProcessPath\u0060 they should probably all be marked nullable\r\n    - We decided to make \u0060AppContext\u0060 non-nullable and return an empty string, but we could normalize that here.\r\n* We considered putting the APIs on \u0060AppContext\u0060 but we don\u0027t believe that\u0027s a type people should be looking it because it\u0027s the platform\u0027s quirking mechanism\r\n* \u0060AppEntryPointPath\u0060 returns a non-existing path for single file which makes it ill-defined (see: https://github.com/dotnet/runtime/issues/40874)\r\n    - The API would be useful if it could be passed to the assembly load APIs, which doesn\u0027t seem to work\r\n    - The only other scenario would getting the \u0060FileVersionInfo\u0060 off of the application\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Environment\r\n    {\r\n        // Returns the path to the file that launched the process. For framework dependent apps\r\n        // this will return the path to dotnet.exe. For environment where this concept doesn\u0027t\r\n        // exist, for example WebAssembly, the method will return null. \r\n        public string? AppProcessPath =\u003E Process.GetCurrentProcess().MainModule.FileName;\r\n\r\n        // Returns the path to the file that contains the \u0060Main\u0060 method.\r\n        // Excluded. See comment above.\r\n        // public string? AppEntryPointPath =\u003E GetCommandLineArgs()[0];\r\n\r\n        // Returns the directory path of your application. Same as AppContext.BaseDirectory.\r\n        public string? AppBaseDirectory =\u003E AppContext.BaseDirectory;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6810000000,
        "Apis": [
          "P:Environment.AppBaseDirectory",
          "P:Environment.AppProcessPath",
          "T:Environment"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "j8HB7GczxNQ",
      "StartDateTime": "2020-08-25T10:06:12-07:00",
      "EndDateTime": "2020-08-25T12:02:28-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/j8HB7GczxNQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41110,
          "Title": "Add ConnectionId to ConnectionBase",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-20T20:06:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41110",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680176004",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41110#issuecomment-680176004",
        "FeedbackMarkdown": "* The connection id shouldn\u0027t change. Some protocols, such as QUIC, have changing ids but the connection id of \u0060ConnectionBase\u0060 won\u0027t be using that. Otherwise, it\u0027s impossible for users to track instances over time, which is the goal for this property.\r\n* To guarantee this, we should the template method pattern where the property is non-virtual and it calls a virtual method to lazily initialize itself.\r\n* The base implementation will use an auto generated GUID or a monotonically increasing integer\r\n* We should allow passing the connection ID to \u0060FromPipe\u0060 and \u0060FromStream\u0060 \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Connections\r\n{\r\n    public partial class ConnectionBase\r\n    {\r\n        public string ConnectionId { get; }\r\n        protected virtual string CreateConnectionId();\r\n    }\r\n    public partial class Connection\r\n    {\r\n        // Existing method, add connectionId\r\n        public static Connection FromPipe(\r\n            IDuplexPipe pipe,\r\n            bool leaveOpen = false,\r\n            IConnectionProperties? properties = null,\r\n            EndPoint? localEndPoint = null,\r\n            EndPoint? remoteEndPoint = null,\r\n            string? connectionId = null);\r\n\r\n\r\n        // Existing method, add connectionId\r\n        public static Connection FromStream(\r\n            Stream stream,\r\n            bool leaveOpen = false,\r\n            IConnectionProperties? properties = null,\r\n            EndPoint? localEndPoint = null,\r\n            EndPoint? remoteEndPoint = null,\r\n            string? connectionId = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Connection.FromPipe(IDuplexPipe,bool,IConnectionProperties?,EndPoint?,EndPoint?,string?)",
          "M:Connection.FromStream(Stream,bool,IConnectionProperties?,EndPoint?,EndPoint?,string?)",
          "M:ConnectionBase.CreateConnectionId()",
          "P:ConnectionBase.ConnectionId",
          "T:Connection",
          "T:ConnectionBase"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40862,
          "Title": "get full path of current process executable",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-14T21:55:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40862",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680189514",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40862#issuecomment-680189514",
        "FeedbackMarkdown": "* Let\u0027s separate the issue of loading content files (#41341) the path of the OS process.\r\n* This looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Environment\r\n    {\r\n        public static string? ProcessPath { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25080000000,
        "Apis": [
          "P:Environment.ProcessPath",
          "T:Environment"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35991,
          "Title": "BackgroundService TaskStatus",
          "Author": "grahamehorner",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-17T20:36:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35991",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Hosting",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680203238",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35991#issuecomment-680203238",
        "FeedbackMarkdown": "* Should be a property ;-)\r\n* Let\u0027s rename it to \u0060ExecuteTask\u0060 to make it clear that\u0027s the task returned by \u0060ExecuteAsync\u0060 rather than being some transient task.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Hosting\r\n{\r\n    public abstract class BackgroundService\r\n    {\r\n        public virtual Task ExecuteTask { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41220000000,
        "Apis": [
          "P:BackgroundService.ExecuteTask",
          "T:BackgroundService"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40936,
          "Title": "Make char.IsAscii public",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-17T15:11:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40936",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680205179",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40936#issuecomment-680205179",
        "FeedbackMarkdown": "* Looks reasonable\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public readonly struct Char\r\n    {\r\n        public static bool IsAscii(char ch);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 56840000000,
        "Apis": [
          "M:Char.IsAscii(char)",
          "T:Char"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41188,
          "Title": "Add Environment.Is32BitProcess",
          "Author": "elachlan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-21T22:28:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41188",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680208361",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41188#issuecomment-680208361",
        "FeedbackMarkdown": "* We already have \u0060Is64BitProcess\u0060 and \u0060Is64BitOperatingSystem\u0060. Given that we\u0027re extremely unlikely to support either 16bit or 128bit, how would this be different from negating those properties?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Environment\r\n    {\r\n        public static bool Is32BitProcess  { get; }\r\n        // public static bool Is32BitOperatingSystem { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59800000000,
        "Apis": [
          "P:Environment.Is32BitProcess",
          "T:Environment"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41304,
          "Title": "Allow ConnectionListener.AcceptAsync() to return null",
          "Author": "halter73",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-25T00:20:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41304",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-08-25T00:00:00-07:00",
        "FeedbackId": "680213099",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41304#issuecomment-680213099",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Connections\r\n{\r\n    public partial class ConnectionListener\r\n    {\r\n        public abstract ValueTask\u003CConnection?\u003E AcceptAsync(\r\n            IConnectionProperties? options = null,\r\n            CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 63790000000,
        "Apis": [
          "M:ConnectionListener.AcceptAsync(IConnectionProperties?,CancellationToken)",
          "T:ConnectionListener"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1p9HLT6O7G8",
      "StartDateTime": "2020-09-01T10:04:24-07:00",
      "EndDateTime": "2020-09-01T11:59:05-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1p9HLT6O7G8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41686,
          "Title": "Add System.BinaryData",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-01T17:26:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41686",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-01T00:00:00-07:00",
        "FeedbackId": "685061045",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41686#issuecomment-685061045",
        "FeedbackMarkdown": "* The type is very opinionated in order to achieve usability:\r\n    - Serialization is done with \u0060System.Text.Json\u0060, with specific options\r\n    - String encoding is always UTF8\r\n* We\u0027re concerned with hard coding the type to \u0060System.Text.Json\u0060, but we acknowledge that defaults are very valuable. If we need to support other serializers, then we can add an enum\r\n    - We could decide to make the constructor that performs JSON serialization as a factory method. Combined with a hypothetical feature \u0060extension statics\u0060 we could make the type more low level than serialization\r\n    - An alternative design is to replace constructors and factories with instance members (\u0060SetBytes\u0060, \u0060SetObject\u0060) which will throw when the underlying array is non-null. That prevents mutation and uses a simple pattern \u0060var x = new BinaryData(); x.SetBytes(...);\u0060. And on top, we can use regular extension methods to split out JSON serialization.\r\n* This type can\u0027t live in \u0060corlib\u0060 because it would depend on \u0060System.Text.Json\u0060 (and whatever future serializers it needs to support). Hence, most areas in the BCL wouldn\u0027t be able to take \u0060BinaryData\u0060, but technologies above the BCL could (\u0060Microsoft.Extensions\u0060, ASP.NET Core, Azure SDK etc)\r\n* Thus, we shouldn\u0027t think of this as an exchange type in the BCL. We already have exchange types; the point of this type is unify them by providing conversions; the point isn\u0027t to provide yet another type. Thus, we don\u0027t see the need to, for example, provide new virtual methods on \u0060Stream\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public readonly struct BinaryData\r\n    {\r\n        public BinaryData(ReadOnlySpan\u003Cbyte\u003E data);\r\n        public BinaryData(byte[] data);\r\n        public BinaryData(object jsonSerializable, Type? type = null);\r\n        public BinaryData(ReadOnlyMemory\u003Cbyte\u003E data);\r\n        public BinaryData(string data);\r\n        public static BinaryData FromBytes(ReadOnlyMemory\u003Cbyte\u003E data);\r\n        public static BinaryData FromBytes(ReadOnlySpan\u003Cbyte\u003E data);\r\n        public static BinaryData FromBytes(byte[] data);\r\n        public static BinaryData FromObject\u003CT\u003E(T jsonSerializable, CancellationToken cancellationToken = default);\r\n        public static Task\u003CBinaryData\u003E FromObjectAsync\u003CT\u003E(T jsonSerializable, CancellationToken cancellationToken = default);\r\n        public static BinaryData FromStream(Stream stream);\r\n        public static Task\u003CBinaryData\u003E FromStreamAsync(Stream stream, CancellationToken cancellationToken = default);\r\n        public static BinaryData FromString(string data);\r\n        public static implicit operator ReadOnlyMemory\u003Cbyte\u003E(BinaryData data);\r\n        public ReadOnlyMemory\u003Cbyte\u003E ToBytes();\r\n        public T ToObject\u003CT\u003E(CancellationToken cancellationToken = default);\r\n        public ValueTask\u003CT\u003E ToObjectAsync\u003CT\u003E(CancellationToken cancellationToken = default);\r\n        public Stream ToStream();\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public override bool Equals(object? obj);\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BinaryData.BinaryData(byte[])",
          "M:BinaryData.BinaryData(object,Type?)",
          "M:BinaryData.BinaryData(ReadOnlyMemory\u003Cbyte\u003E)",
          "M:BinaryData.BinaryData(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryData.BinaryData(string)",
          "M:BinaryData.Equals(object?)",
          "M:BinaryData.FromBytes(byte[])",
          "M:BinaryData.FromBytes(ReadOnlyMemory\u003Cbyte\u003E)",
          "M:BinaryData.FromBytes(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BinaryData.FromObject\u003CT\u003E(T,CancellationToken)",
          "M:BinaryData.FromObjectAsync\u003CT\u003E(T,CancellationToken)",
          "M:BinaryData.FromStream(Stream)",
          "M:BinaryData.FromStreamAsync(Stream,CancellationToken)",
          "M:BinaryData.FromString(string)",
          "M:BinaryData.GetHashCode()",
          "M:BinaryData.implicit(BinaryData)",
          "M:BinaryData.ToBytes()",
          "M:BinaryData.ToObject\u003CT\u003E(CancellationToken)",
          "M:BinaryData.ToObjectAsync\u003CT\u003E(CancellationToken)",
          "M:BinaryData.ToStream()",
          "M:BinaryData.ToString()",
          "T:BinaryData"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41318,
          "Title": "Consider adding more Half methods to BitConverter",
          "Author": "huoyaoyuan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-25T10:40:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41318",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-01T00:00:00-07:00",
        "FeedbackId": "685063700",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41318#issuecomment-685063700",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public class BitConverter\r\n    {\r\n        public static Half ToHalf(byte[] value, int startIndex);\r\n        public static Half ToHalf(ReadOnlySpan\u003Cbyte\u003E value);\r\n        public static byte[] GetBytes(Half value);\r\n        public static bool TryWriteBytes(Span\u003Cbyte\u003E destination, Half value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58160000000,
        "Apis": [
          "M:BitConverter.GetBytes(Half)",
          "M:BitConverter.ToHalf(byte[],int)",
          "M:BitConverter.ToHalf(ReadOnlySpan\u003Cbyte\u003E)",
          "M:BitConverter.TryWriteBytes(Span\u003Cbyte\u003E,Half)",
          "T:BitConverter"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "SyCQa-125uQ",
      "StartDateTime": "2020-09-08T10:26:21-07:00",
      "EndDateTime": "2020-09-08T13:36:24-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/SyCQa-125uQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41949,
          "Title": "Add SocketsHttpHandler.ConnectCallback",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-07T22:50:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41949",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking-release",
              "Color": "b60205",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-08T00:00:00-07:00",
        "FeedbackId": "689032184",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41949#issuecomment-689032184",
        "FeedbackMarkdown": "* We should add a context class that passes in the parameters so that we can add more values over time\r\n* We originally had \u0060SocketsHttpConnectionContext\u0060 as get/set POCO but that would mean that all properties would have to be nullable, which would be super annoying to use\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public sealed class SocketsHttpConnectionContext\r\n    {\r\n        public DnsEndPoint DnsEndPoint { get; }\r\n        public HttpRequestMessage RequestMessage { get; }\r\n    }\r\n    public sealed class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public Func\u003CSocketsHttpConnectionContext, CancellationToken, ValueTask\u003CStream\u003E\u003E? ConnectCallback { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpConnectionContext.DnsEndPoint",
          "P:SocketsHttpConnectionContext.RequestMessage",
          "P:SocketsHttpHandler.ConnectCallback",
          "T:SocketsHttpConnectionContext",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41925,
          "Title": "Mark System.Threading.Thread ResetAbort as Obsolete",
          "Author": "mdh1418",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-07T00:53:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41925",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-08T00:00:00-07:00",
        "FeedbackId": "689040775",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41925#issuecomment-689040775",
        "FeedbackMarkdown": "* We believe it makes sense to reuse the existing diagnostic ID\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public sealed class Thread\r\n    {\r\n        // Obsoleted in .NET 5:\r\n        //[Obsolete(DiagnosticId = \u0022SYSLIB0006\u0022)]\r\n        //public void Abort();\r\n        //[Obsolete(DiagnosticId = \u0022SYSLIB0006\u0022)]\r\n        //public void Abort(object stateInfo);\r\n        [Obsolete(DiagnosticId = \u0022SYSLIB0006\u0022)]\r\n        public static void ResetAbort();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7780000000,
        "Apis": [
          "M:Thread.ResetAbort()",
          "T:Thread"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "LpXyfXS8p70",
      "StartDateTime": "2020-09-15T11:03:01-07:00",
      "EndDateTime": "2020-09-15T11:46:46-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/LpXyfXS8p70/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42154,
          "Title": "System.Net.Http.HttpRequestException is not marked as [Serializable]",
          "Author": "magole",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-12T01:06:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42154",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-15T00:00:00-07:00",
        "FeedbackId": "692890590",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42154#issuecomment-692890590",
        "FeedbackMarkdown": "* Seems fine per our guidance\r\n* We won\u0027t do this for all exception, but only for exceptions that exist in both .NET Framework and .NET Core\r\n* Specifically, we won\u0027t do this for .NET Core-only exceptions\r\n* And moving forward, we\u0027ll phase out \u0060BinaryFormatter\u0060 anyways\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    [Serializable]\r\n    public class HttpRequestException\r\n    {\r\n        protected HttpRequestException(SerializationInfo info, StreamingContext context);\r\n        public override void GetObjectData(SerializationInfo info, StreamingContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HttpRequestException.GetObjectData(SerializationInfo,StreamingContext)",
          "M:HttpRequestException.HttpRequestException(SerializationInfo,StreamingContext)",
          "T:HttpRequestException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 3710,
          "Title": "Add safe overloads to TextRenderer to get output strings.",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-10T02:36:05+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/3710",
          "Milestone": ".NET 7.0",
          "Labels": [
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-15T00:00:00-07:00",
        "FeedbackId": "692900947",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/3710#issuecomment-692900947",
        "FeedbackMarkdown": "* Normally, output buffers go right after the input buffer, but we\u0027ll keep it last here to align with existing overloads and (more importantly) the \u0060out\u0060 string\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public sealed class TextRenderer\r\n    {\r\n        // Existing flags APIs:\r\n        // public static void DrawText(IDeviceContext dc, string text, Font font, Point pt, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, string text, Font font, Point pt, Color foreColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, string text, Font font, Rectangle bounds, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, string text, Font font, Rectangle bounds, Color foreColor, TextFormatFlags flags);\r\n        // public static Size MeasureText(IDeviceContext dc, string text, Font font, Size proposedSize, TextFormatFlags flags);\r\n        // public static Size MeasureText(string text, Font font, Size proposedSize, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, Color backColor, TextFormatFlags flags);\r\n        // public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, TextFormatFlags flags);\r\n        // public static Size MeasureText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags);\r\n        // public static Size MeasureText(ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags);\r\n\r\n        public static void DrawText(IDeviceContext dc, string text, Font font, Point pt, Color foreColor, Color backColor, TextFormatFlags flags, out string outputText);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Point pt, Color foreColor, Color backColor, TextFormatFlags flags, Span\u003Cchar\u003E outputTextBuffer, out int outputTextLength);\r\n        public static void DrawText(IDeviceContext dc, string text, Font font, Rectangle bounds, Color foreColor, Color backColor, TextFormatFlags flags, out string outputText);\r\n        public static void DrawText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Rectangle bounds, Color foreColor, Color backColor, TextFormatFlags flags, Span\u003Cchar\u003E outputTextBuffer, out int outputTextLength);\r\n        public static Size MeasureText(IDeviceContext dc, string text, Font font, Size proposedSize, TextFormatFlags flags, out string outputText);\r\n        public static Size MeasureText(IDeviceContext dc, ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags, Span\u003Cchar\u003E outputTextBuffer, out int outputTextLength);\r\n        public static Size MeasureText(string text, Font font, Size proposedSize, TextFormatFlags flags, out string outputText);\r\n        public static Size MeasureText(ReadOnlySpan\u003Cchar\u003E text, Font font, Size proposedSize, TextFormatFlags flags, Span\u003Cchar\u003E outputTextBuffer, out int outputTextLength);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10590000000,
        "Apis": [
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Point,Color,Color,TextFormatFlags,Span\u003Cchar\u003E,out int)",
          "M:TextRenderer.DrawText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Rectangle,Color,Color,TextFormatFlags,Span\u003Cchar\u003E,out int)",
          "M:TextRenderer.DrawText(IDeviceContext,string,Font,Point,Color,Color,TextFormatFlags,out string)",
          "M:TextRenderer.DrawText(IDeviceContext,string,Font,Rectangle,Color,Color,TextFormatFlags,out string)",
          "M:TextRenderer.MeasureText(IDeviceContext,ReadOnlySpan\u003Cchar\u003E,Font,Size,TextFormatFlags,Span\u003Cchar\u003E,out int)",
          "M:TextRenderer.MeasureText(IDeviceContext,string,Font,Size,TextFormatFlags,out string)",
          "M:TextRenderer.MeasureText(ReadOnlySpan\u003Cchar\u003E,Font,Size,TextFormatFlags,Span\u003Cchar\u003E,out int)",
          "M:TextRenderer.MeasureText(string,Font,Size,TextFormatFlags,out string)",
          "T:TextRenderer"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Kk9Fv8m0Ksw",
      "StartDateTime": "2020-09-22T11:09:21-07:00",
      "EndDateTime": "2020-09-22T11:51:15-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Kk9Fv8m0Ksw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42275,
          "Title": "Allow ignoring unhandled exceptions in UnhandledException event handler",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-15T20:40:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42275",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-22T00:00:00-07:00",
        "FeedbackId": "696895538",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42275#issuecomment-696895538",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class UnhandledExceptionEventArgs : EventArgs\r\n    {\r\n        // Existing property.\r\n        // public bool IsTerminating { get; }\r\n        \r\n        public bool Ignore { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:UnhandledExceptionEventArgs.Ignore",
          "T:UnhandledExceptionEventArgs"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42557,
          "Title": "Add SocketsHttpHandler.PlaintextStreamFilter",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-21T22:03:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42557",
          "Milestone": "5.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-22T00:00:00-07:00",
        "FeedbackId": "696907531",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42557#issuecomment-696907531",
        "FeedbackMarkdown": "* Looks good as proposed, modulo:\r\n* \u0060HttpVersion\u0060 we should consider a term that conveys that it\u0027s the version after policy, such as \u0060NegotiatedHttpVersion\u0060\r\n* \u0060RequestMessage\u0060 should convey that this is the initial message only, such as \u0060InitialRequestMessage\u0060, because the callback is called once per connection, not per request. We should also rename the property on \u0060SocketsHttpConnectionContext\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public sealed class SocketsHttpPlaintextStreamFilterContext\r\n    {\r\n        public Stream PlaintextStream { get; }\r\n        public Version NegotiatedHttpVersion { get; }\r\n        public HttpRequestMessage InitialRequestMessage { get; }\r\n    }\r\n    public sealed class SocketsHttpHandler : HttpMessageHandler\r\n    {\r\n        public Func\u003CSocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask\u003CStream\u003E\u003E? PlaintextStreamFilter { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 5850000000,
        "Apis": [
          "P:SocketsHttpHandler.PlaintextStreamFilter",
          "P:SocketsHttpPlaintextStreamFilterContext.InitialRequestMessage",
          "P:SocketsHttpPlaintextStreamFilterContext.NegotiatedHttpVersion",
          "P:SocketsHttpPlaintextStreamFilterContext.PlaintextStream",
          "T:SocketsHttpHandler",
          "T:SocketsHttpPlaintextStreamFilterContext"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42591,
          "Title": "Add Task-based async API for Socket.SendFile",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-22T17:20:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42591",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-22T00:00:00-07:00",
        "FeedbackId": "696912247",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42591#issuecomment-696912247",
        "FeedbackMarkdown": "* Makes sense, but we should take a cancellation tokena and memories\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        // Existing APM APIs\r\n        // public IAsyncResult BeginSendFile(string fileName, AsyncCallback? callback, object? state);\r\n        // public IAsyncResult BeginSendFile(string? fileName, byte[]? preBuffer, byte[]? postBuffer, TransmitFileOptions flags, AsyncCallback? callback, object? state);\r\n        public ValueTask SendFileAsync(string? fileName, CancellationToken cancellationToken = default);\r\n        public ValueTask SendFileAsync(string? fileName, ReadOnlyMemory\u003Cbyte\u003E preBuffer, ReadOnlyMemory\u003Cbyte\u003E postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19310000000,
        "Apis": [
          "M:Socket.SendFileAsync(string?,CancellationToken)",
          "M:Socket.SendFileAsync(string?,ReadOnlyMemory\u003Cbyte\u003E,ReadOnlyMemory\u003Cbyte\u003E,TransmitFileOptions,CancellationToken)",
          "T:Socket"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "aj5-itpOyvo",
      "StartDateTime": "2020-09-29T10:04:10-07:00",
      "EndDateTime": "2020-09-29T12:04:35-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/aj5-itpOyvo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "deployment-tools",
          "Id": 35,
          "Title": "Productize DOM APIs for release.json",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-28T21:39:56+00:00",
          "Url": "https://github.com/dotnet/deployment-tools/issues/35",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-09-29T00:00:00-07:00",
        "FeedbackId": "700917853",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/deployment-tools/issues/35#issuecomment-700917853",
        "FeedbackMarkdown": "* Provides a public API for the release.json\r\n* Distributed as a NuGet package\r\n* Depends on \u0060Newtonsoft.Json\u0060\r\n* Is \u0060Microsoft.Deployment.Releases\u0060 the right namespace? Should we fit into the other namespaces used by the SDK tooling, which AFAIK is in in \u0060Microsoft.DotNet\u0060.\r\n* Currently Windows-only (because it targets .NET Framework) but it can be fully cross-platform\r\n* General notes:\r\n    - Instead of exposing \u0060IEnumerable\u003CT\u003E\u0060 use collection types \u0060Collection\u003CT\u003E\u0060 and \u0060ReadOnlyCollection\u003CT\u003E\u0060 because they avoid leaking the underlying instance that holds the data. It also allows you to derive from to add custom indexers/methods.\r\n    - Using \u0060DateTime\u0060 over \u0060DateTimeOffset\u0060 for data that has no time component is correct\r\n* \u0060ReleaseIndex\u0060\r\n    - It\u0027s a subset of \u0060ReleaseChannel\u0060. It would be better if these types would be merged and the additional data is lazily loaded. For example \u0060Product\u0060 would represent the data that is in the root JSON file and \u0060ProductDetails\u0060 would contain the entirety of the product that comes from another JSON file. They key is to let the user initiate each separate IO request. Should also return data async.\r\n* \u0060ProductVersion\u0060\r\n    - \u0060ReleaseVersion\u0060\r\n* \u0060ReleaseChannel\u0060\r\n    - \u0060ReleaseChannel\u0060 should be named \u0060Product\u0060\r\n    - \u0060SupportPhase\u0060 should be an enum\r\n    - It\u0027s weird to have \u0060LatestRelease\u0060 and \u0060GetLatestRelease()\u0060. Either get rid of the method and make the property return \u0060Release\u0060 or remove the properties.\r\n    - Having a nullable \u0060LatestReleaseDate\u0060 is odd\r\n    - Shouldn\u0027t have public constructor\r\n* \u0060Release\u0060\r\n    - \u0060Runtimes\u0060 should be \u0060Components\u0060\r\n    - Having both \u0060Sdk\u0060 and \u0060Sdks\u0060 is odd. We should only expose \u0060Sdks\u0060 because that\u0027s well defined\r\n    - \u0060AspNetCoreRuntime\u0060 should be \u0060AspNetCoreComponent\u0060\r\n    - \u0060WindowsDesktopRuntime\u0060 should be \u0060WindowsDesktopComponent\u0060\r\n* \u0060IRelease\u0060\r\n    - It\u0027s odd to have a type called \u0060Release\u0060 but not implementing \u0060IRelease\u0060\r\n    - Also, we should try to avoid interfaces and use abstract base types\r\n    - Should be named \u0060ReleaseComponent\u0060 and an abstract class\r\n* \u0060SdkRelease\u0060\r\n    - Should be named \u0060SdkReleaseComponent\u0060\r\n* \u0060RuntimeRelease\u0060\r\n    - Should be named \u0060RuntimeReleaseComponent\u0060\r\n* \u0060 AspNetCoreRuntimeRelease\u0060\r\n    - Should be named \u0060 AspNetCoreReleaseComponent\u0060\r\n* \u0060 WindowsDesktopRelease\u0060\r\n    - Should be named \u0060 WindowsDesktopReleaseComponent\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Deployment.Releases {\r\n    public interface IRelease {\r\n        IEnumerable\u003CReleaseFile\u003E Files { get; set; }\r\n        string Name { get; }\r\n        ReleaseFlags ReleaseKind { get; }\r\n        ProductVersion Version { get; set; }\r\n    }\r\n    public class AspNetCoreRuntimeRelease : IRelease {\r\n        public AspNetCoreRuntimeRelease();\r\n        public string[] AspNetCoreModuleVersions { get; set; }\r\n        public string DisplayVersion { get; set; }\r\n        public IEnumerable\u003CReleaseFile\u003E Files { get; set; }\r\n        public string Name { get; }\r\n        public ProductVersion Version { get; set; }\r\n        public string VisualStudioVersion { get; set; }\r\n    }\r\n    public class Cve {\r\n        public Cve();\r\n        public string Id { get; set; }\r\n        public Uri Url { get; set; }\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n    }\r\n    public class ProductVersion : IComparable, IComparable\u003CProductVersion\u003E, IEquatable\u003CProductVersion\u003E, ICloneable {\r\n        public ProductVersion(string version);\r\n        public ProductVersion();\r\n        public static readonly string Version2Pattern;\r\n        public string BuildMetadata { get; set; }\r\n        public int Major { get; set; }\r\n        public int Minor { get; set; }\r\n        public int Patch { get; set; }\r\n        public string Prerelease { get; set; }\r\n        public int SdkFeatureBand { get; }\r\n        public int SdkPatchLevel { get; }\r\n        public static int Compare(ProductVersion a, ProductVersion b);\r\n        public static bool Equals(ProductVersion a, ProductVersion b);\r\n        public static bool operator ==(ProductVersion v1, ProductVersion v2);\r\n        public static bool operator \u003E(ProductVersion v1, ProductVersion v2);\r\n        public static bool operator \u003E=(ProductVersion v1, ProductVersion v2);\r\n        public static bool operator !=(ProductVersion v1, ProductVersion v2);\r\n        public static bool operator \u003C(ProductVersion v1, ProductVersion v2);\r\n        public static bool operator \u003C=(ProductVersion v1, ProductVersion v2);\r\n        public object Clone();\r\n        public int ComparePrecedence(ProductVersion value);\r\n        public int CompareTo(object value);\r\n        public int CompareTo(ProductVersion value);\r\n        public bool Equals(ProductVersion obj);\r\n        public bool PrecedenceEquals(ProductVersion value);\r\n        public string ToString(int fieldCount);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public class ProductVersionConverter : JsonConverter\u003CProductVersion\u003E {\r\n        public ProductVersionConverter();\r\n        public override ProductVersion ReadJson(JsonReader reader, Type objectType, ProductVersion existingValue, bool hasExistingValue, JsonSerializer serializer);\r\n        public override void WriteJson(JsonWriter writer, ProductVersion value, JsonSerializer serializer);\r\n    }\r\n    public class Release {\r\n        public Release();\r\n        public AspNetCoreRuntimeRelease AspNetCoreRuntime { get; set; }\r\n        public IEnumerable\u003CCve\u003E Cves { get; set; }\r\n        public IEnumerable\u003CReleaseFile\u003E Files { get; }\r\n        public bool IsPreview { get; }\r\n        public bool IsSecurityUpdate { get; set; }\r\n        public DateTime ReleaseDate { get; set; }\r\n        public Uri ReleaseNotes { get; set; }\r\n        public ProductVersion ReleaseVersion { get; set; }\r\n        public RuntimeRelease Runtime { get; set; }\r\n        public IEnumerable\u003CIRelease\u003E Runtimes { get; }\r\n        public SdkRelease Sdk { get; set; }\r\n        public IEnumerable\u003CSdkRelease\u003E Sdks { get; set; }\r\n        public WindowsDesktopRelease WindowsDesktop { get; set; }\r\n    }\r\n    public class ReleaseChannel {\r\n        public ReleaseChannel();\r\n        public string ChannelVersion { get; set; }\r\n        public DateTime? EolDate { get; set; }\r\n        public bool IsOutOfSupport { get; }\r\n        public ProductVersion LatestRelease { get; set; }\r\n        public DateTime? LatestReleaseDate { get; set; }\r\n        public ProductVersion LatestRuntime { get; set; }\r\n        public ProductVersion LatestSdk { get; set; }\r\n        public Uri LifeCyclePolicyUrl { get; set; }\r\n        public IEnumerable\u003CRelease\u003E Releases { get; set; }\r\n        public SupportPhase SupportPhase { get; set; }\r\n        public Release GetLatestRelease();\r\n        public Release GetLatestRelease(bool isSecurityUpdate);\r\n    }\r\n    public class ReleaseFile {\r\n        public ReleaseFile();\r\n        public string FileName { get; }\r\n        public string Hash { get; }\r\n        public string Name { get; }\r\n        public string Rid { get; }\r\n        public Uri Url { get; }\r\n        public void Download(string fileName);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n    }\r\n    public class ReleaseIndex {\r\n        public ReleaseIndex();\r\n        public string ChannelVersion { get; set; }\r\n        public DateTime? EolDate { get; set; }\r\n        public bool IsOutOfSupport { get; }\r\n        public bool IsSecurity { get; set; }\r\n        public ProductVersion LatestRelease { get; set; }\r\n        public DateTime? LatestReleaseDate { get; set; }\r\n        public ProductVersion LatestRuntime { get; set; }\r\n        public ProductVersion LatestSdk { get; set; }\r\n        public string Product { get; set; }\r\n        public string ReleasesJson { get; set; }\r\n        public SupportPhase SupportPhase { get; set; }\r\n    }\r\n    public class Releases {\r\n        public Releases();\r\n        public static readonly Uri ReleasesIndexJsonUri;\r\n        public int ChannelCount { get; }\r\n        public IEnumerable\u003CReleaseChannel\u003E Channels { get; }\r\n        public IEnumerable\u003Cstring\u003E ChannelVersions { get; }\r\n        public IEnumerable\u003CReleaseIndex\u003E Index { get; set; }\r\n        public ReleaseChannel this[string channelVersion] { get; }\r\n        public static Releases CreateFromDefaultUrl();\r\n        public static Releases CreateFromFile(string releasesIndexPath);\r\n        public static Releases CreateFromFile(string releasesIndexPath, bool useLatest);\r\n        public static Releases CreateFromUrl(Uri uri);\r\n        public bool ContainsChannel(string channelVersion);\r\n        public Release GetRelease(ProductVersion releaseVersion);\r\n        public IEnumerable\u003CRelease\u003E GetReleases(string cveId);\r\n    }\r\n    public class ReleasesHelpers {\r\n        public ReleasesHelpers();\r\n        public static T Create\u003CT\u003E(Uri jsonUrl);\r\n        public static T CreateFromFile\u003CT\u003E(string path);\r\n    }\r\n    public class RuntimeRelease : IRelease {\r\n        public RuntimeRelease();\r\n        public ProductVersion DisplayVersion { get; set; }\r\n        public IEnumerable\u003CReleaseFile\u003E Files { get; set; }\r\n        public string Name { get; }\r\n        public ProductVersion Version { get; set; }\r\n        public string VisualStudioMacVersion { get; set; }\r\n        public string VisualStudioVersion { get; set; }\r\n    }\r\n    public class SdkRelease : IRelease {\r\n        public SdkRelease();\r\n        public string CSharpVersion { get; set; }\r\n        public ProductVersion DisplayVersion { get; set; }\r\n        public IEnumerable\u003CReleaseFile\u003E Files { get; set; }\r\n        public string FSharpVersion { get; set; }\r\n        public string Name { get; }\r\n        public ProductVersion RuntimeVersion { get; set; }\r\n        public ProductVersion Version { get; set; }\r\n        public string VisualStudioMacSupport { get; set; }\r\n        public string VisualStudioMacVersion { get; set; }\r\n        public string VisualStudioSupport { get; set; }\r\n        public string VisualStudioVersion { get; set; }\r\n    }\r\n    public class WindowsDesktopRelease : IRelease {\r\n        public WindowsDesktopRelease();\r\n        public string DisplayVersion { get; set; }\r\n        public IEnumerable\u003CReleaseFile\u003E Files { get; set; }\r\n        public string Name { get; }\r\n        public ProductVersion Version { get; set; }\r\n    }\r\n    [Flags]\r\n    public enum ReleaseFlags {\r\n        None = 0,\r\n        Sdk = 1,\r\n        Runtime = 2,\r\n        AspNetCoreRuntime = 4,\r\n        WindowsDesktopRuntime = 8,\r\n    }\r\n    public enum SupportPhase {\r\n        Undefined = 0,\r\n        [EnumMember]\r\n        EOL = 1,\r\n        [EnumMember]\r\n        LTS = 2,\r\n        [EnumMember]\r\n        Maintenance = 3,\r\n        [EnumMember]\r\n        Preview = 4,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ProductVersion.Version2Pattern",
          "F:ReleaseFlags.AspNetCoreRuntime",
          "F:ReleaseFlags.None",
          "F:ReleaseFlags.Runtime",
          "F:ReleaseFlags.Sdk",
          "F:ReleaseFlags.WindowsDesktopRuntime",
          "F:Releases.ReleasesIndexJsonUri",
          "F:SupportPhase.EOL",
          "F:SupportPhase.LTS",
          "F:SupportPhase.Maintenance",
          "F:SupportPhase.Preview",
          "F:SupportPhase.Undefined",
          "M:AspNetCoreRuntimeRelease.AspNetCoreRuntimeRelease()",
          "M:Cve.Cve()",
          "M:Cve.Equals(object)",
          "M:Cve.GetHashCode()",
          "M:ProductVersion.!=(ProductVersion,ProductVersion)",
          "M:ProductVersion.\u003C(ProductVersion,ProductVersion)",
          "M:ProductVersion.\u003C=(ProductVersion,ProductVersion)",
          "M:ProductVersion.==(ProductVersion,ProductVersion)",
          "M:ProductVersion.\u003E(ProductVersion,ProductVersion)",
          "M:ProductVersion.\u003E=(ProductVersion,ProductVersion)",
          "M:ProductVersion.Clone()",
          "M:ProductVersion.Compare(ProductVersion,ProductVersion)",
          "M:ProductVersion.ComparePrecedence(ProductVersion)",
          "M:ProductVersion.CompareTo(object)",
          "M:ProductVersion.CompareTo(ProductVersion)",
          "M:ProductVersion.Equals(object)",
          "M:ProductVersion.Equals(ProductVersion,ProductVersion)",
          "M:ProductVersion.Equals(ProductVersion)",
          "M:ProductVersion.GetHashCode()",
          "M:ProductVersion.PrecedenceEquals(ProductVersion)",
          "M:ProductVersion.ProductVersion()",
          "M:ProductVersion.ProductVersion(string)",
          "M:ProductVersion.ToString()",
          "M:ProductVersion.ToString(int)",
          "M:ProductVersionConverter.ProductVersionConverter()",
          "M:ProductVersionConverter.ReadJson(JsonReader,Type,ProductVersion,bool,JsonSerializer)",
          "M:ProductVersionConverter.WriteJson(JsonWriter,ProductVersion,JsonSerializer)",
          "M:Release.Release()",
          "M:ReleaseChannel.GetLatestRelease()",
          "M:ReleaseChannel.GetLatestRelease(bool)",
          "M:ReleaseChannel.ReleaseChannel()",
          "M:ReleaseFile.Download(string)",
          "M:ReleaseFile.Equals(object)",
          "M:ReleaseFile.GetHashCode()",
          "M:ReleaseFile.ReleaseFile()",
          "M:ReleaseIndex.ReleaseIndex()",
          "M:Releases.ContainsChannel(string)",
          "M:Releases.CreateFromDefaultUrl()",
          "M:Releases.CreateFromFile(string,bool)",
          "M:Releases.CreateFromFile(string)",
          "M:Releases.CreateFromUrl(Uri)",
          "M:Releases.GetRelease(ProductVersion)",
          "M:Releases.GetReleases(string)",
          "M:Releases.Releases()",
          "M:ReleasesHelpers.Create\u003CT\u003E(Uri)",
          "M:ReleasesHelpers.CreateFromFile\u003CT\u003E(string)",
          "M:ReleasesHelpers.ReleasesHelpers()",
          "M:RuntimeRelease.RuntimeRelease()",
          "M:SdkRelease.SdkRelease()",
          "M:WindowsDesktopRelease.WindowsDesktopRelease()",
          "P:AspNetCoreRuntimeRelease.AspNetCoreModuleVersions",
          "P:AspNetCoreRuntimeRelease.DisplayVersion",
          "P:AspNetCoreRuntimeRelease.Files",
          "P:AspNetCoreRuntimeRelease.Name",
          "P:AspNetCoreRuntimeRelease.Version",
          "P:AspNetCoreRuntimeRelease.VisualStudioVersion",
          "P:Cve.Id",
          "P:Cve.Url",
          "P:IRelease.Files",
          "P:IRelease.Name",
          "P:IRelease.ReleaseKind",
          "P:IRelease.Version",
          "P:ProductVersion.BuildMetadata",
          "P:ProductVersion.Major",
          "P:ProductVersion.Minor",
          "P:ProductVersion.Patch",
          "P:ProductVersion.Prerelease",
          "P:ProductVersion.SdkFeatureBand",
          "P:ProductVersion.SdkPatchLevel",
          "P:Release.AspNetCoreRuntime",
          "P:Release.Cves",
          "P:Release.Files",
          "P:Release.IsPreview",
          "P:Release.IsSecurityUpdate",
          "P:Release.ReleaseDate",
          "P:Release.ReleaseNotes",
          "P:Release.ReleaseVersion",
          "P:Release.Runtime",
          "P:Release.Runtimes",
          "P:Release.Sdk",
          "P:Release.Sdks",
          "P:Release.WindowsDesktop",
          "P:ReleaseChannel.ChannelVersion",
          "P:ReleaseChannel.EolDate",
          "P:ReleaseChannel.IsOutOfSupport",
          "P:ReleaseChannel.LatestRelease",
          "P:ReleaseChannel.LatestReleaseDate",
          "P:ReleaseChannel.LatestRuntime",
          "P:ReleaseChannel.LatestSdk",
          "P:ReleaseChannel.LifeCyclePolicyUrl",
          "P:ReleaseChannel.Releases",
          "P:ReleaseChannel.SupportPhase",
          "P:ReleaseFile.FileName",
          "P:ReleaseFile.Hash",
          "P:ReleaseFile.Name",
          "P:ReleaseFile.Rid",
          "P:ReleaseFile.Url",
          "P:ReleaseIndex.ChannelVersion",
          "P:ReleaseIndex.EolDate",
          "P:ReleaseIndex.IsOutOfSupport",
          "P:ReleaseIndex.IsSecurity",
          "P:ReleaseIndex.LatestRelease",
          "P:ReleaseIndex.LatestReleaseDate",
          "P:ReleaseIndex.LatestRuntime",
          "P:ReleaseIndex.LatestSdk",
          "P:ReleaseIndex.Product",
          "P:ReleaseIndex.ReleasesJson",
          "P:ReleaseIndex.SupportPhase",
          "P:Releases.ChannelCount",
          "P:Releases.Channels",
          "P:Releases.ChannelVersions",
          "P:Releases.Index",
          "P:Releases[string]",
          "P:RuntimeRelease.DisplayVersion",
          "P:RuntimeRelease.Files",
          "P:RuntimeRelease.Name",
          "P:RuntimeRelease.Version",
          "P:RuntimeRelease.VisualStudioMacVersion",
          "P:RuntimeRelease.VisualStudioVersion",
          "P:SdkRelease.CSharpVersion",
          "P:SdkRelease.DisplayVersion",
          "P:SdkRelease.Files",
          "P:SdkRelease.FSharpVersion",
          "P:SdkRelease.Name",
          "P:SdkRelease.RuntimeVersion",
          "P:SdkRelease.Version",
          "P:SdkRelease.VisualStudioMacSupport",
          "P:SdkRelease.VisualStudioMacVersion",
          "P:SdkRelease.VisualStudioSupport",
          "P:SdkRelease.VisualStudioVersion",
          "P:WindowsDesktopRelease.DisplayVersion",
          "P:WindowsDesktopRelease.Files",
          "P:WindowsDesktopRelease.Name",
          "P:WindowsDesktopRelease.Version",
          "T:AspNetCoreRuntimeRelease",
          "T:Cve",
          "T:IRelease",
          "T:ProductVersion",
          "T:ProductVersionConverter",
          "T:Release",
          "T:ReleaseChannel",
          "T:ReleaseFile",
          "T:ReleaseFlags",
          "T:ReleaseIndex",
          "T:Releases",
          "T:ReleasesHelpers",
          "T:RuntimeRelease",
          "T:SdkRelease",
          "T:SupportPhase",
          "T:WindowsDesktopRelease"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "5nMDURGNsQ0",
      "StartDateTime": "2020-10-06T09:58:44-07:00",
      "EndDateTime": "2020-10-06T11:59:31-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5nMDURGNsQ0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31366,
          "Title": "Max Array Length Property/Method",
          "Author": "mikernet",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-01T14:18:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31366",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704422839",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31366#issuecomment-704422839",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public class Array\r\n    {\r\n        public static int GetMaxLength\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Array.GetMaxLength\u003CT\u003E()",
          "T:Array"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40475,
          "Title": "Add overloads for CancellationToken.[Unsafe]Register that pass the CancellationToken to the registered function",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-06T17:13:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40475",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704427405",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40475#issuecomment-704427405",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We omitted the \u0060bool useSynchronizationContext\u0060 as we don\u0027t want to encourage its use. If needed, we can add it later. The behavior of these new methods is as if it was \u0060false\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public struct CancellationToken\r\n    {\r\n        public CancellationTokenRegistration Register(Action\u003Cobject?, CancellationToken\u003E callback, object? state);\r\n        public CancellationTokenRegistration UnsafeRegister(Action\u003Cobject?, CancellationToken\u003E callback, object? state);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8310000000,
        "Apis": [
          "M:CancellationToken.Register(Action\u003Cobject?, CancellationToken\u003E,object?)",
          "M:CancellationToken.UnsafeRegister(Action\u003Cobject?, CancellationToken\u003E,object?)",
          "T:CancellationToken"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42769,
          "Title": "RandomNumberGenerator.GetBytes(int)",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-26T02:18:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42769",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704433885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42769#issuecomment-704433885",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We decided we don\u0027t want an overload for \u0060GetNonZeroBytes()\u0060 because we don\u0027t like that API to begin with\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class RandomNumberGenerator\r\n    {\r\n        public static byte[] GetBytes(int byteCount);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13410000000,
        "Apis": [
          "M:RandomNumberGenerator.GetBytes(int)",
          "T:RandomNumberGenerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42906,
          "Title": "Add MicrosoftPlatformCryptoProvider to CngProvider",
          "Author": "DavidSimner",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-30T16:34:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42906",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704436463",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42906#issuecomment-704436463",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class CngProvider\r\n    {\r\n        public static CngProvider MicrosoftPlatformCryptoProvider { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20580000000,
        "Apis": [
          "P:CngProvider.MicrosoftPlatformCryptoProvider",
          "T:CngProvider"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42763,
          "Title": "Analyzer suggestion: flag calls to RandomNumberGenerator.GetNonZeroBytes",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-25T23:03:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42763",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704445834",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42763#issuecomment-704445834",
        "FeedbackMarkdown": "* A custom analyzer would effectively do the same as obsoleting it.\r\n* We should just obsolete it, asssuming we can add turn it off by default by putting the diagnostic ID in the SDK \u0060.editorconfig\u0060 root file. We should tie to the security rules\r\n* @GrabYourPitchforks, please follow up to figure out why people call this API. Some usage seems high and it\u0027s hard to imagine people are generating secrets.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public abstract class RandomNumberGenerator\r\n    {\r\n        public abstract void GetNonZeroBytes(byte[] data);\r\n        public abstract void GetNonZeroBytes(Span\u003Cbyte\u003E data);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23420000000,
        "Apis": [
          "M:RandomNumberGenerator.GetNonZeroBytes(byte[])",
          "M:RandomNumberGenerator.GetNonZeroBytes(Span\u003Cbyte\u003E)",
          "T:RandomNumberGenerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42706,
          "Title": "Add ability to update Activity.Baggage",
          "Author": "AndreyTretyak",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-24T21:58:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42706",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704451527",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42706#issuecomment-704451527",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Activity\r\n    {\r\n        public Activity SetBaggage(string key, string? value)\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33850000000,
        "Apis": [
          "M:Activity.SetBaggage(string,string?)",
          "T:Activity"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42710,
          "Title": "Port OpenExisting and TryOpenExisting methods for EventWaitHandle/Mutex/Semaphore from .NET Framework",
          "Author": "carlossanlop",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-24T23:12:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42710",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704454746",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42710#issuecomment-704454746",
        "FeedbackMarkdown": "* Looks good as proposed, follows the pattern\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public static partial class EventWaitHandleAcl\r\n    {\r\n        public static EventWaitHandle OpenExisting(string name, EventWaitHandleRights rights);\r\n        public static bool TryOpenExisting(string name, EventWaitHandleRights rights, out EventWaitHandle result);\r\n    }\r\n    public static partial class MutexAcl\r\n    {\r\n        public static Mutex OpenExisting(string name, MutexRights rights);\r\n        public static bool TryOpenExisting(string name, MutexRights rights, out Mutex result);\r\n    }\r\n    public static partial class SemaphoreAcl\r\n    {\r\n        public static Semaphore OpenExisting(string name, SemaphoreRights rights);\r\n        public static bool TryOpenExisting(string name, SemaphoreRights rights, out Semaphore result);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39640000000,
        "Apis": [
          "M:EventWaitHandleAcl.OpenExisting(string,EventWaitHandleRights)",
          "M:EventWaitHandleAcl.TryOpenExisting(string,EventWaitHandleRights,out EventWaitHandle)",
          "M:MutexAcl.OpenExisting(string,MutexRights)",
          "M:MutexAcl.TryOpenExisting(string,MutexRights,out Mutex)",
          "M:SemaphoreAcl.OpenExisting(string,SemaphoreRights)",
          "M:SemaphoreAcl.TryOpenExisting(string,SemaphoreRights,out Semaphore)",
          "T:EventWaitHandleAcl",
          "T:MutexAcl",
          "T:SemaphoreAcl"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42755,
          "Title": "Add ParseValue methods to JsonElement",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-25T20:00:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42755",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704460950",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42755#issuecomment-704460950",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial struct JsonElement\r\n    {\r\n        public static JsonElement ParseValue(ref Utf8JsonReader reader);\r\n        public static bool TryParseValue(ref Utf8JsonReader reader, [NotNullWhen(true)] out JsonElement? element);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43080000000,
        "Apis": [
          "M:JsonElement.ParseValue(ref Utf8JsonReader)",
          "M:JsonElement.TryParseValue(ref Utf8JsonReader,out JsonElement?)",
          "T:JsonElement"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 508,
          "Title": "Enable AsVector\u003CT\u003E in Vector\u003CT\u003E",
          "Author": "msedi",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-04T13:17:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/508",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704464181",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/508#issuecomment-704464181",
        "FeedbackMarkdown": "* Looks good as proposed, unless @CarolEidt has concerns\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public partial class Vector\r\n    {\r\n        public static Vector\u003CTTo\u003E As\u003CTFrom, TTo\u003E(Vector\u003CTFrom\u003E vector)\r\n            where TFrom : struct\r\n            where TTo : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48800000000,
        "Apis": [
          "M:Vector.As\u003CTFrom, TTo\u003E(Vector\u003CTFrom\u003E)",
          "T:Vector"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40202,
          "Title": "Span\u003Cchar\u003E from null-terminated char*",
          "Author": "fbrosseau",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-31T14:02:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40202",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-06T00:00:00-07:00",
        "FeedbackId": "704487238",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40202#issuecomment-704487238",
        "FeedbackMarkdown": "* The API should return \u0060Span\u003CT\u003E\u0060, we can add a \u0060ReadOnly\u0060 version later\r\n* We should throw \u0060InvalidOperationException\u0060 when the size would exceed \u0060int.MaxValue\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class MemoryMarshal\r\n    {\r\n        public static unsafe Span\u003Cchar\u003E CreateSpanFromNullTerminated(char* value);\r\n        public static unsafe Span\u003Cbyte\u003E CreateSpanFromNullTerminated(byte* value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51680000000,
        "Apis": [
          "M:MemoryMarshal.CreateSpanFromNullTerminated(byte*)",
          "M:MemoryMarshal.CreateSpanFromNullTerminated(char*)",
          "T:MemoryMarshal"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "G2ohWFyKnVc",
      "StartDateTime": "2020-10-13T10:07:06-07:00",
      "EndDateTime": "2020-10-13T12:05:02-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/G2ohWFyKnVc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "deployment-tools",
          "Id": 35,
          "Title": "Productize DOM APIs for release.json",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-28T21:39:56+00:00",
          "Url": "https://github.com/dotnet/deployment-tools/issues/35",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-13T00:00:00-07:00",
        "FeedbackId": "707946719",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/deployment-tools/issues/35#issuecomment-707946719",
        "FeedbackMarkdown": "* Pick a strategy: either expose \u0060IReadOnlyXxx\u0060 or use \u0060Collection\u0060/\u0060ReadOnlyCollection\u003CT\u003E\u0060 types but don\u0027t do both\r\n* Some types of the object model have (public) constructors while others don\u0027t. Pick one model.\r\n* Is it possible that consumers of this API can observe inconsistencies when files are updated independently? Should this be done via a versioning scheme or simply by serving the files from a GitHub repo (so long we make sure that commits are consistent).\r\n* \u0060ProductCollection\u0060\r\n    - \u0060ReleaseIndexDefaultUrl\u0060 should be a get-only property\r\n    - \u0060CreateAsync\u0060 is odd. How about \u0060GetAsync()\u0060?\r\n    - The parameters shouldn\u0027t use name \u0060Url\u0060 or \u0060Json\u0060.\r\n    - Don\u0027t overload between file paths and URLs (because we often also add string based overloads for URI based APIs)\r\n    - Add a string-based overload for URI\r\n    - Add \u0060GetFromFile\u0060 for the file-based one\r\n* \u0060Product\u0060\r\n    - \u0060IsSecurityUpdate\u0060. Should at least be renamed \u0060LatestReleaseIsSecurityUpdate\u0060 but we should consider removing it because the SDK has feature trains \u00605.0.100\u0060 and \u00605.0.200\u0060 that are for different VS releases. In which case only 200 is latest, which produce confusing/misleading results. It also seems the property is prone to errors for folks that want to check whether they are missing a security update (because this property is only true when the very latest release is a security update).\r\n    - The static \u0060GetReleasesAsync(Uri releasesJsonUrl)\u0060 method should move to \u0060ProductRelease\u0060\r\n* \u0060SupportPhase\u0060\r\n    - We should probably not surface serialization attributes\r\n    - What does \u0060Maintenance\u0060 mean?\r\n    - \u0060Current\u0060 is missing\r\n* \u0060ProductRelease\u0060\r\n    - Whatever policy you have on the \u0060Product\u0060, such as whether something is go-live \u0060SupportPhase\u0060 it seems the releases should be able to answer any questions as well, because releases are logically a point in time for a product. For example, we expose \u0060IsPreview\u0060 but not \u0060IsGoLive\u0060.\r\n    - Considering a reference back to \u0060Product\u0060\r\n* \u0060ReleaseComponent\u0060\r\n    - \u0060DisplayVersion\u0060 should be a \u0060string\u0060\r\n    - \u0060Runtimes\u0060 should be named \u0060AllRuntimes\u0060 and return \u0060IReadOnlyCollection\u003CT\u003E\u0060\r\n* \u0060ReleaseVersion\u0060\r\n    - This type is mutable, which we probably don\u0027t want. We should also remove \u0060Clone()\u0060 and \u0060ICloneable\u0060\r\n    - You have \u0060ComparePrecedence\u0060 and \u0060PrecedenceEquals\u0060. It seems more consistent to use \u0060PrecedenceCompareTo\u0060 and \u0060PrecedenceEquals\u0060\r\n* \u0060ReleaseFile\u0060\r\n    - We should make sure that hash validation is the default.\r\n    - When the validation fails we should delete the file\r\n    - We should negate the parameter to \u0060skipHashValidation\u0060\r\n    - Should we consider dropping the option of skipping entirely?\r\n    - Consider using \u0060System.IO.InvalidDataException\u0060\r\n    - The \u0060fileName\u0060 parameter is a bit ambiguous because the instance also has one. Maybe \u0060path\u0060 or \u0060destinationPath\u0060?\r\n    - Should probably implement \u0060IEquatable\u003C\u003E\u0060\r\n* \u0060ReleaseVersionConverter\u0060 and \u0060SupportPhaseConverter\u0060\r\n    - Should probably be internal\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Deployment.DotNet.Releases {\r\n    public class AspNetCoreReleaseComponent : ReleaseComponent {\r\n        public IReadOnlyCollection\u003Cstring\u003E AspNetCoreModuleVersions { get; }\r\n        public string VisualStudioVersion { get; }\r\n    }\r\n    public class Cve {\r\n        public Cve();\r\n        public string Id { get; }\r\n        public Uri Url { get; }\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n    }\r\n    public class Product {\r\n        public Product();\r\n        public DateTime? EndOfLifeDate { get; }\r\n        public bool IsSecurityUpdate { get; }\r\n        public DateTime? LatestReleaseDate { get; }\r\n        public ReleaseVersion LatestReleaseVersion { get; }\r\n        public ReleaseVersion LatestRuntimeVersion { get; }\r\n        public ReleaseVersion LatestSdkVersion { get; }\r\n        public string ProductName { get; }\r\n        public string ProductVersion { get; }\r\n        public Uri ReleasesJson { get; }\r\n        public SupportPhase SupportPhase { get; }\r\n        public static Task\u003CReadOnlyCollection\u003CProductRelease\u003E\u003E GetReleasesAsync(Uri releasesJsonUrl);\r\n        public Task\u003CReadOnlyCollection\u003CProductRelease\u003E\u003E GetReleasesAsync();\r\n        public Task\u003CReadOnlyCollection\u003CProductRelease\u003E\u003E GetReleasesAsync(string releasesIndexJsonPath, bool downloadLatest);\r\n        public bool IsOutOfSupport();\r\n    }\r\n    public sealed class ProductCollection : ReadOnlyCollection\u003CProduct\u003E {\r\n        public static readonly Uri ReleaseIndexDefaultUrl;\r\n        public static Task\u003CProductCollection\u003E CreateAsync();\r\n        public static Task\u003CProductCollection\u003E CreateAsync(string releasesIndexJsonPath, bool downloadLatest);\r\n        public static Task\u003CProductCollection\u003E CreateAsync(Uri releasesIndexUrl);\r\n        public IEnumerable\u003CSupportPhase\u003E GetSupportPhases();\r\n    }\r\n    public class ProductRelease {\r\n        public AspNetCoreReleaseComponent AspNetCoreRuntime { get; }\r\n        public IReadOnlyCollection\u003CReleaseComponent\u003E Components { get; }\r\n        public IReadOnlyCollection\u003CCve\u003E Cves { get; }\r\n        public IReadOnlyCollection\u003CReleaseFile\u003E Files { get; }\r\n        public bool IsPreview { get; }\r\n        public bool IsSecurityUpdate { get; }\r\n        public DateTime ReleaseDate { get; }\r\n        public Uri ReleaseNotes { get; }\r\n        public RuntimeReleaseComponent Runtime { get; }\r\n        public IEnumerable\u003CReleaseComponent\u003E Runtimes { get; }\r\n        public IReadOnlyCollection\u003CSdkReleaseComponent\u003E Sdks { get; }\r\n        public ReleaseVersion Version { get; }\r\n        public WindowsDesktopReleaseComponent WindowsDesktopRuntime { get; }\r\n    }\r\n    public abstract class ReleaseComponent {\r\n        public ReleaseVersion DisplayVersion { get; }\r\n        public IReadOnlyCollection\u003CReleaseFile\u003E Files { get; }\r\n        public string Name { get; protected set; }\r\n        public ProductRelease Release { get; }\r\n        public ReleaseVersion Version { get; }\r\n    }\r\n    public class ReleaseFile {\r\n        public ReleaseFile();\r\n        public string FileName { get; }\r\n        public string Hash { get; }\r\n        public string Name { get; }\r\n        public string Rid { get; }\r\n        public Uri Url { get; }\r\n        public Task DownloadAsync(string fileName);\r\n        public Task DownloadAsync(string fileName, bool verifyHash);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n    }\r\n    public class ReleaseVersion : IComparable, IComparable\u003CReleaseVersion\u003E, IEquatable\u003CReleaseVersion\u003E, ICloneable {\r\n        public ReleaseVersion(string version);\r\n        public ReleaseVersion();\r\n        public static readonly string Version2Pattern;\r\n        public string BuildMetadata { get; set; }\r\n        public int Major { get; set; }\r\n        public int Minor { get; set; }\r\n        public int Patch { get; set; }\r\n        public string Prerelease { get; set; }\r\n        public int SdkFeatureBand { get; }\r\n        public int SdkPatchLevel { get; }\r\n        public static int Compare(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool Equals(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator ==(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator \u003E(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator \u003E=(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator !=(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator \u003C(ReleaseVersion a, ReleaseVersion b);\r\n        public static bool operator \u003C=(ReleaseVersion a, ReleaseVersion b);\r\n        public object Clone();\r\n        public int ComparePrecedence(ReleaseVersion value);\r\n        public int CompareTo(object value);\r\n        public int CompareTo(ReleaseVersion value);\r\n        public bool Equals(ReleaseVersion obj);\r\n        public bool PrecedenceEquals(ReleaseVersion value);\r\n        public string ToString(int fieldCount);\r\n        public override bool Equals(object obj);\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n    public class ReleaseVersionConverter : JsonConverter\u003CReleaseVersion\u003E {\r\n        public ReleaseVersionConverter();\r\n        public override ReleaseVersion ReadJson(JsonReader reader, Type objectType, ReleaseVersion existingValue, bool hasExistingValue, JsonSerializer serializer);\r\n        public override void WriteJson(JsonWriter writer, ReleaseVersion value, JsonSerializer serializer);\r\n    }\r\n    public class RuntimeReleaseComponent : ReleaseComponent {\r\n        public string VisualStudioMacVersion { get; }\r\n        public string VisualStudioVersion { get; }\r\n    }\r\n    public class SdkReleaseComponent : ReleaseComponent {\r\n        public string CSharpVersion { get; }\r\n        public string FSharpVersion { get; }\r\n        public ReleaseVersion RuntimeVersion { get; }\r\n        public string VisualBasicVersion { get; }\r\n        public string VisualStudioMacSupport { get; }\r\n        public string VisualStudioMacVersion { get; }\r\n        public string VisualStudioSupport { get; }\r\n        public string VisualStudioVersion { get; }\r\n    }\r\n    public class SupportPhaseConverter : StringEnumConverter {\r\n        public SupportPhaseConverter();\r\n        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);\r\n    }\r\n    public class WindowsDesktopReleaseComponent : ReleaseComponent {\r\n    }\r\n    public enum SupportPhase {\r\n        Unknown = 0,\r\n        [EnumMember]\r\n        EndOfLife = 1,\r\n        Maintenance = 2,\r\n        [EnumMember]\r\n        LongTermSupport = 3,\r\n        Preview = 4,\r\n        RC = 5,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ProductCollection.ReleaseIndexDefaultUrl",
          "F:ReleaseVersion.Version2Pattern",
          "F:SupportPhase.EndOfLife",
          "F:SupportPhase.LongTermSupport",
          "F:SupportPhase.Maintenance",
          "F:SupportPhase.Preview",
          "F:SupportPhase.RC",
          "F:SupportPhase.Unknown",
          "M:Cve.Cve()",
          "M:Cve.Equals(object)",
          "M:Cve.GetHashCode()",
          "M:Product.GetReleasesAsync()",
          "M:Product.GetReleasesAsync(string,bool)",
          "M:Product.GetReleasesAsync(Uri)",
          "M:Product.IsOutOfSupport()",
          "M:Product.Product()",
          "M:ProductCollection.CreateAsync()",
          "M:ProductCollection.CreateAsync(string,bool)",
          "M:ProductCollection.CreateAsync(Uri)",
          "M:ProductCollection.GetSupportPhases()",
          "M:ReleaseFile.DownloadAsync(string,bool)",
          "M:ReleaseFile.DownloadAsync(string)",
          "M:ReleaseFile.Equals(object)",
          "M:ReleaseFile.GetHashCode()",
          "M:ReleaseFile.ReleaseFile()",
          "M:ReleaseVersion.!=(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.\u003C(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.\u003C=(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.==(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.\u003E(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.\u003E=(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.Clone()",
          "M:ReleaseVersion.Compare(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.ComparePrecedence(ReleaseVersion)",
          "M:ReleaseVersion.CompareTo(object)",
          "M:ReleaseVersion.CompareTo(ReleaseVersion)",
          "M:ReleaseVersion.Equals(object)",
          "M:ReleaseVersion.Equals(ReleaseVersion,ReleaseVersion)",
          "M:ReleaseVersion.Equals(ReleaseVersion)",
          "M:ReleaseVersion.GetHashCode()",
          "M:ReleaseVersion.PrecedenceEquals(ReleaseVersion)",
          "M:ReleaseVersion.ReleaseVersion()",
          "M:ReleaseVersion.ReleaseVersion(string)",
          "M:ReleaseVersion.ToString()",
          "M:ReleaseVersion.ToString(int)",
          "M:ReleaseVersionConverter.ReadJson(JsonReader,Type,ReleaseVersion,bool,JsonSerializer)",
          "M:ReleaseVersionConverter.ReleaseVersionConverter()",
          "M:ReleaseVersionConverter.WriteJson(JsonWriter,ReleaseVersion,JsonSerializer)",
          "M:SupportPhaseConverter.ReadJson(JsonReader,Type,object,JsonSerializer)",
          "M:SupportPhaseConverter.SupportPhaseConverter()",
          "P:AspNetCoreReleaseComponent.AspNetCoreModuleVersions",
          "P:AspNetCoreReleaseComponent.VisualStudioVersion",
          "P:Cve.Id",
          "P:Cve.Url",
          "P:Product.EndOfLifeDate",
          "P:Product.IsSecurityUpdate",
          "P:Product.LatestReleaseDate",
          "P:Product.LatestReleaseVersion",
          "P:Product.LatestRuntimeVersion",
          "P:Product.LatestSdkVersion",
          "P:Product.ProductName",
          "P:Product.ProductVersion",
          "P:Product.ReleasesJson",
          "P:Product.SupportPhase",
          "P:ProductRelease.AspNetCoreRuntime",
          "P:ProductRelease.Components",
          "P:ProductRelease.Cves",
          "P:ProductRelease.Files",
          "P:ProductRelease.IsPreview",
          "P:ProductRelease.IsSecurityUpdate",
          "P:ProductRelease.ReleaseDate",
          "P:ProductRelease.ReleaseNotes",
          "P:ProductRelease.Runtime",
          "P:ProductRelease.Runtimes",
          "P:ProductRelease.Sdks",
          "P:ProductRelease.Version",
          "P:ProductRelease.WindowsDesktopRuntime",
          "P:ReleaseComponent.DisplayVersion",
          "P:ReleaseComponent.Files",
          "P:ReleaseComponent.Name",
          "P:ReleaseComponent.Release",
          "P:ReleaseComponent.Version",
          "P:ReleaseFile.FileName",
          "P:ReleaseFile.Hash",
          "P:ReleaseFile.Name",
          "P:ReleaseFile.Rid",
          "P:ReleaseFile.Url",
          "P:ReleaseVersion.BuildMetadata",
          "P:ReleaseVersion.Major",
          "P:ReleaseVersion.Minor",
          "P:ReleaseVersion.Patch",
          "P:ReleaseVersion.Prerelease",
          "P:ReleaseVersion.SdkFeatureBand",
          "P:ReleaseVersion.SdkPatchLevel",
          "P:RuntimeReleaseComponent.VisualStudioMacVersion",
          "P:RuntimeReleaseComponent.VisualStudioVersion",
          "P:SdkReleaseComponent.CSharpVersion",
          "P:SdkReleaseComponent.FSharpVersion",
          "P:SdkReleaseComponent.RuntimeVersion",
          "P:SdkReleaseComponent.VisualBasicVersion",
          "P:SdkReleaseComponent.VisualStudioMacSupport",
          "P:SdkReleaseComponent.VisualStudioMacVersion",
          "P:SdkReleaseComponent.VisualStudioSupport",
          "P:SdkReleaseComponent.VisualStudioVersion",
          "T:AspNetCoreReleaseComponent",
          "T:Cve",
          "T:Product",
          "T:ProductCollection",
          "T:ProductRelease",
          "T:ReleaseComponent",
          "T:ReleaseFile",
          "T:ReleaseVersion",
          "T:ReleaseVersionConverter",
          "T:RuntimeReleaseComponent",
          "T:SdkReleaseComponent",
          "T:SupportPhase",
          "T:SupportPhaseConverter",
          "T:WindowsDesktopReleaseComponent"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "pMasvErucTg",
      "StartDateTime": "2020-10-20T10:02:15-07:00",
      "EndDateTime": "2020-10-20T12:04:55-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/pMasvErucTg/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41686,
          "Title": "Add System.BinaryData",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-01T17:26:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41686",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713056163",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41686#issuecomment-713056163",
        "FeedbackMarkdown": "* The type isn\u0027t meant to unify different representations\r\n* Rather, it\u0027s a helper to make it easier for users to convert data\r\n* Thus, it\u0027s not meant as high-performance exchange type, like span.\r\n* It\u0027s for \u0022user data\u0022, that is, the contract for the API is \u0022give form blob of binary data\u0022. It\u0027s not for protocol-like APIs where the underlying encoding is part of the API contract, e.g. a REST API.\r\n    - This means the API is meant for things like Azure Blob Storage, Azure Queuing, but not \u0060HttpClient\u0060\r\n* We should consider making the type a class. It\u0027s unlike to have perf implications (given that constructing it generally requires copying)\r\n    - This also gives us flexibility in the future, e.g. sub-classing\r\n    - Not much value in sealing (we only give up not being able to add abstracts later)\r\n* The methods that perform JSON serialization/deserialization should take JSON options\r\n    - We should make this the second parameter so we can add new serializers where type remains optional\r\n* We can remove the \u0060FromObjectAsync\u0060 and \u0060ToObjectAsync\u0060 methods, they are hold over from the serialization abstraction which had async implementations\r\n* We should remove the constructor and factory that takes a span, because it copies and it collides wit the \u0060ReadOnlyMemory\u003CT\u003E\u0060\r\n* We should add an implicit conversion to span (guidelines say that one shouldn\u0027t overload between them, so it seems generally fine)\r\n* We should consider hiding \u0060Equals()\u0060, \u0060GetHashCode()\u0060\r\n* The constructors that take \u0060byte[]\u0060 and \u0060ReadOnlyMemory\u003Cbyte\u003E\u0060 will not copy; they just wrap the payload. Mutations will be observed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public class BinaryData\r\n    {\r\n        public BinaryData(byte[] data);\r\n        public BinaryData(object jsonSerializable, JsonSerializerOptions options = default, Type? type = null);\r\n        public BinaryData(ReadOnlyMemory\u003Cbyte\u003E data);\r\n        public BinaryData(string data);\r\n        public static BinaryData FromBytes(ReadOnlyMemory\u003Cbyte\u003E data);\r\n        public static BinaryData FromBytes(byte[] data);\r\n        public static BinaryData FromObjectAsJson\u003CT\u003E(T jsonSerializable, JsonSerializerOptions options = default, CancellationToken cancellationToken = default);\r\n        public static BinaryData FromStream(Stream stream);\r\n        public static Task\u003CBinaryData\u003E FromStreamAsync(Stream stream, CancellationToken cancellationToken = default);\r\n        public static BinaryData FromString(string data);\r\n        public static implicit operator ReadOnlyMemory\u003Cbyte\u003E(BinaryData data);\r\n        public static implicit operator ReadOnlySpan\u003Cbyte\u003E(BinaryData data);\r\n        public ReadOnlyMemory\u003Cbyte\u003E ToBytes();\r\n        public T ToObjectFromJson\u003CT\u003E(JsonSerializerOptions options = default, CancellationToken cancellationToken = default);\r\n        public Stream ToStream();\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public override bool Equals(object? obj);\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public override int GetHashCode();\r\n        public override string ToString();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:BinaryData.BinaryData(byte[])",
          "M:BinaryData.BinaryData(object,JsonSerializerOptions,Type?)",
          "M:BinaryData.BinaryData(ReadOnlyMemory\u003Cbyte\u003E)",
          "M:BinaryData.BinaryData(string)",
          "M:BinaryData.Equals(object?)",
          "M:BinaryData.FromBytes(byte[])",
          "M:BinaryData.FromBytes(ReadOnlyMemory\u003Cbyte\u003E)",
          "M:BinaryData.FromObjectAsJson\u003CT\u003E(T,JsonSerializerOptions,CancellationToken)",
          "M:BinaryData.FromStream(Stream)",
          "M:BinaryData.FromStreamAsync(Stream,CancellationToken)",
          "M:BinaryData.FromString(string)",
          "M:BinaryData.GetHashCode()",
          "M:BinaryData.implicit(BinaryData)",
          "M:BinaryData.ToBytes()",
          "M:BinaryData.ToObjectFromJson\u003CT\u003E(JsonSerializerOptions,CancellationToken)",
          "M:BinaryData.ToStream()",
          "M:BinaryData.ToString()",
          "T:BinaryData"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43106,
          "Title": "[Arm64] MultiplyHigh",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-06T20:09:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43106",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713059473",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43106#issuecomment-713059473",
        "FeedbackMarkdown": "Looks good as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract class ArmBase\r\n    {\r\n        public abstract class Arm64\r\n        {\r\n            public static long MultiplyHigh(long left, long right);\r\n            public static ulong MultiplyHigh(ulong left, ulong right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 55100000000,
        "Apis": [
          "M:ArmBase.Arm64.MultiplyHigh(long,long)",
          "M:ArmBase.Arm64.MultiplyHigh(ulong,ulong)",
          "T:ArmBase",
          "T:ArmBase.Arm64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42948,
          "Title": "Add analyzer for Environment.ProcessPath ",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-01T14:25:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42948",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713060840",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42948#issuecomment-713060840",
        "FeedbackMarkdown": "Makes sense as proposed",
        "TimeCode": 58120000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43257,
          "Title": "Add analyzer for Environment.CurrentManagedThreadId",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-10T17:01:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43257",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713061245",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43257#issuecomment-713061245",
        "FeedbackMarkdown": "Makes sense. Should use the same diagnostic ID as #42948 (we already have one for \u0060ProcessId\u0060, we should reuse that).",
        "TimeCode": 59150000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43111,
          "Title": "Missing \u0060System.Net.Sockets.TcpClient.Connect(IPEndPoint remoteEP)\u0060 overload.",
          "Author": "MartyIX",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-06T20:43:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43111",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713067442",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43111#issuecomment-713067442",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public class TcpClient : IDisposable\r\n    {\r\n        //public void Connect(IPAddress address, int port);\r\n        //public void Connect(IPAddress[] ipAddresses, int port);\r\n        //public Task Connect(IPEndPoint remoteEP);\r\n        //public void Connect(string hostname, int port);\r\n\r\n        //public Task ConnectAsync(IPAddress address, int port);\r\n        //public Task ConnectAsync(IPAddress[] addresses, int port);\r\n        //public Task ConnectAsync(string host, int port);\r\n        public Task ConnectAsync(IPEndPoint remoteEP);\r\n\r\n        //public ValueTask ConnectAsync(IPAddress address, int port, CancellationToken cancellationToken);\r\n        //public ValueTask ConnectAsync(IPAddress[] addresses, int port, CancellationToken cancellationToken);\r\n        //public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken);\r\n        public ValueTask ConnectAsync(IPEndPoint remoteEP, CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59560000000,
        "Apis": [
          "M:TcpClient.ConnectAsync(IPEndPoint,CancellationToken)",
          "M:TcpClient.ConnectAsync(IPEndPoint)",
          "T:TcpClient"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43247,
          "Title": "obsolete DisablePrivateReflectionAttribute",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-10T01:31:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43247",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713070795",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43247#issuecomment-713070795",
        "FeedbackMarkdown": "* We should use a diagnostic ID. This allows us to have a help-topic specific for this issue. \u0060SYSLIB0013\u0060 sounds yes. The topic seems to warrant that.\r\n* Other than that, looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [Obsolete(\u0022DisablePrivateReflectionAttribute has no effect in .NET Core and .NET 5.0\u002B applications.\u0022)]\r\n    public partial class DisablePrivateReflectionAttribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64330000000,
        "Apis": [
          "T:DisablePrivateReflectionAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40579,
          "Title": "Prefer static HashData methods over ComputeHash",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-08T20:45:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40579",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-20T00:00:00-07:00",
        "FeedbackId": "713072863",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40579#issuecomment-713072863",
        "FeedbackMarkdown": "This makes sense.",
        "TimeCode": 68010000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "viYdlWGUiro",
      "StartDateTime": "2020-10-27T10:02:48-07:00",
      "EndDateTime": "2020-10-27T12:08:02-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/viYdlWGUiro/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43176,
          "Title": "Add Stream.ValidateBufferArguments helper",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-08T16:43:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43176",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717408439",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43176#issuecomment-717408439",
        "FeedbackMarkdown": "* There are several derivatives of \u0060Stream\u0060 that need to validate arguments\r\n    - Getting the exception and parameter names is tricky and we had several bugs\r\n* We like the pattern (\u0060Validate\u0060 prefix, \u0060Arguments\u0060 suffix)\r\n    - The names make sense too\r\n    - The choice of not tying it to a specific method makes sense because the buffer one applies to all methods on \u0060Stream\u0060 that take a buffer (and the parameter names are thankfully consistent)\r\n* Let\u0027s remove the \u0060Stream source\u0060 argument from the second (because it\u0027s \u0060this\u0060)\r\n    - The caller is responsible for validating \u0060this\u0060, these methods are only about arguments\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public abstract class Stream\r\n    {\r\n        protected static void ValidateBufferArguments(byte[] buffer, int offset, int count);\r\n        protected static void ValidateCopyToArguments(Stream destination, int bufferSize);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Stream.ValidateBufferArguments(byte[],int,int)",
          "M:Stream.ValidateCopyToArguments(Stream,int)",
          "T:Stream"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1293,
          "Title": "Add HTTP/3 APIs",
          "Author": "scalablecory",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-04T13:22:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1293",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717411979",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1293#issuecomment-717411979",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net\r\n{\r\n    public class partial HttpVersion\r\n    {\r\n        // Existing\r\n        // public static readonly Version Version10;\r\n        // public static readonly Version Version11;\r\n        // public static readonly Version Version20;\r\n        public static readonly Version Version30;\r\n    }\r\n}\r\nnamespace System.Net.Security\r\n{\r\n    public partial struct SslApplicationProtocol\r\n    {\r\n        // Existing\r\n        // public static readonly SslApplicationProtocol Http11;\r\n        // public static readonly SslApplicationProtocol Http2;\r\n        public static readonly SslApplicationProtocol Http3;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20780000000,
        "Apis": [
          "F:.Version30",
          "F:SslApplicationProtocol.Http3",
          "T:partial",
          "T:SslApplicationProtocol"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1608,
          "Title": "Implement DisconnectAsync method in SocketTaskExtensions",
          "Author": "gacardinal",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-10T15:47:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1608",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717417383",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1608#issuecomment-717417383",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should really consider \u0022removing\u0022 SocketTaskExtensions\r\n    - Merge with instance methods\r\n    - Hide type \u0026 member\r\n    - If we do this for .NET 6, we should delete \u0060DisconnectAsync\u0060 from this type\r\n    - @geoffkizer, could you file an issue for this?\r\n* We should use \u0060ValueTask\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public static class SocketTaskExtensions\r\n    {\r\n        // Existing APIs:\r\n        // public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);\r\n        // public void EndDisconnect (IAsyncResult asyncResult);\r\n\r\n        public static ValueTask DisconnectAsync(this Socket socket, bool reuseSocket, CancellationToken cancellationToken=default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24480000000,
        "Apis": [
          "M:SocketTaskExtensions.DisconnectAsync(this Socket,bool,CancellationToken)",
          "T:SocketTaskExtensions"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38536,
          "Title": "Add Insert extension method for IConfigurationBuilder",
          "Author": "fredrikhr",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-29T11:11:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38536",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717421092",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38536#issuecomment-717421092",
        "FeedbackMarkdown": "@maryamariyan request to table this for now so that they can think through the potential breaking changes first.",
        "TimeCode": 30150000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40695,
          "Title": "Add method to Microsoft.Extensions.Configuration.IConfiguration that gets a section and then validates it against a model",
          "Author": "TraceLD",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-12T05:39:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40695",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717423688",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40695#issuecomment-717423688",
        "FeedbackMarkdown": "According to the discussion, this seems to warrant more though first.",
        "TimeCode": 33070000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33769,
          "Title": "Use AsParallel() correctly",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33769",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq.Parallel",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717429099",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33769#issuecomment-717429099",
        "FeedbackMarkdown": "This makes sense. The only thing we have to check with Manish is whether they analyzer should report separate IDs due to how fixers are advertised in the IDE.",
        "TimeCode": 36170000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43483,
          "Title": "Provide default activity name value from [CallerMemberName] in ActivitySource.StartActivity",
          "Author": "kzu",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-22T15:31:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43483",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717443644",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43483#issuecomment-717443644",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public static partial class ActivitySource\r\n    {\r\n        // Existing API, just mark first parameter optional and add [CallerMemberName]\r\n        public Activity? StartActivity ([CallerMemberName] string name = \u0022\u0022,\r\n                                        ActivityKind kind = ActivityKind.Internal);\r\n\r\n        public Activity StartActivity (ActivityKind kind,\r\n                                       ActivityContext? parentContext = default,\r\n                                       IEnumerable\u003CKeyValuePair\u003Cstring,object\u003E\u003E? tags = default,\r\n                                       IEnumerable\u003CActivityLink\u003E? links = default,\r\n                                       DateTimeOffset startTime = default,\r\n                                       [CallerMemberName] string name = \u0022\u0022);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40880000000,
        "Apis": [
          "M:ActivitySource.StartActivity(ActivityKind,ActivityContext?,IEnumerable\u003CKeyValuePair\u003Cstring,object\u003E\u003E?,IEnumerable\u003CActivityLink\u003E?,DateTimeOffset,string)",
          "M:ActivitySource.StartActivity(string,ActivityKind)",
          "T:ActivitySource"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43328,
          "Title": "Analyzer: warn on use of module initializer",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-12T22:00:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43328",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717452492",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43328#issuecomment-717452492",
        "FeedbackMarkdown": "We seem to believe this can even be a warning that is on by default (but it shouldn\u0027t apply to generated code). Advanced users (who this feature is for) know how to turn it off.",
        "TimeCode": 52260000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43590,
          "Title": "Add easy way to create a certificate from just a cert-PEM",
          "Author": "shadow-cs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-19T16:45:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43590",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717455862",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43590#issuecomment-717455862",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    partial class X509Certificate2\r\n    {\r\n        public static X509Certificate2 CreateFromPem(ReadOnlySpan\u003Cchar\u003E certPem);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 56740000000,
        "Apis": [
          "M:X509Certificate2.CreateFromPem(ReadOnlySpan\u003Cchar\u003E)",
          "T:X509Certificate2"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43846,
          "Title": "Add Span overloads for Socket.SendFile",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-26T20:35:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43846",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717460180",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43846#issuecomment-717460180",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We considered span-ifying the string parameter, but that feels contrived\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public class Socket\r\n    {\r\n        // Existing API\r\n        // public void SendFile(string fileName, byte[] preBuffer, byte[] postBuffer, TransmitFileOptions flags);\r\n\r\n        public void SendFile(string fileName, ReadOnlySpan\u003Cbyte\u003E preBuffer, ReadOnlySpan\u003Cbyte\u003E postBuffer, TransmitFileOptions flags);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58390000000,
        "Apis": [
          "M:Socket.SendFile(string,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,TransmitFileOptions)",
          "T:Socket"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28795,
          "Title": "Add API IndexNotOf ",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-26T17:30:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28795",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717466792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28795#issuecomment-717466792",
        "FeedbackMarkdown": "* These APIs seem fairly specialized; it feels this might open up a large amount of potential new APIs due to combinations\r\n* These seem to live in user code\r\n* So unless there is more evidence that suggests this API is useful\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class MemoryExtensions\r\n    {\r\n        int IndexNotOf(this Span\u003CT\u003E span, T value) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this Span\u003CT\u003E span, T value0, T value1) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this Span\u003CT\u003E span, T value0, T value1, T value2) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this Span\u003CT\u003E span, ReadOnlySpan\u003CT\u003E values) where T : IEquatable\u003CT\u003E;\r\n\r\n        int IndexNotOf(this ReadOnlySpan\u003CT\u003E span, T value) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, T value0, T value1) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, T value0, T value1, T value2) where T : IEquatable\u003CT\u003E;\r\n        int IndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E values) where T : IEquatable\u003CT\u003E;\r\n\r\n        int LastIndexNotOf(this Span\u003CT\u003E span, T value) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this Span\u003CT\u003E span, T value0, T value1) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this Span\u003CT\u003E span, T value0, T value1, T value2) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this Span\u003CT\u003E span, ReadOnlySpan\u003CT\u003E values) where T : IEquatable\u003CT\u003E;\r\n\r\n        int LastIndexNotOf(this ReadOnlySpan\u003CT\u003E span, T value) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, T value0, T value1) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, T value0, T value1, T value2) where T : IEquatable\u003CT\u003E;\r\n        int LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E values) where T : IEquatable\u003CT\u003E;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61430000000,
        "Apis": [
          "M:MemoryExtensions.IndexNotOf(this ReadOnlySpan\u003CT\u003E,T)",
          "M:MemoryExtensions.IndexNotOf(this Span\u003CT\u003E,T)",
          "M:MemoryExtensions.IndexNotOfAny(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "M:MemoryExtensions.IndexNotOfAny(this ReadOnlySpan\u003CT\u003E,T,T,T)",
          "M:MemoryExtensions.IndexNotOfAny(this ReadOnlySpan\u003CT\u003E,T,T)",
          "M:MemoryExtensions.IndexNotOfAny(this Span\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "M:MemoryExtensions.IndexNotOfAny(this Span\u003CT\u003E,T,T,T)",
          "M:MemoryExtensions.IndexNotOfAny(this Span\u003CT\u003E,T,T)",
          "M:MemoryExtensions.LastIndexNotOf(this ReadOnlySpan\u003CT\u003E,T)",
          "M:MemoryExtensions.LastIndexNotOf(this Span\u003CT\u003E,T)",
          "M:MemoryExtensions.LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "M:MemoryExtensions.LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E,T,T,T)",
          "M:MemoryExtensions.LastIndexNotOfAny(this ReadOnlySpan\u003CT\u003E,T,T)",
          "M:MemoryExtensions.LastIndexNotOfAny(this Span\u003CT\u003E,ReadOnlySpan\u003CT\u003E)",
          "M:MemoryExtensions.LastIndexNotOfAny(this Span\u003CT\u003E,T,T,T)",
          "M:MemoryExtensions.LastIndexNotOfAny(this Span\u003CT\u003E,T,T)",
          "T:MemoryExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39971,
          "Title": "Introduce Math/F.ReciprocalEstimate and Math/F.ReciprocalSqrtEstimate",
          "Author": "john-h-k",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-27T19:05:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39971",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-10-27T00:00:00-07:00",
        "FeedbackId": "717470965",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39971#issuecomment-717470965",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class Math\r\n    {\r\n        public double ReciprocalEstimate(double d);\r\n        public double SqrtEstimate(double d);\r\n        public double ReciprocalSqrtEstimate(double d);\r\n    }\r\n\r\n    public static class MathF\r\n    {\r\n        public float ReciprocalEstimate(float x);\r\n        public float SqrtEstimate(float x);\r\n        public float ReciprocalSqrtEstimate(float x);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 68800000000,
        "Apis": [
          "M:Math.ReciprocalEstimate(double)",
          "M:Math.ReciprocalSqrtEstimate(double)",
          "M:Math.SqrtEstimate(double)",
          "M:MathF.ReciprocalEstimate(float)",
          "M:MathF.ReciprocalSqrtEstimate(float)",
          "M:MathF.SqrtEstimate(float)",
          "T:Math",
          "T:MathF"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "hhwOM5MzoTA",
      "StartDateTime": "2020-11-10T10:04:35-08:00",
      "EndDateTime": "2020-11-10T12:02:13-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/hhwOM5MzoTA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44025,
          "Title": "WinHttpHandler.TcpKeepAlive",
          "Author": "antonfirsov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-29T16:17:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44025",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724879708",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44025#issuecomment-724879708",
        "FeedbackMarkdown": "API Review:\r\n\r\n* Flatten things to just the one type\r\n* Add a \u0022Tcp\u0022 prefix since it\u0027s TCP KeepAlive, not HTTP KeepAlive\r\n* SupportedOSPlatform attributes might not be required, depending on how you handle older OS interaction\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class WinHttpHandler\r\n{\r\n#if NET5\r\n    [SupportedOSPlatform(\u0022windows10.0.2004\u0022)]\r\n#endif\r\n    public bool TcpKeepAliveEnabled { get; set; }\r\n\r\n#if NET5\r\n    [SupportedOSPlatform(\u0022windows10.0.2004\u0022)]\r\n#endif\r\n    public TimeSpan TcpKeepAliveTime { get; set; }\r\n\r\n#if NET5\r\n    [SupportedOSPlatform(\u0022windows10.0.2004\u0022)]\r\n#endif\r\n    public TimeSpan TcpKeepAliveInterval { get; set; }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:WinHttpHandler.TcpKeepAliveEnabled",
          "P:WinHttpHandler.TcpKeepAliveInterval",
          "P:WinHttpHandler.TcpKeepAliveTime",
          "T:WinHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 2406,
          "Title": "One-shot AES CBC and ECB",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-04T20:57:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/2406",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724886705",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/2406#issuecomment-724886705",
        "FeedbackMarkdown": "Looks good as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public abstract class SymmetricAlgorithm\r\n    {\r\n        // ECB (Block Aligned, no default padding, no IV)\r\n        public byte[] DecryptEcb(byte[] ciphertext, PaddingMode paddingMode);\r\n        public byte[] DecryptEcb(ReadOnlySpan\u003Cbyte\u003E ciphertext, PaddingMode paddingMode);\r\n        public int DecryptEcb(ReadOnlySpan\u003Cbyte\u003E ciphertext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode);\r\n        public byte[] EncryptEcb(byte[] plaintext, PaddingMode paddingMode);\r\n        public byte[] EncryptEcb(ReadOnlySpan\u003Cbyte\u003E plaintext, PaddingMode paddingMode);\r\n        public int EncryptEcb(ReadOnlySpan\u003Cbyte\u003E plaintext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode);\r\n        public bool TryDecryptEcb(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode, out int bytesWritten);\r\n        protected virtual bool TryDecryptEcbCore(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode, out int bytesWritten);\r\n        public bool TryEncryptEcb(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode, out int bytesWritten);\r\n        protected virtual bool TryEncryptEcbCore(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, Span\u003Cbyte\u003E destination, PaddingMode paddingMode, out int bytesWritten);\r\n\r\n        // CBC (Block Aligned, default to PKCS#7 padding, IV required)\r\n        public byte[] DecryptCbc(byte[] ciphertext, byte[] iv, PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public byte[] DecryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public int DecryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination,\r\n            PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public byte[] EncryptCbc(byte[] plaintext, byte[] iv, PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public byte[] EncryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public int EncryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination,\r\n            PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        public bool TryDecryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, out int bytesWritten,\r\n            PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        protected virtual bool TryDecryptCbcCore(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, PaddingMode paddingMode,\r\n            out int bytesWritten);\r\n        public bool TryEncryptCbc(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, out int bytesWritten,\r\n            PaddingMode paddingMode = PaddingMode.PKCS7);\r\n        protected virtual bool TryEncryptCbcCore(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, PaddingMode paddingMode,\r\n            out int bytesWritten);\r\n    }\r\n\r\n    public abstract class SymmetricAlgorithm\r\n    {\r\n        // CFB (Feedback-size aligned, default to No padding, IV required, adds feedback size (default 8))\r\n        public byte[] DecryptCfb(\r\n            byte[] ciphertext, byte[] iv, PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n        public byte[] DecryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, PaddingMode paddingMode = PaddingMode.None,\r\n            int feedbackSizeBits = 8);\r\n        public int DecryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination,\r\n            PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n\r\n        public byte[] EncryptCfb(\r\n            byte[] plaintext, byte[] iv, PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n        public byte[] EncryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, PaddingMode paddingMode = PaddingMode.None,\r\n            int feedbackSizeBits = 8);\r\n        public int EncryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination,\r\n            PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n\r\n        public bool TryDecryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, out int bytesWritten,\r\n            PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n\r\n        public bool TryEncryptCfb(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, out int bytesWritten,\r\n            PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n\r\n        protected virtual bool TryDecryptCfbCore(\r\n            ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, PaddingMode paddingMode,\r\n            int feedbackSizeBits, out int bytesWritten);\r\n\r\n        protected virtual bool TryEncryptCfbCore(\r\n            ReadOnlySpan\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E iv, Span\u003Cbyte\u003E destination, PaddingMode paddingMode,\r\n            int feedbackSizeBits, out int bytesWritten);\r\n    }\r\n\r\n    public abstract class SymmetricAlgorithm\r\n    {\r\n       public int GetCiphertextLengthEcb(int plaintextLength, PaddingMode paddingMode);\r\n       public int GetCiphertextLengthCbc(int plaintextLength, PaddingMode paddingMode = PaddingMode.PKCS7);\r\n       public int GetCiphertextLengthCfb(\r\n           int plaintextLength, PaddingMode paddingMode = PaddingMode.None, int feedbackSizeBits = 8);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9570000000,
        "Apis": [
          "M:SymmetricAlgorithm.DecryptCbc(byte[],byte[],PaddingMode)",
          "M:SymmetricAlgorithm.DecryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.DecryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.DecryptCfb(byte[],byte[],PaddingMode,int)",
          "M:SymmetricAlgorithm.DecryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,PaddingMode,int)",
          "M:SymmetricAlgorithm.DecryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,int)",
          "M:SymmetricAlgorithm.DecryptEcb(byte[],PaddingMode)",
          "M:SymmetricAlgorithm.DecryptEcb(ReadOnlySpan\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.DecryptEcb(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.EncryptCbc(byte[],byte[],PaddingMode)",
          "M:SymmetricAlgorithm.EncryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.EncryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.EncryptCfb(byte[],byte[],PaddingMode,int)",
          "M:SymmetricAlgorithm.EncryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,PaddingMode,int)",
          "M:SymmetricAlgorithm.EncryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,int)",
          "M:SymmetricAlgorithm.EncryptEcb(byte[],PaddingMode)",
          "M:SymmetricAlgorithm.EncryptEcb(ReadOnlySpan\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.EncryptEcb(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode)",
          "M:SymmetricAlgorithm.GetCiphertextLengthCbc(int,PaddingMode)",
          "M:SymmetricAlgorithm.GetCiphertextLengthCfb(int,PaddingMode,int)",
          "M:SymmetricAlgorithm.GetCiphertextLengthEcb(int,PaddingMode)",
          "M:SymmetricAlgorithm.TryDecryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,PaddingMode)",
          "M:SymmetricAlgorithm.TryDecryptCbcCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "M:SymmetricAlgorithm.TryDecryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,PaddingMode,int)",
          "M:SymmetricAlgorithm.TryDecryptCfbCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,int,out int)",
          "M:SymmetricAlgorithm.TryDecryptEcb(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "M:SymmetricAlgorithm.TryDecryptEcbCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "M:SymmetricAlgorithm.TryEncryptCbc(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,PaddingMode)",
          "M:SymmetricAlgorithm.TryEncryptCbcCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "M:SymmetricAlgorithm.TryEncryptCfb(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,PaddingMode,int)",
          "M:SymmetricAlgorithm.TryEncryptCfbCore(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,int,out int)",
          "M:SymmetricAlgorithm.TryEncryptEcb(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "M:SymmetricAlgorithm.TryEncryptEcbCore(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,PaddingMode,out int)",
          "T:SymmetricAlgorithm"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33770,
          "Title": "Do not use OfType\u003CT\u003E() with impossible types",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33770",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724892803",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33770#issuecomment-724892803",
        "FeedbackMarkdown": "Approved as proposed\r\n\r\nCategory: Reliability\r\nSuggested severity: Warning",
        "TimeCode": 17670000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33777,
          "Title": "Use span-based string.Concat",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33777",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724900704",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33777#issuecomment-724900704",
        "FeedbackMarkdown": "* Find calls to \u0060str1 \u002B str2.Substring(...) \u002B ...\u0060 (but not \u0060string.Concat(str1, str2.Substring(...), ...)\u0060, since that\u0027s in a different analyzer)\r\n* If there\u0027s an applicable overload of string.Concat that accepts ReadOnlySpan\u0026lt;char\u003E with the correct number of arguments, suggest changing the Substring call to AsSpan and calling string.Concat\r\n* Don\u0027t arbitrarily suggest changing str1 \u002B str2 to string.Concat(str1, str2).\r\n\r\nCategory: Performance\r\nSuggested severity: Info",
        "TimeCode": 24880000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33784,
          "Title": "Prefer string.AsSpan() over string.Substring() when parsing",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33784",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724901611",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33784#issuecomment-724901611",
        "FeedbackMarkdown": "* Find argument expressions that are str.Substring(...) and there\u0027s an overload (or the same overload) that accepts ReadOnlySpan\u0026lt;char\u003E in that position\r\n* Suggest changing Substring to AsSpan for the call\r\n\r\nCategory: Performance\r\nSuggested severity: Info",
        "TimeCode": 34090000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42753,
          "Title": "Add Type.GetMethod overload that takes Name, BindingFlags, and Parameter Types",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-25T19:45:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42753",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724906242",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42753#issuecomment-724906242",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Type\r\n    {\r\n        public System.Reflection.MethodInfo? GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Type[] types) { throw null; }\r\n\r\n        public System.Reflection.ConstructorInfo? GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Type[] types) { throw null; }\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 35150000000,
        "Apis": [
          "M:Type.GetConstructor(System.Reflection.BindingFlags,System.Type[])",
          "M:Type.GetMethod(string,System.Reflection.BindingFlags,System.Type[])",
          "T:Type"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43901,
          "Title": "Move SocketTaskExtensions methods to Socket class itself",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-27T18:11:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43901",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724910395",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43901#issuecomment-724910395",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n* Copy all members on SocketTaskExtensions to instance methods on Socket (removing the \u0060this\u0060 parameter)\r\n* Mark existing members as EditorBrowsable(Never)\r\n* Remove any members on SocketTaskExtensions that have been introduced for .NET 6.  Be nimble with regard to approved, but not-implemented ones.",
        "TimeCode": 38510000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43933,
          "Title": "Add Span overload for Socket.ReceiveMessageFrom",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-28T04:13:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43933",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724912569",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43933#issuecomment-724912569",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket : IDisposable\r\n    {\r\n        public int ReceiveMessageFrom(Span\u003Cbyte\u003E buffer, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43010000000,
        "Apis": [
          "M:Socket.ReceiveMessageFrom(Span\u003Cbyte\u003E,ref System.Net.Sockets.SocketFlags,ref System.Net.EndPoint,out System.Net.Sockets.IPPacketInformation)",
          "T:Socket"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44213,
          "Title": "System.Threading.ThreadPool.RegisterWorkItemHandler method",
          "Author": "lambdageek",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-03T19:02:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44213",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724914826",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44213#issuecomment-724914826",
        "FeedbackMarkdown": "@stephentoub believes that this is not in a ready state, transitioning to needs work.",
        "TimeCode": 45530000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 15136,
          "Title": "Add static method to create an IEnumerable with one element",
          "Author": "benjamin-hodgson",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-09-04T12:01:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15136",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724922312",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/15136#issuecomment-724922312",
        "FeedbackMarkdown": "API Review:\r\n\r\nWe\u0027re not really clear how this would be used in practice, and why something other than \u0060new[] { item }\u0060 would be better in that context.  It also seems like the best name for a single item is \u0060Single\u0060, but that has a bad collision with the existing \u0060Single\u0060 semantics.  (Yield doesn\u0027t seem like it\u0027s discoverable, just easily explained.)\r\n\r\nWith new data (e.g. sample usage) we might come to different conclusions, but it doesn\u0027t seem like there\u0027s enough utility and there\u0027s a dearth of good names.",
        "TimeCode": 48010000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20064,
          "Title": "Allow for specify return value on System.Linq.Enumerable.*OrDefault methods",
          "Author": "Keboo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-01-31T21:42:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20064",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724928896",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20064#issuecomment-724928896",
        "FeedbackMarkdown": "Looks good as proposed, but there was a concern raised that the Queryable methods might have an impact on Linq-to-SQL, which would be good to verify (@ajcvickers do you have insight or contacts here?).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static partial class Enumerable\r\n    {\r\n        public static TSource SingleOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource SingleOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n\r\n        public static TSource FirstOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource FirstOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n\r\n        public static TSource LastOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource LastOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n    }\r\n\r\n    public static class Queryable\r\n    {\r\n        public static TSource SingleOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource SingleOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n\r\n        public static TSource FirstOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource FirstOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n\r\n        public static TSource LastOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, TSource defaultValue);\r\n        public static TSource LastOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate, TSource defaultValue);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 56340000000,
        "Apis": [
          "M:Enumerable.FirstOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Enumerable.FirstOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,TSource)",
          "M:Enumerable.LastOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Enumerable.LastOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,TSource)",
          "M:Enumerable.SingleOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Enumerable.SingleOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,TSource)",
          "M:Queryable.FirstOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Queryable.FirstOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,TSource)",
          "M:Queryable.LastOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Queryable.LastOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,TSource)",
          "M:Queryable.SingleOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Func\u003CTSource, bool\u003E,TSource)",
          "M:Queryable.SingleOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,TSource)",
          "T:Enumerable",
          "T:Queryable"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28704,
          "Title": "Add ReadOnlySpan\u003Cchar\u003E overloads to StringInfo APIs",
          "Author": "ajtribick",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-16T11:47:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28704",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-10T00:00:00-08:00",
        "FeedbackId": "724933993",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28704#issuecomment-724933993",
        "FeedbackMarkdown": "* Returning the length instead of a span allows the method to be more versatile (ReadOnlySpan, Span, ReadOnlyMemory, Memory, etc)\r\n* GetNextTextElementLength allows for better association in IntelliSense\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Globalization\r\n{\r\n    public partial class StringInfo\r\n    {\r\n        public static int GetNextTextElementLength(string str);\r\n        public static int GetNextTextElementLength(string str, int index);\r\n        public static int GetNextTextElementLength(ReadOnlySpan\u003Cchar\u003E str);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64120000000,
        "Apis": [
          "M:StringInfo.GetNextTextElementLength(ReadOnlySpan\u003Cchar\u003E)",
          "M:StringInfo.GetNextTextElementLength(string,int)",
          "M:StringInfo.GetNextTextElementLength(string)",
          "T:StringInfo"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "bvoCR1hXMfw",
      "StartDateTime": "2020-11-17T10:13:22-08:00",
      "EndDateTime": "2020-11-17T12:00:01-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bvoCR1hXMfw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43957,
          "Title": "Developers can use a built in PriorityQueue type",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-28T18:30:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43957",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:3",
              "Color": "f9d0c4",
              "Description": "Work that is nice to have"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-17T00:00:00-08:00",
        "FeedbackId": "729157090",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43957#issuecomment-729157090",
        "FeedbackMarkdown": "* Add \u0060EnqueueRange(IEnumerable\u003CTElement\u003E values, TPriority priority)\u0060\r\n* Implementing \u0060IEnumerable\u0060 might be problematic because consumers are likely expecting it to return the elements in the order in which \u0060Dequeue\u0060 would (or at least priority order)\r\n    - That argument likely also applies to \u0060Elements\u0060, so we should removed that\r\n    - Instead add a \u0060public UnorderedItemsCollection UnorderedItems { get; }\u0060 (and should not allocate on each get)\r\n        - It would not be snapshot, you can enumerate while modifying, just like any other collection\r\n* Consider adding \u0060Contains\u0060\r\n* This collection will be shipped in the same assembly that contains the other types in \u0060System.Collections.Generic\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public class PriorityQueue\u003CTElement, TPriority\u003E\r\n    {\r\n        public PriorityQueue();\r\n        public PriorityQueue(int initialCapacity);\r\n        public PriorityQueue(IComparer\u003CTPriority\u003E? comparer);\r\n        public PriorityQueue(int initialCapacity, IComparer\u003CTPriority\u003E? comparer);\r\n        public PriorityQueue(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E values);\r\n        public PriorityQueue(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E values, IComparer\u003CTPriority\u003E? comparer);\r\n        public int Count { get; }\r\n        public IComparer\u003CTPriority\u003E Comparer { get; }\r\n        public void Enqueue(TElement element, TPriority priority);\r\n        public TElement Peek();\r\n        public TElement Dequeue();\r\n        public bool TryDequeue([MaybeNullWhen(false)] out TElement element, [MaybeNullWhen(false)] out TPriority priority);\r\n        public bool TryPeek([MaybeNullWhen(false)] out TElement element, [MaybeNullWhen(false)] out TPriority priority);\r\n        public TElement EnqueueDequeue(TElement element, TPriority priority);\r\n        public void EnqueueRange(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E values);\r\n        public void Clear();\r\n        public void EnsureCapacity(int capacity);\r\n        public void TrimExcess();\r\n        public UnorderedItemsCollection UnorderedItems { get; }\r\n        public class UnorderedItemsCollection : IReadOnlyCollection\u003C(TElement, TPriority)\u003E, ICollection\r\n        {\r\n            public struct Enumerator : IEnumerator\u003C(TElement, TPriority)\u003E, IEnumerator { }\r\n            public Enumerator GetEnumerator();\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:PriorityQueue\u003CTElement, TPriority\u003E.Clear()",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.Dequeue()",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.Enqueue(TElement,TPriority)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.EnqueueDequeue(TElement,TPriority)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.EnqueueRange(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.EnsureCapacity(int)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.Peek()",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue()",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue(IComparer\u003CTPriority\u003E?)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E,IComparer\u003CTPriority\u003E?)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue(IEnumerable\u003C(TElement Element, TPriority Priority)\u003E)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue(int,IComparer\u003CTPriority\u003E?)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.PriorityQueue(int)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.TrimExcess()",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.TryDequeue(out TElement,out TPriority)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.TryPeek(out TElement,out TPriority)",
          "M:PriorityQueue\u003CTElement, TPriority\u003E.UnorderedItemsCollection.GetEnumerator()",
          "P:PriorityQueue\u003CTElement, TPriority\u003E.Comparer",
          "P:PriorityQueue\u003CTElement, TPriority\u003E.Count",
          "P:PriorityQueue\u003CTElement, TPriority\u003E.UnorderedItems",
          "T:PriorityQueue\u003CTElement, TPriority\u003E",
          "T:PriorityQueue\u003CTElement, TPriority\u003E.UnorderedItemsCollection",
          "T:PriorityQueue\u003CTElement, TPriority\u003E.UnorderedItemsCollection.Enumerator"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43169,
          "Title": "Add System.Math.SinCos(..) or teach the JITter to calculate Sin and Cos together.",
          "Author": "RaceRalph",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-08T13:57:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43169",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-17T00:00:00-08:00",
        "FeedbackId": "729162076",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43169#issuecomment-729162076",
        "FeedbackMarkdown": "* Seems the register allocator will optimize the tuple the best and that also seems to make the most sense, API wise:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class Math\r\n    {\r\n        public (double Sin, double Cos) SinCos(double x);\r\n    }\r\n    public static partial class MathF\r\n    {\r\n        public (float Sin, float Cos) SinCos(float x);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52190000000,
        "Apis": [
          "M:Math.SinCos(double)",
          "M:MathF.SinCos(float)",
          "T:Math",
          "T:MathF"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43733,
          "Title": "Add System.Math API overloads for nint/nuint",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-22T17:51:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43733",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-17T00:00:00-08:00",
        "FeedbackId": "729164596",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43733#issuecomment-729164596",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class Math\r\n    {\r\n        public static nint Abs(nint value);\r\n        public static nuint Clamp(nuint value, nuint min, nuint max);\r\n        public static nint Clamp(nint value, nint min, nint max);\r\n        public static nint DivRem(nint a, nint b, out nint result);\r\n        public static nint Max(nint val1, nint val2);\r\n        public static nuint Max(nuint val1, nuint val2);\r\n        public static nint Min(nint val1, nint val2);\r\n        public static nuint Min(nuint val1, nuint val2);\r\n        public static nint Sign(nint value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57320000000,
        "Apis": [
          "M:Math.Abs(nint)",
          "M:Math.Clamp(nint,nint,nint)",
          "M:Math.Clamp(nuint,nuint,nuint)",
          "M:Math.DivRem(nint,nint,out nint)",
          "M:Math.Max(nint,nint)",
          "M:Math.Max(nuint,nuint)",
          "M:Math.Min(nint,nint)",
          "M:Math.Min(nuint,nuint)",
          "M:Math.Sign(nint)",
          "T:Math"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42156,
          "Title": "Add System.Math.DivRem for ulong and other integers",
          "Author": "Maykeye",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-12T06:30:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42156",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-17T00:00:00-08:00",
        "FeedbackId": "729167820",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42156#issuecomment-729167820",
        "FeedbackMarkdown": "* Let\u0027s move to the value tuple pattern\r\n* Let\u0027s only addd the tuple pattern for the new overloads\r\n* But let\u0027s also add value pattern overloads for the existing types\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class Math\r\n    {\r\n        public static (byte Quotient, byte Remainder) DivRem(byte left, byte right);\r\n        public static (sbyte Quotient, sbyte Remainder) DivRem(sbyte left, sbyte right);\r\n        public static (short Quotient, short Remainder) DivRem(short left, short right);\r\n        public static (ushort Quotient, ushort Remainder) DivRem(ushort left, ushort right);\r\n        public static (int Quotient, int Remainder) DivRem(int left, int right);\r\n        public static (uint Quotient, uint Remainder) DivRem(uint left, uint right);\r\n        public static (long Quotient, long Remainder) DivRem(long left, long right);\r\n        public static (ulong Quotient, ulong Remainder) DivRem(ulong left, ulong right);\r\n        public static (nint Quotient, nint Remainder) DivRem(nint left, nint right);\r\n        public static (nuint Quotient, nuint Remainder) DivRem(nuint left, nuint right);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 60060000000,
        "Apis": [
          "M:Math.DivRem(byte,byte)",
          "M:Math.DivRem(int,int)",
          "M:Math.DivRem(long,long)",
          "M:Math.DivRem(nint,nint)",
          "M:Math.DivRem(nuint,nuint)",
          "M:Math.DivRem(sbyte,sbyte)",
          "M:Math.DivRem(short,short)",
          "M:Math.DivRem(uint,uint)",
          "M:Math.DivRem(ulong,ulong)",
          "M:Math.DivRem(ushort,ushort)",
          "T:Math"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Dcu0Cz69onc",
      "StartDateTime": "2020-11-24T10:02:41-08:00",
      "EndDateTime": "2020-11-24T12:15:12-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Dcu0Cz69onc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44926,
          "Title": "Bmi2 MultiplyNoFlags2",
          "Author": "echesakovMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-19T03:46:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44926",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "arch-x86",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "arch-x64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-24T00:00:00-08:00",
        "FeedbackId": "733154504",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44926#issuecomment-733154504",
        "FeedbackMarkdown": "* It seems there are two separate issues:\r\n    1. Performance issue, which we can solve with a private intrinsic that uses tuples.\r\n    2. Usability issue due to use of pointers\r\n* We should fix (1) which doesn\u0027t require new public APIs but we should also do a pass of all the APIs that we believe need \u0060out\u0060 or tuple overloads\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Bmi2 : X86Base\r\n    {\r\n        public static (uint Lower, uint Upper) MultiplyNoFlags2(uint left, uint right);\r\n\r\n        public abstract class X64: X86Base.X64\r\n        {\r\n            public static (ulong Lower, ulong Upper) MultiplyNoFlags2(ulong left, ulong right);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Bmi2.MultiplyNoFlags2(uint,uint)",
          "M:Bmi2.X64.MultiplyNoFlags2(ulong,ulong)",
          "T:Bmi2",
          "T:Bmi2.X64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33789,
          "Title": "Override Stream.ReadAsync/WriteAsync",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33789",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-24T00:00:00-08:00",
        "FeedbackId": "733167928",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33789#issuecomment-733167928",
        "FeedbackMarkdown": "* We should scope it to cases is \u0060Stream\u0060 (and not a derived type)\r\n* The rule should flag types that override\r\n    - \u0060ReadAsync(byte[])\u0060 but that don\u0027t override the overload with \u0060Memory\u003CT\u003E\u0060\r\n    - \u0060WriteAsync(byte[])\u0060 but that don\u0027t override the overload with \u0060Memory\u003CT\u003E\u0060\r\n* On by default with severity info\r\n* Perf category\r\n* No fixer needed, the default behavior of auto completing \u0060override\u0060 or Ctrl \u002B . Generate overrides is sufficient",
        "TimeCode": 12440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36194,
          "Title": "Activator.CreateFactory and ConstructorInfo.CreateDelegate",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-11T02:32:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36194",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-24T00:00:00-08:00",
        "FeedbackId": "733185658",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36194#issuecomment-733185658",
        "FeedbackMarkdown": "* We don\u0027t add a \u0060new()\u0060 constraint to match the existing API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Activator\r\n    {\r\n        // Existing APIs\r\n        // public static T CreateInstance\u003CT\u003E();\r\n        // public static object? CreateInstance(Type type);\r\n        // public static object? CreateInstance(Type type, bool nonPublic);\r\n\r\n        public static Func\u003CT\u003E CreateFactory\u003CT\u003E();\r\n        public static Func\u003Cobject?\u003E CreateFactory(Type type);\r\n        public static Func\u003Cobject?\u003E CreateFactory(Type type, bool nonPublic);\r\n    }\r\n}\r\nnamespace System.Reflection\r\n{\r\n    public class ConstructorInfo\r\n    {\r\n      public static TDelegate CreateDelegate\u003CTDelegate\u003E();\r\n      public static Delegate CreateDelegate(Type delegateType);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 28900000000,
        "Apis": [
          "M:Activator.CreateFactory(Type,bool)",
          "M:Activator.CreateFactory(Type)",
          "M:Activator.CreateFactory\u003CT\u003E()",
          "M:ConstructorInfo.CreateDelegate(Type)",
          "M:ConstructorInfo.CreateDelegate\u003CTDelegate\u003E()",
          "T:Activator",
          "T:ConstructorInfo"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43930,
          "Title": "Add ConfigurationBinder.Bind\u003CT\u003E overloads",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-28T02:07:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43930",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-24T00:00:00-08:00",
        "FeedbackId": "733196396",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43930#issuecomment-733196396",
        "FeedbackMarkdown": "* What are the linker annotations?\r\n* Why do we need generic overloads? If we believe the compiler can always implicitly inferred, then it seems maybe we should able to do this inference by the linker as well. In other words, can we annotate the existing object based overloads? It seems local tracking is something the linker could be doing.\r\n* How many APIs like this do we have in the framework? If it\u0027s just a couple, adding generic overloads is fine, but if that\u0027s a pervasive pattern, than a change in the linker seems more useful.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public partial class ConfigurationBinder\r\n    {\r\n        public static void Bind\u003CT\u003E(this IConfiguration configuration, string key, T instance);\r\n        public static void Bind\u003CT\u003E(this IConfiguration configuration, T instance);\r\n        public static void Bind\u003CT\u003E(this IConfiguration configuration, T instance, Action\u003CBinderOptions\u003E configureOptions);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51000000000,
        "Apis": [
          "M:ConfigurationBinder.Bind\u003CT\u003E(this IConfiguration,string,T)",
          "M:ConfigurationBinder.Bind\u003CT\u003E(this IConfiguration,T,Action\u003CBinderOptions\u003E)",
          "M:ConfigurationBinder.Bind\u003CT\u003E(this IConfiguration,T)",
          "T:ConfigurationBinder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44738,
          "Title": "Make it safer and easier to build an X500DistinguishedName",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-16T17:15:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44738",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2020-11-24T00:00:00-08:00",
        "FeedbackId": "733204446",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44738#issuecomment-733204446",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We considered fluent pattern but concluded \u0022meh\u0022\r\n* Consider overriding \u0060ToString()\u0060 (or adding a \u0060DebuggerDisplayAttribute\u0060) so that during debugging people can see what\u0027s already in the builder.\r\n* Let\u0027s use \u0060string\u0060, we can always add \u0060ReadOnlySpan\u003Cchar\u003E\u0060 in the future. But we should overload the byte one.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public sealed class X500DistinguishedNameBuilder\r\n    {\r\n        public void AddEmailAddress(string emailAddress, Asn1Tag? stringEncodingType = null);\r\n        public void AddDomainComponent(string domainComponent, Asn1Tag? stringEncodingType = null);\r\n        public void AddLocalityName(string localityName, Asn1Tag? stringEncodingType = null);\r\n        public void AddCommonName(string commonName, Asn1Tag? stringEncodingType = null);\r\n        public void AddCountryOrRegion(string twoLetterCode, Asn1Tag? stringEncodingType = null);\r\n        public void AddOrganizationName(string organizationName, Asn1Tag? stringEncodingType = null);\r\n        public void AddOrganizationalUnitName(string organizationalUnitName, Asn1Tag? stringEncodingType = null);\r\n        public void AddStateOrProvinceName(string stateOrProvinceName, Asn1Tag? stringEncodingType = null);\r\n\r\n        public void Add(Oid oid, string value, Asn1Tag? stringEncodingType = null);\r\n        public void Add(string oidValue, string value, Asn1Tag? stringEncodingType = null);\r\n\r\n        public void AddEncoded(Oid oid, byte[] encodedValue);\r\n        public void AddEncoded(Oid oid, ReadOnlySpan\u003Cbyte\u003E encodedValue);\r\n        public void AddEncoded(string oidValue, byte[] encodedValue);\r\n        public void AddEncoded(string oidValue, ReadOnlySpan\u003Cbyte\u003E encodedValue);\r\n\r\n        public X500DistinguishedName Build();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64130000000,
        "Apis": [
          "M:X500DistinguishedNameBuilder.Add(Oid,string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.Add(string,string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddCommonName(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddCountryOrRegion(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddDomainComponent(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddEmailAddress(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddEncoded(Oid,byte[])",
          "M:X500DistinguishedNameBuilder.AddEncoded(Oid,ReadOnlySpan\u003Cbyte\u003E)",
          "M:X500DistinguishedNameBuilder.AddEncoded(string,byte[])",
          "M:X500DistinguishedNameBuilder.AddEncoded(string,ReadOnlySpan\u003Cbyte\u003E)",
          "M:X500DistinguishedNameBuilder.AddLocalityName(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddOrganizationalUnitName(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddOrganizationName(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.AddStateOrProvinceName(string,Asn1Tag?)",
          "M:X500DistinguishedNameBuilder.Build()",
          "T:X500DistinguishedNameBuilder"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "TPCjoYyp6e0",
      "StartDateTime": "2021-01-05T09:59:20-08:00",
      "EndDateTime": "2021-01-05T12:39:00-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/TPCjoYyp6e0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43702,
          "Title": "More arities for tuple returning zip extension method",
          "Author": "Logerfo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-21T19:39:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43702",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-05T00:00:00-08:00",
        "FeedbackId": "754807609",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43702#issuecomment-754807609",
        "FeedbackMarkdown": "* Let\u0027s support only three for now as four seems fairly rare.\r\n* We decided to not add an overload for the one taking the result selector.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static class Enumerable\r\n    {\r\n        public static IEnumerable\u003C(TFirst First, TSecond Second, TThird Third)\u003E Zip\u003CTFirst, TSecond, TThird\u003E(this IEnumerable\u003CTFirst\u003E first, IEnumerable\u003CTSecond\u003E second, IEnumerable\u003CTThird\u003E third);\r\n        public static IEnumerable\u003CTResult\u003E Zip\u003CTFirst, TSecond, TThird, TResult\u003E(this IEnumerable\u003CTFirst\u003E first, IEnumerable\u003CTSecond\u003E second, IEnumerable\u003CTThird\u003E third, Func\u003CTFirst, TSecond, TThird, TResult\u003E resultSelector);\r\n    }\r\n\r\n    public static class Queryable\r\n    {\r\n        public static IQueryable\u003C(TFirst First, TSecond Second, TThird Third)\u003E Zip\u003CTFirst, TSecond, TThird\u003E(this IQueryable\u003CTFirst\u003E source1, IEnumerable\u003CTSecond\u003E source2, IEnumerable\u003CTThird\u003E source3);\r\n        public static IQueryable\u003CTResult\u003E Zip\u003CTFirst, TSecond, TThird, TResult\u003E(this IQueryable\u003CTFirst\u003E first, IEnumerable\u003CTSecond\u003E second, IEnumerable\u003CTThird\u003E third, Expression\u003CFunc\u003CTFirst, TSecond, TThird, TResult\u003E\u003E resultSelector);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Enumerable.Zip\u003CTFirst, TSecond, TThird, TResult\u003E(this IEnumerable\u003CTFirst\u003E,IEnumerable\u003CTSecond\u003E,IEnumerable\u003CTThird\u003E,Func\u003CTFirst, TSecond, TThird, TResult\u003E)",
          "M:Enumerable.Zip\u003CTFirst, TSecond, TThird\u003E(this IEnumerable\u003CTFirst\u003E,IEnumerable\u003CTSecond\u003E,IEnumerable\u003CTThird\u003E)",
          "M:Queryable.Zip\u003CTFirst, TSecond, TThird, TResult\u003E(this IQueryable\u003CTFirst\u003E,IEnumerable\u003CTSecond\u003E,IEnumerable\u003CTThird\u003E,Expression\u003CFunc\u003CTFirst, TSecond, TThird, TResult\u003E\u003E)",
          "M:Queryable.Zip\u003CTFirst, TSecond, TThird\u003E(this IQueryable\u003CTFirst\u003E,IEnumerable\u003CTSecond\u003E,IEnumerable\u003CTThird\u003E)",
          "T:Enumerable",
          "T:Queryable"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45705,
          "Title": "Add SingleFileUnsupportedAttribute",
          "Author": "mateoatr",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-07T20:33:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45705",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-Single-File",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-05T00:00:00-08:00",
        "FeedbackId": "754838507",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45705#issuecomment-754838507",
        "FeedbackMarkdown": "* The attribute seems reasonable\r\n    - We shouldn\u0027t take a message because they are hard to change\r\n    - We should take a diagnostic id\r\n* Generalizing this to a capability-based model seems too complex\r\n* We should consider whether we want a capability API (globally for single file or per assembly like \u0060HasLocation\u0060)\r\n    - Do we need all the cases?\r\n    - Is framework loaded from disk or memory?\r\n    - Is user code loaded from disk or memory?\r\n    - Is application extracted?\r\n* Is the attribute named correctly?\r\n    - Unsupported seems to imply it throws; here it just means \u0022the behavior might not be what you want\u0022 while some actually throw\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = false)]\r\n    public sealed class SingleFileUnsupportedAttribute : Attribute\r\n    {\r\n        public SingleFileUnsupportedAttribute();\r\n        public string DiagnosticId { get; set; }\r\n        public string UrlFormat { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8850000000,
        "Apis": [
          "M:SingleFileUnsupportedAttribute.SingleFileUnsupportedAttribute()",
          "P:SingleFileUnsupportedAttribute.DiagnosticId",
          "P:SingleFileUnsupportedAttribute.UrlFormat",
          "T:SingleFileUnsupportedAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31088,
          "Title": "Add compression support in WebSocket",
          "Author": "zlatanov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-07T13:22:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31088",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-05T00:00:00-08:00",
        "FeedbackId": "754854011",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31088#issuecomment-754854011",
        "FeedbackMarkdown": "* Let\u0027s try to put the deflate settings in a single spot. This also solves the problem when we have to support a different compression algorithm with separate settings.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.WebSockets\r\n{\r\n    public sealed class WebSocketDeflateOptions\r\n    {\r\n        public int ClientMaxWindowBits { get; set; } = 15;\r\n        public bool ClientContextTakeover { get; set; } = true;\r\n        public int ServerMaxWindowBits { get; set; } = 15;\r\n        public bool ServerContextTakeover { get; set; } = true;\r\n    }\r\n\r\n    public sealed class WebSocketCreationOptions\r\n    {\r\n        public bool IsServer { get; set; }\r\n        public string? SubProtocol { get; set; }\r\n        public TimeSpan KeepAliveInterval { get; set; }\r\n        public WebSocketDeflateOptions? DeflateOptions { get; set; } = null;\r\n    }\r\n\r\n    public partial class ClientWebSocketOptions\r\n    {\r\n        public WebSocketDeflateOptions? DeflateOptions { get; set; } = null;\r\n    }\r\n\r\n    public partial class WebSocket\r\n    {\r\n        public static WebSocket CreateFromStream(Stream stream, WebSocketCreationOptions options);\r\n    }    \r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41830000000,
        "Apis": [
          "M:WebSocket.CreateFromStream(Stream,WebSocketCreationOptions)",
          "P:ClientWebSocketOptions.DeflateOptions",
          "P:WebSocketCreationOptions.DeflateOptions",
          "P:WebSocketCreationOptions.IsServer",
          "P:WebSocketCreationOptions.KeepAliveInterval",
          "P:WebSocketCreationOptions.SubProtocol",
          "P:WebSocketDeflateOptions.ClientContextTakeover",
          "P:WebSocketDeflateOptions.ClientMaxWindowBits",
          "P:WebSocketDeflateOptions.ServerContextTakeover",
          "P:WebSocketDeflateOptions.ServerMaxWindowBits",
          "T:ClientWebSocketOptions",
          "T:WebSocket",
          "T:WebSocketCreationOptions",
          "T:WebSocketDeflateOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40099,
          "Title": "Should we add support to ignore cycles on serialization?",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-29T19:17:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40099",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-05T00:00:00-08:00",
        "FeedbackId": "754882930",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40099#issuecomment-754882930",
        "FeedbackMarkdown": "* The concern would be ensure that the output is deterministic regardless how we\u0027re traversing the object graph. Is this guaranteed? If that\u0027s the case, this feature seems reasonable.\r\n* When an a list contains a cycle, we should write out \u0060null\u0060 value, instead of just omitting the value (as that\u0027s consistent with the ignore-null-behavior and doesn\u0027t change indices).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class ReferenceHandler\r\n    {   \r\n        // Existing:\r\n        // public static ReferenceHandler Preserve { get; }\r\n        public static ReferenceHandler IgnoreCycle { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59590000000,
        "Apis": [
          "P:ReferenceHandler.IgnoreCycle",
          "T:ReferenceHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44446,
          "Title": "Extend ComWrappers API to better support aggregation",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-10T02:59:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44446",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-05T00:00:00-08:00",
        "FeedbackId": "754884582",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44446#issuecomment-754884582",
        "FeedbackMarkdown": "* Looks good, but we should change the order to preserve positional order between overloads.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    [Flags]\r\n    public partial enum CreateObjectFlags\r\n    {\r\n        // None = 0,\r\n        // TrackerObject = 1,\r\n        // UniqueInstance = 2,\r\n        Aggregation = 4,\r\n        Unwrap = 8,\r\n    }\r\n}\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public abstract class ComWrappers\r\n    {\r\n        // Exists\r\n        // public object GetOrRegisterObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object wrapper);\r\n        public object GetOrRegisterObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object wrapper, IntPtr inner);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 93150000000,
        "Apis": [
          "F:CreateObjectFlags.Aggregation",
          "F:CreateObjectFlags.Unwrap",
          "M:ComWrappers.GetOrRegisterObjectForComInstance(IntPtr,CreateObjectFlags,object,IntPtr)",
          "T:ComWrappers",
          "T:CreateObjectFlags"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "3s2OAi9EbCA",
      "StartDateTime": "2021-01-12T10:04:45-08:00",
      "EndDateTime": "2021-01-12T12:06:51-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/3s2OAi9EbCA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44829,
          "Title": "Consider hiding legacy overloads for Math.DivRem",
          "Author": "SingleAccretion",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-17T20:33:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44829",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "758843410",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44829#issuecomment-758843410",
        "FeedbackMarkdown": "This could confuse people multi-targeting for .NET Standard because neither side is now a superset in IntelliSense. The value of hiding also seems low, especially because developers will typically explore alternative overloads and the tuple overloads will show first.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46440,
          "Title": "Provide an overload of System.Numerics.BigInteger.ToString()/TryFormat() that allows precision greater than 99",
          "Author": "assumenothing",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-29T06:49:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46440",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "758863444",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46440#issuecomment-758863444",
        "FeedbackMarkdown": "* We approved similar APIs for \u0060float\u0060 and \u0060double\u0060. But given that another type showed up, maybe we should change the parser and not add the APIs.\r\n* The rule would be: a format modifier with any number of digits is interpreted a standard format \u002B precision. If they value doesn\u0027t fit into an \u0060int\u0060, we throw.\r\n* We should also un-approve the APIs for \u0060float\u0060 and \u0060double\u0060.\r\n* This is a potential breaking change. We should try to get it into .NET 6 Preview 1 so that we have the longest lead time.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics.BigInteger\r\n{\r\n    public struct BigInteger\r\n    {\r\n        public string ToString(char format, int precision);\r\n        public string ToString(char format, int precision, IFormatProvider? provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, char format, int precision, IFormatProvider? provider = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 5810000000,
        "Apis": [
          "M:BigInteger.ToString(char,int,IFormatProvider?)",
          "M:BigInteger.ToString(char,int)",
          "M:BigInteger.TryFormat(Span\u003Cchar\u003E,out int,char,int,IFormatProvider?)",
          "T:BigInteger"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1946,
          "Title": "Async parallel foreach",
          "Author": "tomesendam",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-12-24T10:18:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1946",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1946#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 27570000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44801,
          "Title": "Add API to read, set and ensure capacity of Stack\u003CT\u003E and Queue\u003CT\u003E",
          "Author": "Enderlook",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-17T13:11:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44801",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "758883879",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44801#issuecomment-758883879",
        "FeedbackMarkdown": "* Looks good\r\n* Let\u0027s also make the method on \u0060List\u003CT\u003E\u0060 public\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public partial class List\u003CT\u003E\r\n    {\r\n        public int EnsureCapacity(int capacity);\r\n    }\r\n    public partial class Stack\u003CT\u003E\r\n    {\r\n        public int EnsureCapacity(int capacity);\r\n    }\r\n    public partial class Queue\u003CT\u003E\r\n    {\r\n        public int EnsureCapacity(int capacity);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40020000000,
        "Apis": [
          "M:List\u003CT\u003E.EnsureCapacity(int)",
          "M:Queue\u003CT\u003E.EnsureCapacity(int)",
          "M:Stack\u003CT\u003E.EnsureCapacity(int)",
          "T:List\u003CT\u003E",
          "T:Queue\u003CT\u003E",
          "T:Stack\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45130,
          "Title": "ChaCha20Poly1305 cryptographic algorithm",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-23T21:48:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45130",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "758897593",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45130#issuecomment-758897593",
        "FeedbackMarkdown": "* We should remove the attribute and tell people they need to call an \u0060IsSupported\u0060\r\n    - We should add an \u0060IsSupported\u0060 property to \u0060AesGcm\u0060 and \u0060AesCcm\u0060 as well.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public sealed partial class ChaCha20Poly1305 : IDisposable\r\n    {\r\n        public static bool IsSupported { get; }\r\n        public ChaCha20Poly1305(byte[] key);\r\n        public ChaCha20Poly1305(ReadOnlySpan\u003Cbyte\u003E key);\r\n        public void Decrypt(byte[] nonce, byte[] ciphertext, byte[] tag, byte[] plaintext, byte[]? associatedData = null);\r\n        public void Decrypt(ReadOnlySpan\u003Cbyte\u003E nonce, ReadOnlySpan\u003Cbyte\u003E ciphertext, ReadOnlySpan\u003Cbyte\u003E tag, Span\u003Cbyte\u003E plaintext, ReadOnlySpan\u003Cbyte\u003E associatedData = default(ReadOnlySpan\u003Cbyte\u003E));\r\n        public void Dispose();\r\n        public void Encrypt(byte[] nonce, byte[] plaintext, byte[] ciphertext, byte[] tag, byte[]? associatedData = null);\r\n        public void Encrypt(ReadOnlySpan\u003Cbyte\u003E nonce, ReadOnlySpan\u003Cbyte\u003E plaintext, Span\u003Cbyte\u003E ciphertext, Span\u003Cbyte\u003E tag, ReadOnlySpan\u003Cbyte\u003E associatedData = default(ReadOnlySpan\u003Cbyte\u003E));\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 47930000000,
        "Apis": [
          "M:ChaCha20Poly1305.ChaCha20Poly1305(byte[])",
          "M:ChaCha20Poly1305.ChaCha20Poly1305(ReadOnlySpan\u003Cbyte\u003E)",
          "M:ChaCha20Poly1305.Decrypt(byte[],byte[],byte[],byte[],byte[]?)",
          "M:ChaCha20Poly1305.Decrypt(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:ChaCha20Poly1305.Dispose()",
          "M:ChaCha20Poly1305.Encrypt(byte[],byte[],byte[],byte[],byte[]?)",
          "M:ChaCha20Poly1305.Encrypt(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,Span\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "P:ChaCha20Poly1305.IsSupported",
          "T:ChaCha20Poly1305"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45267,
          "Title": "Add Memory support to SendPacketElements",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-26T22:53:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45267",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-12T00:00:00-08:00",
        "FeedbackId": "758919212",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45267#issuecomment-758919212",
        "FeedbackMarkdown": "* Looks good as proposed\r\n \r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class SendPacketsElement\r\n    {\r\n        // Existing APIs:\r\n        // public SendPacketsElement(byte[] buffer);\r\n        // public SendPacketsElement(byte[] buffer, int offset, int count);\r\n        // public SendPacketsElement(byte[] buffer, int offset, int count, bool endOfPacket);\r\n        // public byte[]? Buffer { get; }\r\n        // public int Offset { get; }\r\n        // public int Count { get; }\r\n\r\n        public SendPacketsElement(ReadOnlyMemory\u003Cbyte\u003E buffer);\r\n        public SendPacketsElement(ReadOnlyMemory\u003Cbyte\u003E buffer, bool endOfPacket);\r\n        public ReadOnlyMemory\u003Cbyte\u003E? MemoryBuffer { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SendPacketsElement.SendPacketsElement(ReadOnlyMemory\u003Cbyte\u003E,bool)",
          "M:SendPacketsElement.SendPacketsElement(ReadOnlyMemory\u003Cbyte\u003E)",
          "P:SendPacketsElement.MemoryBuffer",
          "T:SendPacketsElement"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "qi1HHJyPUEQ",
      "StartDateTime": "2021-01-15T10:11:40-08:00",
      "EndDateTime": "2021-01-15T12:10:08-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/qi1HHJyPUEQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40169,
          "Title": "Obsolete RNGCryptoServiceProvider",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-31T00:15:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40169",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761105895",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40169#issuecomment-761105895",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    [EditorBrowsable(EditorBrowsableState.Never)] // existing attribute\r\n    [Obsolete(DiagnosticId: nextId)] // new attribute\r\n    public sealed class RNGCryptoServiceProvider : RandomNumberGenerator\r\n    { /* ... */ }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:RNGCryptoServiceProvider"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46930,
          "Title": "Obsolete the Rijndael and RijndaelManaged classes",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-13T19:10:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46930",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761107227",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46930#issuecomment-761107227",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.Algorithms\r\n{\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class Rijndael\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class RijndaelManaged\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7090000000,
        "Apis": [
          "T:Rijndael",
          "T:RijndaelManaged"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46934,
          "Title": "Obsolete unnecessary cryptographic derived types",
          "Author": "bartonjs",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-13T19:30:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46934",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761109630",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46934#issuecomment-761109630",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.Algorithms\r\n{\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class AesCryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class AesManaged\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class DESCryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class MD5CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class RC2CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA1Managed\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA1CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA256Managed\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA256CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA384Managed\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA384CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA512Managed\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class SHA512CryptoServiceProvider\r\n    {\r\n    }\r\n\r\n\u002B   [Obsolete(someID)]\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    public partial class TripleDESCryptoServiceProvider\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8580000000,
        "Apis": [
          "T:AesCryptoServiceProvider",
          "T:AesManaged",
          "T:DESCryptoServiceProvider",
          "T:MD5CryptoServiceProvider",
          "T:RC2CryptoServiceProvider",
          "T:SHA1CryptoServiceProvider",
          "T:SHA1Managed",
          "T:SHA256CryptoServiceProvider",
          "T:SHA256Managed",
          "T:SHA384CryptoServiceProvider",
          "T:SHA384Managed",
          "T:SHA512CryptoServiceProvider",
          "T:SHA512Managed",
          "T:TripleDESCryptoServiceProvider"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42967,
          "Title": "Analyzer for methods with PlatformNotSupportedException body but missing platform attributes",
          "Author": "marek-safar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-01T21:59:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42967",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761116392",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42967#issuecomment-761116392",
        "FeedbackMarkdown": "Because we don\u0027t currently have the ability to mark things as OS-specific based on parameter input, it can only be reliable for methods that are entirely \u0060throw new PlatformNotSupportedException(...)\u0060.  As such, we don\u0027t think there\u0027s sufficient value in it at this time.\r\n\r\nWhen it is possible to do something more complicated the analyzer should not warn if the method is declared \u0060[Obsolete]\u0060, in addition to the OS-based attributes.",
        "TimeCode": 11410000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46594,
          "Title": "Add Thread.UnsafeStart to avoid capturing the ExecutionContext ",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-05T18:41:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46594",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761119709",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46594#issuecomment-761119709",
        "FeedbackMarkdown": "Looks good as proposed, but we simplified it to use a default parameter.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n     public class Thread \r\n     {\r\n          void UnsafeStart(object? parameter = null);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19550000000,
        "Apis": [
          "M:Thread.UnsafeStart(object?)",
          "T:Thread"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46775,
          "Title": "Introduce CallConvMemberFunction to represent the member-function variants of Cdecl, Stdcall, etc. on Windows",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-09T00:27:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46775",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761122659",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46775#issuecomment-761122659",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public class CallConvMemberFunction\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23610000000,
        "Apis": [
          "T:CallConvMemberFunction"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46830,
          "Title": "Expose interop manipulation of SafeHandle",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-11T21:29:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46830",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761148142",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46830#issuecomment-761148142",
        "FeedbackMarkdown": "We think that a hybrid approach is best:\r\n\r\n* Update guidance to say that non-abstract SafeHandle types should have a default ctor (where IsInvalid is true).\r\n  * Update all of our SafeHandle types to follow this guidance.\r\n  * Add an analyzer to suggest this guidance.\r\n* Do not make \u0060SafeHandle.SetHandle\u0060 public.\r\n* Add \u0060Marshal.InitHandle\u0060 (using \u0022Init\u0022 instead of \u0022Set\u0022 to suggest that it should only be used on new instances).\r\n* The reflection code to create instances of types lacking a public constructor is easy enough that the CreateSafeHandle method isn\u0027t required (\u0060(TSafeHandle)Activator.CreateInstance(typeof(TSafeHandle), nonPublic: true)\u0060)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class Marshal\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Initializes the handle of a newly created blah blah blah.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022safeHandle\u0022\u003E\u003Csee cref=\u0022SafeHandle\u0022/\u003E instance to update\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022handle\u0022\u003EPre-existing handle\u003C/param\u003E\r\n        public static void InitHandle(SafeHandle safeHandle, IntPtr handle);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27320000000,
        "Apis": [
          "M:Marshal.InitHandle(SafeHandle,IntPtr)",
          "T:Marshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45290,
          "Title": "Add LoggerMessage.Define overload to disable IsEnabled check",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-27T23:20:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45290",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761156324",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45290#issuecomment-761156324",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    public static class LoggerMessage\r\n    {\r\n        public static Action\u003CILogger, T1, Exception\u003E Define\u003CT1\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n        public static Action\u003CILogger, T1, T2, Exception\u003E Define\u003CT1, T2\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n        public static Action\u003CILogger, T1, T2, T3, Exception\u003E Define\u003CT1, T2, T3\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n        public static Action\u003CILogger, T1, T2, T3, T4, Exception\u003E Define\u003CT1, T2, T3, T4\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n        public static Action\u003CILogger, T1, T2, T3, T4, T5, Exception\u003E Define\u003CT1, T2, T3, T4, T5\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n        public static Action\u003CILogger, T1, T2, T3, T4, T5, T6, Exception\u003E Define\u003CT1, T2, T3, T4, T5, T6\u003E(LogLevel logLevel, EventId eventId, string formatString);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48360000000,
        "Apis": [
          "M:LoggerMessage.Define\u003CT1, T2, T3, T4, T5, T6\u003E(LogLevel,EventId,string)",
          "M:LoggerMessage.Define\u003CT1, T2, T3, T4, T5\u003E(LogLevel,EventId,string)",
          "M:LoggerMessage.Define\u003CT1, T2, T3, T4\u003E(LogLevel,EventId,string)",
          "M:LoggerMessage.Define\u003CT1, T2, T3\u003E(LogLevel,EventId,string)",
          "M:LoggerMessage.Define\u003CT1, T2\u003E(LogLevel,EventId,string)",
          "M:LoggerMessage.Define\u003CT1\u003E(LogLevel,EventId,string)",
          "T:LoggerMessage"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 25608,
          "Title": "System.Numerics.Vectors and Span\u003CT\u003E",
          "Author": "dangi12012",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-24T00:20:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25608",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-15T00:00:00-08:00",
        "FeedbackId": "761168765",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/25608#issuecomment-761168765",
        "FeedbackMarkdown": "We think spanifying the constructor and CopyTo methods makes sense, but don\u0027t think adding the byte-based variants makes sense at the time.\r\n\r\nSemantics of these members should match what \u0060Vector\u003CT\u003E\u0060 does.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static partial struct Vector2\r\n    {\r\n        public Vector2(ReadOnlySpan\u003Cfloat\u003E values);\r\n\r\n        public readonly void CopyTo(Span\u003Cfloat\u003E destination);\r\n        public readonly bool TryCopyTo(Span\u003Cfloat\u003E destination);\r\n    }\r\n\r\n    public static partial struct Vector3\r\n    {\r\n        public Vector3(ReadOnlySpan\u003Cfloat\u003E values);\r\n\r\n        public readonly void CopyTo(Span\u003Cfloat\u003E destination);\r\n        public readonly bool TryCopyTo(Span\u003Cfloat\u003E destination);\r\n    }\r\n\r\n    public static partial struct Vector4\r\n    {\r\n        public Vector4(ReadOnlySpan\u003Cfloat\u003E values);\r\n\r\n        public readonly void CopyTo(Span\u003Cfloat\u003E destination);\r\n        public readonly bool TryCopyTo(Span\u003Cfloat\u003E destination);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52680000000,
        "Apis": [
          "M:Vector2.CopyTo(Span\u003Cfloat\u003E)",
          "M:Vector2.TryCopyTo(Span\u003Cfloat\u003E)",
          "M:Vector2.Vector2(ReadOnlySpan\u003Cfloat\u003E)",
          "M:Vector3.CopyTo(Span\u003Cfloat\u003E)",
          "M:Vector3.TryCopyTo(Span\u003Cfloat\u003E)",
          "M:Vector3.Vector3(ReadOnlySpan\u003Cfloat\u003E)",
          "M:Vector4.CopyTo(Span\u003Cfloat\u003E)",
          "M:Vector4.TryCopyTo(Span\u003Cfloat\u003E)",
          "M:Vector4.Vector4(ReadOnlySpan\u003Cfloat\u003E)",
          "T:Vector2",
          "T:Vector3",
          "T:Vector4"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "-YO1L8CtNTM",
      "StartDateTime": "2021-01-19T09:59:47-08:00",
      "EndDateTime": "2021-01-19T10:49:16-08:00",
      "Title": "JSON DOM (1)",
      "ThumbnailUrl": "https://i.ytimg.com/vi/-YO1L8CtNTM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 163,
          "Title": "Writable DOM and dynamic support for 6.0",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-03T16:09:35+00:00",
          "Url": "https://github.com/dotnet/designs/pull/163",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-19T00:00:00-08:00",
        "FeedbackId": "763165357",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/163#issuecomment-763165357",
        "FeedbackMarkdown": "* It seems the serializer and the DOM are quite intertwined in this design. It seems the DOM should have parsing/formatting methods as well, rather than requiring to serialize it.\r\n* In the design sketch it\u0027s unclear which members \u0060JsonValue\u0060 and \u0060JsonArray\u0060 expose from the interface implementations.\r\n* It seems a bit unclear if/when methods will implicitly serialize/deserialize, for example the \u0060GetValue\u003CT\u003E\u0060 would implicitly deserialize the JSON to \u0060T\u0060 using a converter.\r\n\r\n**Next steps:**\r\n\r\n* Detailed API proposal",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28776,
          "Title": "LINQ APIs to enable C# 8.0 index and range for IEnumerable\u003CT\u003E",
          "Author": "Dixin",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-24T16:01:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28776",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-19T00:00:00-08:00",
        "FeedbackId": "763102398",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28776#issuecomment-763102398",
        "FeedbackMarkdown": "* We\u0027re OK with the \u0060ElementAt\u0060 methods\r\n* We\u0027re unsure about \u0060Slice\u0060, for two reasons:\r\n    - We generally want \u0060Slice\u0060 to return the same type it\u0027s invoked on (hard for interfaces)\r\n    - It\u0027s unclear whether the API should have \u0060Take\u0060 semantics (where bounds are min/max) or \u0060Slice\u0060 where the enumerable must have that exact range\r\n* We\u0027re also unsure about \u0060Queryable\u0060, some of us believe we evolved \u0060Queryable\u0060 already, but we should make sure that\u0027s the case an inline with our breaking change policy on Linq providers\r\n* Should we evolve PLinq as well?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static partial class Enumerable\r\n    {\r\n        public static TSource ElementAt\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Index index);\r\n        public static TSource? ElementAtOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Index index);\r\n        public static IEnumerable\u003CTSource\u003E Slice\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Range range);\r\n    }\r\n\r\n    public static partial class Queryable\r\n    {\r\n        public static TSource ElementAt\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Index index);\r\n        public static TSource? ElementAtOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Index index);\r\n        public static IQueryable\u003CTSource\u003E Slice\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Range range);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Enumerable.ElementAt\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Index)",
          "M:Enumerable.ElementAtOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Index)",
          "M:Enumerable.Slice\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Range)",
          "M:Queryable.ElementAt\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Index)",
          "M:Queryable.ElementAtOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Index)",
          "M:Queryable.Slice\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Range)",
          "T:Enumerable",
          "T:Queryable"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "nIk0aU_Ty_w",
      "StartDateTime": "2021-01-21T10:05:46-08:00",
      "EndDateTime": "2021-01-21T12:03:45-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/nIk0aU_Ty_w/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39866,
          "Title": "Add Activity.GetTagItem",
          "Author": "kzu",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-23T20:47:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39866",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764841563",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39866#issuecomment-764841563",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public class Activity\r\n    {\r\n        public object? GetTagItem(string key);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Activity.GetTagItem(string)",
          "T:Activity"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43637,
          "Title": "Generic Host is not stopped when BackgroundService crashes",
          "Author": "marcselis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-20T13:46:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43637",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Hosting",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764874136",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43637#issuecomment-764874136",
        "FeedbackMarkdown": "* It seems the new behavior is more desirable than the current behavior but it\u0027s hard to know how many apps would be broken by the new behavior.\r\n* The API isn\u0027t very discoverable, so if it\u0027s purely opt-in, then most customers aren\u0027t likely to benefit from the new behavior.\r\n* A compromise would be:\r\n    - Change the templates for .NET 6 to set this property to \u0060BackgroundServiceExceptionBehavior.StopHost\u0060\r\n    - Based on customer feedback, we can change the default for .NET 7 and simplify the templates\r\n* On the other hand, this is early for .NET 6\r\n    - Let\u0027s ship the API\r\n    - Let\u0027s change the default now, not update the templates, see what feedback we get for the previews, and revert back to opt-in if it breaks many people.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Hosting\r\n{\r\n    public enum BackgroundServiceExceptionBehavior\r\n    {\r\n        Ignore,\r\n        StopHost\r\n    }\r\n    public class HostOptions\r\n    {\r\n        public BackgroundServiceExceptionBehavior BackgroundServiceExceptionBehavior { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6090000000,
        "Apis": [
          "F:BackgroundServiceExceptionBehavior.Ignore",
          "F:BackgroundServiceExceptionBehavior.StopHost",
          "P:HostOptions.BackgroundServiceExceptionBehavior",
          "T:BackgroundServiceExceptionBehavior",
          "T:HostOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20137,
          "Title": "Add missing math functions defined by IEEE 754:2019",
          "Author": "dcwuser",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-02-07T20:16:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20137",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764879294",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20137#issuecomment-764879294",
        "FeedbackMarkdown": "* Looks good as proposed, but let\u0027s also add the \u0060MaxNumber\u0060 variants that we previously rejected so that we get entire spec implemented\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class Math\r\n    {    \r\n        public static double AcosPi(double x);\r\n        public static double AsinPi(double x);\r\n        public static double Atan2Pi(double y, double x);\r\n        public static double AtanPi(double x);\r\n        public static double Compound(double x, double n);\r\n        public static double CosPi(double x);\r\n        public static double Exp10(double x);\r\n        public static double Exp10M1(double x);\r\n        public static double Exp2(double x);\r\n        public static double Exp2M1(double x);\r\n        public static double ExpM1(double x);\r\n        public static double Hypot(double x, double y);\r\n        public static double Log10P1(double x);\r\n        public static double Log2P1(double x);\r\n        public static double LogP1(double x);\r\n        public static double MaxMagnitudeNumber(double x, double y);\r\n        public static double MaxNumber(double x, double y);\r\n        public static double MinMagnitudeNumber(double x, double y);\r\n        public static double MinNumber(double x, double y);\r\n        public static double Root(double x, double n);\r\n        public static double SinPi(double x);\r\n        public static double TanPi(double x);\r\n    }\r\n    public static partial class MathF\r\n    {\r\n        public static float AcosPi(float x);\r\n        public static float AsinPi(float x);\r\n        public static float Atan2Pi(float y, float x);\r\n        public static float AtanPi(float x);\r\n        public static float Compound(float x, float n);\r\n        public static float CosPi(float x);\r\n        public static float Exp10(float x);\r\n        public static float Exp10M1(float x);\r\n        public static float Exp2(float x);\r\n        public static float Exp2M1(float x);\r\n        public static float ExpM1(float x);\r\n        public static float Hypot(float x, float y);\r\n        public static float Log10P1(float x);\r\n        public static float Log2P1(float x);\r\n        public static float LogP1(float x);\r\n        public static float MaxMagnitudeNumber(float x, float y);\r\n        public static float MaxNumber(float x, float y);\r\n        public static float MinMagnitudeNumber(float x, float y);\r\n        public static float MinNumber(float x, float y);\r\n        public static float Root(float x, float n);\r\n        public static float SinPi(float x);\r\n        public static float TanPi(float x);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40950000000,
        "Apis": [
          "M:Math.AcosPi(double)",
          "M:Math.AsinPi(double)",
          "M:Math.Atan2Pi(double,double)",
          "M:Math.AtanPi(double)",
          "M:Math.Compound(double,double)",
          "M:Math.CosPi(double)",
          "M:Math.Exp10(double)",
          "M:Math.Exp10M1(double)",
          "M:Math.Exp2(double)",
          "M:Math.Exp2M1(double)",
          "M:Math.ExpM1(double)",
          "M:Math.Hypot(double,double)",
          "M:Math.Log10P1(double)",
          "M:Math.Log2P1(double)",
          "M:Math.LogP1(double)",
          "M:Math.MaxMagnitudeNumber(double,double)",
          "M:Math.MaxNumber(double,double)",
          "M:Math.MinMagnitudeNumber(double,double)",
          "M:Math.MinNumber(double,double)",
          "M:Math.Root(double,double)",
          "M:Math.SinPi(double)",
          "M:Math.TanPi(double)",
          "M:MathF.AcosPi(float)",
          "M:MathF.AsinPi(float)",
          "M:MathF.Atan2Pi(float,float)",
          "M:MathF.AtanPi(float)",
          "M:MathF.Compound(float,float)",
          "M:MathF.CosPi(float)",
          "M:MathF.Exp10(float)",
          "M:MathF.Exp10M1(float)",
          "M:MathF.Exp2(float)",
          "M:MathF.Exp2M1(float)",
          "M:MathF.ExpM1(float)",
          "M:MathF.Hypot(float,float)",
          "M:MathF.Log10P1(float)",
          "M:MathF.Log2P1(float)",
          "M:MathF.LogP1(float)",
          "M:MathF.MaxMagnitudeNumber(float,float)",
          "M:MathF.MaxNumber(float,float)",
          "M:MathF.MinMagnitudeNumber(float,float)",
          "M:MathF.MinNumber(float,float)",
          "M:MathF.Root(float,float)",
          "M:MathF.SinPi(float)",
          "M:MathF.TanPi(float)",
          "T:Math",
          "T:MathF"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 508,
          "Title": "Enable AsVector\u003CT\u003E in Vector\u003CT\u003E",
          "Author": "msedi",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-04T13:17:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/508",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764884320",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/508#issuecomment-764884320",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class Vector\r\n{\r\n    public static Vector\u003CTTo\u003E As\u003CTFrom, TTo\u003E(this Vector\u003CTFrom\u003E vector)\r\n        where TFrom : struct\r\n        where TTo : struct;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46450000000,
        "Apis": [
          "M:Vector.As\u003CTFrom, TTo\u003E(this Vector\u003CTFrom\u003E)",
          "T:Vector"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36015,
          "Title": "Add BinderOption to allow callers to specify that configuration binding should throw an exception upon any failure.",
          "Author": "BlacKCaT27",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-06T01:28:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36015",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764897808",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36015#issuecomment-764897808",
        "FeedbackMarkdown": "* \u0060ErrorOnPropertyMissing\u0060 makes total sense. The default should be \u0060false\u0060 so that it\u0027s not a breaking change. But the name is a bit ambiguous. We\u0027d prefer \u0060ErrorOnUnknownConfiguration\u0060.\r\n* \u0060ErrorOnKeyMissing\u0060 seems a bit strange because options are mostly, well, optional. A better design might be to add an attribute that the user would put on their strongly typed option type property, akin to how serializers work. This design assumes the binder doesn\u0027t initialize unspecified properties to their default value.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public class BinderOptions\r\n    {\r\n        public bool ErrorOnUnknownConfiguration{ get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51230000000,
        "Apis": [
          "P:BinderOptions.ErrorOnUnknownConfiguration",
          "T:BinderOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36003,
          "Title": "Expose Host.ConfigureDefaults",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-22T09:16:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36003",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Hosting",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-21T00:00:00-08:00",
        "FeedbackId": "764900907",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36003#issuecomment-764900907",
        "FeedbackMarkdown": "* Let\u0027s not name it \u0060CreateDefaultBuilder()\u0060 because it doesn\u0027t actually create a new builder, it just applies the defaults.\r\n* Let\u0027s make an extension method so that the usage looks less noisy\r\n* That means we should move it to \u0060HostingHostBuilderExtensions\u0060 instead\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Hosting\r\n{\r\n    public static partial class HostingHostBuilderExtensions\r\n    {\r\n        public static IHostBuilder ConfigureDefaults(this IHostBuilder builder, string[] args);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 65000000000,
        "Apis": [
          "M:HostingHostBuilderExtensions.ConfigureDefaults(this IHostBuilder,string[])",
          "T:HostingHostBuilderExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "efvl_wtYSw8",
      "StartDateTime": "2021-01-26T10:07:01-08:00",
      "EndDateTime": "2021-01-26T12:03:34-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/efvl_wtYSw8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46689,
          "Title": "Add Status field to Activity API",
          "Author": "cijothomas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-07T17:59:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46689",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767748332",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46689#issuecomment-767748332",
        "FeedbackMarkdown": "* It seems problematic to have well-known fields/properties on \u0060ActivityStatus\u0060 because it encourages code like \u0060activity.Status == ActivityStatus.Ok\u0060 which would break if the description changes, which seems odd. At the same time, it would be odd for \u0060ActivityStatus\u0060\u0027s implementation of equality to ignore the description.\r\n    - One option is to remove the well-known values from \u0060ActivityStatus\u0060\r\n    - Another option is to remove \u0060ActivityStatus\u0060 and expose code and description as separate properties on \u0060Activity\u0060. If we are concerned about extending the code, we can make \u0060ActivityStatusCode\u0060 a struct with well known fields. The downside is that this allows for impossible states, such as an unset code but a non-null description.\r\n* We concluded that two properties plus a method to throw on invalid combinations.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public enum ActivityStatusCode\r\n    {\r\n        Unset = 0,\r\n        Ok = 1,\r\n        Error = 2\r\n    }\r\n    public partial class Activity\r\n    {\r\n        public ActivityStatus Status { get; }\r\n        public string? StatusDescription { get; }\r\n        public void SetStatus(ActivityStatusCode code, string? description = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ActivityStatusCode.Error",
          "F:ActivityStatusCode.Ok",
          "F:ActivityStatusCode.Unset",
          "M:Activity.SetStatus(ActivityStatusCode,string?)",
          "P:Activity.Status",
          "P:Activity.StatusDescription",
          "T:Activity",
          "T:ActivityStatusCode"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 28776,
          "Title": "LINQ APIs to enable C# 8.0 index and range for IEnumerable\u003CT\u003E",
          "Author": "Dixin",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-02-24T16:01:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/28776",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767752600",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/28776#issuecomment-767752600",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We\u0027re not providing an implementation for PLinq\r\n* Query providers can choose implement the method, if no there will be some default behavior.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static partial class Enumerable\r\n    {\r\n        public static TSource ElementAt\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Index index);\r\n        public static TSource ElementAtOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Index index);\r\n        public static IEnumerable\u003CTSource\u003E Take\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Range range);\r\n    }\r\n    public static partial class Queryable\r\n    {\r\n        public static TSource ElementAt\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Index index);\r\n        public static TSource ElementAtOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Index index);\r\n        public static IQueryable\u003CTSource\u003E Take\u003CTSource\u003E(this IQueryable\u003CTSource\u003E source, Range range);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21870000000,
        "Apis": [
          "M:Enumerable.ElementAt\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Index)",
          "M:Enumerable.ElementAtOrDefault\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Index)",
          "M:Enumerable.Take\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Range)",
          "M:Queryable.ElementAt\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Index)",
          "M:Queryable.ElementAtOrDefault\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Index)",
          "M:Queryable.Take\u003CTSource\u003E(this IQueryable\u003CTSource\u003E,Range)",
          "T:Enumerable",
          "T:Queryable"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45661,
          "Title": "Add analyzer: Call async methods when in an async method",
          "Author": "jeffhandley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-06T21:48:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45661",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767756782",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45661#issuecomment-767756782",
        "FeedbackMarkdown": "* This might be noisy, at least in the runtime repo\r\n* We should run this first so we can see what the noise is to make a determination of on/off by default and severity",
        "TimeCode": 26520000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46843,
          "Title": "Expose setting/getting of system error code",
          "Author": "elinor-fung",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-12T03:14:56+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46843",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767762870",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46843#issuecomment-767762870",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* The naming of \u0060SetLastWin32Error()\u0060 is unfortunate, because it really sets the last P/Invoke error, regardless of OS but it matches the existing method name. Let\u0027s just obsolete the current concept and add a new pair. This also makes people aware of the conceptual difference between \u0060GetLastSystemError()\u0060 and \u0060GetLastPInvokeError()\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class Marshal\r\n    {\r\n        public static int GetLastSystemError();\r\n        public static void SetLastSystemError(int error);\r\n\r\n        public static int GetLastPInvokeError();\r\n        public static void SetLastPInvokeError(int error);\r\n\r\n        [Obsolete(\u0022Use GetLastSystemError() or GetLastPInvokeError()\u0022, DiagnosticId=\u0022\u003CNextID\u003E\u0022, UrlFormat=\u0022\u003Cthe proper URL\u003E\u0022)]\r\n        public static int GetLastWin32Error();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 30760000000,
        "Apis": [
          "M:Marshal.GetLastPInvokeError()",
          "M:Marshal.GetLastSystemError()",
          "M:Marshal.GetLastWin32Error()",
          "M:Marshal.SetLastPInvokeError(int)",
          "M:Marshal.SetLastSystemError(int)",
          "T:Marshal"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27183,
          "Title": "Non-enumerating Count Linq Method",
          "Author": "TylerBrinkley",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-21T13:41:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27183",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767765647",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27183#issuecomment-767765647",
        "FeedbackMarkdown": "* The concept makes sense but it seems nicer as an extension method\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static class Enumerable\r\n    {\r\n        public static bool TryGetNonEnumeratedCount(this IEnumerable\u003CT\u003E source, out int count);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 36780000000,
        "Apis": [
          "M:Enumerable.TryGetNonEnumeratedCount(this IEnumerable\u003CT\u003E,out int)",
          "T:Enumerable"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27449,
          "Title": "IEnumerable should have a extension for creating fixed size chunks",
          "Author": "inputfalken",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-09-22T16:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27449",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-26T00:00:00-08:00",
        "FeedbackId": "767791986",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27449#issuecomment-767791986",
        "FeedbackMarkdown": "* Looks good as proposed, but: does this need to be on \u0060IQuerable\u003CT\u003E\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static class Enumerable\r\n    {\r\n        public static IEnumerable\u003CT[]\u003E Chunk(this IEnumerable\u003CT\u003E source, int size);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39700000000,
        "Apis": [
          "M:Enumerable.Chunk(this IEnumerable\u003CT\u003E,int)",
          "T:Enumerable"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ynpmIT-DlO0",
      "StartDateTime": "2021-01-28T10:07:25-08:00",
      "EndDateTime": "2021-01-28T11:57:36-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ynpmIT-DlO0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35626,
          "Title": "Proposal: Vector.Sum(Vector\u003CT\u003E) API for horizontal add",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-29T20:32:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35626",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769276218",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35626#issuecomment-769276218",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static partial class Vector\r\n    {\r\n        public static T Sum\u003CT\u003E(Vector\u003CT\u003E vector) where T : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Vector.Sum\u003CT\u003E(Vector\u003CT\u003E)",
          "T:Vector"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36469,
          "Title": "Consider adding SingleToUInt32Bits(float value) to BitConverter",
          "Author": "pgovind",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-14T19:37:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36469",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769282102",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36469#issuecomment-769282102",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class BitConverter\r\n    {\r\n        public static unsafe ulong DoubleToUInt64Bits(double value);\r\n        public static unsafe double UInt64BitsToDouble(ulong value);\r\n\r\n        public static unsafe ushort HalfToUInt16Bits(Half value);\r\n        public static unsafe Half UInt16BitsToHalf(ushort value);\r\n\r\n        public static unsafe uint SingleToUInt32Bits(float value);\r\n        public static unsafe float UInt32BitsToSingle(uint value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3010000000,
        "Apis": [
          "M:BitConverter.DoubleToUInt64Bits(double)",
          "M:BitConverter.HalfToUInt16Bits(Half)",
          "M:BitConverter.SingleToUInt32Bits(float)",
          "M:BitConverter.UInt16BitsToHalf(ushort)",
          "M:BitConverter.UInt32BitsToSingle(uint)",
          "M:BitConverter.UInt64BitsToDouble(ulong)",
          "T:BitConverter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43135,
          "Title": "Expose RoundUpToPowerOf2 from BitOperations and optimize it",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-07T09:51:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43135",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769289340",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43135#issuecomment-769289340",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static class BitOperations\r\n    {\r\n        public static uint RoundUpToPowerOf2(uint i);\r\n        public static ulong RoundUpToPowerOf2(ulong i);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14940000000,
        "Apis": [
          "M:BitOperations.RoundUpToPowerOf2(uint)",
          "M:BitOperations.RoundUpToPowerOf2(ulong)",
          "T:BitOperations"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46467,
          "Title": "Add APIs to make nint \u0026 nuint match Int32 and Int64",
          "Author": "Cyl18",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-30T14:57:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46467",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769292235",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46467#issuecomment-769292235",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public class IntPtr\r\n    {\r\n        public static IntPtr Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out IntPtr result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider? provider, out IntPtr result);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default, IFormatProvider? provider = null);\r\n    }\r\n    public partial class UIntPtr\r\n    {\r\n        public static UIntPtr Parse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style = NumberStyles.Integer, IFormatProvider? provider = null);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out UIntPtr result);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, NumberStyles style, IFormatProvider? provider, out UIntPtr result);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default, IFormatProvider? provider = null);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16460000000,
        "Apis": [
          "M:IntPtr.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider?)",
          "M:IntPtr.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:IntPtr.TryParse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider?,out IntPtr)",
          "M:IntPtr.TryParse(ReadOnlySpan\u003Cchar\u003E,out IntPtr)",
          "M:UIntPtr.Parse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider?)",
          "M:UIntPtr.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:UIntPtr.TryParse(ReadOnlySpan\u003Cchar\u003E,NumberStyles,IFormatProvider?,out UIntPtr)",
          "M:UIntPtr.TryParse(ReadOnlySpan\u003Cchar\u003E,out UIntPtr)",
          "T:IntPtr",
          "T:UIntPtr"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36391,
          "Title": "Developers can get immediate feedback on validation problems",
          "Author": "HaoK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-03T18:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36391",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Options",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769300115",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36391#issuecomment-769300115",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* \u0060ValidateAnnotationsEagerly\u0060 should be \u0060ValidateDataAnnotationsEagerly\u0060 to be a suffix of the existing APIs\r\n* Why do we need both \u0060ValidateEagerly\u0060 and \u0060ValidateDataAnnotationsEagerly\u0060?\r\n    - We concluded we only need \u0060ValidateEagerly\u0060 for now\r\n* Is \u0060Eagerly\u0060 the right term here? I think we\u0027d prefer \u0060OnStartup\u0060 Any opinions @davidfowl?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static class OptionsBuilderDataAnnotationsExtensions\r\n    {\r\n    //  Already exists:\r\n    //  public static OptionsBuilder\u003CTOptions\u003E ValidateDataAnnotations\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E optionsBuilder) where TOptions : class;\r\n        public static OptionsBuilder\u003CTOptions\u003E ValidateOnStartup\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E optionsBuilder) where TOptions : class;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 19790000000,
        "Apis": [
          "M:OptionsBuilderDataAnnotationsExtensions.ValidateOnStartup\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E)",
          "T:OptionsBuilderDataAnnotationsExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45851,
          "Title": "Refering to unknown platform names should result in warnings ",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-13T22:35:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45851",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769312213",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45851#issuecomment-769312213",
        "FeedbackMarkdown": "The severity should be a warning and on by-default. It seems this can\u0027t produce false positives, especially with the escape mechanism of adding a net-new platform via the \u0060SupportedPlatform\u0060 item group in the project file. /cc @marek-safar",
        "TimeCode": 28450000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43971,
          "Title": "[Platform Compatibility Analyzer] Nested APIs shouldn\u0027t be allowed to expand the platform set",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-15T05:37:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43971",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769319631",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43971#issuecomment-769319631",
        "FeedbackMarkdown": "Makes sense. Two thoughts:\r\n\r\n1. Should be a warning and on by-default.\r\n2. The analyzer today can only handle an API coming and going out of support. In principle, there is nothing ill-defined about an API being re-supported after it went out of support, but that seems rare. It feels OK to treat this as a warning until we need to support it.",
        "TimeCode": 40370000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27449,
          "Title": "IEnumerable should have a extension for creating fixed size chunks",
          "Author": "inputfalken",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-09-22T16:14:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27449",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769321329",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27449#issuecomment-769321329",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* Note: Every time we add a member to \u0060Enumerable\u0060 that returns \u0060IEnumerable\u003CT\u003E\u0060 we need to add a corresponding member on \u0060Queryable\u0060 that returns \u0060IQueryable\u003CT\u003E\u0060 (and we do have a test for that)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static class Enumerable\r\n    {\r\n        public static IEnumerable\u003CT[]\u003E Chunk(this IEnumerable\u003CT\u003E source, int size);\r\n    }\r\n    public static class Queryable\r\n    {\r\n        public static IQueryable\u003CT[]\u003E Chunk(this IQueryable\u003CT\u003E source, int size);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48780000000,
        "Apis": [
          "M:Enumerable.Chunk(this IEnumerable\u003CT\u003E,int)",
          "M:Queryable.Chunk(this IQueryable\u003CT\u003E,int)",
          "T:Enumerable",
          "T:Queryable"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27687,
          "Title": "Add Enumerable.*By operators (DistinctBy, ExceptBy, IntersectBy, UnionBy, MinBy, MaxBy)",
          "Author": "GSPP",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-10-21T12:54:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27687",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-01-28T00:00:00-08:00",
        "FeedbackId": "769339626",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27687#issuecomment-769339626",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n* We should make sure the parameter names\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public static class Enumerable\r\n    {\r\n        public static IEnumerable\u003CTSource\u003E DistinctBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TKey\u003E keySelector);\r\n        public static IEnumerable\u003CTSource\u003E DistinctBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TKey\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n        \r\n        public static IEnumerable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector);\r\n        public static IEnumerable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IEnumerable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTKey\u003E second, Func\u003CTSource, TKey\u003E keySelectorFirst);\r\n        public static IEnumerable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTKey\u003E second, Func\u003CTSource, TKey\u003E keySelectorFirst, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IEnumerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector);\r\n        public static IEnumerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IEnumerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTKey\u003E second, Func\u003CTSource, TKey\u003E keySelectorFirst);\r\n        public static IEnumerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTKey\u003E second, Func\u003CTSource, TKey\u003E keySelectorFirst, IEqualityComparer\u003CTKey\u003E? comparer);\r\n        \r\n        public static IEnumerable\u003CTSource\u003E UnionBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector);\r\n        public static IEnumerable\u003CTSource\u003E UnionBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E first, IEnumerable\u003CTSource\u003E second, Func\u003CTSource, TKey\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n        \r\n        public static TSource MinBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TResult\u003E selector);\r\n        public static TSource MinBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TResult\u003E selector, IComparer\u003CTResult\u003E? comparer);\r\n        \r\n        public static TSource MaxBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TResult\u003E selector);\r\n        public static TSource MaxBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, TResult\u003E selector, IComparer\u003CTResult\u003E? comparer);\r\n        \r\n        // Missing min \u0026 max overloads accepting custom comparers added for completeness\r\n        public static TResult Min\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, IComparer\u003CTResult\u003E? comparer);\r\n        public static TResult Max\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E source, IComparer\u003CTResult\u003E? comparer);\r\n    }\r\n    public static class Queryable\r\n    {\r\n        public static IQueryable\u003CTSource\u003E DistinctBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector);\r\n        public static IQueryable\u003CTSource\u003E DistinctBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IQueryable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector);\r\n        public static IQueryable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IQueryable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTKey\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelectorFirst);\r\n        public static IQueryable\u003CTSource\u003E ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTKey\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelectorFirst, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IQueryable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector);\r\n        public static IQueryable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IQuerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IQuerable\u003CTSource\u003E source1, IEnumerable\u003CTKey\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelectorFirst);\r\n        public static IQuerable\u003CTSource\u003E IntersectBy\u003CTSource, TKey\u003E(this IQuerable\u003CTSource\u003E source1, IEnumerable\u003CTKey\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelectorFirst, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static IQueryable\u003CTSource\u003E UnionBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector);\r\n        public static IQueryable\u003CTSource\u003E UnionBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E source1, IEnumerable\u003CTSource\u003E source2, Expression\u003CFunc\u003CTSource, TKey\u003E\u003E keySelector, IEqualityComparer\u003CTKey\u003E? comparer);\r\n\r\n        public static TSource MinBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TResult\u003E\u003E selector);\r\n        public static TSource MinBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TResult\u003E\u003E selector, IComparer\u003CTResult\u003E? comparer);\r\n\r\n        public static TSource MaxBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TResult\u003E\u003E selector);\r\n        public static TSource MaxBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, Expression\u003CFunc\u003CTSource, TResult\u003E\u003E selector, IComparer\u003CTResult\u003E? comparer);\r\n\r\n        // Missing min \u0026 max overloads accepting custom comparers added for completeness\r\n        public static TResult Min\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, IComparer\u003CTResult\u003E? comparer);\r\n        public static TResult Max\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E source, IComparer\u003CTResult\u003E? comparer);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50530000000,
        "Apis": [
          "M:Enumerable.DistinctBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.DistinctBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Enumerable.ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Enumerable.ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.ExceptBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Enumerable.IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Enumerable.IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.IntersectBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Enumerable.Max\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,IComparer\u003CTResult\u003E?)",
          "M:Enumerable.MaxBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TResult\u003E,IComparer\u003CTResult\u003E?)",
          "M:Enumerable.MaxBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TResult\u003E)",
          "M:Enumerable.Min\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,IComparer\u003CTResult\u003E?)",
          "M:Enumerable.MinBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TResult\u003E,IComparer\u003CTResult\u003E?)",
          "M:Enumerable.MinBy\u003CTSource, TResult\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, TResult\u003E)",
          "M:Enumerable.UnionBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Enumerable.UnionBy\u003CTSource, TKey\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E)",
          "M:Queryable.DistinctBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.DistinctBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "M:Queryable.ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "M:Queryable.ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.ExceptBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "M:Queryable.IntersectBy\u003CTSource, TKey\u003E(this IQuerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.IntersectBy\u003CTSource, TKey\u003E(this IQuerable\u003CTSource\u003E,IEnumerable\u003CTKey\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "M:Queryable.IntersectBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.IntersectBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "M:Queryable.Max\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,IComparer\u003CTResult\u003E?)",
          "M:Queryable.MaxBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TResult\u003E\u003E,IComparer\u003CTResult\u003E?)",
          "M:Queryable.MaxBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TResult\u003E\u003E)",
          "M:Queryable.Min\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,IComparer\u003CTResult\u003E?)",
          "M:Queryable.MinBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TResult\u003E\u003E,IComparer\u003CTResult\u003E?)",
          "M:Queryable.MinBy\u003CTSource, TResult\u003E(this IQueryable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TResult\u003E\u003E)",
          "M:Queryable.UnionBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E,IEqualityComparer\u003CTKey\u003E?)",
          "M:Queryable.UnionBy\u003CTSource, TKey\u003E(this IQueryable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,Expression\u003CFunc\u003CTSource, TKey\u003E\u003E)",
          "T:Enumerable",
          "T:Queryable"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "mecKToY4JaE",
      "StartDateTime": "2021-02-02T11:02:30-08:00",
      "EndDateTime": "2021-02-02T12:19:12-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/mecKToY4JaE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31350,
          "Title": "Add ConcurrentDictionary.Comparer property",
          "Author": "mikernet",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-30T21:25:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31350",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-02T00:00:00-08:00",
        "FeedbackId": "771899948",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31350#issuecomment-771899948",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Concurrent\r\n{\r\n    public partial class ConcurrentDictionary\u003CTKey, TValue\u003E\r\n    {\r\n        public IEqualityComparer\u003CTKey\u003E Comparer { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:ConcurrentDictionary\u003CTKey, TValue\u003E.Comparer",
          "T:ConcurrentDictionary\u003CTKey, TValue\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 822,
          "Title": "Align API surface of immutable collections and their corresponding builder types",
          "Author": "reflectronic",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-13T00:50:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/822",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-02T00:00:00-08:00",
        "FeedbackId": "771917845",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/822#issuecomment-771917845",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - Note: this is just syncing builder and immutable container, no API innovation happened here\r\n* We should consider adding a unit test to make sure we keep API surface in sync between the builder and the immutable container\r\n* We removed \u0060Reverse\u0060 due to a source breaking change concern. We should follow up. We believe the concern is very low.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Immutable\r\n{\r\n    public struct ImmutableArray\u003CT\u003E\r\n    {\r\n        public ImmutableArray\u003CT\u003E AddRange(params T[] items);\r\n        public ImmutableArray\u003CT\u003E AddRange(T[] items, int length);\r\n        public ImmutableArray\u003CT\u003E AddRange\u003CTDerived\u003E(TDerived[] items) where TDerived : T;\r\n        public ImmutableArray\u003CT\u003E AddRange(ImmutableArray\u003CT\u003E items, int length);\r\n        public ImmutableArray\u003CT\u003E AddRange\u003CTDerived\u003E(ImmutableArray\u003CTDerived\u003E items) where TDerived : T;\r\n        public partial class Builder\r\n        { \r\n            public void CopyTo(T[] destination);\r\n            public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length);\r\n        \r\n            public int IndexOf(T item, int startIndex, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void InsertRange(int index, IEnumerable\u003CT\u003E items);\r\n            public void InsertRange(int index, ImmutableArray\u003CT\u003E items);\r\n            public void Replace(T oldValue, T newValue);\r\n            public void Replace(T oldValue, T newValue, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void Remove(T item, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void RemoveRange(int index, int length);\r\n            public void RemoveRange(IEnumerable\u003CT\u003E items);\r\n            public void RemoveRange(IEnumerable\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void RemoveAll(Predicate\u003CT\u003E match);\r\n        }\r\n    }\r\n    public partial class ImmutableList\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        { \r\n            public void Remove(T value, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void RemoveRange(int index, int count);\r\n            public void RemoveRange(IEnumerable\u003CT\u003E items);\r\n            public void RemoveRange(IEnumerable\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n            public void Replace(T oldValue, T newValue);\r\n            public void Replace(T oldValue, T newValue, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n        }        \r\n    }\r\n    public partial class ImmutableSortedSet\u003CT\u003E\r\n    {\r\n        public partial class Builder\r\n        { \r\n            public int IndexOf(T item);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3540000000,
        "Apis": [
          "M:ImmutableArray\u003CT\u003E.AddRange(ImmutableArray\u003CT\u003E,int)",
          "M:ImmutableArray\u003CT\u003E.AddRange(params T[])",
          "M:ImmutableArray\u003CT\u003E.AddRange(T[],int)",
          "M:ImmutableArray\u003CT\u003E.AddRange\u003CTDerived\u003E(ImmutableArray\u003CTDerived\u003E)",
          "M:ImmutableArray\u003CT\u003E.AddRange\u003CTDerived\u003E(TDerived[])",
          "M:ImmutableArray\u003CT\u003E.Builder.CopyTo(int,T[],int,int)",
          "M:ImmutableArray\u003CT\u003E.Builder.CopyTo(T[])",
          "M:ImmutableArray\u003CT\u003E.Builder.IndexOf(T,int,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Builder.InsertRange(int,IEnumerable\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.InsertRange(int,ImmutableArray\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.Remove(T,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Builder.RemoveAll(Predicate\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.RemoveRange(IEnumerable\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Builder.RemoveRange(IEnumerable\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.RemoveRange(int,int)",
          "M:ImmutableArray\u003CT\u003E.Builder.Replace(T,T,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Builder.Replace(T,T)",
          "M:ImmutableList\u003CT\u003E.Builder.Remove(T,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableList\u003CT\u003E.Builder.RemoveRange(IEnumerable\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableList\u003CT\u003E.Builder.RemoveRange(IEnumerable\u003CT\u003E)",
          "M:ImmutableList\u003CT\u003E.Builder.RemoveRange(int,int)",
          "M:ImmutableList\u003CT\u003E.Builder.Replace(T,T,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableList\u003CT\u003E.Builder.Replace(T,T)",
          "M:ImmutableSortedSet\u003CT\u003E.Builder.IndexOf(T)",
          "T:ImmutableArray\u003CT\u003E",
          "T:ImmutableArray\u003CT\u003E.Builder",
          "T:ImmutableList\u003CT\u003E",
          "T:ImmutableList\u003CT\u003E.Builder",
          "T:ImmutableSortedSet\u003CT\u003E",
          "T:ImmutableSortedSet\u003CT\u003E.Builder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33765,
          "Title": "Pass number of bytes to Buffer.BlockCopy",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33765",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-02T00:00:00-08:00",
        "FeedbackId": "771928647",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33765#issuecomment-771928647",
        "FeedbackMarkdown": "* On by default as warning seems reasonable, given the scoped nature\r\n* Adding a fixer that offers to multiply the length or call \u0060Array.Copy\u0060 instead",
        "TimeCode": 11280000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33778,
          "Title": "Prefer string.AsSpan over string.Substring",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33778",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-02T00:00:00-08:00",
        "FeedbackId": "771935014",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33778#issuecomment-771935014",
        "FeedbackMarkdown": "* On by default as info seems fine",
        "TimeCode": 27110000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33779,
          "Title": "Use Span.SequenceEquals instead of open-coded comparison loops",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33779",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-02T00:00:00-08:00",
        "FeedbackId": "771948766",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33779#issuecomment-771948766",
        "FeedbackMarkdown": "* We believe detecting open-ended for loops is too expensive and generally not worth it\r\n* It seems detecting usages of \u0060Equals\u0060 with arrays might be worth flagging\r\n* Should we have an analzyer that detects \u0060SequenceEquals\u0060 with two arrays and suggests \u0060AsSpan()\u0060\r\n* Should we add an SZ member for \u0060SequenceEquals\u0060 that by-passes \u0060Enumerable.SequenceEquals\u0060 implementation? Or an extension method?\r\n* And/or should we add a type check for \u0060Enumerable.SequenceEquals\u0060 that does a type check and uses span\u0027s implementation if both arguments are arrays?",
        "TimeCode": 32480000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40099,
          "Title": "Should we add support to ignore cycles on serialization?",
          "Author": "Jozkee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-29T19:17:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40099",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773497284",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40099#issuecomment-773497284",
        "FeedbackMarkdown": "Changed to plural via email:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class ReferenceHandler\r\n    {   \r\n        // Existing:\r\n        // public static ReferenceHandler Preserve { get; }\r\n        public static ReferenceHandler IgnoreCycles { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:ReferenceHandler.IgnoreCycles",
          "T:ReferenceHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36391,
          "Title": "Developers can get immediate feedback on validation problems",
          "Author": "HaoK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-03T18:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36391",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Options",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773514511",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36391#issuecomment-773514511",
        "FeedbackMarkdown": "* Let\u0027s drop the \u0060new()\u0060 constraint? The existing \u0060OptionsBuilderDataAnnotationsExtensions.ValidateDataAnnotations()\u0060 method doesn\u0027t have it.\r\n* We considered existing types in that namespace but we don\u0027t think there is an appropriate home for this.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public static class OptionsBuilderValidationExtensions\r\n    {\r\n        public static OptionsBuilder\u003CTOptions\u003E ValidateOnStart\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E optionsBuilder) where TOptions : class;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:OptionsBuilderValidationExtensions.ValidateOnStart\u003CTOptions\u003E(this OptionsBuilder\u003CTOptions\u003E)",
          "T:OptionsBuilderValidationExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33797,
          "Title": "Don\u0027t guard Dictionary\u003CK, V\u003E.Remove(key) by ContainsKey(key)",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33797",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773517917",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33797#issuecomment-773517917",
        "FeedbackMarkdown": "* Makes sense.\r\n\r\nWe could further improve the fixer to handle this as well:\r\n\r\n\u0060\u0060\u0060C#\r\n// Before\r\nif (data.ContainsKey(key))\r\n{\r\n    data.Remove(key);\r\n    SomeUnrelatedCode();\r\n}\r\n// After\r\nif (data.Remove(key))\r\n{\r\n    SomeUnrelatedCode();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nBut it\u0027s not necessary -- we can start simple and take it from there.",
        "TimeCode": 13790000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33798,
          "Title": "Prefer Dictionary\u003CK, V\u003E.TryGetValue() over guarded indexer access",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33798",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773519610",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33798#issuecomment-773519610",
        "FeedbackMarkdown": "* Looks good\r\n* This is related to #33797 and #33799. We should make sure these  analyzers don\u0027t fight with each other. We might want to put them in the same analyzer and decide which diagnostic is the most appropriate one to raise. They could still generate different IDs.",
        "TimeCode": 17210000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33799,
          "Title": "Prefer Dictionary\u003CK, V\u003E.TryAddValue(key) over guarded Add(key)",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33799",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773520822",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33799#issuecomment-773520822",
        "FeedbackMarkdown": "* Looks good\r\n* Please consider the comment [here](https://github.com/dotnet/runtime/issues/33798#issuecomment-773519610).",
        "TimeCode": 19030000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33806,
          "Title": "Do not call Task.WhenAll with a single argument",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33806",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773522446",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33806#issuecomment-773522446",
        "FeedbackMarkdown": "* Makes sense, but we shouldn\u0027t use \u0060Wait()\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\nasync Task M(Task task)\r\n{\r\n    // Before\r\n    await Task.WhenAll(task);\r\n\r\n    // After\r\n    await task;\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20120000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33807,
          "Title": "Do not call Task.WaitAll with a single argument",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33807",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773524589",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33807#issuecomment-773524589",
        "FeedbackMarkdown": "* Makes sense\r\n\r\n\u0060\u0060\u0060C#\r\nvoid M(Task task)\r\n{\r\n    // Before\r\n    Task.WaitAll(task);\r\n\r\n    // After\r\n    task.Wait();\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22040000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33809,
          "Title": "Use CancellationToken.ThrowIfCancellationRequested",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33809",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773527472",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33809#issuecomment-773527472",
        "FeedbackMarkdown": "* Looks good\r\n* We should only suggest this for \u0060OperationCanceledException\u0060, not \u0060TaskCanceledException\u0060 because \u0060ThrowIfCancellationRequested\u0060 throws the former.",
        "TimeCode": 23700000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45552,
          "Title": "Consider using String.Equals instead of String.Compare",
          "Author": "xtqqczze",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-20T14:41:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45552",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45552#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 26800000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47180,
          "Title": "Use String.Contains(char) instead of String.Contains(String)",
          "Author": "xtqqczze",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-20T18:39:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47180",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773532249",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47180#issuecomment-773532249",
        "FeedbackMarkdown": "* Makes sense\r\n* Is this the only overload that we should do this for?",
        "TimeCode": 29680000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47163,
          "Title": "Obsolete Socket.UseOnlyOverlappedIO",
          "Author": "antonfirsov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-19T13:22:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47163",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773535418",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47163#issuecomment-773535418",
        "FeedbackMarkdown": "* Looks good\r\n* It feels over-engineered to add a diagnostic ID to this obsoletion\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    public partial class Socket\r\n    {\r\n        [Obsolete]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public bool UseOnlyOverlappedIO { get; set; }\r\n    }\r\n    public partial enum SocketInformationOptions\r\n    {\r\n        [Obsolete]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        UseOnlyOverlappedIO = 8,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31620000000,
        "Apis": [
          "F:SocketInformationOptions.UseOnlyOverlappedIO",
          "P:Socket.UseOnlyOverlappedIO",
          "T:Socket",
          "T:SocketInformationOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35284,
          "Title": "New overload for ServiceController.Stop()",
          "Author": "Fs00",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-22T14:07:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35284",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.ServiceProcess",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773539215",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35284#issuecomment-773539215",
        "FeedbackMarkdown": "* Looks good\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.ServiceProcess\r\n{\r\n    public partial class ServiceController\r\n    {\r\n        public void Stop(bool stopDependentServices)\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34940000000,
        "Apis": [
          "M:ServiceController.Stop(bool)",
          "T:ServiceController"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35602,
          "Title": "KeyValuePair\u003CTKey, TValue\u003E should implement IEquatable\u003CT\u003E",
          "Author": "znakeeye",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-29T12:28:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35602",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773543902",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35602#issuecomment-773543902",
        "FeedbackMarkdown": "* We believe @jkotas concerns outweighs the (minor) benefit of adding this API.",
        "TimeCode": 38940000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 38657,
          "Title": "IEnumerable\u003CT\u003E for XmlNodeList",
          "Author": "TobiasKnauss",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-01T05:15:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/38657",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Xml",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773546109",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/38657#issuecomment-773546109",
        "FeedbackMarkdown": "* This wouldn\u0027t help the general \u0060foreach\u0060 case due to the pattern-matched \u0060GetEnumerator()\u0060 method\r\n* This would only help the Linq case\r\n* It general, it feels like a losing battle to trying to enrich technologies built on non-generic collections implement generic collection interfaces",
        "TimeCode": 43530000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43748,
          "Title": "Enhance FileSystemEnumerable to track depth recursion",
          "Author": "iSazonov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-23T04:00:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43748",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773553629",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43748#issuecomment-773553629",
        "FeedbackMarkdown": "* We should \u0060int\u0060\r\n* The default value should be \u0060int.MaxValue\u0060. It seems \u00600\u0060 should just mean don\u0027t recurse at all, rather than no limit.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public partial class EnumerationOptions\r\n    {\r\n        public int MaxRecursionDepth { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45940000000,
        "Apis": [
          "P:EnumerationOptions.MaxRecursionDepth",
          "T:EnumerationOptions"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46255,
          "Title": "string.Join with ReadOnlySpan values parameter",
          "Author": "ladeak",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-19T19:10:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46255",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-04T00:00:00-08:00",
        "FeedbackId": "773560782",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46255#issuecomment-773560782",
        "FeedbackMarkdown": "* Since one can\u0027t stackalloc spans with reference types the value of this API feels low and the existing overload with \u0060IEnumerable\u003CT\u003E\u0060 supports Linq-style slicing\r\n* We may want to revisit this based on where the language is going, but for now let\u0027s not add this API.\r\n* The scenario is definitely interesting. @GrabYourPitchforks any thoughts?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class String\r\n    {\r\n        public static string Join(char separator, ReadOnlySpan\u003Cstring?\u003E values);\r\n        public static string Join(string? separator, ReadOnlySpan\u003Cstring?\u003E values);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54000000000,
        "Apis": [
          "M:String.Join(char,ReadOnlySpan\u003Cstring?\u003E)",
          "M:String.Join(string?,ReadOnlySpan\u003Cstring?\u003E)",
          "T:String"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "7bRCbwE9CYE",
      "StartDateTime": "2021-02-09T10:04:53-08:00",
      "EndDateTime": "2021-02-09T11:10:30-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/7bRCbwE9CYE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47880,
          "Title": "More performant overloads for Graphics.GetContextInfo",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-04T22:59:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47880",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776141547",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47880#issuecomment-776141547",
        "FeedbackMarkdown": "* The existing \u0060GetContextInfo()\u0060 is hidden from IntelliSense. We should mark it as \u0060[Obsolete]\u0060 and point people to the new APIs, at the off chance that someone is using the old one.\r\n* Otherwise, looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    public sealed class Graphics\r\n    {\r\n        [Obsolete(\u0022Use one of the other overloads.\u0022)]\r\n        public object GetContextInfo();\r\n        public void GetContextInfo(out PointF offset);\r\n        public void GetContextInfo(out PointF offset, out Region clip);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Graphics.GetContextInfo()",
          "M:Graphics.GetContextInfo(out PointF,out Region)",
          "M:Graphics.GetContextInfo(out PointF)",
          "T:Graphics"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4338,
          "Title": "Add IDeviceContext overloads to ControlPaint",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-08T21:30:41+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4338",
          "Milestone": ".NET 7.0",
          "Labels": [
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Improve performance, flag performance regressions across core releases"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776147268",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4338#issuecomment-776147268",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class ControlPaint\r\n    {\r\n        public static void DrawBorder(IDeviceContext deviceContext, Rectangle bounds, Color color, ButtonBorderStyle style);\r\n        public static void DrawBorder(IDeviceContext deviceContext, Rectangle bounds, Color leftColor, int leftWidth, ButtonBorderStyle leftStyle, Color topColor, int topWidth, ButtonBorderStyle topStyle, Color rightColor, int rightWidth, ButtonBorderStyle rightStyle, Color bottomColor, int bottomWidth, ButtonBorderStyle bottomStyle);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, int x, int y, int width, int height);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, int x, int y, int width, int height, Border3DStyle style);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, int x, int y, int width, int height, Border3DStyle style, Border3DSide sides);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, Rectangle rectangle);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, Rectangle rectangle, Border3DStyle style);\r\n        public static void DrawBorder3D(IDeviceContext deviceContext, Rectangle rectangle, Border3DStyle style, Border3DSide sides);\r\n        public static void DrawButton(IDeviceContext deviceContext, int x, int y, int width, int height, ButtonState state);\r\n        public static void DrawButton(IDeviceContext deviceContext, Rectangle rectangle, ButtonState state);\r\n        public static void DrawCaptionButton(IDeviceContext deviceContext, int x, int y, int width, int height, CaptionButton button, ButtonState state);\r\n        public static void DrawCaptionButton(IDeviceContext deviceContext, Rectangle rectangle, CaptionButton button, ButtonState state);\r\n        public static void DrawCheckBox(IDeviceContext deviceContext, int x, int y, int width, int height, ButtonState state);\r\n        public static void DrawCheckBox(IDeviceContext deviceContext, Rectangle rectangle, ButtonState state);\r\n        public static void DrawComboButton(IDeviceContext deviceContext, int x, int y, int width, int height, ButtonState state);\r\n        public static void DrawComboButton(IDeviceContext deviceContext, Rectangle rectangle, ButtonState state);\r\n        public static void DrawContainerGrabHandle(IDeviceContext deviceContext, Rectangle bounds);\r\n        public static void DrawFocusRectangle(IDeviceContext deviceContext, Rectangle rectangle);\r\n        public static void DrawFocusRectangle(IDeviceContext deviceContext, Rectangle rectangle, Color foreColor, Color backColor);\r\n        public static void DrawGrabHandle(IDeviceContext deviceContext, Rectangle rectangle, bool primary, bool enabled);\r\n        public static void DrawGrid(IDeviceContext deviceContext, Rectangle area, Size pixelsBetweenDots, Color backColor);\r\n        public static void DrawLockedFrame(IDeviceContext deviceContext, Rectangle rectangle, bool primary);\r\n        public static void DrawMenuGlyph(IDeviceContext deviceContext, int x, int y, int width, int height, MenuGlyph glyph);\r\n        public static void DrawMenuGlyph(IDeviceContext deviceContext, int x, int y, int width, int height, MenuGlyph glyph, Color foreColor, Color backColor);\r\n        public static void DrawMenuGlyph(IDeviceContext deviceContext, Rectangle rectangle, MenuGlyph glyph);\r\n        public static void DrawMenuGlyph(IDeviceContext deviceContext, Rectangle rectangle, MenuGlyph glyph, Color foreColor, Color backColor);\r\n        public static void DrawMixedCheckBox(IDeviceContext deviceContext, int x, int y, int width, int height, ButtonState state);\r\n        public static void DrawMixedCheckBox(IDeviceContext deviceContext, Rectangle rectangle, ButtonState state);\r\n        public static void DrawRadioButton(IDeviceContext deviceContext, int x, int y, int width, int height, ButtonState state);\r\n        public static void DrawRadioButton(IDeviceContext deviceContext, Rectangle rectangle, ButtonState state);\r\n        public static void DrawScrollButton(IDeviceContext deviceContext, int x, int y, int width, int height, ScrollButton button, ButtonState state);\r\n        public static void DrawScrollButton(IDeviceContext deviceContext, Rectangle rectangle, ScrollButton button, ButtonState state);\r\n        public static void DrawSelectionFrame(IDeviceContext deviceContext, bool active, Rectangle outsideRect, Rectangle insideRect, Color backColor);\r\n        public static void DrawSizeGrip(IDeviceContext deviceContext, Color backColor, int x, int y, int width, int height);\r\n        public static void DrawSizeGrip(IDeviceContext deviceContext, Color backColor, Rectangle bounds);\r\n        public static void DrawVisualStyleBorder(IDeviceContext deviceContext, Rectangle bounds);\r\n\r\n        // Omitted, IDeviceContext doesn\u0027t make sense as this also takes Image\r\n        // public static void DrawImageDisabled(Graphics graphics, Image image, int x, int y, Color background);\r\n\r\n        // Already exists\r\n        // public static void DrawStringDisabled(IDeviceContext deviceContext, string s, Font font, Color color, RectangleF layoutRectangle, StringFormat format);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9860000000,
        "Apis": [
          "M:ControlPaint.DrawBorder(IDeviceContext,Rectangle,Color,ButtonBorderStyle)",
          "M:ControlPaint.DrawBorder(IDeviceContext,Rectangle,Color,int,ButtonBorderStyle,Color,int,ButtonBorderStyle,Color,int,ButtonBorderStyle,Color,int,ButtonBorderStyle)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,int,int,int,int,Border3DStyle,Border3DSide)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,int,int,int,int,Border3DStyle)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,int,int,int,int)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,Rectangle,Border3DStyle,Border3DSide)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,Rectangle,Border3DStyle)",
          "M:ControlPaint.DrawBorder3D(IDeviceContext,Rectangle)",
          "M:ControlPaint.DrawButton(IDeviceContext,int,int,int,int,ButtonState)",
          "M:ControlPaint.DrawButton(IDeviceContext,Rectangle,ButtonState)",
          "M:ControlPaint.DrawCaptionButton(IDeviceContext,int,int,int,int,CaptionButton,ButtonState)",
          "M:ControlPaint.DrawCaptionButton(IDeviceContext,Rectangle,CaptionButton,ButtonState)",
          "M:ControlPaint.DrawCheckBox(IDeviceContext,int,int,int,int,ButtonState)",
          "M:ControlPaint.DrawCheckBox(IDeviceContext,Rectangle,ButtonState)",
          "M:ControlPaint.DrawComboButton(IDeviceContext,int,int,int,int,ButtonState)",
          "M:ControlPaint.DrawComboButton(IDeviceContext,Rectangle,ButtonState)",
          "M:ControlPaint.DrawContainerGrabHandle(IDeviceContext,Rectangle)",
          "M:ControlPaint.DrawFocusRectangle(IDeviceContext,Rectangle,Color,Color)",
          "M:ControlPaint.DrawFocusRectangle(IDeviceContext,Rectangle)",
          "M:ControlPaint.DrawGrabHandle(IDeviceContext,Rectangle,bool,bool)",
          "M:ControlPaint.DrawGrid(IDeviceContext,Rectangle,Size,Color)",
          "M:ControlPaint.DrawLockedFrame(IDeviceContext,Rectangle,bool)",
          "M:ControlPaint.DrawMenuGlyph(IDeviceContext,int,int,int,int,MenuGlyph,Color,Color)",
          "M:ControlPaint.DrawMenuGlyph(IDeviceContext,int,int,int,int,MenuGlyph)",
          "M:ControlPaint.DrawMenuGlyph(IDeviceContext,Rectangle,MenuGlyph,Color,Color)",
          "M:ControlPaint.DrawMenuGlyph(IDeviceContext,Rectangle,MenuGlyph)",
          "M:ControlPaint.DrawMixedCheckBox(IDeviceContext,int,int,int,int,ButtonState)",
          "M:ControlPaint.DrawMixedCheckBox(IDeviceContext,Rectangle,ButtonState)",
          "M:ControlPaint.DrawRadioButton(IDeviceContext,int,int,int,int,ButtonState)",
          "M:ControlPaint.DrawRadioButton(IDeviceContext,Rectangle,ButtonState)",
          "M:ControlPaint.DrawScrollButton(IDeviceContext,int,int,int,int,ScrollButton,ButtonState)",
          "M:ControlPaint.DrawScrollButton(IDeviceContext,Rectangle,ScrollButton,ButtonState)",
          "M:ControlPaint.DrawSelectionFrame(IDeviceContext,bool,Rectangle,Rectangle,Color)",
          "M:ControlPaint.DrawSizeGrip(IDeviceContext,Color,int,int,int,int)",
          "M:ControlPaint.DrawSizeGrip(IDeviceContext,Color,Rectangle)",
          "M:ControlPaint.DrawVisualStyleBorder(IDeviceContext,Rectangle)",
          "T:ControlPaint"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39406,
          "Title": "Expose \u0060System.Drawing.Graphics.NativeGraphics\u0060.",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-16T02:18:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39406",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776150895",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39406#issuecomment-776150895",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    public partial class Graphics\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Graphics FromHandle(IntPtr handle);\r\n    }\r\n    public partial class Brush\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Brush FromHandle(IntPtr handle);\r\n    }\r\n    public partial class Pen\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Pen FromHandle(IntPtr handle);\r\n    }\r\n    public partial class Image\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Image FromHandle(IntPtr handle);\r\n    }\r\n\r\n    public partial class Region\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Region FromHandle(IntPtr handle);\r\n    }\r\n}\r\nnamespace System.Drawing.Drawing2D\r\n{\r\n    public partial class Matrix\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static Matrix FromHandle(IntPtr handle);\r\n    }\r\n\r\n    public partial class GraphicsPath\r\n    {\r\n        public IntPtr Handle { get; }\r\n        public static GraphicsPath FromHandle(IntPtr handle);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15110000000,
        "Apis": [
          "M:Brush.FromHandle(IntPtr)",
          "M:Graphics.FromHandle(IntPtr)",
          "M:GraphicsPath.FromHandle(IntPtr)",
          "M:Image.FromHandle(IntPtr)",
          "M:Matrix.FromHandle(IntPtr)",
          "M:Pen.FromHandle(IntPtr)",
          "M:Region.FromHandle(IntPtr)",
          "P:Brush.Handle",
          "P:Graphics.Handle",
          "P:GraphicsPath.Handle",
          "P:Image.Handle",
          "P:Matrix.Handle",
          "P:Pen.Handle",
          "P:Region.Handle",
          "T:Brush",
          "T:Graphics",
          "T:GraphicsPath",
          "T:Image",
          "T:Matrix",
          "T:Pen",
          "T:Region"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47940,
          "Title": "Add more performant transform APIs in System.Drawing",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-06T01:05:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47940",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776158368",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47940#issuecomment-776158368",
        "FeedbackMarkdown": "* We should add constructors and an instance method to perform the conversions\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    public partial class Graphics\r\n    {\r\n        // Exists:\r\n        // public Matrix Transform { get; set; }\r\n        public Matrix3x2 TransformElements { get; set; }\r\n    }\r\n    public partial struct PointF\r\n    {\r\n        public PointF(Vector2 vector);\r\n        public Vector2 ToVector2();\r\n        public static explicit operator Vector2(PointF point);\r\n        public static explicit operator PointF(Vector2 vector);\r\n    }\r\n    public partial struct SizeF\r\n    {\r\n        public SizeF(Vector2 vector);\r\n        public Vector2 ToVector2();\r\n        public static explicit operator Vector2(SizeF size);\r\n        public static explicit operator SizeF(Vector2 vector);\r\n    }\r\n    public partial struct RectangleF\r\n    {\r\n        public RectangleF(Vector4 vector);\r\n        public Vector4 ToVector4();\r\n        public static explicit operator Vector4(RectangleF rectangle);\r\n        public static explicit operator RectangleF(Vector4 vector);\r\n    }\r\n}\r\nnamespace System.Drawing.Drawing2D\r\n{\r\n    public partial class Matrix\r\n    {\r\n        public Matrix(Matrix3x2 matrix);\r\n        // Exists:\r\n        // public float[] Elements { get; }\r\n        public Matrix3x2 MatrixElements { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18670000000,
        "Apis": [
          "M:Matrix.Matrix(Matrix3x2)",
          "M:PointF.explicit(PointF)",
          "M:PointF.explicit(Vector2)",
          "M:PointF.PointF(Vector2)",
          "M:PointF.ToVector2()",
          "M:RectangleF.explicit(RectangleF)",
          "M:RectangleF.explicit(Vector4)",
          "M:RectangleF.RectangleF(Vector4)",
          "M:RectangleF.ToVector4()",
          "M:SizeF.explicit(SizeF)",
          "M:SizeF.explicit(Vector2)",
          "M:SizeF.SizeF(Vector2)",
          "M:SizeF.ToVector2()",
          "P:Graphics.TransformElements",
          "P:Matrix.MatrixElements",
          "T:Graphics",
          "T:Matrix",
          "T:PointF",
          "T:RectangleF",
          "T:SizeF"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 39443,
          "Title": "Add an Enumerable.Match method",
          "Author": "simon-curtis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-16T15:47:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/39443",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776164437",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/39443#issuecomment-776164437",
        "FeedbackMarkdown": "* Let\u0027s return the raw \u0060List\u003CT\u003E\u0060 because it\u0027s more useful to callers (and we likely can\u0027t change the instance anyway)\r\n* Let\u0027s rename the tuple fields to \u0060Matched\u0060 and \u0060Unmatched\u0060 to make easier to understand\r\n* We should rename the method to \u0060Match\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public partial static class Enumerable\r\n    {\r\n        public static (List\u003CTSource\u003E Matched, List\u003CTSource\u003E Unmatched) Match\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E source, Func\u003CTSource, bool\u003E predicate);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26010000000,
        "Apis": [
          "M:Enumerable.Match\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,Func\u003CTSource, bool\u003E)",
          "T:Enumerable"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45148,
          "Title": "Add IsIPv6UniqueLocal to IPAddress",
          "Author": "huysentruitw",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-24T11:45:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45148",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776169854",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45148#issuecomment-776169854",
        "FeedbackMarkdown": "* We should remove the \u0060Address\u0060 suffix\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net\r\n{\r\n    public partial class IPAddress\r\n    {\r\n        // Existing:\r\n        // public bool IsIPv4MappedToIPv6 { get; }\r\n        // public bool IsIPv6LinkLocal { get; }\r\n        // public bool IsIPv6Multicast { get; }\r\n        // public bool IsIPv6SiteLocal { get; }\r\n        // public bool IsIPv6Teredo { get; }\r\n        public bool IsIPv6UniqueLocal { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31420000000,
        "Apis": [
          "P:IPAddress.IsIPv6UniqueLocal",
          "T:IPAddress"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46988,
          "Title": "Microsoft.Extensions.Configuration App binding adding to the initialized Collections, not replacing ",
          "Author": "Cazzar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-14T15:31:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46988",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776182332",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46988#issuecomment-776182332",
        "FeedbackMarkdown": "* How important is this?\r\n    - This is getting into the realm of the complicated serialization behavior.\r\n    - It seems default values in collections are a bit of fringe behavior.\r\n    - Let\u0027s close it for now until there is more evidence that we need this.\r\n* General feedback:\r\n    - It seems a bit weird to ask developers to make their collections settable; it would be more natural if the binder would call a \u0060Clear()\u0060 method.\r\n    - If the collection implements both \u0060IList\u0060 and is settable, preferring the setter seems reasonable.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public partial class BinderOptions\r\n    {\r\n        // Already exists:\r\n        // public bool BindNonPublicProperties { get; set; }\r\n        public bool OverrideLists { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:BinderOptions.OverrideLists",
          "T:BinderOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46704,
          "Title": "Support customized Activity trace id generation",
          "Author": "lupengamzn",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-07T21:09:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46704",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776187733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46704#issuecomment-776187733",
        "FeedbackMarkdown": "* Let\u0027s name this property \u0060TraceIdGenerator\u0060\r\n* The method will neither throw when it\u0027s set more than once nor when it\u0027s set after an ID was generated. The consumer has to set it early, ideally in main. But if they don\u0027t we\u0027ll honor it next time an ID is generated. It just means that part of the activities may not be processable if the format of the ID is important to them.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Activity\r\n    {\r\n        public static Func\u003CActivityTraceId\u003E? TraceIdGenerator { get; set; } \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:Activity.TraceIdGenerator",
          "T:Activity"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47768,
          "Title": "Add IsMacCatalyst() and IsMacCatalystVersionAtLeast() to System.Runtime",
          "Author": "directhex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-02T15:41:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47768",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-09T00:00:00-08:00",
        "FeedbackId": "776189841",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47768#issuecomment-776189841",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class OperatingSystem\r\n    {\r\n        public static bool IsMacCatalyst();\r\n        public static bool IsMacCatalystVersionAtLeast(int major, int minor = 0, int build = 0);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:OperatingSystem.IsMacCatalyst()",
          "M:OperatingSystem.IsMacCatalystVersionAtLeast(int,int,int)",
          "T:OperatingSystem"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "FiLPzjvfX2c",
      "StartDateTime": "2021-02-10T16:03:57-08:00",
      "EndDateTime": "2021-02-10T17:31:00-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/FiLPzjvfX2c/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 1199,
          "Title": "Task Dialog: Improve hyperlink usage",
          "Author": "kpreisser",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-22T11:03:21+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/1199",
          "Milestone": ".NET 7.0",
          "Labels": [
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-11T00:00:00-08:00",
        "FeedbackId": "777151783",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/1199#issuecomment-777151783",
        "FeedbackMarkdown": "* \u0060LinkId\u0060 is a bit weird because ID implies some sort of opaque identifier that the developer have to map to something whereas it\u0027s really the value of the \u0060href\u0060 attribute. If you want to avoid the web naming conventions, I suggest something like \u0060LinkTarget\u0060.\r\n* It feels a bit heavy handed in the unassisted scenario having to derive from the page. It seems easier if \u0060TaskDialogPage\u0060 would offer an event. Creating types is a fairly heavy operation and can\u0027t be done inside a method whereas an event can be subscribed to with a local function or lambda expression.\r\n* We should either consistently use \u0022hyperlink\u0022 or \u0022link\u0022. We\u0027d prefer \u0022link\u0022 because \u0022hyperlink\u0022 doesn\u0027t feel like UI but more like HTML.\r\n* It seems you\u0027ll always need the unassisted model (for cases where the number of links isn\u0027t statically known). It also seems the result with factory methods wouldn\u0027t be easily toolable in the designer. It feels easier to just say the page/dialog has a \u0060LinkClicked\u0060 event that provides the link target in the event args and not have \u0060TaskDialogLink\u0060 class at all.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public class TaskDialogLink\r\n    {\r\n        public event EventHandler Click;\r\n        public string Text { get; }\r\n        public override string ToString();\r\n    }\r\n    public class TaskDialogLinkClickedEventArgs : EventArgs\r\n    {\r\n        public string LinkTarget { get; }\r\n    }\r\n    public partial class TaskDialogPage\r\n    {\r\n       protected bool EnableLinks { get; set; }\r\n       public TaskDialogLink CreateLink(string text);\r\n       protected virtual void OnLinkClicked(TaskDialogLinkClickedEventArgs e);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:TaskDialogLink.ToString()",
          "M:TaskDialogPage.CreateLink(string)",
          "M:TaskDialogPage.OnLinkClicked(TaskDialogLinkClickedEventArgs)",
          "P:TaskDialogLink.Text",
          "P:TaskDialogLinkClickedEventArgs.LinkTarget",
          "P:TaskDialogPage.EnableLinks",
          "T:TaskDialogLink",
          "T:TaskDialogLinkClickedEventArgs",
          "T:TaskDialogPage"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "MFUXZLyDqbU",
      "StartDateTime": "2021-02-16T10:04:44-08:00",
      "EndDateTime": "2021-02-16T12:21:10-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/MFUXZLyDqbU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45689,
          "Title": "Add runtime API to load Hot Reload deltas",
          "Author": "lambdageek",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-07T18:26:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45689",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780028743",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45689#issuecomment-780028743",
        "FeedbackMarkdown": "* It\u0027s not a mainline API, but it\u0027s logically similar to the existing \u0060TryGetRawMetadata()\u0060\r\n* However, we don\u0027t believe this should be an extension method because most people would never need it\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    public static partial class AssemblyExtensions\r\n    {\r\n        public static void ApplyUpdate(Assembly assembly, ReadOnlySpan\u003Cbyte\u003E metadataDelta, ReadOnlySpan\u003Cbyte\u003E ilDelta, ReadOnlySpan\u003Cbyte\u003E pdbDelta = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AssemblyExtensions.ApplyUpdate(Assembly,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "T:AssemblyExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47990,
          "Title": "Provide a way to get a PipeReader from a \u0060ReadOnlySequence\u003Cbyte\u003E\u0060",
          "Author": "Alxandr",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-08T10:12:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47990",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780034307",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47990#issuecomment-780034307",
        "FeedbackMarkdown": "* We could also overloads to create a reader straight from a \u0060byte[]\u0060 or \u0060ReadOnlyMemory\u003Cbyte\u003E\u0060 but those can be constructed by creating a sequence, so we can add them later if we think that\u0027s common enough.\r\n* We don\u0027t believe this method needs any options\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipelines\r\n{\r\n    public abstract class PipeReader\r\n    {\r\n        public static PipeReader Create(ReadOnlySequence\u003Cbyte\u003E sequence);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10710000000,
        "Apis": [
          "M:PipeReader.Create(ReadOnlySequence\u003Cbyte\u003E)",
          "T:PipeReader"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24897,
          "Title": "Improve performance of Rfc2898DeriveBytes",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-02T20:12:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24897",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780044973",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24897#issuecomment-780044973",
        "FeedbackMarkdown": "* Let\u0027s drop the name \u0060DeriveBytes\u0060 from the method name because it doesn\u0027t really add anything\r\n* We considered a separate type but it seems the difference is streaming vs non-streaming and static vs non-static seems to convey is sufficiently.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class Rfc2898DeriveBytes\r\n    {\r\n        public static byte[] Pbkdf2(\r\n            byte[] password,\r\n            byte[] salt,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm,\r\n            int outputLength);\r\n\r\n        public static byte[] Pbkdf2(\r\n            ReadOnlySpan\u003Cbyte\u003E password,\r\n            ReadOnlySpan\u003Cbyte\u003E salt,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm,\r\n            int outputLength);\r\n\r\n        public static void Pbkdf2(\r\n            ReadOnlySpan\u003Cbyte\u003E password,\r\n            ReadOnlySpan\u003Cbyte\u003E salt,\r\n            Span\u003Cbyte\u003E destination,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm);\r\n\r\n        public static byte[] Pbkdf2(\r\n            string password,\r\n            byte[] salt,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm,\r\n            int outputLength);\r\n\r\n        public static byte[] Pbkdf2(\r\n            ReadOnlySpan\u003Cchar\u003E password,\r\n            ReadOnlySpan\u003Cbyte\u003E salt,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm,\r\n            int outputLength);\r\n\r\n        public static void Pbkdf2(\r\n            ReadOnlySpan\u003Cchar\u003E password,\r\n            ReadOnlySpan\u003Cbyte\u003E salt,\r\n            Span\u003Cbyte\u003E destination,\r\n            int iterations,\r\n            HashAlgorithmName hashAlgorithm);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16030000000,
        "Apis": [
          "M:Rfc2898DeriveBytes.Pbkdf2(byte[],byte[],int,HashAlgorithmName,int)",
          "M:Rfc2898DeriveBytes.Pbkdf2(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,int,HashAlgorithmName,int)",
          "M:Rfc2898DeriveBytes.Pbkdf2(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,int,HashAlgorithmName)",
          "M:Rfc2898DeriveBytes.Pbkdf2(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E,int,HashAlgorithmName,int)",
          "M:Rfc2898DeriveBytes.Pbkdf2(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,int,HashAlgorithmName)",
          "M:Rfc2898DeriveBytes.Pbkdf2(string,byte[],int,HashAlgorithmName,int)",
          "T:Rfc2898DeriveBytes"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42784,
          "Title": "Allow setting the Activity properties after Activity creation and before starting it when using ActivitySource",
          "Author": "macrogreg",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-26T22:52:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42784",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780052959",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42784#issuecomment-780052959",
        "FeedbackMarkdown": "* We should add a simplified overload that only requires name and kind\r\n* The proposed name is sufficiently clear\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public sealed class ActivitySource : IDisposable\r\n    {\r\n        public Activity? CreateActivity(string name, \r\n                                        ActivityKind kind);\r\n\r\n        public Activity? CreateActivity(string name,\r\n                                        ActivityKind kind, \r\n                                        ActivityContext parentContext,\r\n                                        IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E? tags = null, \r\n                                        IEnumerable\u003CActivityLink\u003E? links = null);\r\n\r\n        public Activity? CreateActivity(string name, \r\n                                        ActivityKind kind,\r\n                                        string parentContext,\r\n                                        IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E? tags = null, \r\n                                        IEnumerable\u003CActivityLink\u003E? links = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27300000000,
        "Apis": [
          "M:ActivitySource.CreateActivity(string,ActivityKind,ActivityContext,IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E?,IEnumerable\u003CActivityLink\u003E?)",
          "M:ActivitySource.CreateActivity(string,ActivityKind,string,IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E?,IEnumerable\u003CActivityLink\u003E?)",
          "M:ActivitySource.CreateActivity(string,ActivityKind)",
          "T:ActivitySource"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43853,
          "Title": "Impossible to set Activity.IdFormat when using ActivitySource",
          "Author": "pakrym",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-26T22:01:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43853",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780060001",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43853#issuecomment-780060001",
        "FeedbackMarkdown": "* We don\u0027t need this API because we just added \u0060CreateActivity\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public sealed class ActivitySource : IDisposable\r\n    {\r\n        public Activity? StartActivity(ActivityKind kind, \r\n                                       ActivityContext parentContext = default, \r\n                                       IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E? tags = null, \r\n                                       IEnumerable\u003CActivityLink\u003E? links = null, \r\n                                       ActivityIdFormat idFormat = ActivityIdFormat.Unknown,\r\n                                       DateTimeOffset startTime = default,\r\n                                       [CallerMemberName] string name = \u0022\u0022);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 35680000000,
        "Apis": [
          "M:ActivitySource.StartActivity(ActivityKind,ActivityContext,IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E?,IEnumerable\u003CActivityLink\u003E?,ActivityIdFormat,DateTimeOffset,string)",
          "T:ActivitySource"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44738,
          "Title": "Make it safer and easier to build an X500DistinguishedName",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-16T17:15:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44738",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780064442",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44738#issuecomment-780064442",
        "FeedbackMarkdown": "* Let\u0027s just drop the nested type and replace it with an \u0060int\u0060. It\u0027a a power API and users likely end up hard casting the \u0060Asn1\u0060 enums.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public sealed partial class X500DistinguishedNameBuilder\r\n    {\r\n        public void AddEmailAddress(string emailAddress);\r\n        public void AddDomainComponent(string domainComponent);\r\n        public void AddLocalityName(string localityName);\r\n        public void AddCommonName(string commonName); \r\n        public void AddCountryOrRegion(string twoLetterCode);\r\n        public void AddOrganizationName(string organizationName);\r\n        public void AddOrganizationalUnitName(string organizationalUnitName);\r\n        public void AddStateOrProvinceName(string stateOrProvinceName);\r\n    \r\n        public void Add(string oidValue, string value, int stringEncodingType = 0);\r\n        public void Add(Oid oid, string value, int stringEncodingType = 0);\r\n    \r\n        public void AddEncoded(Oid oid, byte[] encodedValue);\r\n        public void AddEncoded(Oid oid, ReadOnlySpan\u003Cbyte\u003E encodedValue);\r\n        public void AddEncoded(string oidValue, byte[] encodedValue);\r\n        public void AddEncoded(string oidValue, ReadOnlySpan\u003Cbyte\u003E encodedValue);\r\n    \r\n        public X500DistinguishedName Build();    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43770000000,
        "Apis": [
          "M:X500DistinguishedNameBuilder.Add(Oid,string,int)",
          "M:X500DistinguishedNameBuilder.Add(string,string,int)",
          "M:X500DistinguishedNameBuilder.AddCommonName(string)",
          "M:X500DistinguishedNameBuilder.AddCountryOrRegion(string)",
          "M:X500DistinguishedNameBuilder.AddDomainComponent(string)",
          "M:X500DistinguishedNameBuilder.AddEmailAddress(string)",
          "M:X500DistinguishedNameBuilder.AddEncoded(Oid,byte[])",
          "M:X500DistinguishedNameBuilder.AddEncoded(Oid,ReadOnlySpan\u003Cbyte\u003E)",
          "M:X500DistinguishedNameBuilder.AddEncoded(string,byte[])",
          "M:X500DistinguishedNameBuilder.AddEncoded(string,ReadOnlySpan\u003Cbyte\u003E)",
          "M:X500DistinguishedNameBuilder.AddLocalityName(string)",
          "M:X500DistinguishedNameBuilder.AddOrganizationalUnitName(string)",
          "M:X500DistinguishedNameBuilder.AddOrganizationName(string)",
          "M:X500DistinguishedNameBuilder.AddStateOrProvinceName(string)",
          "M:X500DistinguishedNameBuilder.Build()",
          "T:X500DistinguishedNameBuilder"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47525,
          "Title": "Developers can have access to more options when configuring async awaitables",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-27T13:48:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47525",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:3",
              "Color": "f9d0c4",
              "Description": "Work that is nice to have"
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-16T00:00:00-08:00",
        "FeedbackId": "780093604",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47525#issuecomment-780093604",
        "FeedbackMarkdown": "* Let\u0027s make it readonly so that we can mark APIs as \u0060in\u0060\r\n* We need to decide whether to have a type \u0060AwaitBehavior\u0060 or whether we should use optional parameters\r\n* It seems \u0060ValueTask\u0060 and \u0060Task\u0060 might differ in what they can support; the same might be true for other \u0060IAsync\u0060 interfaces\r\n* We may also want to add an analyzer to flag cancellation tokens that should have been past to the underlying operation instead\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public readonly struct AwaitBehavior\r\n    {\r\n        public CancellationToken CancellationToken { get; init; }\r\n        public TimeSpan Timeout { get; init; }\r\n        public bool ContinueOnCapturedContext { get; init; }\r\n        public bool ForceAsync { get; init; }\r\n        public bool SuppressExceptions { get; init; }\r\n    }\r\n    public partial class Task\r\n    {\r\n        public ConfiguredCancelableTaskAwaitable ConfigureAwait(AwaitBehavior awaitBehavior);\r\n    }\r\n    public partial class Task\u003CTResult\u003E\r\n    {\r\n        public new ConfiguredCancelableTaskAwaitable\u003CTResult\u003E ConfigureAwait(AwaitBehavior awaitBehavior);\r\n    }\r\n    public partial struct ValueTask\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaitable ConfigureAwait(AwaitBehavior awaitBehavior);\r\n    }\r\n    public partial struct ValueTask\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E ConfigureAwait(AwaitBehavior awaitBehavior);\r\n    }\r\n}\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public readonly struct ConfiguredCancelableTaskAwaitable\r\n    {\r\n        public ConfiguredCancelableTaskAwaiter GetAwaiter();\r\n        public readonly struct ConfiguredCancelableTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public void GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly struct ConfiguredCancelableTaskAwaitable\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public TResult GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly partial struct ConfiguredCancelableValueTaskAwaitable\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public void GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly partial struct ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public TResult GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48630000000,
        "Apis": [
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable.GetAwaiter()",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.GetAwaiter()",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable.GetAwaiter()",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.GetAwaiter()",
          "M:Task.ConfigureAwait(AwaitBehavior)",
          "M:Task\u003CTResult\u003E.ConfigureAwait(AwaitBehavior)",
          "M:ValueTask.ConfigureAwait(AwaitBehavior)",
          "M:ValueTask\u003CTResult\u003E.ConfigureAwait(AwaitBehavior)",
          "P:AwaitBehavior.CancellationToken",
          "P:AwaitBehavior.ContinueOnCapturedContext",
          "P:AwaitBehavior.ForceAsync",
          "P:AwaitBehavior.SuppressExceptions",
          "P:AwaitBehavior.Timeout",
          "P:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.IsCompleted",
          "T:AwaitBehavior",
          "T:ConfiguredCancelableTaskAwaitable",
          "T:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter",
          "T:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E",
          "T:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter",
          "T:ConfiguredCancelableValueTaskAwaitable",
          "T:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter",
          "T:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E",
          "T:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter",
          "T:Task",
          "T:Task\u003CTResult\u003E",
          "T:ValueTask",
          "T:ValueTask\u003CTResult\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "8kDxa8BfQmw",
      "StartDateTime": "2021-02-23T10:06:39-08:00",
      "EndDateTime": "2021-02-23T12:09:59-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8kDxa8BfQmw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43976,
          "Title": "Analyzer that suggests ToUpperInvariant/ToLowerInvariant in place of ToUpper/ToLower",
          "Author": "jamesqo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-17T06:42:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43976",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Globalization",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784413285",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43976#issuecomment-784413285",
        "FeedbackMarkdown": "* This is one of the more noisy analyzers from FxCop\r\n    - It makes sense for class libraries / server projects, but for WinForms, WPF it doesn\u0027t really make a difference\r\n    - Can we scope the analyzer for the project type / output type? Not all libraries are the same (e.g. some are user control, some are test projects)\r\n* However, it seems useful to have a severity of hidden so that people can invoke the fixer to replace all calls to the appropriate overload",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46571,
          "Title": "Add Tags and Baggage to LogScope using ActivityTrackingOptions",
          "Author": "msallin",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-05T10:14:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46571",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784415533",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46571#issuecomment-784415533",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    public partial enum ActivityTrackingOptions\r\n    {\r\n        Tags        = 0x0020,\r\n        Baggage     = 0x0040,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10630000000,
        "Apis": [
          "F:ActivityTrackingOptions.Baggage",
          "F:ActivityTrackingOptions.Tags",
          "T:ActivityTrackingOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46681,
          "Title": "Add back EnumBuilder.CreateType()",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-07T17:01:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46681",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection.Emit",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784420313",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46681#issuecomment-784420313",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should ensure that we address the other issues in the [baseline file](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Reflection.Emit/src/MatchingRefApiCompatBaseline.txt) or add comments indicating why why are by-design.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Emit\r\n{\r\n    public sealed partial class EnumBuilder : TypeInfo\r\n    {\r\n        public Type? CreateType();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12720000000,
        "Apis": [
          "M:EnumBuilder.CreateType()",
          "T:EnumBuilder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47599,
          "Title": "Allow using \u0060SupportedOSPlatformAttribute\u0060 on interfaces",
          "Author": "spouliot",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-28T21:17:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47599",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Priority:2",
              "Color": "e99695",
              "Description": "Work that is important, but not critical for the release"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784429051",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47599#issuecomment-784429051",
        "FeedbackMarkdown": "* We should also add it to \u0060UnsupportedOSPlatformAttribute\u0060\r\n* Our analyzer should probably warn when types implement the interface but aren\u0027t marked as platform-specific for at least the version that the interface is constrained to.\r\n    - If types don\u0027t want that, they can suppress the warning and implement the interface methods with guards\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Versioning\r\n{\r\n    [AttributeUsage(Assembly | Class | Constructor | Enum | Event | Field | Method | Module |\r\n                    Interface /* new */ |\r\n                    Property | Struct, AllowMultiple=true, Inherited=false)]\r\n    public partial class SupportedOSPlatformAttribute\r\n    {\r\n    }\r\n\r\n    [AttributeUsage(Assembly | Class | Constructor | Enum | Event | Field | Method | Module |\r\n                    Interface /* new */ |\r\n                    Property | Struct, AllowMultiple=true, Inherited=false)]\r\n    public partial class UnsupportedOSPlatformAttribute \r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17410000000,
        "Apis": [
          "T:SupportedOSPlatformAttribute",
          "T:UnsupportedOSPlatformAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48304,
          "Title": "MemoryExtensions.SequenceEqual with IComparer\u003CT\u003E",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-15T18:38:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48304",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784438196",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48304#issuecomment-784438196",
        "FeedbackMarkdown": "* Makes sense\r\n* We could drop the constraint on the existing APIs and do the right thing internally, but we can do that later\r\n    - Or we could default the comparer to \u0060null\u0060, which means the caller will either use the existing one when it is equatable and use the new one when it\u0027s not.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static class MemoryExtensions\r\n    {\r\n        // Existing\r\n        // public static bool SequenceEqual\u003CT\u003E(this ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E other) where T : IEquatable\u003CT\u003E;\r\n        // public static bool SequenceEqual\u003CT\u003E(this Span\u003CT\u003E span, ReadOnlySpan\u003CT\u003E other) where T : System.IEquatable\u003CT\u003E;\r\n        public static bool SequenceEqual\u003CT\u003E(this ReadOnlySpan\u003CT\u003E span, ReadOnlySpan\u003CT\u003E other, IEqualityComparer\u003CT\u003E? comparer = null);\r\n        public static bool SequenceEqual\u003CT\u003E(this Span\u003CT\u003E span, ReadOnlySpan\u003CT\u003E other, IEqualityComparer\u003CT\u003E? comparer = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25880000000,
        "Apis": [
          "M:MemoryExtensions.SequenceEqual\u003CT\u003E(this ReadOnlySpan\u003CT\u003E,ReadOnlySpan\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "M:MemoryExtensions.SequenceEqual\u003CT\u003E(this Span\u003CT\u003E,ReadOnlySpan\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "T:MemoryExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47525,
          "Title": "Developers can have access to more options when configuring async awaitables",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-27T13:48:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47525",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:3",
              "Color": "f9d0c4",
              "Description": "Work that is nice to have"
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-02-23T00:00:00-08:00",
        "FeedbackId": "784477523",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47525#issuecomment-784477523",
        "FeedbackMarkdown": "* We don\u0027t want to do \u0060SuppressExceptions\u0060 it has too many issues and it\u0027s non-trivial to implement\r\n* \u0060ForceAsync\u0060 is niche, but a nice to have\r\n* We could omit \u0060Timeout\u0060 and say people who want them can construct a cancellation token but we see people frequently getting this wrong.\r\n* We feel the struct isn\u0027t the right path, rather we should just use overloads\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public partial class Task\r\n    {\r\n        public ConfiguredCancelableTaskAwaitable ConfigureAwait(TimeSpan timeout);\r\n        public ConfiguredCancelableTaskAwaitable ConfigureAwait(CancellationToken cancellationToken);\r\n        public ConfiguredCancelableTaskAwaitable ConfigureAwait(bool continueOnCapturedContext,\r\n                                                                TimeSpan timeout,\r\n                                                                CancellationToken cancellationToken);\r\n\r\n    }\r\n    public partial class Task\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableTaskAwaitable\u003CTResult\u003E ConfigureAwait(TimeSpan timeout);\r\n        public ConfiguredCancelableTaskAwaitable\u003CTResult\u003E ConfigureAwait(CancellationToken cancellationToken);\r\n        public ConfiguredCancelableTaskAwaitable\u003CTResult\u003E ConfigureAwait(bool continueOnCapturedContext,\r\n                                                                         TimeSpan timeout,\r\n                                                                         CancellationToken cancellationToken);\r\n\r\n    }\r\n    public partial struct ValueTask\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaitable ConfigureAwait(TimeSpan timeout);\r\n        public ConfiguredCancelableValueTaskAwaitable ConfigureAwait(CancellationToken cancellationToken);\r\n        public ConfiguredCancelableValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext,\r\n                                                                     TimeSpan timeout,\r\n                                                                     CancellationToken cancellationToken);\r\n    }\r\n    public partial struct ValueTask\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E ConfigureAwait(TimeSpan timeout);\r\n        public ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E ConfigureAwait(CancellationToken cancellationToken);\r\n        public ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E ConfigureAwait(bool continueOnCapturedContext,\r\n                                                                              TimeSpan timeout,\r\n                                                                              CancellationToken cancellationToken);\r\n\r\n    }\r\n}\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public readonly struct ConfiguredCancelableTaskAwaitable\r\n    {\r\n        public ConfiguredCancelableTaskAwaiter GetAwaiter();\r\n        public readonly struct ConfiguredCancelableTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public void GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly struct ConfiguredCancelableTaskAwaitable\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public TResult GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly partial struct ConfiguredCancelableValueTaskAwaitable\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public void GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n    public readonly partial struct ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E\r\n    {\r\n        public ConfiguredCancelableValueTaskAwaiter GetAwaiter();\r\n        public readonly partial struct ConfiguredCancelableValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion\r\n        {\r\n            public bool IsCompleted { get; }\r\n            public TResult GetResult();\r\n            public void OnCompleted(Action continuation);\r\n            public void UnsafeOnCompleted(Action continuation);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34200000000,
        "Apis": [
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable.GetAwaiter()",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.GetAwaiter()",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable.GetAwaiter()",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.GetResult()",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.OnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.UnsafeOnCompleted(Action)",
          "M:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.GetAwaiter()",
          "M:Task.ConfigureAwait(bool,TimeSpan,CancellationToken)",
          "M:Task.ConfigureAwait(CancellationToken)",
          "M:Task.ConfigureAwait(TimeSpan)",
          "M:Task\u003CTResult\u003E.ConfigureAwait(bool,TimeSpan,CancellationToken)",
          "M:Task\u003CTResult\u003E.ConfigureAwait(CancellationToken)",
          "M:Task\u003CTResult\u003E.ConfigureAwait(TimeSpan)",
          "M:ValueTask.ConfigureAwait(bool,TimeSpan,CancellationToken)",
          "M:ValueTask.ConfigureAwait(CancellationToken)",
          "M:ValueTask.ConfigureAwait(TimeSpan)",
          "M:ValueTask\u003CTResult\u003E.ConfigureAwait(bool,TimeSpan,CancellationToken)",
          "M:ValueTask\u003CTResult\u003E.ConfigureAwait(CancellationToken)",
          "M:ValueTask\u003CTResult\u003E.ConfigureAwait(TimeSpan)",
          "P:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter.IsCompleted",
          "P:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter.IsCompleted",
          "T:ConfiguredCancelableTaskAwaitable",
          "T:ConfiguredCancelableTaskAwaitable.ConfiguredCancelableTaskAwaiter",
          "T:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E",
          "T:ConfiguredCancelableTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableTaskAwaiter",
          "T:ConfiguredCancelableValueTaskAwaitable",
          "T:ConfiguredCancelableValueTaskAwaitable.ConfiguredCancelableValueTaskAwaiter",
          "T:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E",
          "T:ConfiguredCancelableValueTaskAwaitable\u003CTResult\u003E.ConfiguredCancelableValueTaskAwaiter",
          "T:Task",
          "T:Task\u003CTResult\u003E",
          "T:ValueTask",
          "T:ValueTask\u003CTResult\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "qnGfdfGnO2E",
      "StartDateTime": "2021-03-02T10:06:13-08:00",
      "EndDateTime": "2021-03-02T12:13:25-08:00",
      "Title": "JSON DOM API Review",
      "ThumbnailUrl": "https://i.ytimg.com/vi/qnGfdfGnO2E/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 163,
          "Title": "Writable DOM and dynamic support for 6.0",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-03T16:09:35+00:00",
          "Url": "https://github.com/dotnet/designs/pull/163",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-02T00:00:00-08:00",
        "FeedbackId": "789181317",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/163#issuecomment-789181317",
        "FeedbackMarkdown": "* The Azure SDK has a design (and usability studies) that uses structs. Could we lift their design?\r\n    - It sounds like they aren\u0027t entirely happy with their design either, but it seems we might be able to merge it.\r\n* The Azure SDK team has a set of JSON payloads that users have to pass to their APIs. We should write sample code that shows how one would do that with the DOM to make sure it\u0027s not super busy/complicated.\r\n    - @KrzysztofCwalina will provide @SteveHarter with examples\r\n* The proposal is lazy, but it\u0027s class-based which will cause more allocations as one navigates\r\n* \u0060JsonNode\u0060\r\n    - \u0060GetValue\u003CT\u003E\u0060 with value types will throw when the value is \u0060null\u0060. It seems robust code should use \u0060int?\u0060 or call \u0060TryGetValue()\u0060.\r\n    - \u0060Path\u0060 should be a method\r\n    - The \u0060Deserialize()\u0060 method should always take options\r\n    - It seems \u0060GetValue\u003CT\u003E\u0060 and \u0060Deserialize\u003CT\u003E\u0060 are very similar. Should they be combined?\r\n    - \u0060ToString()\u0060 should return the JSON, with the special handling of simple string values not including the quotes, like \u0060JsonDocument\u0060\r\n    - \u0060WriteTo()\u0060 should probably have an overload that accepts a \u0060Stream\u0060, maybe also one that accepts a \u0060TextWriter\u0060\r\n    - \u0060WriteTo()\u0060 probably needs an async version\r\n    - \u0060Parse()\u0060 should probably be the inverse of \u0060WriteTo\u0060, in terms of types it accepts and async overloads\r\n    - Should we remove \u0060ValueKind\u0060? \u0060JsonValue\u003CT\u003E\u0060 will return \u0060Unspecified\u0060 for deferred serialized objects\r\n* \u0060JsonArray\u0060\r\n    - The \u0060Add(object?)\u0060 is a typo and should be removed, but it\u0027s useful for use with anonymous objects\r\n    - We should consider \u0060Add\u003CT\u003E(T value)\u0060 that constructs a \u0060JsonValue\u003CT\u003E\u0060 automatically\r\n    - It seems a bit unfortunate that this has deferred deserialization semantics, meaning, if you walk the DOM after calling \u0060Add\u003CT\u003E()\u0060 it\u0027s a \u0060JsonValue\u003CT\u003E\u0060 with no children, even if you added a compound object.\r\n    - People may want to pass in a size that they can index into. This would be different from \u0060List\u003CT\u003E\u0060 where the specified size would implicitly add \u0060null\u0060 values which makes them valid for indexing. Alternatively, we could make arrays work like a dictionary where the key is an index.\r\n* Action items\r\n    - Create samples for the Azure SDK (which is creating payloads)\r\n    - One sample for modifying an existing payload\r\n    - One sample for pure reading\r\n\r\nGeneral types:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Node\r\n{\r\n    public abstract class JsonNode : System.Dynamic.IDynamicMetaObjectProvider {}\r\n    public sealed class JsonArray : JsonNode, IList\u003CJsonNode?\u003E {}\r\n    public sealed class JsonObject : JsonNode, IDictionary\u003Cstring, JsonNode?\u003E {}\r\n    public abstract class JsonValue : JsonNode {}\r\n    public sealed class JsonValue\u003CT\u003E : JsonValue {}\r\n}\r\n\u0060\u0060\u0060\r\n\r\nFull API:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Node\r\n{\r\n    public abstract class JsonNode : System.Dynamic.IDynamicMetaObjectProvider\r\n    {\r\n        internal JsonNode(); // prevent external derived classes.\r\n\r\n        public JsonNode Clone(); // Deep clone.\r\n\r\n        // Returns the options specified during creation\\deserialization otherwise null.\r\n        // If null, child nodes obtain value from parent nodes recursively.\r\n        public JsonSerializerOptions? Options { get; }\r\n\r\n        // JsonArray terse syntax support (no JsonArray cast necessary).\r\n        public virtual JsonNode? this[int index] { get; set; }\r\n\r\n        // JsonObject terse syntax (no JsonObject cast necessary).\r\n        public virtual JsonNode? this[string propertyName] { get; set; }\r\n\r\n        // JsonValue terse syntax (no JsonValue\u003CT\u003E cast necessary).\r\n        // Return the internal value, a JsonElement conversion, or a custom conversion to the provided type.\r\n        // Allows for common programming model when JsonValue\u003CT\u003E is based on JsonElement or a CLR value.\r\n        // \u0022TypeToGet\u0022 vs \u0022T\u0022 to prevent collision on JsonValue\u003CT\u003E. (could just be \u0022T\u0022 if made non-virtual and dispatch to internal virtual methods instead)\r\n        public virtual JsonValue? GetValue\u003CTypeToGet\u003E();\r\n        public virtual bool TryGetValue\u003CTypeToGet\u003E(out TypeToGet? value);\r\n        // Overloads with the converter for \u003CTypeToGet\u003E:\r\n        public virtual JsonValue? GetValue\u003CTypeToGet\u003E(JsonConverter converter);\r\n        public virtual bool TryGetValue\u003CTypeToGet\u003E(JsonConverter converter, out TypeToGet? value);\r\n\r\n        // Return the parent and root nodes; useful for LINQ.\r\n        public JsonNode? Parent { get; }\r\n        public JsonNode? Root { get; }\r\n\r\n        // The JSON Path; same \u0022JsonPath\u0022 syntax we use for JsonException information.\r\n        public string Path { get; }\r\n\r\n        // Serialize\\deserialize wrappers. These are helpers and thus can be considered optional.\r\n        // \u0022TypeToDeserialize\u0022 could be \u0022T\u0022 instead.\r\n        public abstract TypeToDeserialize? Deserialize\u003CTypeToDeserialize\u003E();\r\n        public abstract bool TryDeserialize\u003CTypeToDeserialize\u003E(out TypeToDeserialize? value);\r\n        public string ToJsonString(); // serialize as a string\r\n        // public byte[] ToUtf8Bytes(); // not proposed, but may be useful\r\n        // WriteTo() terminology consistent with Utf8JsonWriter.\r\n        public abstract void WriteTo(System.Text.Json.Utf8JsonWriter writer);\r\n        // Parse() terminology consistent with Utf8JsonReader\\JsonDocument.\r\n        public static JsonNode? Parse(string? json, JsonSerializerOptions? options = null);\r\n        public static JsonNode? ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonSerializerOptions? options = null);\r\n        public static JsonNode? ReadFrom(ref Utf8JsonReader reader, JsonSerializerOptions? options = null);\r\n\r\n        // The ValueKind from deserialization. Not used internally but may be useful for consumers.\r\n        public JsonValueKind ValueKind { get; }\r\n\r\n        // JsonElement interop\r\n        public static JsonNode GetNode(JsonElement jsonElement);\r\n        public static bool TryGetNode(JsonElement jsonElement, [NotNullWhen(true)] out JsonNode? jsonNode);\r\n\r\n        // Dynamic support; implemented explicitly to help hide.\r\n        System.Dynamic.DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression parameter);\r\n\r\n        // Explicit operators (can throw) from known primitives.\r\n        public static explicit operator bool(JsonNode value);\r\n        public static explicit operator byte(JsonNode value);\r\n        public static explicit operator DateTime(JsonNode value);\r\n        public static explicit operator DateTimeOffset(JsonNode value);\r\n        public static explicit operator decimal(JsonNode value);\r\n        public static explicit operator double(JsonNode value);\r\n        public static explicit operator Guid(JsonNode value);\r\n        public static explicit operator short(JsonNode value);\r\n        public static explicit operator int(JsonNode value);\r\n        public static explicit operator long(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte(JsonNode value);\r\n        public static explicit operator float(JsonNode value);\r\n        public static explicit operator char(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong(JsonNode value);\r\n\r\n        public static explicit operator bool?(JsonNode value);\r\n        public static explicit operator byte?(JsonNode value);\r\n        public static explicit operator DateTime?(JsonNode value);\r\n        public static explicit operator DateTimeOffset?(JsonNode value);\r\n        public static explicit operator decimal?(JsonNode value);\r\n        public static explicit operator double?(JsonNode value);\r\n        public static explicit operator Guid?(JsonNode value);\r\n        public static explicit operator short?(JsonNode value);\r\n        public static explicit operator int?(JsonNode value);\r\n        public static explicit operator long?(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte?(JsonNode value);\r\n        public static explicit operator float?(JsonNode value);\r\n        public static explicit operator string?(JsonNode value);\r\n        public static explicit operator char?(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort?(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint?(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong?(JsonNode value);\r\n\r\n        // Implicit operators (won\u0027t throw) from known primitives.\r\n        public static implicit operator JsonNode(bool value);\r\n        public static implicit operator JsonNode(byte value);\r\n        public static implicit operator JsonNode(DateTime value);\r\n        public static implicit operator JsonNode(DateTimeOffset value);\r\n        public static implicit operator JsonNode(decimal value);\r\n        public static implicit operator JsonNode(double value);\r\n        public static implicit operator JsonNode(Guid value);\r\n        public static implicit operator JsonNode(short value);\r\n        public static implicit operator JsonNode(int value);\r\n        public static implicit operator JsonNode(long value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(sbyte value);\r\n        public static implicit operator JsonNode(float value);\r\n        public static implicit operator JsonNode?(char value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ushort value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(uint value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ulong value);\r\n\r\n        public static implicit operator JsonNode(bool? value);\r\n        public static implicit operator JsonNode(byte? value);\r\n        public static implicit operator JsonNode(DateTime? value);\r\n        public static implicit operator JsonNode(DateTimeOffset? value);\r\n        public static implicit operator JsonNode(decimal? value);\r\n        public static implicit operator JsonNode(double? value);\r\n        public static implicit operator JsonNode(Guid? value);\r\n        public static implicit operator JsonNode(short? value);\r\n        public static implicit operator JsonNode(string? value);\r\n        public static implicit operator JsonNode(int? value);\r\n        public static implicit operator JsonNode(long? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(sbyte? value);\r\n        public static implicit operator JsonNode(float? value);\r\n        public static implicit operator JsonNode?(char? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ushort? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(uint? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ulong? value);\r\n    }\r\n\r\n    public sealed class JsonArray : JsonNode, IList\u003CJsonNode?\u003E\r\n    {\r\n        public JsonArray(JsonElement jsonElement, JsonSerializerOptions? options = null);\r\n\r\n        // Param-based constructors for easy constructor initializers.\r\n        public JsonArray(JsonSerializerOptions? options, params JsonNode[] items);\r\n        public JsonArray(params JsonNode[] items);\r\n\r\n        public override JsonNode Clone();\r\n\r\n        public override void WriteTo(System.Text.Json.Utf8JsonWriter writer);\r\n\r\n        public static JsonArray? Parse(string? json, JsonSerializerOptions? options = null);\r\n        public static JsonArray? ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonSerializerOptions? options = null);\r\n        public static JsonArray? ReadFrom(ref Utf8JsonReader reader, JsonSerializerOptions? options = null);\r\n\r\n        // IList\u003CJsonNode?\u003E (some hidden via explicit implementation):\r\n        public int Count { get ;}\r\n        bool ICollection\u003CJsonNode?\u003E.IsReadOnly { get ;}\r\n        public void Add(object? item);\r\n        public void Add(JsonNode? item);\r\n        public void Clear();\r\n        public bool Contains(JsonNode? item);\r\n        public IEnumerator\u003CJsonNode?\u003E GetEnumerator();\r\n        public int IndexOf(JsonNode? item);\r\n        public void Insert(int index, JsonNode? item);\r\n        public bool Remove(JsonNode? item);\r\n        public void RemoveAt(int index);\r\n        void ICollection\u003CJsonNode?\u003E.CopyTo(JsonNode?[]? array, int arrayIndex);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n    }\r\n\r\n    public sealed class JsonObject : JsonNode, IDictionary\u003Cstring, JsonNode?\u003E\r\n    {\r\n        public JsonObject(JsonSerializerOptions? options = null);\r\n        public JsonObject(JsonElement jsonElement, JsonSerializerOptions? options = null);\r\n\r\n        public override JsonNode Clone();\r\n\r\n        public bool TryGetPropertyValue(string propertyName, outJsonNode? jsonNode);\r\n\r\n        public override void WriteTo(System.Text.Json.Utf8JsonWriter writer);\r\n\r\n        public static JsonObject? Parse(string? json, JsonSerializerOptions? options = null);\r\n        public static JsonObject? ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonSerializerOptions? options = null);\r\n        public static JsonObject? ReadFrom(ref Utf8JsonReader reader, JsonSerializerOptions? options = null);\r\n\r\n        // IDictionary\u003Cstring, JsonNode?\u003E (some hidden via explicit implementation):\r\n        public int Count { get; }\r\n        bool ICollection\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E.IsReadOnly { get; }\r\n        ICollection\u003Cstring\u003E IDictionary\u003Cstring,JsonNode?\u003E.Keys { get; }\r\n        ICollection\u003CJsonNode?\u003E IDictionary\u003Cstring,JsonNode?\u003E.Values { get; }\r\n        public void Add(string propertyName,JsonNode? value);\r\n        public void Clear();\r\n        public bool ContainsKey(string propertyName);\r\n        public IEnumerator\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E GetEnumerator();\r\n        public bool Remove(string propertyName);\r\n        void ICollection\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E.Add(KeyValuePair\u003Cstring,JsonNode\u003E item);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E.Contains(KeyValuePair\u003Cstring,JsonNode\u003E item);\r\n        void ICollection\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E.CopyTo(KeyValuePair\u003Cstring,JsonNode\u003E[] array, int arrayIndex);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring,JsonNode?\u003E\u003E.Remove(KeyValuePair\u003Cstring,JsonNode\u003E item);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n        bool IDictionary\u003Cstring,JsonNode?\u003E.TryGetValue(string propertyName, outJsonNode? jsonNode);\r\n    }\r\n\r\n    // Separate class to make it easy to check type via \u0022if (node is JsonValue)\u0022\r\n    // and to support passing of a value class polymorphically (without the \u003CT\u003E)\r\n    public abstract class JsonValue : JsonNode\r\n    {\r\n        public JsonValue(JsonSerializerOptions? options = null);\r\n\r\n        // Possible factory method that doesn\u0027t require specifying \u003CT\u003E due to generic type inference:\r\n        // public static JsonValue\u003CT\u003E Create(T value);\r\n    }\r\n\r\n    public sealed class JsonValue\u003CT\u003E : JsonValue\r\n    {\r\n        public JsonValue(T value, JsonSerializerOptions? options = null);\r\n\r\n        // Allow a custom converter and JsonValueKind to be specified.\r\n        public JsonValue(T value, JsonConverter? converter = null, JsonValueKind valueKind, JsonSerializerOptions? options = null);\r\n\r\n        public override JsonNode Clone();\r\n\r\n        public override TypeToReturn GetValue\u003CTypeToReturn\u003E();\r\n        public override TypeToReturn GetValue\u003CTypeToReturn\u003E(JsonConverter converter);\r\n        public override bool TryGetValue\u003CTypeToReturn\u003E(out TypeToReturn value);\r\n        public override bool TryGetValue\u003CTypeToReturn\u003E(JsonConverter converter, out TypeToReturn value);\r\n\r\n        // The internal raw value.\r\n        public override T Value {get; set;}\r\n\r\n        public override void WriteTo(System.Text.Json.Utf8JsonWriter writer);\r\n\r\n        public static JsonValue\u003CT\u003E Parse(string? json, JsonSerializerOptions? options = null);\r\n        public static JsonValue\u003CT\u003E ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonSerializerOptions? options = null);\r\n        public static JsonValue\u003CT\u003E ReadFrom(ref Utf8JsonReader reader, JsonSerializerOptions? options = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonArray.Add(JsonNode?)",
          "M:JsonArray.Add(object?)",
          "M:JsonArray.Clear()",
          "M:JsonArray.Clone()",
          "M:JsonArray.Contains(JsonNode?)",
          "M:JsonArray.CopyTo(JsonNode?[]?,int)",
          "M:JsonArray.GetEnumerator()",
          "M:JsonArray.IndexOf(JsonNode?)",
          "M:JsonArray.Insert(int,JsonNode?)",
          "M:JsonArray.JsonArray(JsonElement,JsonSerializerOptions?)",
          "M:JsonArray.JsonArray(JsonSerializerOptions?,params JsonNode[])",
          "M:JsonArray.JsonArray(params JsonNode[])",
          "M:JsonArray.Parse(string?,JsonSerializerOptions?)",
          "M:JsonArray.ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E,JsonSerializerOptions?)",
          "M:JsonArray.ReadFrom(ref Utf8JsonReader,JsonSerializerOptions?)",
          "M:JsonArray.Remove(JsonNode?)",
          "M:JsonArray.RemoveAt(int)",
          "M:JsonArray.WriteTo(System.Text.Json.Utf8JsonWriter)",
          "M:JsonNode.Clone()",
          "M:JsonNode.Deserialize\u003CTypeToDeserialize\u003E()",
          "M:JsonNode.explicit(JsonNode)",
          "M:JsonNode.GetMetaObject(System.Linq.Expressions.Expression)",
          "M:JsonNode.GetNode(JsonElement)",
          "M:JsonNode.GetValue\u003CTypeToGet\u003E()",
          "M:JsonNode.GetValue\u003CTypeToGet\u003E(JsonConverter)",
          "M:JsonNode.implicit(bool?)",
          "M:JsonNode.implicit(bool)",
          "M:JsonNode.implicit(byte?)",
          "M:JsonNode.implicit(byte)",
          "M:JsonNode.implicit(char?)",
          "M:JsonNode.implicit(char)",
          "M:JsonNode.implicit(DateTime?)",
          "M:JsonNode.implicit(DateTime)",
          "M:JsonNode.implicit(DateTimeOffset?)",
          "M:JsonNode.implicit(DateTimeOffset)",
          "M:JsonNode.implicit(decimal?)",
          "M:JsonNode.implicit(decimal)",
          "M:JsonNode.implicit(double?)",
          "M:JsonNode.implicit(double)",
          "M:JsonNode.implicit(float?)",
          "M:JsonNode.implicit(float)",
          "M:JsonNode.implicit(Guid?)",
          "M:JsonNode.implicit(Guid)",
          "M:JsonNode.implicit(int?)",
          "M:JsonNode.implicit(int)",
          "M:JsonNode.implicit(long?)",
          "M:JsonNode.implicit(long)",
          "M:JsonNode.implicit(sbyte?)",
          "M:JsonNode.implicit(sbyte)",
          "M:JsonNode.implicit(short?)",
          "M:JsonNode.implicit(short)",
          "M:JsonNode.implicit(string?)",
          "M:JsonNode.implicit(uint?)",
          "M:JsonNode.implicit(uint)",
          "M:JsonNode.implicit(ulong?)",
          "M:JsonNode.implicit(ulong)",
          "M:JsonNode.implicit(ushort?)",
          "M:JsonNode.implicit(ushort)",
          "M:JsonNode.JsonNode()",
          "M:JsonNode.Parse(string?,JsonSerializerOptions?)",
          "M:JsonNode.ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E,JsonSerializerOptions?)",
          "M:JsonNode.ReadFrom(ref Utf8JsonReader,JsonSerializerOptions?)",
          "M:JsonNode.ToJsonString()",
          "M:JsonNode.TryDeserialize\u003CTypeToDeserialize\u003E(out TypeToDeserialize?)",
          "M:JsonNode.TryGetNode(JsonElement,out JsonNode?)",
          "M:JsonNode.TryGetValue\u003CTypeToGet\u003E(JsonConverter,out TypeToGet?)",
          "M:JsonNode.TryGetValue\u003CTypeToGet\u003E(out TypeToGet?)",
          "M:JsonNode.WriteTo(System.Text.Json.Utf8JsonWriter)",
          "M:JsonObject.Add(KeyValuePair\u003Cstring,JsonNode\u003E)",
          "M:JsonObject.Add(string,JsonNode?)",
          "M:JsonObject.Clear()",
          "M:JsonObject.Clone()",
          "M:JsonObject.Contains(KeyValuePair\u003Cstring,JsonNode\u003E)",
          "M:JsonObject.ContainsKey(string)",
          "M:JsonObject.CopyTo(KeyValuePair\u003Cstring,JsonNode\u003E[],int)",
          "M:JsonObject.GetEnumerator()",
          "M:JsonObject.JsonObject(JsonElement,JsonSerializerOptions?)",
          "M:JsonObject.JsonObject(JsonSerializerOptions?)",
          "M:JsonObject.Parse(string?,JsonSerializerOptions?)",
          "M:JsonObject.ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E,JsonSerializerOptions?)",
          "M:JsonObject.ReadFrom(ref Utf8JsonReader,JsonSerializerOptions?)",
          "M:JsonObject.Remove(KeyValuePair\u003Cstring,JsonNode\u003E)",
          "M:JsonObject.Remove(string)",
          "M:JsonObject.TryGetPropertyValue(string,outJsonNode?)",
          "M:JsonObject.TryGetValue(string,outJsonNode?)",
          "M:JsonObject.WriteTo(System.Text.Json.Utf8JsonWriter)",
          "M:JsonValue.JsonValue(JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.Clone()",
          "M:JsonValue\u003CT\u003E.GetValue\u003CTypeToReturn\u003E()",
          "M:JsonValue\u003CT\u003E.GetValue\u003CTypeToReturn\u003E(JsonConverter)",
          "M:JsonValue\u003CT\u003E.JsonValue(T,JsonConverter?,JsonValueKind,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.JsonValue(T,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.Parse(string?,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.ReadFrom(ref Utf8JsonReader,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.TryGetValue\u003CTypeToReturn\u003E(JsonConverter,out TypeToReturn)",
          "M:JsonValue\u003CT\u003E.TryGetValue\u003CTypeToReturn\u003E(out TypeToReturn)",
          "M:JsonValue\u003CT\u003E.WriteTo(System.Text.Json.Utf8JsonWriter)",
          "P:JsonArray.Count",
          "P:JsonArray.IsReadOnly",
          "P:JsonNode.Options",
          "P:JsonNode.Parent",
          "P:JsonNode.Path",
          "P:JsonNode.Root",
          "P:JsonNode.ValueKind",
          "P:JsonNode[int]",
          "P:JsonNode[string]",
          "P:JsonObject.Count",
          "P:JsonObject.IsReadOnly",
          "P:JsonObject.Keys",
          "P:JsonObject.Values",
          "P:JsonValue\u003CT\u003E.Value",
          "T:JsonArray",
          "T:JsonNode",
          "T:JsonObject",
          "T:JsonValue",
          "T:JsonValue\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "f4L59H56o9I",
      "StartDateTime": "2021-03-03T16:01:12-08:00",
      "EndDateTime": "2021-03-03T17:02:07-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/f4L59H56o9I/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 3512,
          "Title": "Support InitialDirectory and ClientGuid on FolderBrowserDialog",
          "Author": "weltkante",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-26T10:54:06+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/3512",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-04T00:00:00-08:00",
        "FeedbackId": "790176927",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/3512#issuecomment-790176927",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class FolderBrowserDialog \r\n    {\r\n        [DefaultValue(\u0022\u0022)]\r\n        public string InitialDirectory { get; set; }\r\n\r\n        [Browsable(false)]\r\n        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\r\n        [Localizable(false)]\r\n        public Guid? ClientGuid { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:FolderBrowserDialog.ClientGuid",
          "P:FolderBrowserDialog.InitialDirectory",
          "T:FolderBrowserDialog"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4431,
          "Title": "Provide source span in LinkClicked handler of RichTextBox",
          "Author": "weltkante",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-04T15:15:58+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4431",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-04T00:00:00-08:00",
        "FeedbackId": "790180629",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4431#issuecomment-790180629",
        "FeedbackMarkdown": "* Looks good as proposed.\r\n    - It\u0027s a bit odd to default \u0060LinkStart\u0060 to zero, but that would be consistent without, for example, \u0060SelectionStart\u0060 and \u0060SelectionLength\u0060 work in WinForms\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class LinkClickedEventArgs : EventArgs\r\n    {\r\n        // Existing\r\n        // public LinkClickedEventArgs(string linkText);\r\n        // public string LinkText { get; }\r\n        public LinkClickedEventArgs(string linkText, int linkStart, int linkLength);\r\n        public int LinkStart { get; }\r\n        public int LinkLength { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6340000000,
        "Apis": [
          "M:LinkClickedEventArgs.LinkClickedEventArgs(string,int,int)",
          "P:LinkClickedEventArgs.LinkLength",
          "P:LinkClickedEventArgs.LinkStart",
          "T:LinkClickedEventArgs"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4146,
          "Title": "Add IsAncestorSiteInDesignMode for Control",
          "Author": "KlausLoeffelmann",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-21T19:56:24+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4146",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-04T00:00:00-08:00",
        "FeedbackId": "790189643",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4146#issuecomment-790189643",
        "FeedbackMarkdown": "* Makes sense, but it might be better to introduce a property that combines \u0060Component.DesignMode\u0060 and \u0060Control.IsAncestorSiteInDesignMode\u0060 so that you have a single property that answers \u0022am I being designed or is one of my parents being designed\u0022\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class Control\r\n    {\r\n        protected bool IsAncestorSiteInDesignMode { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10910000000,
        "Apis": [
          "P:Control.IsAncestorSiteInDesignMode",
          "T:Control"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4608,
          "Title": "Simplify \u0060Invoke\u0060 and \u0060BeginInvoke\u0060 signature and accept \u0060Action\u0060",
          "Author": "RussKie",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-25T21:27:59+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4608",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-04T00:00:00-08:00",
        "FeedbackId": "790192221",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4608#issuecomment-790192221",
        "FeedbackMarkdown": "* Looks good as proposed\r\n  - ~~Is this a source breaking change for VB? @KathleenDollard @jaredpar?~~ Jared already said looks good. But it looks like @KathleenDollard still has come concerns. This should be verified.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class Control\r\n    {\r\n        public IAsyncResult BeginInvoke(Action method);\r\n        // public IAsyncResult BeginInvoke(Delegate method);\r\n        // public IAsyncResult BeginInvoke(Delegate method, params object[] args);\r\n\r\n        public T Invoke\u003CT\u003E(Func\u003CT\u003E method);\r\n        public void Invoke(Action method);\r\n        // public object Invoke(Delegate method);\r\n        // public object Invoke(Delegate method, params object[] args);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21130000000,
        "Apis": [
          "M:Control.BeginInvoke(Action)",
          "M:Control.Invoke(Action)",
          "M:Control.Invoke\u003CT\u003E(Func\u003CT\u003E)",
          "T:Control"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "_Svjl1-jauY",
      "StartDateTime": "2021-03-09T10:03:44-08:00",
      "EndDateTime": "2021-03-09T12:01:26-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_Svjl1-jauY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47525,
          "Title": "Developers can have access to more options when configuring async awaitables",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-27T13:48:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47525",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:3",
              "Color": "f9d0c4",
              "Description": "Work that is nice to have"
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-09T00:00:00-08:00",
        "FeedbackId": "794272772",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47525#issuecomment-794272772",
        "FeedbackMarkdown": "* This API looks cleaner and seems easier to evolve. We don\u0027t believe this adds significant overhead of the \u0060ConfigureAwait\u0060 approach. In terms of discoverability it will do about the same, because it requires to invoke a method before awaiting the result.\r\n* The existing \u0060Wait\u0060 API has overloads that take \u0060int milliseconds\u0060 but we consider this a mistake, so we don\u0027t replicate them here and just use \u0060TimeSpan\u0060.\r\n* @stephentoub please reopen the issue that allows suppression throwing exceptions because we cut this from this issue.\r\n* Let\u0027s cut the \u0060Value\u0060 and \u0060ValueTask\u0060 ones as there is the additional complexity of accidentally touching it twice and they are really just convenience methods that can be mitigated by calling \u0060AsTask().WaitAsync(...)\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public partial class Task\r\n    {\r\n        public Task WaitAsync(CancellationToken cancellationToken);\r\n        public Task WaitAsync(TimeSpan timeout);\r\n        public Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);\r\n    }\r\n\r\n    public partial class Task\u003CTResult\u003E\r\n    {\r\n        public Task\u003CTResult\u003E WaitAsync(CancellationToken cancellationToken);\r\n        public Task\u003CTResult\u003E WaitAsync(TimeSpan timeout);\r\n        public Task\u003CTResult\u003E WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Task.WaitAsync(CancellationToken)",
          "M:Task.WaitAsync(TimeSpan,CancellationToken)",
          "M:Task.WaitAsync(TimeSpan)",
          "M:Task\u003CTResult\u003E.WaitAsync(CancellationToken)",
          "M:Task\u003CTResult\u003E.WaitAsync(TimeSpan,CancellationToken)",
          "M:Task\u003CTResult\u003E.WaitAsync(TimeSpan)",
          "T:Task",
          "T:Task\u003CTResult\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48743,
          "Title": "Add API to make configuring the HostOptions easier",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-25T06:47:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48743",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Hosting",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-09T00:00:00-08:00",
        "FeedbackId": "794276653",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48743#issuecomment-794276653",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Hosting\r\n{\r\n    public static class HostingHostBuilderExtensions\r\n    {\r\n        public static IHostBuilder ConfigureHostOptions(this IHostBuilder hostBuilder, Action\u003CHostOptions\u003E configure);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 14650000000,
        "Apis": [
          "M:HostingHostBuilderExtensions.ConfigureHostOptions(this IHostBuilder,Action\u003CHostOptions\u003E)",
          "T:HostingHostBuilderExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 37539,
          "Title": "Add ability to perform zero byte reads in StreamPipeReader",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-06-06T06:58:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/37539",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-09T00:00:00-08:00",
        "FeedbackId": "794287642",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/37539#issuecomment-794287642",
        "FeedbackMarkdown": "* Last time we said that zero byte reads are technically a violation of the \u0060Stream.Read()\u0060 contract, but we believe enough streams support this already that it\u0027s better to change the documentation to call this out as something a stream must support. Therefore, we don\u0027t need a new API on \u0060Stream\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipelines\r\n{\r\n    public class StreamPipeReaderOptions\r\n    {\r\n        public bool UseZeroByteReads { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16660000000,
        "Apis": [
          "P:StreamPipeReaderOptions.UseZeroByteReads",
          "T:StreamPipeReaderOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31525,
          "Title": "Modern Timer API",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-20T07:56:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31525",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-09T00:00:00-08:00",
        "FeedbackId": "794351681",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31525#issuecomment-794351681",
        "FeedbackMarkdown": "* We need to decide which model we want to use when you missed a period (1) should it complete immediately once (2) should it complete immediately for each period that was missed and (3) should it just skip to the next period. Supporting all would require an enum, but we may want to start simple, but we need to agree what \u0022the simple\u0022 case is.\r\n    - For ASP.NET\u0027s scenarios we only need mode (2).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n   public class PeriodicTimer : IDisposable\r\n   {\r\n        public PeriodicTimer(TimeSpan period);\r\n        public ValueTask\u003Cbool\u003E WaitForNextTickAsync(CancellationToken cancellationToken = default);\r\n        public void Stop();\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22030000000,
        "Apis": [
          "M:PeriodicTimer.PeriodicTimer(TimeSpan)",
          "M:PeriodicTimer.Stop()",
          "M:PeriodicTimer.WaitForNextTickAsync(CancellationToken)",
          "T:PeriodicTimer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27062,
          "Title": "Developers can use CollectionsMarshal ref accessors for Dictionary\u003CTKey, TValue\u003E",
          "Author": "benaadams",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-08-04T14:05:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27062",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:3",
              "Color": "f9d0c4",
              "Description": "Work that is nice to have"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-09T00:00:00-08:00",
        "FeedbackId": "794381764",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27062#issuecomment-794381764",
        "FeedbackMarkdown": "* Makes sense, we should not use the \u0060Try\u0060-prefix because it refers to the try-pattern which would return a \u0060bool\u0060 and out the value\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class CollectionsMarshal\r\n    {        \r\n        public static ref TValue GetValueRef\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E dictionary, [NotNull] TKey key);\r\n        public static ref TValue GetValueRefOrNullRef\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E dictionary, [NotNull] TKey key);\r\n        public static ref TValue GetValueRefOrAddDefault\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E dictionary, [NotNull] TKey key, out bool exists);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54800000000,
        "Apis": [
          "M:CollectionsMarshal.GetValueRef\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E,TKey)",
          "M:CollectionsMarshal.GetValueRefOrAddDefault\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E,TKey,out bool)",
          "M:CollectionsMarshal.GetValueRefOrNullRef\u003CTKey, TValue\u003E(Dictionary\u003CTKey, TValue\u003E,TKey)",
          "T:CollectionsMarshal"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1570,
          "Title": "Developers using JsonSerializer can asynchronously (de)serialize IAsyncEnumerable\u003CT\u003E",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-13T19:47:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1570",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-16T00:00:00-07:00",
        "FeedbackId": "800522775",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1570#issuecomment-800522775",
        "FeedbackMarkdown": "* Why do we need \u0060SerializeAsyncEnumerable\u0060? Can\u0027t we do that just in the implementation of the existing \u0060SerializeAsync\u0060 method?\r\n    - It seems the primary reason is to support additional parameters, but (1) it doesn\u0027t seem necessary and (2) it could be made part of the \u0060JsonSerializerOptions\u0060\r\n* Do we need \u0060DeserializeAsyncEnumerable\u0060?\r\n    - It seems we do, due to the different behavior of ownership of errors\r\n    - Do we need to support this at all?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public static class JsonSerializer\r\n    {\r\n        public static Task SerializeAsyncEnumerable\u003CTValue\u003E(\r\n            Stream utf8Json,\r\n            IAsyncEnumerable\u003CTValue\u003E value,\r\n            int flushInterval = 0,\r\n            JsonSerializerOptions? options = null,\r\n            CancellationToken cancellationToken = default);\r\n\r\n        public static IAsyncEnumerable\u003CTValue?\u003E DeserializeAsyncEnumerable\u003CTValue\u003E(\r\n            Stream utf8Json,\r\n            JsonSerializerOptions? options = null,\r\n            CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonSerializer.DeserializeAsyncEnumerable\u003CTValue\u003E(Stream,JsonSerializerOptions?,CancellationToken)",
          "M:JsonSerializer.SerializeAsyncEnumerable\u003CTValue\u003E(Stream,IAsyncEnumerable\u003CTValue\u003E,int,JsonSerializerOptions?,CancellationToken)",
          "T:JsonSerializer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49465,
          "Title": "Enhance DynamicallyAccessedMembers Attribute to apply to class ",
          "Author": "LakshanF",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-11T00:52:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49465",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-16T00:00:00-07:00",
        "FeedbackId": "800524476",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49465#issuecomment-800524476",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\n namespace System.Diagnostics.CodeAnalysis\r\n {\r\n     [AttributeUsage(\r\n\u002B        AttributeTargets.Class |\r\n         AttributeTargets.Field |\r\n         AttributeTargets.GenericParameter |\r\n\u002B        AttributeTargets.Interface |\r\n\u002B        AttributeTargets.Struct |\r\n         AttributeTargets.Method |\r\n         AttributeTargets.Parameter |\r\n         AttributeTargets.Property |\r\n         AttributeTargets.ReturnValue,\r\n         Inherited = false)]\r\n     public partial class DynamicallyAccessedMembersAttribute : Attribute\r\n     {\r\n     }\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49670,
          "Title": "Add \u0060Empty\u0060 property to \u0060BinaryData\u0060",
          "Author": "ellismg",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-15T22:03:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49670",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-16T00:00:00-07:00",
        "FeedbackId": "800527813",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49670#issuecomment-800527813",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We can the analyzer/fixer suggestion from the existing analyzer but it should a get a new ID\r\n\r\n\u0060\u0060\u0060c#\r\nnamespace System\r\n{\r\n    public class BinaryData\r\n    {\r\n        public static BinaryData Empty { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:BinaryData.Empty",
          "T:BinaryData"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49036,
          "Title": "Introduce Date and Time only structs",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-03T00:05:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49036",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-18T00:00:00-07:00",
        "FeedbackId": "802237375",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49036#issuecomment-802237375",
        "FeedbackMarkdown": "* \u0060DateOnly\u0060 vs \u0060Date\u0060\r\n    - VB has a keyword \u0060Date\u0060 that binds to \u0060System.DateTime\u0060. If we called the type \u0060Date\u0060 VB users would have to use a namespace qualified name or use the escaping mechanism \u0060[Date]\u0060. If we expect this type to be popular among VB users that would be bad. If we don\u0027t believe it is, \u0060Date\u0060 might be acceptable to.\r\n    - We already have many properties in the BCL called \u0060Date\u0060 that return a \u0060DateTime\u0060. If we wanted to add properties that return the new type, we\u0027d have to come up with a new name. In that sense, it might be better if were to choose a different name and use that for both the type name and the property name, such as the proposed \u0060DateOnly\u0060.\r\n* \u0060DateOnly\u0060\r\n    - The constructor taking a single int is a bit weird. Should this be a factory instead?\r\n    - Is \u0060DaysInMonth()\u0060, \u0060IsLeapYear()\u0060 required?\r\n    - We can\u0027t have an implicit conversion from \u0060DateTime\u0060 to \u0060Date\u0060 because it results in data loss. Also, if we want to have an implicit conversion the other way, we shouldn\u0027t have the other way because it can result in ambiguities. Do we need conversions at all or should we have named methods or properties?\r\n    - The plus operator is unfortunate because time zone is unspecified. An instance method like \u0060ToDateTime(TimeOfDay, ...)\u0060 can have arguments. If we want to support an implicit zero time, we probably want different methods.\r\n    - Let\u0027s remove the static \u0060Compare()\u0060 and \u0060Equals\u0060 methods?\r\n    - The parse methods should have string overloads\r\n* \u0060TimeOfDay\u0060\r\n    - Can we get away with removing the \u0060Meridiem\u0060 type and associated constructors and properties and only expose this concept in parsing and formatting?\r\n    - Circular math without throwing makes sense, but it might surprise people. We should add an overload that indicates by how many days the clock wrapped forward or backwards. To make the API simpler, let\u0027s remove the other \u0060AddXxx()\u0060 methods.\r\n    - \u0060IsBetween()\u0060 the parameters should be named \u0060start\u0060 and \u0060end\u0060\r\n    - Let\u0027s remove the binary \u0060-\u0060 and \u0060\u002B\u0060 that take TimeSpan in favor of the \u0060Add\u0060 method\r\n    - Let\u0027s remove the conversion operators in favor of constructors\r\n    - Let\u0027s remove the static \u0060Compare()\u0060 and \u0060Equals\u0060 methods?\r\n    - The parse methods should have string overloads\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    // The name should be just Date but we couldn\u0027t use this name as VB is using the name type.\r\n    // Using DateOnly name but we may accept better names if there is any.\r\n    public readonly struct DateOnly : IComparable, IComparable\u003CDateOnly\u003E, IEquatable\u003CDateOnly\u003E, IFormattable\r\n    {\r\n        public static DateOnly MaxValue { get; }\r\n        public static DateOnly MinValue { get; }\r\n\r\n        public DateOnly(int year, int month, int day);\r\n        public DateOnly(int year, int month, int day, Calendar calendar);\r\n        public DateOnly(int dayNumber); // Needed only for serialization as we did in DateTime.Ticks\r\n\r\n        public int Year { get; }\r\n        public int Month { get; }\r\n        public int Day { get; }\r\n        public DayOfWeek DayOfWeek { get; }\r\n        public int DayOfYear { get; }\r\n        public int DayNumber { get; } // can be used to calculate the number of days between 2 dates\r\n        public static int DaysInMonth(int year, int month);\r\n\r\n        public DateOnly AddDays(int days);\r\n        public DateOnly AddMonths(int months);\r\n        public DateOnly AddYears(int years);\r\n        public static bool IsLeapYear(int year);\r\n        public static bool operator ==(DateOnly left, DateOnly right);\r\n        public static bool operator \u003E(DateOnly left, DateOnly right);\r\n        public static bool operator \u003E=(DateOnly left, DateOnly right);\r\n        public static bool operator !=(DateOnly left, DateOnly right);\r\n        public static bool operator \u003C(DateOnly left, DateOnly right);\r\n        public static bool operator \u003C=(DateOnly left, DateOnly right);\r\n\r\n        public int CompareTo(DateOnly value);\r\n        public int CompareTo(object? value);\r\n\r\n        public bool Equals(DateOnly value);\r\n        public override bool Equals(object? value);\r\n        public override int GetHashCode(); // day number\r\n\r\n        // Only Allowed DateTimeStyles: AllowWhiteSpaces, AllowTrailingWhite, AllowLeadingWhite, and AllowInnerWhite\r\n        public static DateOnly Parse(string s);\r\n        public static DateOnly Parse(string s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(string s, string format);\r\n        public static DateOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(string s, string [] formats);\r\n        public static DateOnly ParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(string s, out DateOnly date);\r\n        public static bool TryParse(string s, IFormatProvider? provider, DateTimeStyles styles, out DateOnly date);\r\n        public static bool TryParseExact(string s, string format, out DateOnly date);\r\n        public static bool TryParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n        public static bool TryParseExact(string s, string [] formats, out DateOnly date);\r\n        public static bool TryParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n\r\n        public static DateOnly Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static DateOnly Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out DateOnly date);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n\r\n        // Acceptable formats:\r\n        //      Year month pattern              y/Y\r\n        //      Sortable date/time pattern      s   date part only // like O one\r\n        //      RFC1123 pattern                 r/R date part only // include the day of week. based on RFC1123/rfc5322 \u0022ddd, dd MMM yyyy\u0022\r\n        //      round-trip date/time pattern    o/O date part only\r\n        //      Month/day pattern               m/M\r\n        //      Short date pattern              d\r\n        //      Long date pattern               D\r\n\r\n        public string ToLongDateString(); // use \u0022D\u0022     should we call it ToLongString\r\n        public string ToShortDateString(); // us \u0022d\u0022     should we call it ToShortString\r\n\r\n        public override string ToString();\r\n        public string ToString(string? format);\r\n        public string ToString(IFormatProvider? provider);\r\n        public string ToString(string? format, IFormatProvider? provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default, IFormatProvider? provider = null);\r\n    }\r\n\r\n    public readonly struct TimeOfDay : IComparable, IComparable\u003CTimeOfDay\u003E, IEquatable\u003CTimeOfDay\u003E, IFormattable // TimeOfDay\r\n    {\r\n        public static TimeOfDay MaxValue { get; }\r\n        public static TimeOfDay MinValue { get; }\r\n\r\n        public TimeOfDay(int hour, int minutes);\r\n        public TimeOfDay(int hour, int minutes, int seconds);\r\n        public TimeOfDay(int hour, int minutes, int seconds, int milliseconds);\r\n        public TimeOfDay(long ticks);\r\n        public TimeOfDay(TimeSpan timeSpan);\r\n        public TimeOfDay(DateTime dateTime);\r\n\r\n        public int Hour { get; }\r\n        public int Minute { get; }\r\n        public int Second { get; }\r\n        public int Millisecond { get; }\r\n        public long Ticks { get; }\r\n\r\n        public TimeOfDay Add(TimeSpan timeSpan); // circular\r\n        public TimeOfDay Add(TimeSpan timeSpan, out int daysWrappedAround);\r\n        public bool IsBetween(TimeOfDay start, TimeOfDay end);\r\n\r\n        public static bool operator ==(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003E(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003E=(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator !=(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003C(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003C=(TimeOfDay left, TimeOfDay right);\r\n\r\n        public static TimeSpan operator -(TimeOfDay t1, TimeOfDay t2); // Always positive time span\r\n\r\n        public int CompareTo(TimeOfDay value);\r\n        public int CompareTo(object? value);\r\n\r\n        public bool Equals(TimeOfDay value);\r\n        public override bool Equals(object? value);\r\n        public override int GetHashCode();\r\n\r\n        // Only Allowed DateTimeStyles: AllowWhiteSpaces, AllowTrailingWhite, AllowLeadingWhite, and AllowInnerWhite\r\n        public static TimeOfDay Parse(string s);\r\n        public static TimeOfDay Parse(string s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(string s, string format);\r\n        public static TimeOfDay ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(string s, string [] formats);\r\n        public static TimeOfDay ParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(string s, out TimeOfDay time);\r\n        public static bool TryParse(string s, IFormatProvider? provider, DateTimeStyles styles, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string format, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string [] formats, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n\r\n        public static TimeOfDay Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static TimeOfDay Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out TimeOfDay time);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n\r\n        // Acceptable formats:\r\n        //      Sortable date/time pattern      s   Time part only\r\n        //      RFC1123 pattern                 r/R Time part only like o\r\n        //      round-trip date/time pattern    o/O Time part only\r\n        //      Short time pattern              t\r\n        //      Long time pattern               T\r\n\r\n        public string ToLongString(); // use \u0022T\u0022     ToLongTimeString\r\n        public string ToShortString(); // us \u0022t\u0022     ToShortTimeString\r\n\r\n        public override string ToString();\r\n        public string ToString(string? format);\r\n        public string ToString(IFormatProvider? provider);\r\n        public string ToString(string? format, IFormatProvider? provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default(ReadOnlySpan\u003Cchar\u003E), IFormatProvider? provider = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DateOnly.!=(DateOnly,DateOnly)",
          "M:DateOnly.\u003C(DateOnly,DateOnly)",
          "M:DateOnly.\u003C=(DateOnly,DateOnly)",
          "M:DateOnly.==(DateOnly,DateOnly)",
          "M:DateOnly.\u003E(DateOnly,DateOnly)",
          "M:DateOnly.\u003E=(DateOnly,DateOnly)",
          "M:DateOnly.AddDays(int)",
          "M:DateOnly.AddMonths(int)",
          "M:DateOnly.AddYears(int)",
          "M:DateOnly.CompareTo(DateOnly)",
          "M:DateOnly.CompareTo(object?)",
          "M:DateOnly.DateOnly(int,int,int,Calendar)",
          "M:DateOnly.DateOnly(int,int,int)",
          "M:DateOnly.DateOnly(int)",
          "M:DateOnly.DaysInMonth(int,int)",
          "M:DateOnly.Equals(DateOnly)",
          "M:DateOnly.Equals(object?)",
          "M:DateOnly.GetHashCode()",
          "M:DateOnly.IsLeapYear(int)",
          "M:DateOnly.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:DateOnly.Parse(string,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.Parse(string)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [])",
          "M:DateOnly.ParseExact(string,string [],IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(string,string [])",
          "M:DateOnly.ParseExact(string,string,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(string,string)",
          "M:DateOnly.ToLongDateString()",
          "M:DateOnly.ToShortDateString()",
          "M:DateOnly.ToString()",
          "M:DateOnly.ToString(IFormatProvider?)",
          "M:DateOnly.ToString(string?,IFormatProvider?)",
          "M:DateOnly.ToString(string?)",
          "M:DateOnly.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:DateOnly.TryParse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParse(ReadOnlySpan\u003Cchar\u003E,out DateOnly)",
          "M:DateOnly.TryParse(string,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParse(string,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],out DateOnly)",
          "M:DateOnly.TryParseExact(string,string [],IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(string,string [],out DateOnly)",
          "M:DateOnly.TryParseExact(string,string,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(string,string,out DateOnly)",
          "M:TimeOfDay.-(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.!=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003C(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003C=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.==(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003E(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003E=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.Add(TimeSpan,out int)",
          "M:TimeOfDay.Add(TimeSpan)",
          "M:TimeOfDay.CompareTo(object?)",
          "M:TimeOfDay.CompareTo(TimeOfDay)",
          "M:TimeOfDay.Equals(object?)",
          "M:TimeOfDay.Equals(TimeOfDay)",
          "M:TimeOfDay.GetHashCode()",
          "M:TimeOfDay.IsBetween(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:TimeOfDay.Parse(string,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.Parse(string)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [])",
          "M:TimeOfDay.ParseExact(string,string [],IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(string,string [])",
          "M:TimeOfDay.ParseExact(string,string,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(string,string)",
          "M:TimeOfDay.TimeOfDay(DateTime)",
          "M:TimeOfDay.TimeOfDay(int,int,int,int)",
          "M:TimeOfDay.TimeOfDay(int,int,int)",
          "M:TimeOfDay.TimeOfDay(int,int)",
          "M:TimeOfDay.TimeOfDay(long)",
          "M:TimeOfDay.TimeOfDay(TimeSpan)",
          "M:TimeOfDay.ToLongString()",
          "M:TimeOfDay.ToShortString()",
          "M:TimeOfDay.ToString()",
          "M:TimeOfDay.ToString(IFormatProvider?)",
          "M:TimeOfDay.ToString(string?,IFormatProvider?)",
          "M:TimeOfDay.ToString(string?)",
          "M:TimeOfDay.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:TimeOfDay.TryParse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParse(ReadOnlySpan\u003Cchar\u003E,out TimeOfDay)",
          "M:TimeOfDay.TryParse(string,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParse(string,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string [],IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string [],out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string,out TimeOfDay)",
          "P:DateOnly.Day",
          "P:DateOnly.DayNumber",
          "P:DateOnly.DayOfWeek",
          "P:DateOnly.DayOfYear",
          "P:DateOnly.MaxValue",
          "P:DateOnly.MinValue",
          "P:DateOnly.Month",
          "P:DateOnly.Year",
          "P:TimeOfDay.Hour",
          "P:TimeOfDay.MaxValue",
          "P:TimeOfDay.Millisecond",
          "P:TimeOfDay.Minute",
          "P:TimeOfDay.MinValue",
          "P:TimeOfDay.Second",
          "P:TimeOfDay.Ticks",
          "T:DateOnly",
          "T:TimeOfDay"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "UF3eu1WBRrc",
      "StartDateTime": "2021-03-23T10:05:12-07:00",
      "EndDateTime": "2021-03-23T12:10:43-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/UF3eu1WBRrc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49036,
          "Title": "Introduce Date and Time only structs",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-03T00:05:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49036",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-23T00:00:00-07:00",
        "FeedbackId": "805091554",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49036#issuecomment-805091554",
        "FeedbackMarkdown": "* \u0060DateOnly\u0060\r\n    - Remove \u0060AddSeconds()\u0060\r\n    - Add \u0060ToTimeSpan()\u0060\r\n    - The \u0060AddXxx()\u0060 methods should take \u0060double\u0060, because that\u0027s what \u0060DateTime\u0060 does\r\n* \u0060TimeOfDay\u0060\r\n    - Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public readonly struct DateOnly : IComparable, IComparable\u003CDateOnly\u003E, IEquatable\u003CDateOnly\u003E, IFormattable\r\n    {\r\n        public static DateOnly MaxValue { get; }\r\n        public static DateOnly MinValue { get; }\r\n\r\n        public DateOnly(int year, int month, int day);\r\n        public DateOnly(int year, int month, int day, Calendar calendar);\r\n\r\n        public static DateOnly FromDayNumber(int dayNumber);\r\n\r\n        public int Year { get; }\r\n        public int Month { get; }\r\n        public int Day { get; }\r\n        public DayOfWeek DayOfWeek { get; }\r\n        public int DayOfYear { get; }\r\n        public int DayNumber { get; } // can be used to calculate the number of days between 2 dates\r\n\r\n        public DateOnly AddDays(double days);\r\n        public DateOnly AddMonths(double months);\r\n        public DateOnly AddYears(double years);\r\n\r\n        public static bool operator ==(DateOnly left, DateOnly right);\r\n        public static bool operator \u003E(DateOnly left, DateOnly right);\r\n        public static bool operator \u003E=(DateOnly left, DateOnly right);\r\n        public static bool operator !=(DateOnly left, DateOnly right);\r\n        public static bool operator \u003C(DateOnly left, DateOnly right);\r\n        public static bool operator \u003C=(DateOnly left, DateOnly right);\r\n\r\n        public DateTime ToDateTime(TimeOfDay time);\r\n        public DateTime ToDateTime(TimeOfDay time, DateTimeKind kind);\r\n        public static DateOnly FromDateTime(DateTime dateTime);\r\n\r\n        public int CompareTo(DateOnly value);\r\n        public int CompareTo(object? value);\r\n\r\n        public bool Equals(DateOnly value);\r\n\r\n        public override bool Equals(object? value);\r\n        public override int GetHashCode(); // day number\r\n\r\n        // Only Allowed DateTimeStyles: AllowWhiteSpaces, AllowTrailingWhite, AllowLeadingWhite, and AllowInnerWhite\r\n        public static DateOnly Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static DateOnly Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats);\r\n        public static DateOnly ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static DateOnly Parse(string s);\r\n        public static DateOnly Parse(string s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(string s, string format);\r\n        public static DateOnly ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static DateOnly ParseExact(string s, string [] formats);\r\n        public static DateOnly ParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out DateOnly date);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, out DateOnly date);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n\r\n        public static bool TryParse(string s, out DateOnly date);\r\n        public static bool TryParse(string s, IFormatProvider? provider, DateTimeStyles styles, out DateOnly date);\r\n        public static bool TryParseExact(string s, string format, out DateOnly date);\r\n        public static bool TryParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n        public static bool TryParseExact(string s, string [] formats, out DateOnly date);\r\n        public static bool TryParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out DateOnly date);\r\n\r\n        // Acceptable formats:\r\n        //      Year month pattern              y/Y\r\n        //      Sortable date/time pattern      s   date part only // like O one\r\n        //      RFC1123 pattern                 r/R date part only // include the day of week. based on RFC1123/rfc5322 \u0022ddd, dd MMM yyyy\u0022\r\n        //      round-trip date/time pattern    o/O date part only\r\n        //      Month/day pattern               m/M\r\n        //      Short date pattern              d\r\n        //      Long date pattern               D\r\n\r\n        public string ToLongDateString(); // use \u0022D\u0022     should we call it ToLongString\r\n        public string ToShortDateString(); // us \u0022d\u0022     should we call it ToShortString\r\n\r\n        public override string ToString();\r\n        public string ToString(string? format);\r\n        public string ToString(System.IFormatProvider? provider);\r\n        public string ToString(string? format, System.IFormatProvider? provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default(ReadOnlySpan\u003Cchar\u003E), IFormatProvider? provider = null);\r\n    }\r\n\r\n    public readonly struct TimeOfDay : IComparable, IComparable\u003CTimeOfDay\u003E, IEquatable\u003CTimeOfDay\u003E, IFormattable // TimeOfDay\r\n    {\r\n        public static TimeOfDay MaxValue { get; }\r\n        public static TimeOfDay MinValue { get; }\r\n\r\n        public TimeOfDay(int hour, int minutes);\r\n        public TimeOfDay(int hour, int minutes, int seconds);\r\n        public TimeOfDay(int hour, int minutes, int seconds, int milliseconds);\r\n\r\n        public TimeOfDay(long ticks);\r\n\r\n        public int Hour { get; }\r\n        public int Minute { get; }\r\n        public int Second { get; }\r\n        public int Millisecond { get; }\r\n        public long Ticks { get; }\r\n\r\n        public TimeOfDay Add(TimeSpan timeSpan); // circular\r\n        public TimeOfDay Add(TimeSpan timeSpan, out int wrappedDays); // circular\r\n\r\n        public TimeOfDay AddHours(double hours);\r\n        public TimeOfDay AddHours(double hours, out int wrappedDays);\r\n\r\n        public TimeOfDay AddMinutes(double minutes);\r\n        public TimeOfDay AddMinutes(double minutes, out int wrappedDays);\r\n       \r\n        public bool IsBetween(TimeOfDay start, TimeOfDay end);\r\n\r\n        public static bool operator ==(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003E(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003E=(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator !=(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003C(TimeOfDay left, TimeOfDay right);\r\n        public static bool operator \u003C=(TimeOfDay left, TimeOfDay right);\r\n\r\n        public static TimeSpan operator -(TimeOfDay t1, TimeOfDay t2); // Always positive time span\r\n        public static TimeOfDay FromTimeSpan(TimeSpan timeSpan);\r\n        public static TimeOfDay FromDateTime(DateTime dateTime); \r\n        public int CompareTo(TimeOfDay value);\r\n        public int CompareTo(object? value);\r\n\r\n        public bool Equals(TimeOfDay value);\r\n        public override bool Equals(object? value);\r\n        public override int GetHashCode();\r\n\r\n        // Only Allowed DateTimeStyles: AllowWhiteSpaces, AllowTrailingWhite, AllowLeadingWhite, and AllowInnerWhite\r\n        public static TimeOfDay Parse(ReadOnlySpan\u003Cchar\u003E s);\r\n        public static TimeOfDay Parse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats);\r\n        public static TimeOfDay ParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static TimeOfDay Parse(string s);\r\n        public static TimeOfDay Parse(string s, IFormatProvider? provider, DateTimeStyles styles = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(string s, string format);\r\n        public static TimeOfDay ParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n        public static TimeOfDay ParseExact(string s, string [] formats);\r\n        public static TimeOfDay ParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style = DateTimeStyles.None);\r\n\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, out TimeOfDay time);\r\n        public static bool TryParse(ReadOnlySpan\u003Cchar\u003E s, IFormatProvider? provider, DateTimeStyles styles, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, out TimeOfDay time);\r\n        public static bool TryParseExact(ReadOnlySpan\u003Cchar\u003E s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n\r\n        public static bool TryParse(string s, out TimeOfDay time);\r\n        public static bool TryParse(string s, IFormatProvider? provider, DateTimeStyles styles, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string format, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string format, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string [] formats, out TimeOfDay time);\r\n        public static bool TryParseExact(string s, string [] formats, IFormatProvider? provider, DateTimeStyles style, out TimeOfDay time);\r\n\r\n        // Acceptable formats:\r\n        //      Sortable date/time pattern      s   Time part only\r\n        //      RFC1123 pattern                 r/R Time part only like o\r\n        //      round-trip date/time pattern    o/O Time part only\r\n        //      Short time pattern              t\r\n        //      Long time pattern               T\r\n\r\n        public string ToLongString(); // use \u0022T\u0022     ToLongTimeString\r\n        public string ToShortString(); // us \u0022t\u0022     ToShortTimeString\r\n\r\n        public override string ToString();\r\n        public string ToString(string? format);\r\n        public string ToString(IFormatProvider? provider);\r\n        public string ToString(string? format, IFormatProvider? provider);\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format = default(ReadOnlySpan\u003Cchar\u003E), IFormatProvider? provider = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:DateOnly.!=(DateOnly,DateOnly)",
          "M:DateOnly.\u003C(DateOnly,DateOnly)",
          "M:DateOnly.\u003C=(DateOnly,DateOnly)",
          "M:DateOnly.==(DateOnly,DateOnly)",
          "M:DateOnly.\u003E(DateOnly,DateOnly)",
          "M:DateOnly.\u003E=(DateOnly,DateOnly)",
          "M:DateOnly.AddDays(double)",
          "M:DateOnly.AddMonths(double)",
          "M:DateOnly.AddYears(double)",
          "M:DateOnly.CompareTo(DateOnly)",
          "M:DateOnly.CompareTo(object?)",
          "M:DateOnly.DateOnly(int,int,int,Calendar)",
          "M:DateOnly.DateOnly(int,int,int)",
          "M:DateOnly.Equals(DateOnly)",
          "M:DateOnly.Equals(object?)",
          "M:DateOnly.FromDateTime(DateTime)",
          "M:DateOnly.FromDayNumber(int)",
          "M:DateOnly.GetHashCode()",
          "M:DateOnly.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:DateOnly.Parse(string,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.Parse(string)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [])",
          "M:DateOnly.ParseExact(string,string [],IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(string,string [])",
          "M:DateOnly.ParseExact(string,string,IFormatProvider?,DateTimeStyles)",
          "M:DateOnly.ParseExact(string,string)",
          "M:DateOnly.ToDateTime(TimeOfDay,DateTimeKind)",
          "M:DateOnly.ToDateTime(TimeOfDay)",
          "M:DateOnly.ToLongDateString()",
          "M:DateOnly.ToShortDateString()",
          "M:DateOnly.ToString()",
          "M:DateOnly.ToString(string?,System.IFormatProvider?)",
          "M:DateOnly.ToString(string?)",
          "M:DateOnly.ToString(System.IFormatProvider?)",
          "M:DateOnly.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:DateOnly.TryParse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParse(ReadOnlySpan\u003Cchar\u003E,out DateOnly)",
          "M:DateOnly.TryParse(string,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParse(string,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],out DateOnly)",
          "M:DateOnly.TryParseExact(string,string [],IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(string,string [],out DateOnly)",
          "M:DateOnly.TryParseExact(string,string,IFormatProvider?,DateTimeStyles,out DateOnly)",
          "M:DateOnly.TryParseExact(string,string,out DateOnly)",
          "M:TimeOfDay.-(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.!=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003C(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003C=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.==(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003E(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.\u003E=(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.Add(TimeSpan,out int)",
          "M:TimeOfDay.Add(TimeSpan)",
          "M:TimeOfDay.AddHours(double,out int)",
          "M:TimeOfDay.AddHours(double)",
          "M:TimeOfDay.AddMinutes(double,out int)",
          "M:TimeOfDay.AddMinutes(double)",
          "M:TimeOfDay.CompareTo(object?)",
          "M:TimeOfDay.CompareTo(TimeOfDay)",
          "M:TimeOfDay.Equals(object?)",
          "M:TimeOfDay.Equals(TimeOfDay)",
          "M:TimeOfDay.FromDateTime(DateTime)",
          "M:TimeOfDay.FromTimeSpan(TimeSpan)",
          "M:TimeOfDay.GetHashCode()",
          "M:TimeOfDay.IsBetween(TimeOfDay,TimeOfDay)",
          "M:TimeOfDay.Parse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.Parse(ReadOnlySpan\u003Cchar\u003E)",
          "M:TimeOfDay.Parse(string,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.Parse(string)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(ReadOnlySpan\u003Cchar\u003E,string [])",
          "M:TimeOfDay.ParseExact(string,string [],IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(string,string [])",
          "M:TimeOfDay.ParseExact(string,string,IFormatProvider?,DateTimeStyles)",
          "M:TimeOfDay.ParseExact(string,string)",
          "M:TimeOfDay.TimeOfDay(int,int,int,int)",
          "M:TimeOfDay.TimeOfDay(int,int,int)",
          "M:TimeOfDay.TimeOfDay(int,int)",
          "M:TimeOfDay.TimeOfDay(long)",
          "M:TimeOfDay.ToLongString()",
          "M:TimeOfDay.ToShortString()",
          "M:TimeOfDay.ToString()",
          "M:TimeOfDay.ToString(IFormatProvider?)",
          "M:TimeOfDay.ToString(string?,IFormatProvider?)",
          "M:TimeOfDay.ToString(string?)",
          "M:TimeOfDay.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:TimeOfDay.TryParse(ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParse(ReadOnlySpan\u003Cchar\u003E,out TimeOfDay)",
          "M:TimeOfDay.TryParse(string,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParse(string,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,ReadOnlySpan\u003Cchar\u003E,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(ReadOnlySpan\u003Cchar\u003E,string [],out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string [],IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string [],out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string,IFormatProvider?,DateTimeStyles,out TimeOfDay)",
          "M:TimeOfDay.TryParseExact(string,string,out TimeOfDay)",
          "P:DateOnly.Day",
          "P:DateOnly.DayNumber",
          "P:DateOnly.DayOfWeek",
          "P:DateOnly.DayOfYear",
          "P:DateOnly.MaxValue",
          "P:DateOnly.MinValue",
          "P:DateOnly.Month",
          "P:DateOnly.Year",
          "P:TimeOfDay.Hour",
          "P:TimeOfDay.MaxValue",
          "P:TimeOfDay.Millisecond",
          "P:TimeOfDay.Minute",
          "P:TimeOfDay.MinValue",
          "P:TimeOfDay.Second",
          "P:TimeOfDay.Ticks",
          "T:DateOnly",
          "T:TimeOfDay"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36022,
          "Title": "Enhance user-facing API for strongly-typed ILogger messages",
          "Author": "lodejard",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-09T02:21:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36022",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-23T00:00:00-07:00",
        "FeedbackId": "805134925",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36022#issuecomment-805134925",
        "FeedbackMarkdown": "* We should  make sure this design is aligned with C# 10\u0027s changes to interpolated string builders\r\n* The generator currently finds the \u0060ILogger\u0060 instance by name, it should do it by type and fail if more than one field of \u0060ILogger\u0060 is in scope. We could introduce an attribute to let people choose their name in those cases. Project file configuration would be unfortunate because it\u0027s not within the code.\r\n* Event IDs needs to be unique for a given category. It would be nice to have simple rules that allows the generator to validate uniqueness for most cases. We could accept false positives and rely on the normal suppression mechanism for diagnostics.\r\n* Alternatively, the original proposal used extension methods which people didn\u0027t like because they don\u0027t want people to use the basic \u0060Log\u0060 methods. Maybe the generator could warn on usages when extension methods exists?\r\n    - This would mean that we don\u0027t have to identity the logger field\r\n    - This would mean that event IDs uniqueness scope would be indicated by the type of the first argument.\r\n* We shouldn\u0027t introduce an \u0060Internal\u0060 namespace\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed partial class LoggerMessageAttribute : Attribute\r\n    {\r\n        public LoggerMessageAttribute(int eventId, LogLevel level, string? message = null);\r\n        public LoggerMessageAttribute(int eventId, string? message = null);\r\n        public int EventId { get; }\r\n        public string? EventName { get; set; }\r\n        public LogLevel? Level { get; }\r\n        public string? Message { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15600000000,
        "Apis": [
          "M:LoggerMessageAttribute.LoggerMessageAttribute(int,LogLevel,string?)",
          "M:LoggerMessageAttribute.LoggerMessageAttribute(int,string?)",
          "P:LoggerMessageAttribute.EventId",
          "P:LoggerMessageAttribute.EventName",
          "P:LoggerMessageAttribute.Level",
          "P:LoggerMessageAttribute.Message",
          "T:LoggerMessageAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49903,
          "Title": "AsyncMethodBuilderOverrideAttribute and PoolingAsyncValueTaskMethodBuilders",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-19T20:41:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49903",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-23T00:00:00-07:00",
        "FeedbackId": "805149431",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49903#issuecomment-805149431",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Class |\r\n                    AttributeTargets.Struct |\r\n                    AttributeTargets.Interface |\r\n                    AttributeTargets.Method |\r\n                    AttributeTargets.Constructor |\r\n                    AttributeTargets.Event |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Module, Inherited = false, AllowMultiple = true)]\r\n    public sealed partial class AsyncMethodBuilderOverrideAttribute : System.Attribute\r\n    {\r\n        public AsyncMethodBuilderOverrideAttribute(Type builderType);\r\n        public Type BuilderType { get; }\r\n    }\r\n    public struct PoolingAsyncValueTaskMethodBuilder\r\n    {\r\n        public static PoolingAsyncValueTaskMethodBuilder Create();\r\n        public ValueTask Task { get; }\r\n        public void SetResult();\r\n        public void SetException(Exception exception);\r\n        public void AwaitOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;\r\n        public void AwaitUnsafeOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;\r\n        public void Start\u003CTStateMachine\u003E(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;\r\n        public void SetStateMachine(IAsyncStateMachine stateMachine);\r\n    }\r\n    public struct PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E\r\n    {\r\n        public static PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E Create();\r\n        public ValueTask\u003CTResult\u003E Task { get; }\r\n        public void SetResult(TResult result);\r\n        public void SetException(Exception exception);\r\n        public void AwaitOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;\r\n        public void AwaitUnsafeOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;\r\n        public void SetStateMachine(IAsyncStateMachine stateMachine);\r\n        public void Start\u003CTStateMachine\u003E(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52580000000,
        "Apis": [
          "M:AsyncMethodBuilderOverrideAttribute.AsyncMethodBuilderOverrideAttribute(Type)",
          "M:PoolingAsyncValueTaskMethodBuilder.AwaitOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter,ref TStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder.AwaitUnsafeOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter,ref TStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder.Create()",
          "M:PoolingAsyncValueTaskMethodBuilder.SetException(Exception)",
          "M:PoolingAsyncValueTaskMethodBuilder.SetResult()",
          "M:PoolingAsyncValueTaskMethodBuilder.SetStateMachine(IAsyncStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder.Start\u003CTStateMachine\u003E(ref TStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.AwaitOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter,ref TStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.AwaitUnsafeOnCompleted\u003CTAwaiter, TStateMachine\u003E(ref TAwaiter,ref TStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.Create()",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.SetException(Exception)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.SetResult(TResult)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.SetStateMachine(IAsyncStateMachine)",
          "M:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.Start\u003CTStateMachine\u003E(ref TStateMachine)",
          "P:AsyncMethodBuilderOverrideAttribute.BuilderType",
          "P:PoolingAsyncValueTaskMethodBuilder.Task",
          "P:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E.Task",
          "T:AsyncMethodBuilderOverrideAttribute",
          "T:PoolingAsyncValueTaskMethodBuilder",
          "T:PoolingAsyncValueTaskMethodBuilder\u003CTResult\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50044,
          "Title": "ExceptionDispatchInfo.TrySetStackTrace",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-22T17:43:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50044",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-23T00:00:00-07:00",
        "FeedbackId": "805161306",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50044#issuecomment-805161306",
        "FeedbackMarkdown": "* Let\u0027s make this a non-try method (and let it fail if it can\u0027t work)\r\n* We should make sure that \u0060new StackTrace(exception)\u0060 doesn\u0027t blow up when someone catches the exception and tries to parse the stack trace\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.ExceptionServices\r\n{\r\n    public sealed class ExceptionDispatchInfo\r\n    {\r\n        public static bool SetRemoteStackTrace(Exception source, string stackTrace);\r\n\r\n        // existing API for reference\r\n        // public static Exception SetCurrentStackTrace(Exception source);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64380000000,
        "Apis": [
          "M:ExceptionDispatchInfo.SetRemoteStackTrace(Exception,string)",
          "T:ExceptionDispatchInfo"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "vNPybpatlUU",
      "StartDateTime": "2021-03-26T12:02:45-07:00",
      "EndDateTime": "2021-03-26T13:58:50-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/vNPybpatlUU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49407,
          "Title": "Time Zone IANA Ids to/From Windows Ids conversion APIs",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-10T02:46:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49407",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808455616",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49407#issuecomment-808455616",
        "FeedbackMarkdown": "* Looks good as proposed but please make sure to properly null-annotate them.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class TimeZoneInfo\r\n    {\r\n        public bool HasIanaId { get; }\r\n        public static bool TryConvertIanaIdToWindowsId(string ianaId, out string windowsId);\r\n        public static bool TryConvertWindowsIdToIanaId(string windowsId, out string ianaId);\r\n        public static bool TryConvertWindowsIdToIanaId(string windowsId, string region, out string ianaId);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:TimeZoneInfo.TryConvertIanaIdToWindowsId(string,out string)",
          "M:TimeZoneInfo.TryConvertWindowsIdToIanaId(string,out string)",
          "M:TimeZoneInfo.TryConvertWindowsIdToIanaId(string,string,out string)",
          "P:TimeZoneInfo.HasIanaId",
          "T:TimeZoneInfo"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50256,
          "Title": "Add BaseUtcOffset to TimeZoneInfo.AdjustmentRule.",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-25T19:53:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50256",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808463210",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50256#issuecomment-808463210",
        "FeedbackMarkdown": "* We probably want an overload for \u0060CreateAdjustmentRule\u0060 that allows people to construct an instance with an offset\r\n* We need to think about what this means for instances that were created without an offset. Should it be nullable?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n   public partial class TimeZoneInfo\r\n   {\r\n        public partial class AdjustmentRule\r\n        {\r\n            public TimeSpan BaseUtcOffset { get; }\r\n            public static AdjustmentRule CreateAdjustmentRule(\r\n                DateTime dateStart,\r\n                DateTime dateEnd,\r\n                TimeSpan daylightDelta,\r\n                TransitionTime daylightTransitionStart,\r\n                TransitionTime daylightTransitionEnd,\r\n                TimeSpan baseUtcOffset\r\n            );\r\n         }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7540000000,
        "Apis": [
          "M:TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(DateTime,DateTime,TimeSpan,TransitionTime,TransitionTime,TimeSpan)",
          "P:TimeZoneInfo.AdjustmentRule.BaseUtcOffset",
          "T:TimeZoneInfo",
          "T:TimeZoneInfo.AdjustmentRule"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24328,
          "Title": "General purpose non-cryptographic hashing API for .NET",
          "Author": "jamesqo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-03T20:42:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24328",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808489277",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24328#issuecomment-808489277",
        "FeedbackMarkdown": "* Namespace\r\n    - We\u0027re not convinced it deserves a top level namespace like \u0060System.Hashing\u0060.\r\n    - Let\u0027s use \u0060System.IO.Hashing\u0060, we could consider a peer to compression which we have in \u0060System.IO.Compression\u0060.\r\n    - \u0060System.Buffers\u0060 and \u0060System.Numerics\u0060 both seem less discoverable because they seem to focus on the implementation, not the scenario.\r\n* Assembly\r\n    - Should probably be in a separate assembly because there seems to be a need to have it OOB and be able to extend the set of types\r\n* \u0060NonCryptographicHashAlgorithm\u0060\r\n    - \u0060Length\u0060 is ambiguous. It could mean digest length or how much data was fed to it. How about \u0060HashLengthInBytes\u0060?\r\n    - Should we keep track of the length of the data that was appended? This probably requires \u0060AppendCore\u0060 and \u0060ResetCore\u0060 so that we can factor common code into a non-abstract version. We don\u0027t believe this is common enough to justify the complexity.\r\n    - We should obsolete and hide \u0060GetHashCode()\u0060, like we did for \u0060HashCode\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Hashing\r\n{\r\n    public abstract class NonCryptographicHashAlgorithm\r\n    {\r\n        public int HashLengthInBytes { get; }\r\n\r\n        protected NonCryptographicHashAlgorithm(int hashLengthInBytes);\r\n\r\n        public abstract void Append(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public abstract void Reset();\r\n        protected abstract int GetCurrentHashCore(Span\u003Cbyte\u003E destination);\r\n\r\n        public void Append(byte[] source);\r\n        public void Append(Stream stream);\r\n        public Task AppendAsync(Stream stream, CancellationToken cancellationToken = default);\r\n        public byte[] GetCurrentHash();\r\n        public bool TryGetCurrentHash(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetCurrentHash(Span\u003Cbyte\u003E destination);\r\n        public byte[] GetHashAndReset();\r\n        public bool TryGetHashAndReset(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetHashAndReset(Span\u003Cbyte\u003E destination);\r\n\r\n        protected virtual int GetHashAndResetCore(Span\u003Cbyte\u003E destination);\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        [Obsolete(\u0022Use GetCurrentHash() to retrieve the computed hash code.\u0022, true)]\r\n        public int GetHashCode();\r\n    }\r\n    public class XxHash32 : NonCryptographicHashAlgorithm\r\n    {\r\n        public XxHash32();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n    public class XxHash64 : NonCryptographicHashAlgorithm\r\n    {\r\n        public XxHash64();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n    public class Crc32 : NonCryptographicHashAlgorithm\r\n    {\r\n        public Crc32();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n    public class Crc64 : NonCryptographicHashAlgorithm\r\n    {\r\n        public Crc64();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16870000000,
        "Apis": [
          "M:Crc32.Crc32()",
          "M:Crc32.Hash(byte[])",
          "M:Crc32.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Crc32.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Crc32.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:Crc64.Crc64()",
          "M:Crc64.Hash(byte[])",
          "M:Crc64.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Crc64.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Crc64.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:NonCryptographicHashAlgorithm.Append(byte[])",
          "M:NonCryptographicHashAlgorithm.Append(ReadOnlySpan\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.Append(Stream)",
          "M:NonCryptographicHashAlgorithm.AppendAsync(Stream,CancellationToken)",
          "M:NonCryptographicHashAlgorithm.GetCurrentHash()",
          "M:NonCryptographicHashAlgorithm.GetCurrentHash(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetCurrentHashCore(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashAndReset()",
          "M:NonCryptographicHashAlgorithm.GetHashAndReset(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashAndResetCore(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashCode()",
          "M:NonCryptographicHashAlgorithm.NonCryptographicHashAlgorithm(int)",
          "M:NonCryptographicHashAlgorithm.Reset()",
          "M:NonCryptographicHashAlgorithm.TryGetCurrentHash(Span\u003Cbyte\u003E,out int)",
          "M:NonCryptographicHashAlgorithm.TryGetHashAndReset(Span\u003Cbyte\u003E,out int)",
          "M:XxHash32.Hash(byte[])",
          "M:XxHash32.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:XxHash32.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:XxHash32.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:XxHash32.XxHash32()",
          "M:XxHash64.Hash(byte[])",
          "M:XxHash64.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:XxHash64.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:XxHash64.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:XxHash64.XxHash64()",
          "P:NonCryptographicHashAlgorithm.HashLengthInBytes",
          "T:Crc32",
          "T:Crc64",
          "T:NonCryptographicHashAlgorithm",
          "T:XxHash32",
          "T:XxHash64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50059,
          "Title": "StringComparer.IsWellKnownComparer",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-22T20:38:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50059",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808496914",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50059#issuecomment-808496914",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public abstract class StringComparer\r\n    {\r\n        public static bool IsWellKnownOrdinalComparer(IEqualityComparer\u003Cstring?\u003E? comparer,\r\n                                                      out bool ignoreCase);\r\n\r\n        public static bool IsWellKnownCultureAwareComparer(IEqualityComparer\u003Cstring?\u003E? comparer,\r\n                                                           [NotNullWhen(true)] out CompareInfo? compareInfo,\r\n                                                           out CompareOptions compareOptions);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:StringComparer.IsWellKnownCultureAwareComparer(IEqualityComparer\u003Cstring?\u003E?,out CompareInfo?,out CompareOptions)",
          "M:StringComparer.IsWellKnownOrdinalComparer(IEqualityComparer\u003Cstring?\u003E?,out bool)",
          "T:StringComparer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48492,
          "Title": "Add CancellationTokenSource.TryReset()",
          "Author": "halter73",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-19T00:57:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48492",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808499702",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48492#issuecomment-808499702",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial class CancellationTokenSource\r\n    {\r\n        public bool TryReset();    \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59080000000,
        "Apis": [
          "M:CancellationTokenSource.TryReset()",
          "T:CancellationTokenSource"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43887,
          "Title": "Proposal: add a static, thread-static Random.Current instance",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-27T13:37:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43887",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808500968",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43887#issuecomment-808500968",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Random\r\n    {\r\n        public static Random Shared { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 62900000000,
        "Apis": [
          "P:Random.Shared",
          "T:Random"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36522,
          "Title": "Inform client code when a BoundedChannel drops an item",
          "Author": "odydoum",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-15T10:47:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36522",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading.Channels",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808502110",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36522#issuecomment-808502110",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Channels\r\n{\r\n    public static class Channel\r\n    {\r\n        // Existing:\r\n        // public static Channel\u003CT\u003E CreateBounded\u003CT\u003E(int capacity);\r\n        // public static Channel\u003CT\u003E CreateBounded\u003CT\u003E(BoundedChannelOptions options);\r\n        public static Channel\u003CT\u003E CreateBounded\u003CT\u003E(BoundedChannelOptions options, Action\u003CT\u003E itemDropped);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64770000000,
        "Apis": [
          "M:Channel.CreateBounded\u003CT\u003E(BoundedChannelOptions,Action\u003CT\u003E)",
          "T:Channel"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36010,
          "Title": "Configuration \u003E Binder - Support for binding by custom attribute names. ",
          "Author": "Coderrob",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-12-29T01:12:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36010",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-26T00:00:00-07:00",
        "FeedbackId": "808504315",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36010#issuecomment-808504315",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - Does this need an analyzer?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    [AttributeUsage(AttributeTargets.Field | AttributeTargets.Property)]\r\n    public sealed class ConfigurationKeyNameAttribute : Attribute\r\n    {\r\n        public ConfigurationKeyNameAttribute(string name);\r\n        public string Name { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 66460000000,
        "Apis": [
          "M:ConfigurationKeyNameAttribute.ConfigurationKeyNameAttribute(string)",
          "P:ConfigurationKeyNameAttribute.Name",
          "T:ConfigurationKeyNameAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "DzwksIp-zN4",
      "StartDateTime": "2021-03-30T10:03:45-07:00",
      "EndDateTime": "2021-03-30T12:11:31-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/DzwksIp-zN4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24698,
          "Title": "Add isAsync overload for Create/Open/etc.",
          "Author": "Duranom",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-17T16:53:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24698",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-30T00:00:00-07:00",
        "FeedbackId": "810441090",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24698#issuecomment-810441090",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n        public StreamWriter AppendText(string path, FileOptions options) =\u003E throw null;\r\n        public static System.IO.FileStream Create(string path, System.IO.FileOptions options) =\u003E throw null;\r\n        public static System.IO.StreamWriter CreateText(string path, System.IO.FileOptions options) =\u003E throw null;   \r\n        public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileOptions options) =\u003E throw null;\r\n        public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileOptions options) =\u003E throw null;\r\n        public static System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options) =\u003E throw null;\r\n        public static System.IO.FileStream OpenRead(string path, System.IO.FileOptions options) =\u003E throw null; { throw null; }\r\n        public static System.IO.StreamReader OpenText(string path, System.IO.FileOptions options) =\u003E throw null; { throw null; }\r\n        public static System.IO.FileStream OpenWrite(string path, System.IO.FileOptions options) =\u003E throw null; { throw null; }\r\n    }\r\n    public sealed partial class FileInfo : System.IO.FileSystemInfo\r\n    {\r\n        public StreamWriter AppendText(FileOptions options) =\u003E throw null;\r\n        public System.IO.FileStream Create(System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.StreamWriter CreateText(System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.FileStream OpenRead(System.IO.FileOptions options) =\u003E throw null;\r\n        public System.IO.StreamReader OpenText(System.IO.FileOptions options) =\u003E throw null;    \r\n        public System.IO.FileStream OpenWrite(System.IO.FileOptions options) =\u003E throw null;\r\n    }\r\n    public partial class StreamReader : System.IO.TextReader\r\n    {\r\n        public StreamReader(string path, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamReader(string path, bool detectEncodingFromByteOrderMarks, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamReader(string path, System.Text.Encoding encoding, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, System.IO.FileOptions options) =\u003E throw null;\r\n    }\r\n    public partial class StreamWriter : System.IO.TextWriter\r\n    {\r\n        public StreamWriter(string path, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamWriter(string path, bool append, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamWriter(string path, bool append, System.Text.Encoding encoding, System.IO.FileOptions options) =\u003E throw null;\r\n        public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize, System.IO.FileOptions options) =\u003E throw null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:.OpenText(string,System.IO.FileOptions)",
          "M:File.AppendText(string,FileOptions)",
          "M:File.Create(string,System.IO.FileOptions)",
          "M:File.CreateText(string,System.IO.FileOptions)",
          "M:File.Open(string,System.IO.FileMode,System.IO.FileAccess,System.IO.FileOptions)",
          "M:File.Open(string,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions)",
          "M:File.Open(string,System.IO.FileMode,System.IO.FileOptions)",
          "M:File.OpenRead(string,System.IO.FileOptions)",
          "M:FileInfo.AppendText(FileOptions)",
          "M:FileInfo.Create(System.IO.FileOptions)",
          "M:FileInfo.CreateText(System.IO.FileOptions)",
          "M:FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileOptions)",
          "M:FileInfo.Open(System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.FileOptions)",
          "M:FileInfo.Open(System.IO.FileMode,System.IO.FileOptions)",
          "M:FileInfo.OpenRead(System.IO.FileOptions)",
          "M:FileInfo.OpenText(System.IO.FileOptions)",
          "M:FileInfo.OpenWrite(System.IO.FileOptions)",
          "M:StreamReader.StreamReader(string,bool,System.IO.FileOptions)",
          "M:StreamReader.StreamReader(string,System.IO.FileOptions)",
          "M:StreamReader.StreamReader(string,System.Text.Encoding,bool,int,System.IO.FileOptions)",
          "M:StreamReader.StreamReader(string,System.Text.Encoding,bool,System.IO.FileOptions)",
          "M:StreamReader.StreamReader(string,System.Text.Encoding,System.IO.FileOptions)",
          "M:StreamWriter.StreamWriter(string,bool,System.IO.FileOptions)",
          "M:StreamWriter.StreamWriter(string,bool,System.Text.Encoding,int,System.IO.FileOptions)",
          "M:StreamWriter.StreamWriter(string,bool,System.Text.Encoding,System.IO.FileOptions)",
          "M:StreamWriter.StreamWriter(string,System.IO.FileOptions)",
          "T:File",
          "T:FileInfo",
          "T:StreamReader",
          "T:StreamWriter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45946,
          "Title": "FileStream file preallocation performance",
          "Author": "dmex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-11T07:31:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45946",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-30T00:00:00-07:00",
        "FeedbackId": "810455289",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45946#issuecomment-810455289",
        "FeedbackMarkdown": "* Some of the existing methods are getting really long signatures, let\u0027s start defaulting these.\r\n* We asked if we really needed/wanted all 4, and it seemed like a reasonable thing to do.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public class FileStream : Stream\r\n    {\r\n        public FileStream(string path, FileMode mode, FileAccess access = appropriate default, FileShare share = appropriate default, int bufferSize = appropriate default, FileOptions options = appropriate default, long allocationSize = appropriate default)\r\n    }\r\n    \r\n    public partial class StreamWriter : System.IO.TextWriter\r\n    {\r\n        public StreamWriter(string path, bool append = false, System.Text.Encoding? encoding, int bufferSize = -1, FileOptions options = FileOptions.None, long allocationSize = -1)\r\n    }\r\n    \r\n    public static partial class File\r\n    {\r\n        public static FileStream Create(string path, int bufferSize = appropriate default, FileOptions options = appropriate default, long allocationSize = appropriate default)\r\n    }\r\n    \r\n    public sealed partial class FileInfo : System.IO.FileSystemInfo\r\n    {\r\n        public System.IO.FileStream Create(FileOptions options = appropriate default, long allocationSize = appropriate default)\r\n    }\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 13490000000,
        "Apis": [
          "M:File.Create(string,int,FileOptions,long)",
          "M:FileInfo.Create(FileOptions,long)",
          "M:FileStream.FileStream(string,FileMode,FileAccess,FileShare,int,FileOptions,long)",
          "M:StreamWriter.StreamWriter(string,bool,System.Text.Encoding?,int,FileOptions,long)",
          "T:File",
          "T:FileInfo",
          "T:FileStream",
          "T:StreamWriter"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24847,
          "Title": "Async File IO APIs mimicking Win32 OVERLAPPED",
          "Author": "alexbudmsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-30T22:29:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24847",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-30T00:00:00-07:00",
        "FeedbackId": "810484866",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24847#issuecomment-810484866",
        "FeedbackMarkdown": "* In the review we were generally (but not unanimously) against the new types\r\n* The \u0060SafeFileHandle\u0060 extensions approach was received more warmly\r\n* Instead of extension methods, consider just static invocations to allow for variations.\r\n* Consider an \u0060IsSupported\u0060-type API so that it\u0027s clear they don\u0027t work on mobile.\r\n\r\nSomething like\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO // TBD\r\n{\r\n    public static class FileHandleOperations\r\n    {\r\n        public static bool SupportsOffsetOperations { get; }\r\n\r\n        public static int ReadAtOffset(SafeFileHandle fileHandle, Span\u003Cbyte\u003E buffer, ulong fileOffset);\r\n        public static int ReadAtOffset(IntPtr fileHandle, Span\u003Cbyte\u003E buffer, ulong fileOffset);\r\n\r\n        public static int WriteAtOffset(SafeFileHandle fileHandle, ReadOnlySpan\u003Cbyte\u003E buffer, ulong fileOffset);\r\n        public static int WriteAtOffset(IntPtr fileHandle, ReadOnlySpan\u003Cbyte\u003E buffer, ulong fileOffset);\r\n         \r\n        public static ValueTask\u003Cint\u003E ReadAtOffsetAsync(SafeFileHandle fileHandle, Memory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E ReadAtOffsetAsync(IntPtr fileHandle, Memory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n\r\n        public static ValueTask\u003Cint\u003E WriteAtOffsetAsync(SafeFileHandle fileHandle, ReadOnlyMemory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E WriteAtOffsetAsync(IntPtr fileHandle, ReadOnlyMemory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nbut that needs to be verified against the original scenarios.",
        "TimeCode": 26810000000,
        "Apis": [
          "M:FileHandleOperations.ReadAtOffset(IntPtr,Span\u003Cbyte\u003E,ulong)",
          "M:FileHandleOperations.ReadAtOffset(SafeFileHandle,Span\u003Cbyte\u003E,ulong)",
          "M:FileHandleOperations.ReadAtOffsetAsync(IntPtr,Memory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:FileHandleOperations.ReadAtOffsetAsync(SafeFileHandle,Memory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:FileHandleOperations.WriteAtOffset(IntPtr,ReadOnlySpan\u003Cbyte\u003E,ulong)",
          "M:FileHandleOperations.WriteAtOffset(SafeFileHandle,ReadOnlySpan\u003Cbyte\u003E,ulong)",
          "M:FileHandleOperations.WriteAtOffsetAsync(IntPtr,ReadOnlyMemory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:FileHandleOperations.WriteAtOffsetAsync(SafeFileHandle,ReadOnlyMemory\u003Cbyte\u003E,ulong,CancellationToken)",
          "P:FileHandleOperations.SupportsOffsetOperations",
          "T:FileHandleOperations"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50122,
          "Title": "Add class as a target for RequiresUnreferencedCodeAttribute",
          "Author": "tlakollo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-23T20:47:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50122",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "area-AssemblyLoader-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-30T00:00:00-07:00",
        "FeedbackId": "810493381",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50122#issuecomment-810493381",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We discussed the Struct and Interface targets, and felt that while they\u0027ll eventually show up we shouldn\u0027t add the usage until we have an implementation backing them up.\r\n\r\n\u0060\u0060\u0060diff\r\n namespace System.Diagnostics.CodeAnalysis\r\n {\r\n     [AttributeUsage(\r\n\u002B        AttributeTargets.Class |\r\n         AttributeTargets.Constructor |\r\n         AttributeTargets.Method,\r\n         Inherited = false)]\r\n     public sealed class RequiresUnreferencedCodeAttribute : Attribute\r\n     {\r\n     }\r\n }\r\n\u0060\u0060\u0060\u0060",
        "TimeCode": 53600000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31088,
          "Title": "Add compression support in WebSocket",
          "Author": "zlatanov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-07T13:22:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31088",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-03-30T00:00:00-07:00",
        "FeedbackId": "810509834",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31088#issuecomment-810509834",
        "FeedbackMarkdown": "* We discussed whether the DisableCompression should be Enable or Disable, and agree Disable makes sense as a per-message option\r\n* The WebSocketMessageFlags enum should name the zero member (None, Default, etc)\r\n* Consider defaulting the WebSocketMessageFlags parameter in SendAsync\r\n* We\u0027re OK with the new \u0022Dangerous\u0022 prefix, so long as it\u0027s really expected to be rarely used -- don\u0027t dilute the meaning of \u0022Dangerous\u0022.\r\n  * Ensure that there\u0027s consistency or followup action for higher level APIs that may be doing similar things, such as SignalR/ASP.NET.\r\n\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Net.WebSockets\r\n{\r\n    public sealed class WebSocketCreationOptions\r\n    {\r\n        public bool IsServer { get; set; }\r\n        public string? SubProtocol { get; set; }\r\n        public TimeSpan KeepAliveInterval { get; set; }\r\n-       public WebSocketDeflateOptions? DeflateOptions { get; set; } = null;\r\n\u002B       public WebSocketDeflateOptions? DangerousDeflateOptions { get; set; } = null;\r\n    }\r\n\r\n    public partial class ClientWebSocketOptions\r\n    {\r\n-       public WebSocketDeflateOptions? DeflateOptions { get; set; } = null;\r\n\u002B       public WebSocketDeflateOptions? DangerousDeflateOptions { get; set; } = null;\r\n    }\r\n\r\n\u002B   [Flags]\r\n\u002B   public enum WebSocketMessageFlags\r\n\u002B   {\r\n\u002B       None = 0,\r\n\u002B\r\n\u002B       // taken from existing WebSocket.SendAsync params\r\n\u002B       EndOfMessage = 1,\r\n\u002B\r\n\u002B       // new\r\n\u002B       DisableCompression = 2\r\n\u002B   }\r\n\r\n    public partial class WebSocket\r\n    {\r\n\u002B       public virtual ValueTask SendAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, WebSocketMessageType messageType, WebSocketMessageFlags messageFlags, CancellationToken cancellationToken = default);\r\n    }    \r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61680000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4712,
          "Title": "[DialogResult] Add TryAgain and Continue (result 10, and 11) respectively.",
          "Author": "AraHaan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-23T04:00:43+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4712",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-01T00:00:00-07:00",
        "FeedbackId": "812047601",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4712#issuecomment-812047601",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial enum DialogResult\r\n    {\r\n        // ...\r\n        TryAgain,\r\n        Continue\r\n    }\r\n    public partial enum MessageBoxButtons\r\n    {\r\n        // ...\r\n        CancelTryContinue\r\n    }\r\n    public partial enum MessageBoxDefaultButton\r\n    {\r\n        // ...\r\n        Button4\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:DialogResult.Continue",
          "F:DialogResult.TryAgain",
          "F:MessageBoxButtons.CancelTryContinue",
          "F:MessageBoxDefaultButton.Button4",
          "T:DialogResult",
          "T:MessageBoxButtons",
          "T:MessageBoxDefaultButton"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49361,
          "Title": "Add a notification mechanism for EnC and HotReload",
          "Author": "StephaneDelcroix",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-09T14:08:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49361",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Diagnostics-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-01T00:00:00-07:00",
        "FeedbackId": "812052792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49361#issuecomment-812052792",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=True)]\r\n    public sealed class MetadataUpdateHandlerAttribute : Attribute\r\n    {\r\n        public MetadataUpdateHandlerAttribute(Type type)   \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MetadataUpdateHandlerAttribute.MetadataUpdateHandlerAttribute(Type)",
          "T:MetadataUpdateHandlerAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50256,
          "Title": "Add BaseUtcOffset to TimeZoneInfo.AdjustmentRule.",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-25T19:53:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50256",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-01T00:00:00-07:00",
        "FeedbackId": "812056450",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50256#issuecomment-812056450",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n   public partial class TimeZoneInfo\r\n   {\r\n        public partial class AdjustmentRule\r\n        {\r\n            public TimeSpan BaseUtcOffsetDelta { get; }\r\n\r\n            // Existing method:\r\n            // public static AdjustmentRule CreateAdjustmentRule(\r\n            //     DateTime dateStart,\r\n            //     DateTime dateEnd,\r\n            //     TimeSpan daylightDelta,\r\n            //     TransitionTime daylightTransitionStart,\r\n            //     TransitionTime daylightTransitionEnd\r\n            // );\r\n\r\n            public static AdjustmentRule CreateAdjustmentRule(\r\n                DateTime dateStart,\r\n                DateTime dateEnd,\r\n                TimeSpan daylightDelta,\r\n                TransitionTime daylightTransitionStart,\r\n                TransitionTime daylightTransitionEnd,\r\n                TimeSpan baseUtcOffsetDelta\r\n            );\r\n         }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:TimeZoneInfo.AdjustmentRule.CreateAdjustmentRule(DateTime,DateTime,TimeSpan,TransitionTime,TransitionTime,TimeSpan)",
          "P:TimeZoneInfo.AdjustmentRule.BaseUtcOffsetDelta",
          "T:TimeZoneInfo",
          "T:TimeZoneInfo.AdjustmentRule"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1570,
          "Title": "Developers using JsonSerializer can asynchronously (de)serialize IAsyncEnumerable\u003CT\u003E",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-13T19:47:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1570",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-01T00:00:00-07:00",
        "FeedbackId": "812078537",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1570#issuecomment-812078537",
        "FeedbackMarkdown": "* We don\u0027t believe we need any opt-in or opt-out\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializer\r\n    {\r\n        public static IAsyncEnumerable\u003CTValue?\u003E DeserializeAsyncEnumerable\u003CTValue\u003E(Stream utf8Json, JsonSerializerOptions? options = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonSerializer.DeserializeAsyncEnumerable\u003CTValue\u003E(Stream,JsonSerializerOptions?)",
          "T:JsonSerializer"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47649,
          "Title": "API for writeable DOM and C# dynamic support",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-29T20:56:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47649",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-01T00:00:00-07:00",
        "FeedbackId": "812123225",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47649#issuecomment-812123225",
        "FeedbackMarkdown": "* \u0060JsonNode\u0060\r\n    - \u0060ReadFrom\u0060 should be \u0060Parse\u0060\r\n    - \u0060WriteToUtf8\u0060 should be \u0060WriteTo\u0060\r\n    - Remove \u0060ToUtf8Bytes()\u0060 but keep \u0060ToJsonString()\u0060\r\n    - The conversions seem fine, the equivalent is \u0060JsonValue.Create()\u0060 or extracting the value\r\n    - Consider implementing \u0060IConvertible\u0060\r\n    - One downside of implicit conversions is that \u0060jsonArray.Contains(3)\u0060 will\r\n      compile but always return \u0060false\u0060 because it\u0027s reference equality\r\n* \u0060JsonValue\u0060\r\n    - The non-generic class should have a \u0060Value\u0060 property of type \u0060object\u0060 that returns the boxed value\r\n    - The constructor should be \u0060private protected\u0060 so that consumers can\u0027t subclass\r\n* \u0060JsonValue\u003CT\u003E\u0060\r\n    - It seems when reading a document most values are going to be \u0060JsonValue\u003CJsonElement\u003E\u0060 (as opposed to \u0060JsonValue\u003Cint\u003E\u0060 or \u0060JsonValue\u003Cstring\u003E\u0060)\r\n    - Should we make this class internal and only deal with \u0060JsonValue\u0060? This way, callers can\u0027t get the \u0060T\u0060 wrong. If we do this, we should remove the non-generic \u0060Value\u0060 property from \u0060JsonValue\u0060 as well.\r\n* \u0060JsonObject\u0060\r\n    - Should this have a property \u0060IEnumerable\u003Cstring\u003E Properties\u0060?\r\n    - We should implement \u0060ContainsKey()\u0060 explicit and add \u0060HasProperty()\u0060\r\n* \u0060JsonNode\u0060\r\n    - Should we have \u0060JsonNode\u003CT\u003E AsValue\u003CT\u003E()\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Node\r\n{\r\n    public sealed partial class JsonArray : JsonNode, ICollection\u003CJsonNode?\u003E, IEnumerable\u003CJsonNode?\u003E, IList\u003CJsonNode?\u003E, IEnumerable\r\n    {\r\n        public JsonArray(JsonNodeOptions? options = default);\r\n        public JsonArray(JsonElement element, JsonNodeOptions? options = default);\r\n        public JsonArray(JsonNodeOptions options, params JsonNode[] items);\r\n        public JsonArray(params JsonNode[] items);\r\n        public int Count { get; }\r\n        bool ICollection\u003CJsonNode?\u003E.IsReadOnly { get; }\r\n        public void Add(JsonNode? item);\r\n        public void Add\u003CT\u003E(T value);\r\n        public void Clear();\r\n        public bool Contains(JsonNode? item);\r\n        public IEnumerator\u003CJsonNode?\u003E GetEnumerator();\r\n        public int IndexOf(JsonNode? item);\r\n        public void Insert(int index, JsonNode? item);\r\n        public bool Remove(JsonNode? item);\r\n        public void RemoveAt(int index);\r\n        void ICollection\u003CJsonNode?\u003E.CopyTo(JsonNode?[]? array, int arrayIndex);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n        public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = default);\r\n    }\r\n    public abstract partial class JsonNode\r\n    {\r\n        internal JsonNode();\r\n        public JsonNode? this[int index] { get; set; }\r\n        public JsonNode? this[string key] { get; set; }\r\n        public JsonNodeOptions? Options { get; }\r\n        public JsonNode? Parent { get; }\r\n        public JsonNode Root { get; }\r\n        public JsonArray AsArray();\r\n        public JsonObject AsObject();\r\n        public JsonValue AsValue();\r\n        public string GetPath();\r\n        public virtual TValue GetValue\u003CTValue\u003E(JsonSerializerOptions? options = null);\r\n        public static explicit operator bool(JsonNode value);\r\n        public static explicit operator byte(JsonNode value);\r\n        public static explicit operator char(JsonNode value);\r\n        public static explicit operator DateTime(JsonNode value);\r\n        public static explicit operator DateTimeOffset(JsonNode value);\r\n        public static explicit operator decimal(JsonNode value);\r\n        public static explicit operator double(JsonNode value);\r\n        public static explicit operator Guid(JsonNode value);\r\n        public static explicit operator short(JsonNode value);\r\n        public static explicit operator int(JsonNode value);\r\n        public static explicit operator long(JsonNode value);\r\n        public static explicit operator bool?(JsonNode? value);\r\n        public static explicit operator byte?(JsonNode? value);\r\n        public static explicit operator char?(JsonNode? value);\r\n        public static explicit operator DateTimeOffset?(JsonNode? value);\r\n        public static explicit operator DateTime?(JsonNode? value);\r\n        public static explicit operator decimal?(JsonNode? value);\r\n        public static explicit operator double?(JsonNode? value);\r\n        public static explicit operator Guid?(JsonNode? value);\r\n        public static explicit operator short?(JsonNode? value);\r\n        public static explicit operator int?(JsonNode? value);\r\n        public static explicit operator long?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte?(JsonNode? value);\r\n        public static explicit operator float?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte(JsonNode value);\r\n        public static explicit operator float(JsonNode value);\r\n        public static explicit operator string?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong(JsonNode value);\r\n        public static implicit operator JsonNode(bool value);\r\n        public static implicit operator JsonNode(byte value);\r\n        public static implicit operator JsonNode(char value);\r\n        public static implicit operator JsonNode(DateTime value);\r\n        public static implicit operator JsonNode(DateTimeOffset value);\r\n        public static implicit operator JsonNode(decimal value);\r\n        public static implicit operator JsonNode(double value);\r\n        public static implicit operator JsonNode(Guid value);\r\n        public static implicit operator JsonNode(short value);\r\n        public static implicit operator JsonNode(int value);\r\n        public static implicit operator JsonNode(long value);\r\n        public static implicit operator JsonNode?(bool? value);\r\n        public static implicit operator JsonNode?(byte? value);\r\n        public static implicit operator JsonNode?(char? value);\r\n        public static implicit operator JsonNode?(DateTimeOffset? value);\r\n        public static implicit operator JsonNode?(DateTime? value);\r\n        public static implicit operator JsonNode?(decimal? value);\r\n        public static implicit operator JsonNode?(double? value);\r\n        public static implicit operator JsonNode?(Guid? value);\r\n        public static implicit operator JsonNode?(short? value);\r\n        public static implicit operator JsonNode?(int? value);\r\n        public static implicit operator JsonNode?(long? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(sbyte? value);\r\n        public static implicit operator JsonNode?(float? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ushort? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(uint? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ulong? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(sbyte value);\r\n        public static implicit operator JsonNode(float value);\r\n        public static implicit operator JsonNode?(string? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(ushort value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(uint value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(ulong value);\r\n        public static JsonNode? Parse(string json, JsonNodeOptions? nodeOptions = default, JsonDocumentOptions documentOptions = default);\r\n        public static JsonNode? ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonNodeOptions? nodeOptions = default, JsonDocumentOptions documentOptions = default);\r\n        public static JsonNode? ReadFrom(ref Utf8JsonReader reader, JsonNodeOptions? nodeOptions = default);\r\n        public static JsonNode? ReadFromUtf8Stream(Stream utf8Json, JsonNodeOptions? nodeOptions = default, JsonDocumentOptions documentOptions = default);\r\n        public string ToJsonString(JsonSerializerOptions? options = default);\r\n        public override string ToString();\r\n        public byte[] ToUtf8Bytes(JsonSerializerOptions? options = default);\r\n        public abstract void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = default);\r\n        public void WriteToUtf8Stream(Stream utf8Json, JsonSerializerOptions? options = default);\r\n    }\r\n    public partial struct JsonNodeOptions\r\n    {\r\n        public bool PropertyNameCaseInsensitive { readonly get; set; }\r\n    }\r\n    public sealed partial class JsonObject : JsonNode, ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E, IDictionary\u003Cstring, JsonNode?\u003E, IEnumerable\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E, IEnumerable\r\n    {\r\n        public JsonObject(JsonNodeOptions? options = default);\r\n        public JsonObject(JsonElement element, JsonNodeOptions? options = default);\r\n        public int Count { get; }\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.IsReadOnly { get; }\r\n        ICollection\u003Cstring\u003E IDictionary\u003Cstring, JsonNode?\u003E.Keys { get; }\r\n        ICollection\u003CJsonNode?\u003E IDictionary\u003Cstring, JsonNode?\u003E.Values { get; }\r\n        public void Add(string propertyName, JsonNode? value);\r\n        public void Clear();\r\n        public bool ContainsKey(string propertyName);\r\n        public IEnumerator\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E GetEnumerator();\r\n        public bool Remove(string propertyName);\r\n        void ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.Add(KeyValuePair\u003Cstring, JsonNode\u003E item);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.Contains(KeyValuePair\u003Cstring, JsonNode\u003E item);\r\n        void ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.CopyTo(KeyValuePair\u003Cstring, JsonNode\u003E[] array, int arrayIndex);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.Remove(KeyValuePair\u003Cstring, JsonNode\u003E item);\r\n        bool IDictionary\u003Cstring, JsonNode?\u003E.TryGetValue(string propertyName, out JsonNode jsonNode);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n        public bool TryGetPropertyValue(string propertyName, out JsonNode? jsonNode);\r\n        public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = default);\r\n    }\r\n    public abstract partial class JsonValue : JsonNode\r\n    {\r\n        private protected JsonValue(JsonNodeOptions? options = default);\r\n        public object Value { get; }\r\n        public static JsonValue\u003CT\u003E? Create\u003CT\u003E(T value, JsonNodeOptions? options = default);\r\n        public abstract bool TryGetValue\u003CTValue\u003E(out TValue? value, JsonSerializerOptions? options = default);\r\n    }\r\n    public sealed partial class JsonValue\u003CT\u003E : JsonValue\r\n    {\r\n        public JsonValue(T value, JsonNodeOptions? options = default);\r\n        public new T Value { get; }\r\n        public override TypeToReturn GetValue\u003CTypeToReturn\u003E(JsonSerializerOptions? options = default);\r\n        public override bool TryGetValue\u003CTValue\u003E(out TValue value, JsonSerializerOptions? options = default);\r\n        public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonArray.Add(JsonNode?)",
          "M:JsonArray.Add\u003CT\u003E(T)",
          "M:JsonArray.Clear()",
          "M:JsonArray.Contains(JsonNode?)",
          "M:JsonArray.CopyTo(JsonNode?[]?,int)",
          "M:JsonArray.GetEnumerator()",
          "M:JsonArray.IndexOf(JsonNode?)",
          "M:JsonArray.Insert(int,JsonNode?)",
          "M:JsonArray.JsonArray(JsonElement,JsonNodeOptions?)",
          "M:JsonArray.JsonArray(JsonNodeOptions,params JsonNode[])",
          "M:JsonArray.JsonArray(JsonNodeOptions?)",
          "M:JsonArray.JsonArray(params JsonNode[])",
          "M:JsonArray.Remove(JsonNode?)",
          "M:JsonArray.RemoveAt(int)",
          "M:JsonArray.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonNode.AsArray()",
          "M:JsonNode.AsObject()",
          "M:JsonNode.AsValue()",
          "M:JsonNode.explicit(JsonNode?)",
          "M:JsonNode.explicit(JsonNode)",
          "M:JsonNode.GetPath()",
          "M:JsonNode.GetValue\u003CTValue\u003E(JsonSerializerOptions?)",
          "M:JsonNode.implicit(bool?)",
          "M:JsonNode.implicit(bool)",
          "M:JsonNode.implicit(byte?)",
          "M:JsonNode.implicit(byte)",
          "M:JsonNode.implicit(char?)",
          "M:JsonNode.implicit(char)",
          "M:JsonNode.implicit(DateTime?)",
          "M:JsonNode.implicit(DateTime)",
          "M:JsonNode.implicit(DateTimeOffset?)",
          "M:JsonNode.implicit(DateTimeOffset)",
          "M:JsonNode.implicit(decimal?)",
          "M:JsonNode.implicit(decimal)",
          "M:JsonNode.implicit(double?)",
          "M:JsonNode.implicit(double)",
          "M:JsonNode.implicit(float?)",
          "M:JsonNode.implicit(float)",
          "M:JsonNode.implicit(Guid?)",
          "M:JsonNode.implicit(Guid)",
          "M:JsonNode.implicit(int?)",
          "M:JsonNode.implicit(int)",
          "M:JsonNode.implicit(long?)",
          "M:JsonNode.implicit(long)",
          "M:JsonNode.implicit(sbyte?)",
          "M:JsonNode.implicit(sbyte)",
          "M:JsonNode.implicit(short?)",
          "M:JsonNode.implicit(short)",
          "M:JsonNode.implicit(string?)",
          "M:JsonNode.implicit(uint?)",
          "M:JsonNode.implicit(uint)",
          "M:JsonNode.implicit(ulong?)",
          "M:JsonNode.implicit(ulong)",
          "M:JsonNode.implicit(ushort?)",
          "M:JsonNode.implicit(ushort)",
          "M:JsonNode.JsonNode()",
          "M:JsonNode.Parse(string,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.ParseUtf8Bytes(ReadOnlySpan\u003Cbyte\u003E,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.ReadFrom(ref Utf8JsonReader,JsonNodeOptions?)",
          "M:JsonNode.ReadFromUtf8Stream(Stream,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.ToJsonString(JsonSerializerOptions?)",
          "M:JsonNode.ToString()",
          "M:JsonNode.ToUtf8Bytes(JsonSerializerOptions?)",
          "M:JsonNode.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonNode.WriteToUtf8Stream(Stream,JsonSerializerOptions?)",
          "M:JsonObject.Add(KeyValuePair\u003Cstring, JsonNode\u003E)",
          "M:JsonObject.Add(string,JsonNode?)",
          "M:JsonObject.Clear()",
          "M:JsonObject.Contains(KeyValuePair\u003Cstring, JsonNode\u003E)",
          "M:JsonObject.ContainsKey(string)",
          "M:JsonObject.CopyTo(KeyValuePair\u003Cstring, JsonNode\u003E[],int)",
          "M:JsonObject.GetEnumerator()",
          "M:JsonObject.JsonObject(JsonElement,JsonNodeOptions?)",
          "M:JsonObject.JsonObject(JsonNodeOptions?)",
          "M:JsonObject.Remove(KeyValuePair\u003Cstring, JsonNode\u003E)",
          "M:JsonObject.Remove(string)",
          "M:JsonObject.TryGetPropertyValue(string,out JsonNode?)",
          "M:JsonObject.TryGetValue(string,out JsonNode)",
          "M:JsonObject.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonValue.Create\u003CT\u003E(T,JsonNodeOptions?)",
          "M:JsonValue.JsonValue(JsonNodeOptions?)",
          "M:JsonValue.TryGetValue\u003CTValue\u003E(out TValue?,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.GetValue\u003CTypeToReturn\u003E(JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.JsonValue(T,JsonNodeOptions?)",
          "M:JsonValue\u003CT\u003E.TryGetValue\u003CTValue\u003E(out TValue,JsonSerializerOptions?)",
          "M:JsonValue\u003CT\u003E.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "P:JsonArray.Count",
          "P:JsonArray.IsReadOnly",
          "P:JsonNode.Options",
          "P:JsonNode.Parent",
          "P:JsonNode.Root",
          "P:JsonNode[int]",
          "P:JsonNode[string]",
          "P:JsonNodeOptions.PropertyNameCaseInsensitive",
          "P:JsonObject.Count",
          "P:JsonObject.IsReadOnly",
          "P:JsonObject.Keys",
          "P:JsonObject.Values",
          "P:JsonValue.Value",
          "P:JsonValue\u003CT\u003E.Value",
          "T:JsonArray",
          "T:JsonNode",
          "T:JsonNodeOptions",
          "T:JsonObject",
          "T:JsonValue",
          "T:JsonValue\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "MNWITQvvMYU",
      "StartDateTime": "2021-04-06T10:05:50-07:00",
      "EndDateTime": "2021-04-06T12:03:15-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/MNWITQvvMYU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45448,
          "Title": "Compile-time source generation for System.Text.Json",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-02T00:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45448",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-06T00:00:00-07:00",
        "FeedbackId": "814368729",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45448#issuecomment-814368729",
        "FeedbackMarkdown": "* General notes\r\n    - The current proposal is that building application that use linking by default (Blazor, iOS, Android)\r\n    - This means that by default, starting, in .NET, those application models will warn on usage of JSON serialization/deserialization because those will be marked as linker unfriendly. Can we improve this, by, for example, having more of a progressive mode?\r\n    - Since this proposal is generating the serializer on a per assembly boundary, and each assembly\u0027s context contains the serialization of the type closure, it means the closure of assemblies is a single versioning bubble. In other words, if a type in a dependency adds new property, the serializer won\u0027t know about until it\u0027s being re-generated. That\u0027s different from the reflection approach.\r\n\r\n* \u0060JsonContext\u0060\r\n    - Consider dropping \u0060From\u0060 and instead expose the constructor taking options directly\r\n    - It seems unfortunate that for users to take advantage of the source generated serializer all call sites need to change to pass in the context/type info. This might make it harder for frameworks like ASP.NET Core that serialize user provided types without having access to the generated \u0060JsonContext\u0060\r\n    - The \u0060SerializeXxx\u0060 funcs are currently hardcoded. We need to make sure that they work for options that the context is tied to. We need to make sure that the generated code is correct; for example, it needs to honor the casing policy. It\u0027s OK to have a slower path for non-standard configuration, but we can\u0027t ignore the supplied configuration.\r\n    - Can we also get a generic \u0060GetTypeInfo\u003CT\u003E()\u0060",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "YnMtcUwzFq4",
      "StartDateTime": "2021-04-08T13:05:05-07:00",
      "EndDateTime": "2021-04-08T15:51:57-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/YnMtcUwzFq4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45448,
          "Title": "Compile-time source generation for System.Text.Json",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-02T00:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45448",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-08T00:00:00-07:00",
        "FeedbackId": "816280665",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45448#issuecomment-816280665",
        "FeedbackMarkdown": "* Consider changing JsonSerializerOptions.SetContext to JsonSerializerOptions.AddContext\r\n  * Even if it would throw on a second call now, it allows either a stack or list-based implementation in the future, to combine contexts across assemblies.\r\n* Consider adding JsonSerializerContext.CreateTypeInfoViaReflection to enable dynamic scenarios in the context-preferred world.\r\n\u0060\u0060\u0060C#\r\npartial class JsonSerializerContext\r\n{\r\n    public static JsonTypeInfo\u003CT\u003E CreateTypeInfoViaReflection\u003CT\u003E(JsonSerializerOptions options);\r\n    public static JsonTypeInfo CreateTypeInfoViaReflection(Type type, JsonSerializerOptions options);\r\n}\r\n\u0060\u0060\u0060\r\n* JsonSerializerContext.GetTypeInfo and JsonSerializerContext.GetTypeInfo\u003CT\u003E should both be abstract\r\n* Remove the default ctor on JsonSerializerContext and hide the null options state\r\n\u0060\u0060\u0060C#\r\npartial class JsonSerializerContext\r\n{\r\n    // This can use lazy initialization, or other techniques, to make AddContext work without creating an options.\r\n    public JsonSerializerOptions Options { get; }\r\n\r\n    protected JsonSerializerContext(JsonSerializerOptions? options = null) { }\r\n}\r\n\u0060\u0060\u0060\r\n* Make JsonTypeInfo.Converter a non-public property, if possible\r\n* It feels like JsonTypeInfo should be abstract if JsonTypeInfo\u003CT\u003E is.  But it\u0027s not important since both types have no public ctors.\r\n* JsonSerializableAttribute.TypeInfoPropertyName should be declared nullable\r\n* Move JsonSerializableAttribute to System.Text.Json.Serialization\r\n* Collapse System.Text.Json.Serialization.Metadata.Internal into System.Text.Json.Serialization.Metadata\r\n* Rename MetadataServices to JsonMetadataServices\r\n* We discussed if it would make sense to replace the JsonNumberHandling parameter to InitializeObject\u003CT\u003E be something to represent all possible type-specific attributes, but decided that could be deferred until we had a second thing\r\n* We discussed if the JsonNumberHandling parameter to InitializeObject\u003CT\u003E should be nullable, and decided it didn\u0027t need to because the generator can already distinguish between using an attribute-specified value or options.DefaultNumberHandling\r\n* Rename CreatePropertyInfo\u0027s clrPropertyName to propertyName, declaredPropertyName, runtimePropertyName, or memberName.\r\n* Move all the members on ConverterProvider to JsonMetadataServices, adding a \u0022Converter\u0022 suffix to each property.\r\n* Are we missing scenarios/overloads for the System.Net.Http.Json members that don\u0027t currently accept a JsonSerializerOptions?\r\n* We\u0027re missing IList/IDictionary versions of JsonMetadataServices.Create* members.",
        "TimeCode": 0,
        "Apis": [
          "M:JsonSerializerContext.CreateTypeInfoViaReflection(Type,JsonSerializerOptions)",
          "M:JsonSerializerContext.CreateTypeInfoViaReflection\u003CT\u003E(JsonSerializerOptions)",
          "M:JsonSerializerContext.JsonSerializerContext(JsonSerializerOptions?)",
          "P:JsonSerializerContext.Options",
          "T:JsonSerializerContext"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "COnBP3RQXRE",
      "StartDateTime": "2021-04-09T12:11:52-07:00",
      "EndDateTime": "2021-04-09T13:59:45-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/COnBP3RQXRE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47649,
          "Title": "API for writeable DOM and C# dynamic support",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-29T20:56:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47649",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-09T00:00:00-07:00",
        "FeedbackId": "816912404",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47649#issuecomment-816912404",
        "FeedbackMarkdown": "Looks good as edited\r\n\r\n\u0060\u0060\u0060cs\r\nnamespace System.Text.Json.Node\r\n{\r\n    public sealed partial class JsonArray : JsonNode, ICollection\u003CJsonNode?\u003E, IEnumerable\u003CJsonNode?\u003E, IList\u003CJsonNode?\u003E, IEnumerable\r\n    {\r\n        public JsonArray(JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        public JsonArray(JsonNodeOptions options, params JsonNode?[] items);\r\n        public JsonArray(params JsonNode?[] items);\r\n        public int Count { get; }\r\n        public static JsonArray? Create(JsonElement element, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        bool ICollection\u003CJsonNode?\u003E.IsReadOnly { get; }\r\n        public void Add(JsonNode? item);\r\n        public void Add\u003CT\u003E(T value);\r\n        public void Clear();\r\n        public bool Contains(JsonNode? item);\r\n        public IEnumerator\u003CJsonNode?\u003E GetEnumerator();\r\n        public int IndexOf(JsonNode? item);\r\n        public void Insert(int index, JsonNode? item);\r\n        public bool Remove(JsonNode? item);\r\n        public void RemoveAt(int index);\r\n        void ICollection\u003CJsonNode?\u003E.CopyTo(JsonNode?[]? array, int arrayIndex);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n        public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null);\r\n    }\r\n    public abstract partial class JsonNode\r\n    {\r\n        internal JsonNode();\r\n        public JsonNode? this[int index] { get; set; }\r\n        public JsonNode? this[string propertyName] { get; set; }\r\n        public JsonNodeOptions? Options { get; }\r\n        public JsonNode? Parent { get; }\r\n        public JsonNode Root { get; }\r\n        public JsonArray AsArray();\r\n        public JsonObject AsObject();\r\n        public JsonValue AsValue();\r\n        public string GetPath();\r\n        public virtual TValue GetValue\u003C[DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)]TValue\u003E();\r\n        public static explicit operator bool(JsonNode value);\r\n        public static explicit operator byte(JsonNode value);\r\n        public static explicit operator char(JsonNode value);\r\n        public static explicit operator DateTime(JsonNode value);\r\n        public static explicit operator DateTimeOffset(JsonNode value);\r\n        public static explicit operator decimal(JsonNode value);\r\n        public static explicit operator double(JsonNode value);\r\n        public static explicit operator Guid(JsonNode value);\r\n        public static explicit operator short(JsonNode value);\r\n        public static explicit operator int(JsonNode value);\r\n        public static explicit operator long(JsonNode value);\r\n        public static explicit operator bool?(JsonNode? value);\r\n        public static explicit operator byte?(JsonNode? value);\r\n        public static explicit operator char?(JsonNode? value);\r\n        public static explicit operator DateTimeOffset?(JsonNode? value);\r\n        public static explicit operator DateTime?(JsonNode? value);\r\n        public static explicit operator decimal?(JsonNode? value);\r\n        public static explicit operator double?(JsonNode? value);\r\n        public static explicit operator Guid?(JsonNode? value);\r\n        public static explicit operator short?(JsonNode? value);\r\n        public static explicit operator int?(JsonNode? value);\r\n        public static explicit operator long?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte?(JsonNode? value);\r\n        public static explicit operator float?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator sbyte(JsonNode value);\r\n        public static explicit operator float(JsonNode value);\r\n        public static explicit operator string?(JsonNode? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ushort(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator uint(JsonNode value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static explicit operator ulong(JsonNode value);\r\n        public static implicit operator JsonNode(bool value);\r\n        public static implicit operator JsonNode(byte value);\r\n        public static implicit operator JsonNode(char value);\r\n        public static implicit operator JsonNode(DateTime value);\r\n        public static implicit operator JsonNode(DateTimeOffset value);\r\n        public static implicit operator JsonNode(decimal value);\r\n        public static implicit operator JsonNode(double value);\r\n        public static implicit operator JsonNode(Guid value);\r\n        public static implicit operator JsonNode(short value);\r\n        public static implicit operator JsonNode(int value);\r\n        public static implicit operator JsonNode(long value);\r\n        public static implicit operator JsonNode?(bool? value);\r\n        public static implicit operator JsonNode?(byte? value);\r\n        public static implicit operator JsonNode?(char? value);\r\n        public static implicit operator JsonNode?(DateTimeOffset? value);\r\n        public static implicit operator JsonNode?(DateTime? value);\r\n        public static implicit operator JsonNode?(decimal? value);\r\n        public static implicit operator JsonNode?(double? value);\r\n        public static implicit operator JsonNode?(Guid? value);\r\n        public static implicit operator JsonNode?(short? value);\r\n        public static implicit operator JsonNode?(int? value);\r\n        public static implicit operator JsonNode?(long? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(sbyte? value);\r\n        public static implicit operator JsonNode?(float? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ushort? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(uint? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode?(ulong? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(sbyte value);\r\n        public static implicit operator JsonNode(float value);\r\n        public static implicit operator JsonNode?(string? value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(ushort value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(uint value);\r\n        [CLSCompliantAttribute(false)]\r\n        public static implicit operator JsonNode(ulong value);\r\n        public static JsonNode? Parse(string json, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?), JsonDocumentOptions documentOptions = default(JsonDocumentOptions));\r\n        public static JsonNode? Parse(ref Utf8JsonReader reader, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?));\r\n        public static JsonNode? Parse(IO.Stream utf8Json, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?), JsonDocumentOptions documentOptions = default(JsonDocumentOptions));\r\n        public static JsonNode? Parse(ReadOnlySpan\u003Cbyte\u003E utf8Json, JsonNodeOptions? nodeOptions = default(JsonNodeOptions?), JsonDocumentOptions documentOptions = default(JsonDocumentOptions));\r\n        public string ToJsonString(JsonSerializerOptions? options = null);\r\n        public override string ToString();\r\n        public abstract void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null);\r\n    }\r\n    public partial struct JsonNodeOptions\r\n    {\r\n        private int _dummyPrimitive;\r\n        public bool PropertyNameCaseInsensitive { readonly get; set; }\r\n    }\r\n    public sealed partial class JsonObject : JsonNode, ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E, IDictionary\u003Cstring, JsonNode?\u003E, IEnumerable\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E, IEnumerable\r\n    {\r\n        public JsonObject(JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        public JsonObject(IEnumerable\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E properties, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        public int Count { get; }\r\n        public static JsonObject? Create(JsonElement element, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.IsReadOnly { get; }\r\n        ICollection\u003Cstring\u003E IDictionary\u003Cstring, JsonNode?\u003E.Keys { get; }\r\n        ICollection\u003CJsonNode?\u003E IDictionary\u003Cstring, JsonNode?\u003E.Values { get; }\r\n        public void Add(KeyValuePair\u003Cstring, JsonNode?\u003E property);\r\n        public void Add(string propertyName, JsonNode? value);\r\n        public void Clear();\r\n        public bool ContainsKey(string propertyName);\r\n        public IEnumerator\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E GetEnumerator();\r\n        public bool Remove(string propertyName);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.Contains(KeyValuePair\u003Cstring, JsonNode\u003E item);\r\n        void ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.CopyTo(KeyValuePair\u003Cstring, JsonNode\u003E[] array, int index);\r\n        bool ICollection\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E.Remove(KeyValuePair\u003Cstring, JsonNode\u003E item);\r\n        bool IDictionary\u003Cstring, JsonNode?\u003E.TryGetValue(string propertyName, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)]out JsonNode jsonNode);\r\n        IEnumerator IEnumerable.GetEnumerator();\r\n        public bool TryGetPropertyValue(string propertyName, out JsonNode? jsonNode);\r\n        public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null);\r\n    }\r\n    public abstract partial class JsonValue : JsonNode\r\n    {\r\n        private protected JsonValue(JsonNodeOptions? options = null);\r\n        public static JsonValue? Create\u003CT\u003E(T value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n        public abstract bool TryGetValue\u003C[DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)]T\u003E([System.Diagnostics.CodeAnalysis.NotNullWhen(true)]out T? value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:JsonNodeOptions._dummyPrimitive",
          "M:JsonArray.Add(JsonNode?)",
          "M:JsonArray.Add\u003CT\u003E(T)",
          "M:JsonArray.Clear()",
          "M:JsonArray.Contains(JsonNode?)",
          "M:JsonArray.CopyTo(JsonNode?[]?,int)",
          "M:JsonArray.Create(JsonElement,JsonNodeOptions?)",
          "M:JsonArray.GetEnumerator()",
          "M:JsonArray.IndexOf(JsonNode?)",
          "M:JsonArray.Insert(int,JsonNode?)",
          "M:JsonArray.JsonArray(JsonNodeOptions,params JsonNode?[])",
          "M:JsonArray.JsonArray(JsonNodeOptions?)",
          "M:JsonArray.JsonArray(params JsonNode?[])",
          "M:JsonArray.Remove(JsonNode?)",
          "M:JsonArray.RemoveAt(int)",
          "M:JsonArray.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonNode.AsArray()",
          "M:JsonNode.AsObject()",
          "M:JsonNode.AsValue()",
          "M:JsonNode.explicit(JsonNode?)",
          "M:JsonNode.explicit(JsonNode)",
          "M:JsonNode.GetPath()",
          "M:JsonNode.GetValue\u003CTValue\u003E()",
          "M:JsonNode.implicit(bool?)",
          "M:JsonNode.implicit(bool)",
          "M:JsonNode.implicit(byte?)",
          "M:JsonNode.implicit(byte)",
          "M:JsonNode.implicit(char?)",
          "M:JsonNode.implicit(char)",
          "M:JsonNode.implicit(DateTime?)",
          "M:JsonNode.implicit(DateTime)",
          "M:JsonNode.implicit(DateTimeOffset?)",
          "M:JsonNode.implicit(DateTimeOffset)",
          "M:JsonNode.implicit(decimal?)",
          "M:JsonNode.implicit(decimal)",
          "M:JsonNode.implicit(double?)",
          "M:JsonNode.implicit(double)",
          "M:JsonNode.implicit(float?)",
          "M:JsonNode.implicit(float)",
          "M:JsonNode.implicit(Guid?)",
          "M:JsonNode.implicit(Guid)",
          "M:JsonNode.implicit(int?)",
          "M:JsonNode.implicit(int)",
          "M:JsonNode.implicit(long?)",
          "M:JsonNode.implicit(long)",
          "M:JsonNode.implicit(sbyte?)",
          "M:JsonNode.implicit(sbyte)",
          "M:JsonNode.implicit(short?)",
          "M:JsonNode.implicit(short)",
          "M:JsonNode.implicit(string?)",
          "M:JsonNode.implicit(uint?)",
          "M:JsonNode.implicit(uint)",
          "M:JsonNode.implicit(ulong?)",
          "M:JsonNode.implicit(ulong)",
          "M:JsonNode.implicit(ushort?)",
          "M:JsonNode.implicit(ushort)",
          "M:JsonNode.JsonNode()",
          "M:JsonNode.Parse(IO.Stream,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.Parse(ReadOnlySpan\u003Cbyte\u003E,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.Parse(ref Utf8JsonReader,JsonNodeOptions?)",
          "M:JsonNode.Parse(string,JsonNodeOptions?,JsonDocumentOptions)",
          "M:JsonNode.ToJsonString(JsonSerializerOptions?)",
          "M:JsonNode.ToString()",
          "M:JsonNode.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonObject.Add(KeyValuePair\u003Cstring, JsonNode?\u003E)",
          "M:JsonObject.Add(string,JsonNode?)",
          "M:JsonObject.Clear()",
          "M:JsonObject.Contains(KeyValuePair\u003Cstring, JsonNode\u003E)",
          "M:JsonObject.ContainsKey(string)",
          "M:JsonObject.CopyTo(KeyValuePair\u003Cstring, JsonNode\u003E[],int)",
          "M:JsonObject.Create(JsonElement,JsonNodeOptions?)",
          "M:JsonObject.GetEnumerator()",
          "M:JsonObject.JsonObject(IEnumerable\u003CKeyValuePair\u003Cstring, JsonNode?\u003E\u003E,JsonNodeOptions?)",
          "M:JsonObject.JsonObject(JsonNodeOptions?)",
          "M:JsonObject.Remove(KeyValuePair\u003Cstring, JsonNode\u003E)",
          "M:JsonObject.Remove(string)",
          "M:JsonObject.TryGetPropertyValue(string,out JsonNode?)",
          "M:JsonObject.TryGetValue(string,out JsonNode)",
          "M:JsonObject.WriteTo(Utf8JsonWriter,JsonSerializerOptions?)",
          "M:JsonValue.Create\u003CT\u003E(T,JsonNodeOptions?)",
          "M:JsonValue.JsonValue(JsonNodeOptions?)",
          "M:JsonValue.TryGetValue\u003CT\u003E(out T?)",
          "P:JsonArray.Count",
          "P:JsonArray.IsReadOnly",
          "P:JsonNode.Options",
          "P:JsonNode.Parent",
          "P:JsonNode.Root",
          "P:JsonNode[int]",
          "P:JsonNode[string]",
          "P:JsonNodeOptions.PropertyNameCaseInsensitive",
          "P:JsonObject.Count",
          "P:JsonObject.IsReadOnly",
          "P:JsonObject.Keys",
          "P:JsonObject.Values",
          "T:JsonArray",
          "T:JsonNode",
          "T:JsonNodeOptions",
          "T:JsonObject",
          "T:JsonValue"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36022,
          "Title": "Enhance user-facing API for strongly-typed ILogger messages",
          "Author": "lodejard",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-09T02:21:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36022",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Bottom Up Work",
              "Color": "fef2c0",
              "Description": "Not part of a theme, epic, or user story"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-09T00:00:00-07:00",
        "FeedbackId": "816960233",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36022#issuecomment-816960233",
        "FeedbackMarkdown": "We got rid of all attribute ctor parameters, because it\u0027s complicated validation logic done by the generator.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed partial class LoggerMessageAttribute : Attribute\r\n    {\r\n        public LoggerMessageAttribute();\r\n        public int? EventId { get; set; }\r\n        public string? EventName { get; set; }\r\n        public LogLevel? Level { get; set; }\r\n        public string Message { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe reviewed the current generator diagnostics and had the following feedback (using the current numbers, which need to be adjusted to account for IDs already being used):\r\n\r\n* Error 10: Either generics should work, or it also should check that it\u0027s not in a generic type\r\n* Error 12: Too opinionated, too noisy, don\u0027t check.\r\n* Error 17: A related error, the log level was specified as both a parameter and as an attribute value, should also be expressed.\r\n* Error 18: Should be a warning, not an error.",
        "TimeCode": 5310000000,
        "Apis": [
          "M:LoggerMessageAttribute.LoggerMessageAttribute()",
          "P:LoggerMessageAttribute.EventId",
          "P:LoggerMessageAttribute.EventName",
          "P:LoggerMessageAttribute.Level",
          "P:LoggerMessageAttribute.Message",
          "T:LoggerMessageAttribute"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50913,
          "Title": "Add LoggerMessage.Define overloads accepting up to 14 arguments.",
          "Author": "maryamariyan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-08T14:51:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50913",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-09T00:00:00-07:00",
        "FeedbackId": "816966012",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50913#issuecomment-816966012",
        "FeedbackMarkdown": "We think there\u0027s not a scenario for this, and we shouldn\u0027t add it until there is one.",
        "TimeCode": 53880000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "_lSOebMGeo8",
      "StartDateTime": "2021-04-13T10:06:03-07:00",
      "EndDateTime": "2021-04-13T12:17:36-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/_lSOebMGeo8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50601,
          "Title": "C# 10 interpolated strings support, part 1",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-01T18:50:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50601",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-13T00:00:00-07:00",
        "FeedbackId": "818990566",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50601#issuecomment-818990566",
        "FeedbackMarkdown": "API Review notes:\r\n\r\n* Why do we need the InterpolationHole version for string? (To specialize out of T/object and to avoid future \u0022universal formatting\u0022)\r\n* InterpolatedStringBuilder is a ref struct.  Is that important?\r\n  * What\u0027s the behavior in async?\r\n  * Answers were \u0022yes\u0022, and \u0022we\u0027ll make it work\u0022.\r\n* Do/can we do anything special for T : IFormattable or ISpanFormattable?\r\n  * Seems like when we want it (value types) it\u0027s already handled by the JIT\r\n* TryFormatBaseString =\u003E AppendLiteral\r\n* TryFormatInterpolationHole =\u003E AppendFormatted\r\n* \u0022Should we add support for void* or T*?\u0022 We\u0027re happy with \u0022no\u0022.\r\n* Do we need InterpolatedStringBuilder to be IDisposable? We\u0027re happy with \u0022no\u0022.\r\n* We decided ToString() shouldn\u0027t be destructive, so added ToStringAndClear() (which the compiler will call).\r\n* InterpolatedStringBuilder.Create, rename parameters to literalLength and formattedCount (to match the method renames)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public interface ISpanFormattable : IFormattable // currently internal\r\n    {\r\n        bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public ref struct InterpolatedStringBuilder\r\n    {\r\n        // Create the builder and extract its string / clean up\r\n        public static InterpolatedStringBuilder Create(int literalLength, int formattedCount);\r\n        public string ToStringAndClear();\r\n\r\n        // To handle the base string portions of the interpolated string\r\n        public void AppendLiteral(string value);\r\n\r\n        // To handle most types, full set of overloads to minimize IL bloat at call sites\r\n        public void AppendFormatted\u003CT\u003E(T value);\r\n        public void AppendFormatted\u003CT\u003E(T value, string? format);\r\n        public void AppendFormatted\u003CT\u003E(T value, int alignment);\r\n        public void AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n\r\n        // To allow for ROS to be in holes\r\n        public void AppendFormatted(ReadOnlySpan\u003Cchar\u003E value);\r\n        public void AppendFormatted(ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n\r\n        // To handle strings, because they\u0027re very common and we can optimize for them specially\r\n        public void AppendFormatted(string? value);\r\n        public void AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n\r\n        // Fallback for everything that can\u0027t be target typed\r\n        public void AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:InterpolatedStringBuilder.AppendFormatted(object?,int,string?)",
          "M:InterpolatedStringBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:InterpolatedStringBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E)",
          "M:InterpolatedStringBuilder.AppendFormatted(string?,int,string?)",
          "M:InterpolatedStringBuilder.AppendFormatted(string?)",
          "M:InterpolatedStringBuilder.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:InterpolatedStringBuilder.AppendFormatted\u003CT\u003E(T,int)",
          "M:InterpolatedStringBuilder.AppendFormatted\u003CT\u003E(T,string?)",
          "M:InterpolatedStringBuilder.AppendFormatted\u003CT\u003E(T)",
          "M:InterpolatedStringBuilder.AppendLiteral(string)",
          "M:InterpolatedStringBuilder.Create(int,int)",
          "M:InterpolatedStringBuilder.ToStringAndClear()",
          "M:ISpanFormattable.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "T:InterpolatedStringBuilder",
          "T:ISpanFormattable"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ZyivxqIt4Zk",
      "StartDateTime": "2021-04-15T10:05:39-07:00",
      "EndDateTime": "2021-04-15T12:18:39-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ZyivxqIt4Zk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43290,
          "Title": "Add ability to explicitly send EOF for connected Streams",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-12T05:07:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43290",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-15T00:00:00-07:00",
        "FeedbackId": "820633348",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43290#issuecomment-820633348",
        "FeedbackMarkdown": "We felt that the concept really warranted introducing a new middle type to the hierarchy:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public abstract class DuplexStream : Stream\r\n    {\r\n        // when disposed, this write-only stream will call CompleteWrites().\r\n        // this allows compat with e.g. StreamWriter that knows nothing about shutdown.\r\n        public Stream GetWriteOnlyStream() =\u003E throw null;\r\n    \r\n        public abstract void CompleteWrites();\r\n        public abstract ValueTask CompleteWritesAsync(CancellationToken cancellationToken = default);\r\n    \r\n        override all the things;\r\n    }\r\n}\r\n\r\npartial class NetworkStream : DuplexStream \r\n{\r\n}\r\n\r\nand other streams as needed.\r\n\u0060\u0060\u0060\r\n\r\n(I edited so that NetworkStream derives from DuplexStream, not BidirectionalStream)",
        "TimeCode": 0,
        "Apis": [
          "F:DuplexStream.the",
          "M:DuplexStream.CompleteWrites()",
          "M:DuplexStream.CompleteWritesAsync(CancellationToken)",
          "M:DuplexStream.GetWriteOnlyStream()",
          "T:DuplexStream",
          "T:NetworkStream"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49944,
          "Title": "Seal internal/private types",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-20T20:45:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49944",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-15T00:00:00-07:00",
        "FeedbackId": "820636274",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49944#issuecomment-820636274",
        "FeedbackMarkdown": "Sounds good, assuming the general heuristics of\r\n\r\n* Internal and private non-static, non-abstract, non-sealed classes that\r\n* Don\u2019t have any derived types in its containing assembly\r\n\r\nBut it needs to be opt-in.",
        "TimeCode": 42050000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50902,
          "Title": "Add an API to reduce GC memory usage",
          "Author": "PeterSolMS",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-08T12:36:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50902",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-GC-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-15T00:00:00-07:00",
        "FeedbackId": "820662422",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50902#issuecomment-820662422",
        "FeedbackMarkdown": "* We changed the int 0-9 to a double 0-1\r\n* We moved it onto GCSettings and renamed it.\r\n* Otherwise, looks good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime\r\n{\r\n    partial class GCSettings\r\n    {\r\n        // NaN represents \u0022there is no goal\u0022\r\n        // Setter throws for things outside the range [0, 1] union NaN\r\n        public double MemoryOptimizationGoal { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 44270000000,
        "Apis": [
          "P:GCSettings.MemoryOptimizationGoal",
          "T:GCSettings"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51156,
          "Title": "Extensible Calling Conventions for native callee functions",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-13T01:44:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51156",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-15T00:00:00-07:00",
        "FeedbackId": "820672447",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51156#issuecomment-820672447",
        "FeedbackMarkdown": "* Should it also work on Delegates? (We feel no is OK)\r\n* Sealed the attribute, since its for tooling\r\n* AllowMultiple should be false\r\n* We like CallConv more than Callee in this context\r\n* The CallConvs member should be a property, but since UnmanagedCallersOnly has a field we went for symmetry.\r\n* An analyzer to notice that DllImport had a convention specified and UnmanagedCallConv was also specified would be valuable.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n     /// \u003Csummary\u003E\r\n     /// Provides an equivalent to \u003Csee cref=\u0022UnmanagedCallersOnlyAttribute\u0022/\u003E for native\r\n     /// functions declared in .NET.\r\n     /// \u003C/summary\u003E\r\n     [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]\r\n     public sealed class UnmanagedCallConvAttribute : Attribute\r\n     {\r\n         public UnmanagedCallConvAttribute() { }\r\n \r\n         /// \u003Csummary\u003E\r\n         /// Types indicating calling conventions for the unmanaged target.\r\n         /// \u003C/summary\u003E\r\n         /// \u003Cremarks\u003E\r\n         /// If \u003Cc\u003Enull\u003C/c\u003E, the semantics are identical to \u003Cc\u003ECallingConvention.Winapi\u003C/c\u003E.\r\n         /// \u003C/remarks\u003E\r\n         public Type[]? CallConvs;\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 69180000000,
        "Apis": [
          "F:UnmanagedCallConvAttribute.CallConvs",
          "M:UnmanagedCallConvAttribute.UnmanagedCallConvAttribute()",
          "T:UnmanagedCallConvAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "RQfgeW0cOFk",
      "StartDateTime": "2021-04-20T10:06:59-07:00",
      "EndDateTime": "2021-04-20T12:01:00-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/RQfgeW0cOFk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50635,
          "Title": "C# 10 interpolated strings support, part 2",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-02T03:23:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50635",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-20T00:00:00-07:00",
        "FeedbackId": "823508701",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50635#issuecomment-823508701",
        "FeedbackMarkdown": "* Builders that are nested types should be [EditorBrowsable(Never)]\r\n* Change System.Runtime.CompilerServices.InterpolatedSpanBuilder to System.MemoryExtensions\u002BInterpolatedTryWriteBuilder\r\n* Interpolated string target methods on StringBuilder should be Append, not AppendFormat, since no separate format string is supplied.\r\n* Also do it for StringBuilder.AppendLine\r\n* The scratchBuffer String.Format should an overload of String.Create\r\n  * Therefore the IFormatProvider and builder one should also be String.Create\r\n* We\u0027re not fully happy with the name scratchBuffer, but we\u0027re not sure what a good answer is.  The adjective temporary received a minor happy response.  temporaryBuffer?\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\r\n    public sealed class InterpolatedBuilderArgumentAttribute : Attribute\r\n    {\r\n        public InterpolatedBuilderArgumentAttribute(string argument);\r\n        public InterpolatedBuilderArgumentAttribute(params string[] arguments);\r\n\r\n        public string[] Arguments { get; }\r\n    }\r\n\r\n    public ref struct InterpolatedStringBuilder // from https://github.com/dotnet/runtime/issues/50601\r\n    {\r\n        public static InterpolatedStringBuilder Create(int literalLength, int formattedCount, IFormatProvider? provider); // additional factory\r\n        public static InterpolatedStringBuilder Create(int literalLength, int formattedCount, IFormatProvider? provider, Span\u003Cchar\u003E scratchBuffer); // additional factory\r\n        \u2026\r\n    }\r\n}\r\n\r\nnamespace System\r\n{\r\n    public static class MemoryExtensions\r\n    {\r\n        public static bool TryWrite(this Span\u003Cchar\u003E span, [InterpolatedBuilderArgument(\u0022span\u0022)] ref InterpolatedSpanBuilder builder, out int charsWritten);\r\n        public static bool TryWrite(this Span\u003Cchar\u003E span, IFormatProvider? provider, [InterpolatedBuilderArgument(\u0022span\u0022, \u0022provider\u0022)] ref InterpolatedSpanBuilder builder, out int charsWritten);\r\n        \u2026\r\n\r\n        [EditorBrowsable(Never)]\r\n        public ref struct InterpolatedTryWriteBuilder\r\n        {\r\n            public static InterpolatedTryWriteBuilder Create(int literalLength, int formattedCount, Span\u003Cchar\u003E destination, out bool success);\r\n            public static InterpolatedTryWriteBuilder Create(int literalLength, int formattedCount, Span\u003Cchar\u003E destination, IFormatProvider? provider, out bool success);\r\n    \r\n            // Same members as on InterpolatedStringBuilder\r\n            public bool AppendLiteral(string s);\r\n            public bool AppendFormatted\u003CT\u003E(T value);\r\n            public bool AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public bool AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public bool AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public bool AppendFormatted(ReadOnlySpan\u003Cchar\u003E value);\r\n            public bool AppendFormatted(ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public bool AppendFormatted(string? value);\r\n            public bool AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n            public bool AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n        }\r\n    }\r\n\r\n    public partial sealed class String\r\n    {\r\n        public static string Create(IFormatProvider? provider, Span\u003Cchar\u003E scratchBuffer, [InterpolatedBuilderArgument(\u0022provider\u0022, \u0022scatchBuffer\u0022)] ref InterpolatedStringBuilder builder);\r\n        public static string Create(IFormatProvider? provider, [InterpolatedBuilderArgument(\u0022provider\u0022)] ref InterpolatedStringBuilder builder);\r\n    }\r\n}\r\n\r\nnamespace System.Text\r\n{\r\n    public sealed class StringBuilder\r\n    {\r\n        public StringBuilder Append([InterpolatedBuilderArgument(\u0022this\u0022)] ref InterpolatedAppendFormatBuilder builder);\r\n        public StringBuilder Append(IFormatProvider? provider, [InterpolatedBuilderArgument(\u0022this\u0022, \u0022provider\u0022)] ref InterpolatedAppendFormatBuilder builder);\r\n        public StringBuilder AppendLine([InterpolatedBuilderArgument(\u0022this\u0022)] ref InterpolatedAppendFormatBuilder builder);\r\n        public StringBuilder AppendLine(IFormatProvider? provider, [InterpolatedBuilderArgument(\u0022this\u0022, \u0022provider\u0022)] ref InterpolatedAppendFormatBuilder builder);\r\n\r\n        [EditorBrowsable(Never)]\r\n        public struct InterpolatedAppendFormatBuilder\r\n        {\r\n            public static InterpolatedAppendFormatBuilder Create(int literalLength, int formattedCount, StringBuilder stringBuilder);\r\n            public static InterpolatedAppendFormatBuilder Create(int literalLength, int formattedCount, StringBuilder stringBuilder, IFormatProvider? provider);\r\n\r\n            // Same members as on InterpolatedStringBuilder\r\n            public bool AppendLiteral(string s);\r\n            public bool AppendFormatted\u003CT\u003E(T value);\r\n            public bool AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public bool AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public bool AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public bool AppendFormatted(ReadOnlySpan\u003Cchar\u003E value);\r\n            public bool AppendFormatted(ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public bool AppendFormatted(string? value);\r\n            public bool AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n            public bool AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n        }\r\n\r\n        \u2026\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:InterpolatedBuilderArgumentAttribute.InterpolatedBuilderArgumentAttribute(params string[])",
          "M:InterpolatedBuilderArgumentAttribute.InterpolatedBuilderArgumentAttribute(string)",
          "M:InterpolatedStringBuilder.Create(int,int,IFormatProvider?,Span\u003Cchar\u003E)",
          "M:InterpolatedStringBuilder.Create(int,int,IFormatProvider?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted(object?,int,string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted(string?,int,string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted(string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted\u003CT\u003E(T,int)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted\u003CT\u003E(T,string?)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendFormatted\u003CT\u003E(T)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.AppendLiteral(string)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.Create(int,int,Span\u003Cchar\u003E,IFormatProvider?,out bool)",
          "M:MemoryExtensions.InterpolatedTryWriteBuilder.Create(int,int,Span\u003Cchar\u003E,out bool)",
          "M:MemoryExtensions.TryWrite(this Span\u003Cchar\u003E,IFormatProvider?,ref InterpolatedSpanBuilder,out int)",
          "M:MemoryExtensions.TryWrite(this Span\u003Cchar\u003E,ref InterpolatedSpanBuilder,out int)",
          "M:String.Create(IFormatProvider?,ref InterpolatedStringBuilder)",
          "M:String.Create(IFormatProvider?,Span\u003Cchar\u003E,ref InterpolatedStringBuilder)",
          "M:StringBuilder.Append(IFormatProvider?,ref InterpolatedAppendFormatBuilder)",
          "M:StringBuilder.Append(ref InterpolatedAppendFormatBuilder)",
          "M:StringBuilder.AppendLine(IFormatProvider?,ref InterpolatedAppendFormatBuilder)",
          "M:StringBuilder.AppendLine(ref InterpolatedAppendFormatBuilder)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted(object?,int,string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted(ReadOnlySpan\u003Cchar\u003E)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted(string?,int,string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted(string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted\u003CT\u003E(T,int)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted\u003CT\u003E(T,string?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendFormatted\u003CT\u003E(T)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.AppendLiteral(string)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.Create(int,int,StringBuilder,IFormatProvider?)",
          "M:StringBuilder.InterpolatedAppendFormatBuilder.Create(int,int,StringBuilder)",
          "P:InterpolatedBuilderArgumentAttribute.Arguments",
          "T:InterpolatedBuilderArgumentAttribute",
          "T:InterpolatedStringBuilder",
          "T:MemoryExtensions",
          "T:MemoryExtensions.InterpolatedTryWriteBuilder",
          "T:String",
          "T:StringBuilder",
          "T:StringBuilder.InterpolatedAppendFormatBuilder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49346,
          "Title": "SslStream delayed client certificate negotiation",
          "Author": "Tratcher",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-09T00:56:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49346",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-20T00:00:00-07:00",
        "FeedbackId": "823526100",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49346#issuecomment-823526100",
        "FeedbackMarkdown": "* We changed \u0022Get\u0022 to \u0022Negotiate\u0022 to make it clear that complicated protocol stuff is happening.\r\n* We removed the value from the return, the caller needs to just check the RemoteCertificate property again.\r\n* Because we don\u0027t really want it to be called, we don\u0027t see the need for the synchronous version.\r\n* It\u0027s virtual because all of the authenticate methods are virtual.\r\n* Sounds like it\u0027ll need some SupportedOS attributes.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Security\r\n{\r\n    public partial class SslStream\r\n    {\r\n        public virtual Task NegotiateClientCertificateAsync(CancellationToken cancellationToken = default) =\u003E throw null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51380000000,
        "Apis": [
          "M:SslStream.NegotiateClientCertificateAsync(CancellationToken)",
          "T:SslStream"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "CL7PuoLYiGM",
      "StartDateTime": "2021-04-23T10:06:49-07:00",
      "EndDateTime": "2021-04-23T12:02:52-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/CL7PuoLYiGM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51487,
          "Title": "Add DynamicallyAccessedMemberTypes.Interfaces enum value",
          "Author": "vitek-karas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-19T10:59:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51487",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-AssemblyLoader-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-23T00:00:00-07:00",
        "FeedbackId": "825798995",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51487#issuecomment-825798995",
        "FeedbackMarkdown": "* There was some discussion that \u0022Interfaces\u0022 was perhaps not the best name, but we couldn\u0027t come up with a better one, and since the scope is already \u0022members\u0022 we felt it was OK.\r\n\u0060\u0060\u0060diff\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    enum DynamicallyAccessedMemberTypes\r\n    {\r\n        None = 0,\r\n        PublicParameterlessConstructor = 0x0001,\r\n        PublicConstructors = 0x0002 | PublicParameterlessConstructor,\r\n        NonPublicConstructors = 0x0004,\r\n        PublicMethods = 0x0008,\r\n        NonPublicMethods = 0x0010,\r\n        PublicFields = 0x0020,\r\n        NonPublicFields = 0x0040,\r\n        PublicNestedTypes = 0x0080,\r\n        NonPublicNestedTypes = 0x0100,\r\n        PublicProperties = 0x0200,\r\n        NonPublicProperties = 0x0400,\r\n        PublicEvents = 0x0800,\r\n        NonPublicEvents = 0x1000,\r\n\u002B       Interfaces = 0x2000,\r\n        All = ~None\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29723,
          "Title": "Expose top-level nullability information from reflection",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-31T03:07:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29723",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-23T00:00:00-07:00",
        "FeedbackId": "825819967",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29723#issuecomment-825819967",
        "FeedbackMarkdown": "API Review notes:\r\n\r\n* Consider splitting State into the \u0022read\u0022 and \u0022write\u0022 states, to allow for straightforward expression of \u0060public string? Foo { get; [DisallowNull] set; }\u0060\r\n* Does NullableState need something like \u0022ItsComplicated\u0022 for [MaybeNullWhen] and other state-based things?\r\n* Should there be a method to get the nullability related custom attributes associated with the context?\r\n* NullabilityInfo.GenericTypeArguments returns an array, so it\u0027s either cloning or is mutable.  Consider ReadOnlyCollection, or making it a method",
        "TimeCode": 10860000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43970,
          "Title": "Make CreateScope return ServiceScope that also implements IAsyncDisposable",
          "Author": "bjorkstromm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-28T20:13:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43970",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-DependencyInjection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-23T00:00:00-07:00",
        "FeedbackId": "825826754",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43970#issuecomment-825826754",
        "FeedbackMarkdown": "* We renamed CreateAsyncServiceScope to CreateAsyncScope to better match the existing name\r\n* We moved it into the extension type for the existing method to avoid making a new type\r\n\r\n\u0060\u0060\u0060C#\r\npublic partial class ServiceProviderServiceExtensions\r\n{\r\n    public static AsyncServiceScope CreateAsyncScope(this IServiceProvider serviceProvider)\r\n    {\r\n        return new AsyncServiceScope(serviceProvider.CreateScope());\r\n    }\r\n}\r\n\r\npublic struct AsyncServiceScope : IServiceScope, IAsyncDisposable\r\n{\r\n    private readonly IServiceScope _serviceScope;\r\n\r\n    public AsyncServiceScope(IServiceScope serviceScope)\r\n    {\r\n        _serviceScope = serviceScope;\r\n    }\r\n\r\n    public IServiceProvider ServiceProvider =\u003E _serviceScope.ServiceProvider;\r\n\r\n    public void Dispose()\r\n    {\r\n        _serviceScope.Dispose();\r\n    }\r\n\r\n    public ValueTask DisposeAsync()\r\n    {\r\n        if (_serviceScope is IAsyncDisposable ad)\r\n        {\r\n            return ad.DisposeAsync();\r\n        }\r\n        _serviceScope.Dispose();\r\n        return ValueTask.CompletedTask;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26460000000,
        "Apis": [
          "F:AsyncServiceScope._serviceScope",
          "M:AsyncServiceScope.AsyncServiceScope(IServiceScope)",
          "M:AsyncServiceScope.Dispose()",
          "M:AsyncServiceScope.DisposeAsync()",
          "M:ServiceProviderServiceExtensions.CreateAsyncScope(this IServiceProvider)",
          "P:AsyncServiceScope.ServiceProvider",
          "T:AsyncServiceScope",
          "T:ServiceProviderServiceExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50527,
          "Title": "Make improvements to signal handling on .NET applications",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-31T23:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50527",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-23T00:00:00-07:00",
        "FeedbackId": "825858901",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50527#issuecomment-825858901",
        "FeedbackMarkdown": "* \u0022Signal\u0022 is a very generic word, how about \u0022PosixSignal\u0022?\r\n* SignalHandlerRegistration should be a class instead of a struct\r\n* SignalRegistration instead of SignalHandlerRegistration\r\n* Use negative numbers in the PosixSignal enum and handle translation in the PAL\r\n* Add PosixSignal enum members for all the ones we want to support, which should not include ones that we know will break the .NET runtime (SIGIO?)\r\n* We sealed the types\r\n* We added a constructor for PosixSignalContext for testability\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n     public enum PosixSignal\r\n     {\r\n         SIGHUP = -1,\r\n         SIGINT = -2,\r\n         SIGQUIT = -3,\r\n         SIGTERM = -4,\r\n         SIGCHLD = -5,\r\n         ...\r\n     }\r\n\r\n     public sealed class PosixSignalContext\r\n     {\r\n         public PosixSignal Signal { get; }\r\n         public bool Cancel { get; set; }\r\n\r\n         public PosixSignalContext(PosixSignal signal) { }\r\n     }\r\n\r\n     public sealed class PosixSignalRegistration : IDisposable\r\n     {\r\n         private PosixSignalRegistration() { }\r\n\r\n         public static PosixSignalRegistration Create(PosixSignal signal, Action\u003CPosixSignalContext\u003E handler);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33410000000,
        "Apis": [
          "F:PosixSignal.SIGCHLD",
          "F:PosixSignal.SIGHUP",
          "F:PosixSignal.SIGINT",
          "F:PosixSignal.SIGQUIT",
          "F:PosixSignal.SIGTERM",
          "M:PosixSignalContext.PosixSignalContext(PosixSignal)",
          "M:PosixSignalRegistration.Create(PosixSignal,Action\u003CPosixSignalContext\u003E)",
          "M:PosixSignalRegistration.PosixSignalRegistration()",
          "P:PosixSignalContext.Cancel",
          "P:PosixSignalContext.Signal",
          "T:PosixSignal",
          "T:PosixSignalContext",
          "T:PosixSignalRegistration"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "r6OhQXOPmX4",
      "StartDateTime": "2021-04-27T10:08:13-07:00",
      "EndDateTime": "2021-04-27T11:57:39-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/r6OhQXOPmX4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43780,
          "Title": "AVX-VNNI intrinsics",
          "Author": "hanblee",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-23T18:40:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43780",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-27T00:00:00-07:00",
        "FeedbackId": "827771780",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43780#issuecomment-827771780",
        "FeedbackMarkdown": "Looks good as proposed.  One thing that was observed is one set of methods is short/short, but the other is byte/sbyte.  Double check the sign bits.\r\n\r\n\u0060\u0060\u0060cs\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class AvxVnni : Avx2\r\n    {\r\n        internal AvxVnni() { }\r\n\r\n        public static new bool IsSupported { [Intrinsic] get { return false; } }\r\n\r\n        public new abstract class X64 : Avx2.X64\r\n        {\r\n            internal X64() { }\r\n\r\n            public static new bool IsSupported { [Intrinsic] get { return false; } }\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_dpbusd_epi32 (__m128i src, __m128i a, __m128i b)\r\n        /// VPDPBUSD xmm, xmm, xmm\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cint\u003E MultiplyWideningAndAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cbyte\u003E left, Vector128\u003Csbyte\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_dpwssd_epi32 (__m128i src, __m128i a, __m128i b)\r\n        /// VPDPWSSD xmm, xmm, xmm\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cint\u003E MultiplyWideningAndAdd(Vector128\u003Cint\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m256i _mm256_dpbusd_epi32 (__m256i src, __m256i a, __m256i b)\r\n        /// VPDPBUSD ymm, ymm, ymm\r\n        /// \u003C/summary\u003E\r\n        public static Vector256\u003Cint\u003E MultiplyWideningAndAdd(Vector256\u003Cint\u003E addend, Vector256\u003Cbyte\u003E left, Vector256\u003Csbyte\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m256i _mm256_dpwssd_epi32 (__m256i src, __m256i a, __m256i b)\r\n        /// VPDPWSSD ymm, ymm, ymm\r\n        /// \u003C/summary\u003E\r\n        public static Vector256\u003Cint\u003E MultiplyWideningAndAdd(Vector256\u003Cint\u003E addend, Vector256\u003Cshort\u003E left, Vector256\u003Cshort\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_dpbusds_epi32 (__m128i src, __m128i a, __m128i b)\r\n        /// VPDPBUSDS xmm, xmm, xmm\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cint\u003E MultiplyWideningAndAddSaturate(Vector128\u003Cint\u003E addend, Vector128\u003Cbyte\u003E left, Vector128\u003Csbyte\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_dpwssds_epi32 (__m128i src, __m128i a, __m128i b)\r\n        /// VPDPWSSDS xmm, xmm, xmm\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cint\u003E MultiplyWideningAndAddSaturate(Vector128\u003Cint\u003E addend, Vector128\u003Cshort\u003E left, Vector128\u003Cshort\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m256i _mm256_dpbusds_epi32 (__m256i src, __m256i a, __m256i b)\r\n        /// VPDPBUSDS ymm, ymm, ymm\r\n        /// \u003C/summary\u003E\r\n        public static Vector256\u003Cint\u003E MultiplyWideningAndAddSaturate(Vector256\u003Cint\u003E addend, Vector256\u003Cbyte\u003E left, Vector256\u003Csbyte\u003E right) { throw new PlatformNotSupportedException(); }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m256i _mm256_dpwssds_epi32 (__m256i src, __m256i a, __m256i b)\r\n        /// VPDPWSSDS ymm, ymm, ymm\r\n        /// \u003C/summary\u003E\r\n        public static Vector256\u003Cint\u003E MultiplyWideningAndAddSaturate(Vector256\u003Cint\u003E addend, Vector256\u003Cshort\u003E left, Vector256\u003Cshort\u003E right) { throw new PlatformNotSupportedException(); }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AvxVnni.AvxVnni()",
          "M:AvxVnni.MultiplyWideningAndAdd(Vector128\u003Cint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AvxVnni.MultiplyWideningAndAdd(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AvxVnni.MultiplyWideningAndAdd(Vector256\u003Cint\u003E,Vector256\u003Cbyte\u003E,Vector256\u003Csbyte\u003E)",
          "M:AvxVnni.MultiplyWideningAndAdd(Vector256\u003Cint\u003E,Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E)",
          "M:AvxVnni.MultiplyWideningAndAddSaturate(Vector128\u003Cint\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:AvxVnni.MultiplyWideningAndAddSaturate(Vector128\u003Cint\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:AvxVnni.MultiplyWideningAndAddSaturate(Vector256\u003Cint\u003E,Vector256\u003Cbyte\u003E,Vector256\u003Csbyte\u003E)",
          "M:AvxVnni.MultiplyWideningAndAddSaturate(Vector256\u003Cint\u003E,Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E)",
          "M:AvxVnni.X64.X64()",
          "P:AvxVnni.IsSupported",
          "P:AvxVnni.X64.IsSupported",
          "T:AvxVnni",
          "T:AvxVnni.X64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51541,
          "Title": "Add SupportedOSPlatformGuard and UnsupportedOSPlatformGuard Platform-Guard attributes",
          "Author": "buyaa-n",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-20T01:22:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51541",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-27T00:00:00-07:00",
        "FeedbackId": "827825898",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51541#issuecomment-827825898",
        "FeedbackMarkdown": "We did a long discussion as to whether we should accept a boolean in the manner of \u0060[MaybeNullWhen]\u0060, but felt like it probably doesn\u0027t come up much, and we could add it later.\r\n\r\nWe did remove AttributeTargets.Enum from the attribute decl, though.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Versioning\r\n{\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]\r\n    public sealed class SupportedOSPlatformGuardAttribute : OSPlatformAttribute\r\n    {\r\n        public SupportedOSPlatformGuardAttribute(string platformName) ;\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]\r\n    public sealed class UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute\r\n    {\r\n        public UnsupportedOSPlatformGuardAttribute(string platformName) ;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 2860000000,
        "Apis": [
          "M:SupportedOSPlatformGuardAttribute.SupportedOSPlatformGuardAttribute(string)",
          "M:UnsupportedOSPlatformGuardAttribute.UnsupportedOSPlatformGuardAttribute(string)",
          "T:SupportedOSPlatformGuardAttribute",
          "T:UnsupportedOSPlatformGuardAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 25063,
          "Title": "Add PipeReader.ReadAsync overloads to allow waiting for a specific amount of data",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-02-16T00:57:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/25063",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-27T00:00:00-07:00",
        "FeedbackId": "827837589",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/25063#issuecomment-827837589",
        "FeedbackMarkdown": "* Since there\u0027s a parameter that should be validated (if negative, throw), it should use the Template Method Pattern (ReadAsync =\u003E virtual ReadAsyncCore)\r\n* To enhance discoverability we feel like not being an overload is better: ReadAsync =\u003E ReadAtLeastAsync\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipelines\r\n{\r\n    partial class PipeReader\r\n    {\r\n        public ValueTask\u003CReadResult\u003E ReadAtLeastAsync(int minimumBytes, CancellationToken cancellationToken = default);\r\n        protected virtual ValueTask\u003CReadResult\u003E ReadAtLeastAsyncCore(int minimumBytes, CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n@GrabYourPitchforks seems to have had some existential concerns with this.  The shape is approved as long as we don\u0027t outright axe the feature.",
        "TimeCode": 50820000000,
        "Apis": [
          "M:PipeReader.ReadAtLeastAsync(int,CancellationToken)",
          "M:PipeReader.ReadAtLeastAsyncCore(int,CancellationToken)",
          "T:PipeReader"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49878,
          "Title": "Implement IEnumerable\u003C\u003E on various X509 collection types",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-19T16:18:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49878",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-27T00:00:00-07:00",
        "FeedbackId": "827840659",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49878#issuecomment-827840659",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public class X509Certificate2Collection : X509CertificateCollection,\r\n\u002B         IEnumerable\u003CX509Certificate2\u003E\r\n    {\r\n        ...\r\n    }\r\n    \r\n    public sealed class X509Certificate2Enumerator : IEnumerator,\r\n\u002B         IEnumerator\u003CX509Certificate2\u003E\r\n    {\r\n        ...\r\n    }\r\n        \r\n    \r\n    public sealed class X509ChainElementCollection : ICollection,\r\n\u002B        IEnumerable\u003CX509ChainElement\u003E\r\n    {\r\n        ...\r\n    }\r\n    \r\n    public sealed class X509ChainElementEnumerator : IEnumerator,\r\n\u002B        IEnumerator\u003CX509ChainElement\u003E\r\n    {\r\n        ...\r\n    }\r\n    \r\n    public sealed class X509ExtensionCollection : ICollection,\r\n\u002B        IEnumerable\u003CX509Extension\u003E\r\n    {\r\n        ...\r\n    }\r\n    \r\n    public sealed class X509ExtensionEnumerator : IEnumerator,\r\n\u002B        IEnumerator\u003CX509Extension\u003E\r\n    {\r\n        ...\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61790000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ctxGYi6HDxw",
      "StartDateTime": "2021-04-29T10:06:37-07:00",
      "EndDateTime": "2021-04-29T12:43:38-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ctxGYi6HDxw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44659,
          "Title": "Low level API support for Objective-C scenarios",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-13T20:25:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44659",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "tracking",
              "Color": "b60205",
              "Description": "This issue is tracking the completion of other related issues."
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-29T00:00:00-07:00",
        "FeedbackId": "829495419",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44659#issuecomment-829495419",
        "FeedbackMarkdown": "* Is the ObjectiveC namespace justified? It may end up with a low number of types.\r\n  * We decided yes, for symmetry with the others.\r\n* Bridge.CreateReferenceTrackingHandle should out Span\u003CIntPtr\u003E instead of just IntPtr so it can communicate that you get two pointers worth of memory (and avoids the famous last words of \u0022it\u0027ll always be two\u0022).\r\n* Rename Bridge.CreateReferenceTrackingHandle@scratchMemory to taggedMemory\r\n* Remove the UnhandledExceptionPropagation event and make it be only one delegate, bound in the Initialize call\r\n* TrackedNativeReferencesAttribute should be sealed, Inherited=true, AllowMultiple=false\r\n* Is \u0022Bridge\u0022 too general name even for an out of the way namespace?\r\n  * We suggested ObjectiveCMarshal\r\n* We renamed TrackedNativeReferenceAttribute to ObjectiveCTrackedTypeAttribute\r\n* We renamed SetMessageSendPendingExceptionForThread to SetMessageSendPendingException (dropped \u0022ForThread\u0022)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices.ObjectiveC\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Attribute used to indicate a class is tracked from the native environment.\r\n    /// \u003C/summary\u003E\r\n    [AttributeUsage(AttributeTargets.Class, Inherited=true, AllowMultiple=false)]\r\n    public sealed class ObjectiveCTrackedTypeAttribute : Attribute\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Instantiate a \u003Csee cref=\u0022ObjectiveCTrackedTypeAttribute\u0022/\u003E instance.\r\n        /// \u003C/summary\u003E\r\n        public ObjectiveCTrackedTypeAttribute() { }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// API to enable an Objective-C bridge.\r\n    /// \u003C/summary\u003E\r\n    public static class ObjectiveCMarshal\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Initialize reference tracking for the Objective-C bridge API.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022beginEndCallback\u0022\u003ECalled when tracking begins and ends.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022isReferencedCallback\u0022\u003ECalled to determine if a managed object instance is referenced elsewhere, and must not be collected by the GC.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022trackedObjectEnteredFinalization\u0022\u003ECalled when a tracked object enters the finalization queue.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022unhandledExceptionPropagationHandler\u0022\u003EHandler for the propagation of unhandled Exceptions across a managed -\u003E native boundary (that is, Reverse P/Invoke).\u003C/param\u003E\r\n        /// \u003Cexception cref=\u0022InvalidOperationException\u0022\u003EThrown if this API has already been called.\u003C/exception\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All callbacks must be written in native code since they will be called by the GC and\r\n        /// managed code is not able to run at that time.\r\n        ///\r\n        /// The \u003Cparamref name=\u0022beginEndCallback\u0022/\u003E will be called when reference tracking begins and ends.\r\n        /// The associated begin/end pair will never be nested.\r\n        ///\r\n        /// The \u003Cparamref name=\u0022isReferencedCallback\u0022/\u003E should return 0 for not reference or 1 for\r\n        /// referenced. Any other value has undefined behavior.\r\n        /// \u003C/remarks\u003E\r\n        public static unsafe void InitializeReferenceTracking(\r\n            delegate* unmanaged\u003Cvoid\u003E beginEndCallback,\r\n            delegate* unmanaged\u003CIntPtr, int\u003E isReferencedCallback,\r\n            delegate* unmanaged\u003CIntPtr, void\u003E trackedObjectEnteredFinalization,\r\n            UnhandledExceptionPropagationHandler unhandledExceptionPropagationHandler);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Request native reference tracking for the supplied object.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003EThe object to track.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022scratchMemory\u0022\u003EA pointer to scratch memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReference tracking GC handle.\u003C/returns\u003E\r\n        /// \u003Cexception cref=\u0022InvalidOperationException\u0022\u003EThrown if the Bridge API has not been initialized.\u003C/exception\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Reference tracking in the \u003Csee cref=\u0022Bridge\u0022/\u003E must be initialized prior to calling\r\n        /// this function.\r\n        ///\r\n        /// The \u003Cparamref name=\u0022obj\u0022/\u003E must have a type in its hierarchy marked with\r\n        /// \u003Csee cref=\u0022TrackedNativeReferenceAttribute\u0022/\u003E.\r\n        ///\r\n        /// The \u0022Is Referenced\u0022 callback passed to InitializeReferenceTracking\r\n        /// will be passed the \u003Cparamref name=\u0022scratchMemory\u0022/\u003E returned from this function.\r\n        /// The memory it points at is 2 pointer\u0027s worth (for example, 16 bytes on a 64-bit platform) and\r\n        /// will be zeroed out and available until \u003Cparamref name=\u0022obj\u0022/\u003E is collected by the GC.\r\n        /// The memory pointed to by \u003Cparamref name=\u0022scratchMemory\u0022/\u003E can be used for any purpose by the\r\n        /// caller of this function and usable during the \u0022Is Referenced\u0022 callback.\r\n        ///\r\n        /// Calling this function multiple times with the same \u003Cparamref name=\u0022obj\u0022/\u003E will\r\n        /// return a new handle each time but the same scratch memory will be returned. The\r\n        /// scratch memory is only guaranteed to be zero initialized on the first call.\r\n        ///\r\n        /// The caller is responsible for freeing the returned \u003Csee cref=\u0022GCHandle\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        public static GCHandle CreateReferenceTrackingHandle(\r\n            object obj,\r\n            out Span\u003CIntPtr\u003E taggedMemory);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Objective-C msgSend function override options.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Csee href=\u0022https://developer.apple.com/documentation/objectivec/1456712-objc_msgsend\u0022/\u003E\r\n        public enum MsgSendFunction\r\n        {\r\n            ObjCMsgSend,\r\n            ObjCMsgSendFpret,\r\n            ObjCMsgSendStret,\r\n            ObjCMsgSendSuper,\r\n            ObjCMsgSendSuperStret,\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Set function pointer override for an Objective-C runtime message passing export.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022msgSendFunction\u0022\u003EThe export to override.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022func\u0022\u003EThe function override.\u003C/param\u003E\r\n        /// \u003Cexception cref=\u0022InvalidOperationException\u0022\u003EThrown if the msgSend function has already been overridden.\u003C/exception\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing an override can enable support for Objective-C\r\n        /// exception propagation and variadic argument support.\r\n        /// \u003C/remarks\u003E\r\n        public static void SetMessageSendCallback(MsgSendFunction msgSendFunction, IntPtr func);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Sets a pending exception for this thread to be thrown\r\n        /// the next time the runtime is entered from an overridden\r\n        /// msgSend P/Invoke.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022exception\u0022\u003EThe exception.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If \u003Cc\u003Enull\u003C/c\u003E is supplied any pending exception is discarded.\r\n        /// \u003C/remarks\u003E\r\n        public static void SetMessageSendPendingException(Exception? exception);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Handler for unhandled Exceptions crossing the managed -\u003E native boundary (that is, Reverse P/Invoke).\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022exception\u0022\u003EUnhandled exception.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022lastMethod\u0022\u003ELast managed method.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022context\u0022\u003EContext provided to the returned function pointer.\u003C/param\u003E\r\n        /// \u003Creturns\u003EException propagation callback.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the handler is able to propagate the managed Exception properly to the native environment an\r\n        /// unmanaged callback can be returned, otherwise \u003Cc\u003Enull\u003C/c\u003E. The RuntimeMethodHandle is to the\r\n        /// last managed method that was executed prior to leaving the runtime. Along with the returned callback\r\n        /// the handler can return a context that will be passed to the callback during dispatch.\r\n        ///\r\n        /// The returned handler will be passed the context when called and is the responsibility of the callback\r\n        /// to managed. The handler must not return and is expected to propagate the exception into the native\r\n        /// environment or fail fast.\r\n        /// \u003C/remarks\u003E\r\n        public unsafe delegate delegate* unmanaged\u003CIntPtr, void\u003E UnhandledExceptionPropagationHandler(\r\n            Exception exception,\r\n            RuntimeMethodHandle lastMethod,\r\n            out IntPtr context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:ObjectiveCMarshal.MsgSendFunction.ObjCMsgSend",
          "F:ObjectiveCMarshal.MsgSendFunction.ObjCMsgSendFpret",
          "F:ObjectiveCMarshal.MsgSendFunction.ObjCMsgSendStret",
          "F:ObjectiveCMarshal.MsgSendFunction.ObjCMsgSendSuper",
          "F:ObjectiveCMarshal.MsgSendFunction.ObjCMsgSendSuperStret",
          "M:ObjectiveCMarshal.CreateReferenceTrackingHandle(object,out Span\u003CIntPtr\u003E)",
          "M:ObjectiveCMarshal.InitializeReferenceTracking(delegate* unmanaged\u003Cvoid\u003E,delegate* unmanaged\u003CIntPtr, int\u003E,delegate* unmanaged\u003CIntPtr, void\u003E,UnhandledExceptionPropagationHandler)",
          "M:ObjectiveCMarshal.SetMessageSendCallback(MsgSendFunction,IntPtr)",
          "M:ObjectiveCMarshal.SetMessageSendPendingException(Exception?)",
          "M:ObjectiveCTrackedTypeAttribute.ObjectiveCTrackedTypeAttribute()",
          "T:ObjectiveCMarshal",
          "T:ObjectiveCMarshal.MsgSendFunction",
          "T:ObjectiveCMarshal.UnhandledExceptionPropagationHandler(Exception,RuntimeMethodHandle,out IntPtr)",
          "T:ObjectiveCTrackedTypeAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24271,
          "Title": "Proposed API for symbolic links",
          "Author": "carlreinke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-29T05:50:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24271",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-04-29T00:00:00-07:00",
        "FeedbackId": "829537170",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24271#issuecomment-829537170",
        "FeedbackMarkdown": "* File.CreateSymbolicLink should return FileSystemInfo instead of FileInfo, to avoid the type problem when the target was a directory\r\n* Same for GetSymbolicLinkTarget\r\n* The FileSystemInfo.CreateAsSymbolicLink seems problematic, since it could cause the existing instance to change whether it \u0022believes\u0022 it\u0027s a file or a directory, depending on the target.\r\n  * What does new FileSystemInfo(@\u0022C:\\Windows\u0022) do?  What happens when use members on it later?\r\n  * Ultimately we ended up not needing to know, but it did leave us in a confused state in the middle.\r\n* In review we were concerned with how this might affect existing behaviors of things like DirectoryInfo.EnumerateDirectories (does that currently examine if symbolic links are directories?) and since we weren\u0027t sure what the answers were we had trouble continuing.\r\n* The File and Directory GetSymbolicLinkTarget want the returnFinalTarget boolean, for symmetry.\r\n* We defaulted all the returnFinalTarget values to false\r\n* @GrabYourPitchforks  has lots of opinions on documentation for when returnFinalTarget is true.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public abstract partial class FileSystemInfo\r\n    {\r\n        public void CreateAsSymbolicLink(string pathToTarget);\r\n        public FileSystemInfo? GetSymbolicLinkTarget(bool returnFinalTarget = false); \r\n    }\r\n    public static class File\r\n    {\r\n        public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);\r\n        public static FileSystemInfo? GetSymbolicLinkTarget(string linkPath, bool returnFinalTarget = false);\r\n    }\r\n    public static class Directory\r\n    {\r\n        public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);\r\n        public static FileSystemInfo? GetSymbolicLinkTarget(string linkPath, bool returnFinalTarget = false);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54980000000,
        "Apis": [
          "M:Directory.CreateSymbolicLink(string,string)",
          "M:Directory.GetSymbolicLinkTarget(string,bool)",
          "M:File.CreateSymbolicLink(string,string)",
          "M:File.GetSymbolicLinkTarget(string,bool)",
          "M:FileSystemInfo.CreateAsSymbolicLink(string)",
          "M:FileSystemInfo.GetSymbolicLinkTarget(bool)",
          "T:Directory",
          "T:File",
          "T:FileSystemInfo"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "FkHK-jcvVRE",
      "StartDateTime": "2021-05-03T10:01:08-07:00",
      "EndDateTime": "2021-05-03T12:09:41-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/FkHK-jcvVRE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44728,
          "Title": "Optimize ServiceCollectionDescriptorExtensions TryAdd",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-16T14:41:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44728",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-DependencyInjection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-03T00:00:00-07:00",
        "FeedbackId": "831413792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44728#issuecomment-831413792",
        "FeedbackMarkdown": "Approved as proposed.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n    public class ServiceCollection\r\n    {\r\n\u002B     public bool TryAdd(ServiceDescriptor descriptor);\r\n\u002B     public bool TryAddEnumerable(ServiceDescriptor descriptor);\r\n\u002B     public bool TryReplace(ServiceDescriptor descriptor);\r\n\u002B     public void RemoveAll(Type serviceType);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51937,
          "Title": "Change namespace name \u0060System.Text.Json.Node\u0060 to \u0060System.Text.Json.Nodes\u0060",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-27T16:42:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51937",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-03T00:00:00-07:00",
        "FeedbackId": "831415512",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51937#issuecomment-831415512",
        "FeedbackMarkdown": "Renaming the namespace is approved as proposed\r\n\r\nSystem.Text.Json.Node =\u003E System.Text.Json.Node**s**",
        "TimeCode": 19000000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 205,
          "Title": "Adding a rough draft of the \u0022minimum viable product\u0022 for the .NET Libraries APIs to support generic math",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-15T04:09:21+00:00",
          "Url": "https://github.com/dotnet/designs/pull/205",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-03T00:00:00-07:00",
        "FeedbackId": "831470677",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/205#issuecomment-831470677",
        "FeedbackMarkdown": "* Should we eliminate IParseable and just add ISpanParseable?\r\n* Rename all lhs parameters to left and all rhs parameters to right\r\n* We need a consistent name for the (low-level) operator defining interfaces.\r\n  * I[Purpose]Operators seems the most reasonable, with Purpose being the primary metadata name, or concept\r\n  * IEquatableOperators =\u003E IEqualityOperators\r\n  * IComparableOperators =\u003E IComparisonOperators\r\n  * IAddable =\u003E IAdditionOperators\r\n  * ISubtractable =\u003E ISubtractionOperators\r\n  * IRemainder =\u003E IModulusOperators\r\n  * INegatable =\u003E IUnaryNegationOperators\r\n  * IShiftable =\u003E IShiftOperators\r\n* We need a consistent name for the value-exposing interfaces (MinValue/MaxValue)\r\n  * (Maybe they\u0027re the best they\u0027re going to be?)\r\n  * IAdditiveIdentity =\u003E\r\n  * IMultiplicativeIdentity =\u003E\r\n  * IMinMaxValue =\u003E\r\n* INumber we discussed, and feel it\u0027s probably the right name\r\n* INumber.Create* feels a little weird.  Is it the right level?  Is there a good way to help convey what TOthers do and don\u0027t work?\r\n  * Should they be a different interface, higher or lower level?\r\n* BinaryInteger.Rotate* second parameters should be TSelf, not int.\r\n* IBinaryNumber and beyond were only skimmed\r\n* IBinaryNumber\u0027s methods probably want some changes (@bartonjs has some regrets about \u0022isUnsigned\u0022, at least).",
        "TimeCode": 20820000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "Cquc3gfSirQ",
      "StartDateTime": "2021-05-07T10:06:39-07:00",
      "EndDateTime": "2021-05-07T12:26:41-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/Cquc3gfSirQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44445,
          "Title": "Developers can trace their code using Open Telemetry Metrics",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-10T02:16:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44445",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tracking",
              "Color": "b60205",
              "Description": "This issue is tracking the completion of other related issues."
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:0",
              "Color": "b60205",
              "Description": "Work that we can\u0027t release without"
            },
            {
              "Name": "Cost:XL",
              "Color": "007700",
              "Description": "Work that requires one engineer more than 4 weeks"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-07T00:00:00-07:00",
        "FeedbackId": "834688067",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44445#issuecomment-834688067",
        "FeedbackMarkdown": "* In the Metric.Create* methods, consider swapping the order of unit and description, if (name\u002Bunit) seems more likely than (name\u002Bdescription).\r\n* \u0022Observable\u0022 in this context has a meaning opposite of what it means in \u0022ObservableCollection\u0022\r\n  * We don\u0027t have a solid replacement name for it, though, since it seems that every appropriate word already has a conflicting meaning in OpenTelemetry.\r\n* Consider renaming \u0060Instrument\u003CT\u003E\u0060 to \u0060StreamingInstrument\u003CT\u003E\u0060, or some other prefix, to give better separation between \u0060ObservableInstrument\u003CT\u003E\u0060 and \u0022the other kind\u0022.\r\n* Add a \u0060public Measurement(T value)\u0060 constructor so the params one is not called with the empty array.\r\n* For \u0060Counter\u003CT\u003E.Add\u0060, rename \u0060measurement\u0060 to \u0060delta\u0060 to make it more clear that the caller should provide only the amount to increase since the last call, vs that \u0022Add\u0022 means appending to a list.\r\n* Rename \u0060Histogram\u003CT\u003E.Record\u0060\u0027s \u0060measurement\u0060 parameter to \u0060value\u0060 (to avoid confusion with \u0060Measurement\u003CT\u003E\u0060 and associated semantics)\r\n* \u0060Measurement\u003CT\u003E\u0060 should be declared readonly\r\n* MeasurementCallback should constraint T to match the rest of the proposal (T : unmanaged)\r\n* Replace all of the T : unmanaged constraints with T : struct\r\n\r\nWe had to stop before really looking at MetricListener.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51962,
          "Title": "C# 10 interpolated strings support, part 3",
          "Author": "333fred",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-27T23:12:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51962",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-07T00:00:00-07:00",
        "FeedbackId": "834716920",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51962#issuecomment-834716920",
        "FeedbackMarkdown": "After a long discussion we think the best convention we\u0027ll come up with is the suffix \u0022InterpolatedStringHandler\u0022\r\n\r\nTherefore, the renames should be\r\n\r\n* InterpolatedStringHandlerArgumentAttribute\r\n* InterpolatedStringHandlerAttribute\r\n* DefaultInterpolatedStringHandler\r\n* SpanInterpolatedStringHandler\r\n* StringBuilder\u002BAppendFormatInterpolatedStringHandler\r\n\r\nThe attribute is otherwise good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]\r\n    public sealed class InterpolatedStringHandlerAttribute : Attribute\r\n    {\r\n        public InterpolatedStringHandlerAttribute()\r\n        {\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 60630000000,
        "Apis": [
          "M:InterpolatedStringHandlerAttribute.InterpolatedStringHandlerAttribute()",
          "T:InterpolatedStringHandlerAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50913,
          "Title": "Add LoggerMessage.Define overloads accepting up to 14 arguments.",
          "Author": "maryamariyan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-08T14:51:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50913",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-11T00:00:00-07:00",
        "FeedbackId": "838958162",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50913#issuecomment-838958162",
        "FeedbackMarkdown": "The new overloads need more work, @davidfowl has concerns about the return type, and some explosion.\r\n\r\nThe new LogOptions class should be LogDefineOptions\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{ \r\n    public class LogDefineOptions\r\n    {\r\n        public bool SkipEnabledCheck { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nUpdating the not-yet-released API:\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.Extensions.Logging\r\n{ \r\n    public static partial class LoggerMessage\r\n    {\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, System.Exception?\u003E Define\u003CT1\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, System.Exception?\u003E Define\u003CT1\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, System.Exception?\u003E Define\u003CT1, T2\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, System.Exception?\u003E Define\u003CT1, T2\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, System.Exception?\u003E Define\u003CT1, T2, T3\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, System.Exception?\u003E Define\u003CT1, T2, T3\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, System.Exception?\u003E Define\u003CT1, T2, T3, T4\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, System.Exception?\u003E Define\u003CT1, T2, T3, T4\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, System.Exception?\u003E Define\u003CT1, T2, T3, T4, T5\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, System.Exception?\u003E Define\u003CT1, T2, T3, T4, T5\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n-        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, T6, System.Exception?\u003E Define\u003CT1, T2, T3, T4, T5, T6\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, bool skipEnabledCheck) { throw null; }\r\n\u002B        public static System.Action\u003CMicrosoft.Extensions.Logging.ILogger, T1, T2, T3, T4, T5, T6, System.Exception?\u003E Define\u003CT1, T2, T3, T4, T5, T6\u003E(Microsoft.Extensions.Logging.LogLevel logLevel, Microsoft.Extensions.Logging.EventId eventId, string formatString, Microsoft.Extensions.Logging.LogOptions options) {\u200B throw null; }\u200B\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:LogDefineOptions.SkipEnabledCheck",
          "T:LogDefineOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44445,
          "Title": "Developers can trace their code using Open Telemetry Metrics",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-10T02:16:18+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44445",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Tracing",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tracking",
              "Color": "b60205",
              "Description": "This issue is tracking the completion of other related issues."
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:0",
              "Color": "b60205",
              "Description": "Work that we can\u0027t release without"
            },
            {
              "Name": "Cost:XL",
              "Color": "007700",
              "Description": "Work that requires one engineer more than 4 weeks"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-11T00:00:00-07:00",
        "FeedbackId": "839028589",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44445#issuecomment-839028589",
        "FeedbackMarkdown": "In addition to the previous feedback:\r\n\r\n* Do MeterListener.InstrumentPublished and MeasurementsCompleted need to be get/set? Should they be ctor parameters instead?\r\n  * It seems there are theoretical scenarios for replacing them later, so get/set is fine\r\n* What is the experience when a SetMeasurementCallback wasn\u0027t called for the T that is being reported?\r\n  * Consider something like \u0060public Action\u003CInstrument\u003E? UnregisteredMeasurementCallback { get; set; }\u0060 to get called in that case instead of just data loss.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Metrics\r\n{\r\n    public class Meter : IDisposable\r\n    {\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The constructor allows creating the Meter class with the name and optionally the version.\r\n        /// The name should be validated as described by the OpenTelemetry specs.\r\n        /// \u003C/summary\u003E\r\n        public Meter(string name)  { throw null;  }\r\n        public Meter(string name, string? version) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Getter properties to retrieve the Meter name and version\r\n        /// \u003C/summary\u003E\r\n        public string Name { get; }\r\n        public string? Version { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Factory methods to create Counter and Histogram instruments.\r\n        /// \u003C/summary\u003E\r\n        public Counter\u003CT\u003E CreateCounter\u003CT\u003E(\r\n                            string name,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        public Histogram\u003CT\u003E CreateHistogram\u003CT\u003E(\r\n                            string name,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Factory methods to create an ObservableCounter instrument.\r\n        /// \u003C/summary\u003E\r\n\r\n        public ObservableCounter\u003CT\u003E CreateObservableCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CT\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        public ObservableCounter\u003CT\u003E CreateObservableCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CMeasurement\u003CT\u003E\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null,) where T : struct { throw null; }\r\n\r\n        public ObservableCounter\u003CT\u003E CreateObservableCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E observeValues,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Factory methods to create ObservableGauge instrument.\r\n        /// \u003C/summary\u003E\r\n        public ObservableGauge\u003CT\u003E CreateObservableGauge\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CT\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null,) where T : struct { throw null; }\r\n\r\n        public ObservableGauge\u003CT\u003E CreateObservableGauge\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CMeasurement\u003CT\u003E\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        public ObservableGauge\u003CT\u003E CreateObservableGauge\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E observeValues,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Factory methods to create ObservableUpDownCounter instrument.\r\n        /// \u003C/summary\u003E\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CT\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null,) where T : struct { throw null; }\r\n\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CMeasurement\u003CT\u003E\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null,) where T : struct { throw null; }\r\n\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E observeValues,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct { throw null; }\r\n\r\n        public void Dispose() { throw null; }\r\n    }\r\n\r\n/// \u003Csummary\u003E\r\n    /// Is the base class which contains all common properties between different types of instruments.\r\n    /// It contains the protected constructor and the Publish method allows activating the instrument\r\n    /// to start recording measurements.\r\n    /// \u003C/summary\u003E\r\n\r\n    public abstract class Instrument\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Protected constructor to initialize the common instrument properties.\r\n        /// \u003C/summary\u003E\r\n        protected Instrument(Meter meter, string name, string? unit, string? description) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Publish is to allow activating the instrument to start recording measurements and to allow\r\n        /// listeners to start listening to such measurements.\r\n        /// \u003C/summary\u003E\r\n        protected void Publish() { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Getters to retrieve the properties that the instrument is created with.\r\n        /// \u003C/summary\u003E\r\n        public Meter Meter { get; }\r\n        public string Name { get; }\r\n        public string? Unit { get; }\r\n        public string? Description { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// A property tells if a listener is listening to this instrument measurement recording.\r\n        /// \u003C/summary\u003E\r\n        public bool Enabled =\u003E throw null;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// A property tells if the instrument is a regular instrument or an observable instrument.\r\n        /// \u003C/summary\u003E\r\n        public virtual bool IsObservable =\u003E throw null;\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Instrument\u003CT\u003E is the base class from which all instruments that report measurements in the context of the request will inherit from.\r\n    /// Mainly it will support the CLS compliant numerical types.\r\n    /// \u003C/summary\u003E\r\n    public abstract class Instrument\u003CT\u003E : Instrument where T : struct\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Protected constructor to create the instrument with the common properties.\r\n        /// \u003C/summary\u003E\r\n        protected Instrument(Meter meter, string name, string? unit, string? description) :\r\n                        base(meter, name, unit, description) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Record measurement overloads allowing passing different numbers of tags.\r\n        /// \u003C/summary\u003E\r\n\r\n        protected void RecordMeasurement(T measurement) { throw null; }\r\n\r\n        protected void RecordMeasurement(\r\n                            T measurement,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag) { throw null; }\r\n\r\n        protected void RecordMeasurement(\r\n                            T measurement,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag2) { throw null; }\r\n\r\n        protected void RecordMeasurement(\r\n                            T measurement,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag2,\r\n                            KeyValuePair\u003Cstring, object?\u003E tag3) { throw null; }\r\n\r\n        protected void RecordMeasurement(\r\n                            T measurement,\r\n                            ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags) { throw null; }\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// ObservableInstrument\u003CT\u003E is the base class from which all observable instruments will inherit from.\r\n    /// It will only support the CLS compliant numerical types.\r\n    /// \u003C/summary\u003E\r\n    public abstract class ObservableInstrument\u003CT\u003E : Instrument where T : struct\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Protected constructor to create the instrument with the common properties.\r\n        /// \u003C/summary\u003E\r\n        protected ObservableInstrument(\r\n                    Meter meter,\r\n                    string name,\r\n                    string? unit,\r\n                    string? description) : base(meter, name, unit, description) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Observe() fetches the current measurements being tracked by this instrument.\r\n        /// \u003C/summary\u003E\r\n        protected abstract IEnumerable\u003CMeasurement\u003CT\u003E\u003E Observe();\r\n\r\n        public override bool IsObservable =\u003E true;\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// A measurement stores one observed value and its associated tags. This type is used by Observable instruments\u0027 Observe() method when reporting current measurements with associated tags.\r\n    /// with the associated tags.\r\n    /// \u003C/summary\u003E\r\n    public readonly struct Measurement\u003CT\u003E where T : struct\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Construct the Measurement using the value and the list of tags.\r\n        /// We\u0027ll always copy the input list as this is not perf hot path.\r\n        /// \u003C/summary\u003E\r\n        public Measurement(T value) { throw null; }\r\n        public Measurement(T value, IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags) { throw null; }\r\n        public Measurement(T value, params KeyValuePair\u003Cstring, object?\u003E[] tags) { throw null; }\r\n        public Measurement(T value, ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags) { throw null; }\r\n\r\n        public ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E Tags { get { throw null;  } }\r\n        public T Value { get; }\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// The counter is an Instrument that supports non-negative increments.\r\n    /// e.g. Number of completed requests.\r\n    /// \u003C/summary\u003E\r\n    public sealed class Counter\u003CT\u003E : Instrument\u003CT\u003E where T : struct\r\n    {\r\n        public void Add(T delta) { throw null; }\r\n        public void Add(T delta,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag) { throw null; }\r\n        public void Add(T delta,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag2) { throw null; }\r\n        public void Add(T delta,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag2,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag3) { throw null; }\r\n        public void Add(T delta,\r\n                        ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags) { throw null; }\r\n        public void Add(T delta,\r\n                        params KeyValuePair\u003Cstring, object?\u003E[] tags) { throw null; }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// The histogram is an Instrument that can be used to report arbitrary values\r\n    /// that are likely to be statistically meaningful. It is intended for statistics such as the request duration.\r\n    /// e.g. the request duration.\r\n    /// \u003C/summary\u003E\r\n    public sealed class Histogram\u003CT\u003E : Instrument\u003CT\u003E where T : struct\r\n    {\r\n        public void Record(T value) { throw null; }\r\n        public void Record(\r\n                        T value,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag) { throw null; }\r\n        public void Record(\r\n                        T value,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag2) { throw null; }\r\n        public void Record(\r\n                        T value,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag1,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag2,\r\n                        KeyValuePair\u003Cstring, object?\u003E tag3) { throw null; }\r\n        public void Record(T value,\r\n                            ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags) { throw null; }\r\n        public void Record(\r\n                        T value,\r\n                        params KeyValuePair\u003Cstring, object?\u003E[] tags) { throw null; }\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// ObservableCounter is an observable Instrument that reports monotonically increasing value(s)\r\n    /// when the instrument is being observed.\r\n    /// e.g. CPU time (for different processes, threads, user mode or kernel mode).\r\n    /// \u003C/summary\u003E\r\n    public sealed class ObservableCounter\u003CT\u003E : ObservableInstrument\u003CT\u003E where T : struct\r\n    {\r\n        protected override IEnumerable\u003CMeasurement\u003CT\u003E\u003E Observe() { throw null; }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// ObservableUpDownCounter is an observable Instrument that reports additive value(s)\r\n    /// when the instrument is being observed.\r\n    /// e.g. the process heap size\r\n    /// \u003C/summary\u003E\r\n    public sealed class ObservableUpDownCounter\u003CT\u003E : ObservableInstrument\u003CT\u003E where T : struct\r\n    {\r\n        protected override IEnumerable\u003CMeasurement\u003CT\u003E\u003E Observe() { throw null; }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// ObservableGauge is an observable Instrument that reports non-additive value(s)\r\n    /// when the instrument is being observed.\r\n    /// e.g. the current room temperature\r\n    /// \u003C/summary\u003E\r\n    public sealed class ObservableGauge\u003CT\u003E : ObservableInstrument\u003CT\u003E where T : struct\r\n    {\r\n        protected override IEnumerable\u003CMeasurement\u003CT\u003E\u003E Observe() { throw null; }\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// A delegate to represent the callbacks signatures used in the listener.\r\n    /// \u003C/summary\u003E\r\n    public delegate void MeasurementCallback\u003CT\u003E(\r\n                            Instrument instrument,\r\n                            T measurement,\r\n                            ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags,\r\n                            object? state) where T : struct;\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// The listener class can be used to listen to kinds of instruments.\r\n    /// recorded measurements.\r\n    /// \u003C/summary\u003E\r\n    public sealed class MeterListener : IDisposable\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Simple constructor\r\n        /// \u003C/summary\u003E\r\n        public MeterListener() { throw null;  }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Callbacks to get notification when an instrument is published\r\n        /// \u003C/summary\u003E\r\n        public Action\u003CInstrument, MeterListener\u003E? InstrumentPublished { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Callbacks to get notification when stopping the measurement on some instrument\r\n        /// this can happen when the Meter or the Listener is disposed of. Or calling Stop()\r\n        /// on the listener.\r\n        /// \u003C/summary\u003E\r\n        public Action\u003CInstrument, object?\u003E? MeasurementsCompleted { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Start listening to a specific instrument measurement recording.\r\n        /// \u003C/summary\u003E\r\n        public void EnableMeasurementEvents(Instrument instrument, object? state = null) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Stop listening to a specific instrument measurement recording.\r\n        /// returns the associated state.\r\n        /// \u003C/summary\u003E\r\n        public object? DisableMeasurementEvents(Instrument instrument) { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Set a callback for a specific numeric type to get the measurement recording notification\r\n        /// from all instruments which enabled listened to and was created with the same specified\r\n        /// numeric type. If a measurement of type T is recorded and a callback of type T is registered, that callback is used. If there is no callback for type T but there is a callback for type object, the measured value is boxed and reported via the object typed callback. If there is neither type T callback nor object callback then the measurement will not be reported.\r\n        /// \u003C/summary\u003E\r\n        public void SetMeasurementEventCallback\u003CT\u003E(MeasurementCallback\u003CT\u003E? measurementCallback) where T : struct { throw null; }\r\n\r\n        public void Start() { throw null; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Call all Observable instruments to get the recorded measurements reported to the\r\n        /// callbacks enabled by SetMeasurementEventCallback\u003CT\u003E\r\n        /// \u003C/summary\u003E\r\n        public void RecordObservableInstruments() { throw null; }\r\n\r\n        public void Dispose() { throw null; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Counter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Counter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Counter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Counter\u003CT\u003E.Add(T,params KeyValuePair\u003Cstring, object?\u003E[])",
          "M:Counter\u003CT\u003E.Add(T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:Counter\u003CT\u003E.Add(T)",
          "M:Histogram\u003CT\u003E.Record(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Histogram\u003CT\u003E.Record(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Histogram\u003CT\u003E.Record(T,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Histogram\u003CT\u003E.Record(T,params KeyValuePair\u003Cstring, object?\u003E[])",
          "M:Histogram\u003CT\u003E.Record(T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:Histogram\u003CT\u003E.Record(T)",
          "M:Instrument.Instrument(Meter,string,string?,string?)",
          "M:Instrument.Publish()",
          "M:Instrument\u003CT\u003E.Instrument(Meter,string,string?,string?)",
          "M:Instrument\u003CT\u003E.RecordMeasurement(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Instrument\u003CT\u003E.RecordMeasurement(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Instrument\u003CT\u003E.RecordMeasurement(T,KeyValuePair\u003Cstring, object?\u003E)",
          "M:Instrument\u003CT\u003E.RecordMeasurement(T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:Instrument\u003CT\u003E.RecordMeasurement(T)",
          "M:Measurement\u003CT\u003E.Measurement(T,IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:Measurement\u003CT\u003E.Measurement(T,params KeyValuePair\u003Cstring, object?\u003E[])",
          "M:Measurement\u003CT\u003E.Measurement(T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:Measurement\u003CT\u003E.Measurement(T)",
          "M:Meter.CreateCounter\u003CT\u003E(string,string?,string?)",
          "M:Meter.CreateHistogram\u003CT\u003E(string,string?,string?)",
          "M:Meter.CreateObservableCounter\u003CT\u003E(string,Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableCounter\u003CT\u003E(string,Func\u003CMeasurement\u003CT\u003E\u003E,string?,string?,)",
          "M:Meter.CreateObservableCounter\u003CT\u003E(string,Func\u003CT\u003E,string?,string?)",
          "M:Meter.CreateObservableGauge\u003CT\u003E(string,Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableGauge\u003CT\u003E(string,Func\u003CMeasurement\u003CT\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableGauge\u003CT\u003E(string,Func\u003CT\u003E,string?,string?,)",
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CMeasurement\u003CT\u003E\u003E,string?,string?,)",
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CT\u003E,string?,string?,)",
          "M:Meter.Dispose()",
          "M:Meter.Meter(string,string?)",
          "M:Meter.Meter(string)",
          "M:MeterListener.DisableMeasurementEvents(Instrument)",
          "M:MeterListener.Dispose()",
          "M:MeterListener.EnableMeasurementEvents(Instrument,object?)",
          "M:MeterListener.MeterListener()",
          "M:MeterListener.RecordObservableInstruments()",
          "M:MeterListener.SetMeasurementEventCallback\u003CT\u003E(MeasurementCallback\u003CT\u003E?)",
          "M:MeterListener.Start()",
          "M:ObservableCounter\u003CT\u003E.Observe()",
          "M:ObservableGauge\u003CT\u003E.Observe()",
          "M:ObservableInstrument\u003CT\u003E.ObservableInstrument(Meter,string,string?,string?)",
          "M:ObservableInstrument\u003CT\u003E.Observe()",
          "M:ObservableUpDownCounter\u003CT\u003E.Observe()",
          "P:Instrument.Description",
          "P:Instrument.Enabled",
          "P:Instrument.IsObservable",
          "P:Instrument.Meter",
          "P:Instrument.Name",
          "P:Instrument.Unit",
          "P:Measurement\u003CT\u003E.Tags",
          "P:Measurement\u003CT\u003E.Value",
          "P:Meter.Name",
          "P:Meter.Version",
          "P:MeterListener.InstrumentPublished",
          "P:MeterListener.MeasurementsCompleted",
          "P:ObservableInstrument\u003CT\u003E.IsObservable",
          "T:Counter\u003CT\u003E",
          "T:Histogram\u003CT\u003E",
          "T:Instrument",
          "T:Instrument\u003CT\u003E",
          "T:Measurement\u003CT\u003E",
          "T:MeasurementCallback\u003CT\u003E(Instrument,T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E,object?)",
          "T:Meter",
          "T:MeterListener",
          "T:ObservableCounter\u003CT\u003E",
          "T:ObservableGauge\u003CT\u003E",
          "T:ObservableInstrument\u003CT\u003E",
          "T:ObservableUpDownCounter\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "rMcp-58NXZ0",
      "StartDateTime": "2021-05-13T10:11:20-07:00",
      "EndDateTime": "2021-05-13T12:45:11-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/rMcp-58NXZ0/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49905,
          "Title": "System.Runtime.CompilerServices.RuntimeFeature.VirtualStaticsInInterfaces",
          "Author": "jcouv",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-19T20:56:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49905",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49905#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52276,
          "Title": "LoggerMessageAttribute should have a constructor that takes EventId, LogLevel, and Message",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-04T23:07:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52276",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-13T00:00:00-07:00",
        "FeedbackId": "840716389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52276#issuecomment-840716389",
        "FeedbackMarkdown": "We think that only one simplified constructor is necessary.  The generator needs to account for the fact that the EventId/LogLevel/String can now be specified both as the ctor and as the property set -- in the same attribute instance.  (\u0060[LoggerMessage(1, ..., ..., EventId = 2)]\u0060 is actually event ID 2)\r\n\r\n\u0060\u0060\u0060C#\r\npartial class LoggerMessageAttribute\r\n{\r\n    public LoggerMessageAttribute(int eventId, LogLevel level, string message) { }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 190000000,
        "Apis": [
          "M:LoggerMessageAttribute.LoggerMessageAttribute(int,LogLevel,string)",
          "T:LoggerMessageAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52152,
          "Title": "Add IServiceScopeFactory.CreateAsyncScope",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-01T08:23:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52152",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-DependencyInjection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-13T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52152#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 15160000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24847,
          "Title": "Async File IO APIs mimicking Win32 OVERLAPPED",
          "Author": "alexbudmsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-30T22:29:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24847",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-13T00:00:00-07:00",
        "FeedbackId": "840789333",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24847#issuecomment-840789333",
        "FeedbackMarkdown": "* WriteAtOffset should be void-returning, and throw if it can\u0027t complete, like Stream.Write\r\n* Length shouldn\u0027t be a property since it has no meaning on pipes (and throws)\r\n* Scatter/Gather should use IReadOnlyList as the outer generic\r\n* We moved the IO operations to a new System.IO.RandomAccess static\r\n* We moved the SafeHandle.Open to File.OpenHandle\r\n* We had a discussion about extension methods, decided no for now.\r\n* We had a discussion about signed vs unsigned and decided signed returns with overloaded inputs.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class RandomAccess\r\n    {\r\n        public static long GetLength(SafeFileHandle handle) =\u003E throw null;\r\n\r\n        public static int ReadAtOffset(SafeFileHandle handle, Span\u003Cbyte\u003E buffer, long fileOffset);\r\n        public static int ReadAtOffset(SafeFileHandle handle, Span\u003Cbyte\u003E buffer, ulong fileOffset);\r\n        public static void WriteAtOffset(SafeFileHandle handle, ReadOnlySpan\u003Cbyte\u003E buffer, long fileOffset);\r\n        public static void WriteAtOffset(SafeFileHandle handle, ReadOnlySpan\u003Cbyte\u003E buffer, ulong fileOffset);\r\n\r\n        public static long ReadScatterAtOffset(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, long fileOffset);\r\n        public static long ReadScatterAtOffset(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset);\r\n        public static void WriteGatherAtOffset(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, long fileOffset);\r\n        public static void WriteGatherAtOffset(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset);\r\n    \r\n        public static ValueTask\u003Cint\u003E ReadAtOffsetAsync(SafeFileHandle handle, Memory\u003Cbyte\u003E buffer, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E ReadAtOffsetAsync(SafeFileHandle handle, Memory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAtOffsetAsync(SafeFileHandle handle, ReadOnlyMemory\u003Cbyte\u003E buffer, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAtOffsetAsync(SafeFileHandle handle, ReadOnlyMemory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n\r\n        public static ValueTask\u003Clong\u003E ReadScatterAtOffsetAsync(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Clong\u003E ReadScatterAtOffsetAsync(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteGatherAtOffsetAsync(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteGatherAtOffsetAsync(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset, CancellationToken cancellationToken = default);\r\n    }\r\n\r\n    partial class File\r\n    {\r\n        public static SafeFileHandle OpenHandle(string filePath, FileMode mode = FileMode.Open, FileAccess access = FileAccess.Read, FileShare share = FileShare.Read, FileOptions options = FileOptions.None, long preAllocationSize = 0)\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Win32.SafeHandles\r\n{\r\n    partial class SafeFileHandle\r\n    {\r\n        public bool IsAsync { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24750000000,
        "Apis": [
          "M:File.OpenHandle(string,FileMode,FileAccess,FileShare,FileOptions,long)",
          "M:RandomAccess.GetLength(SafeFileHandle)",
          "M:RandomAccess.ReadAtOffset(SafeFileHandle,Span\u003Cbyte\u003E,long)",
          "M:RandomAccess.ReadAtOffset(SafeFileHandle,Span\u003Cbyte\u003E,ulong)",
          "M:RandomAccess.ReadAtOffsetAsync(SafeFileHandle,Memory\u003Cbyte\u003E,long,CancellationToken)",
          "M:RandomAccess.ReadAtOffsetAsync(SafeFileHandle,Memory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:RandomAccess.ReadScatterAtOffset(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,long)",
          "M:RandomAccess.ReadScatterAtOffset(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,ulong)",
          "M:RandomAccess.ReadScatterAtOffsetAsync(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,long,CancellationToken)",
          "M:RandomAccess.ReadScatterAtOffsetAsync(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,ulong,CancellationToken)",
          "M:RandomAccess.WriteAtOffset(SafeFileHandle,ReadOnlySpan\u003Cbyte\u003E,long)",
          "M:RandomAccess.WriteAtOffset(SafeFileHandle,ReadOnlySpan\u003Cbyte\u003E,ulong)",
          "M:RandomAccess.WriteAtOffsetAsync(SafeFileHandle,ReadOnlyMemory\u003Cbyte\u003E,long,CancellationToken)",
          "M:RandomAccess.WriteAtOffsetAsync(SafeFileHandle,ReadOnlyMemory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:RandomAccess.WriteGatherAtOffset(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,long)",
          "M:RandomAccess.WriteGatherAtOffset(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,ulong)",
          "M:RandomAccess.WriteGatherAtOffsetAsync(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,long,CancellationToken)",
          "M:RandomAccess.WriteGatherAtOffsetAsync(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,ulong,CancellationToken)",
          "P:SafeFileHandle.IsAsync",
          "T:File",
          "T:RandomAccess",
          "T:SafeFileHandle"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52446,
          "Title": "Add new option bag for FileStream ctor",
          "Author": "adamsitnik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-07T14:51:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52446",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-14T00:00:00-07:00",
        "FeedbackId": "841408090",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52446#issuecomment-841408090",
        "FeedbackMarkdown": "* There is no notion of required properties for structs/classes\r\n    - We should extract path and keep it as a constructor parameter\r\n    - IOW, we the options type should focus on optional parameters\r\n* Does this need to be a struct? Structs always have usability issues and this API seems like the one where the constructor does so much work that the allocation of the options type doesn\u0027t seem to matter.\r\n    - Is there value in \u0060init\u0060 or is \u0060get\u0060/\u0060set\u0060 good enough? The benefit is wider language support and presumably \u0060FileStream\u0060 will copy the values anyways because there are already fields and/or the options are directly translated into the native code without holding onto them.\r\n* We should have a separate issue about the ability to pass in the buffer as that opens up the possibility of use-after-free issues and also makes it more error prone to share options across multiple \u0060FileStream\u0060 instances\r\n* \u0060PreAllocation\u0060\r\n    - Should this be \u0060Preallocation\u0060 or \u0060PreAllocation\u0060? @bartonjs to decide.\r\n* The options don\u0027t cover the constructor that takes a handle. Should it?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public sealed class FileStreamOptions\r\n    {\r\n        public FileStreamOptions();\r\n        public FileMode Mode { get; set; }\r\n        public FileAccess Access { get; set; }\r\n        public FileShare Share { get; set; }\r\n        public FileOptions Options { get; set; }\r\n        public long PreAllocationSize { get; set; }\r\n    }\r\n    public partial class FileStream : Stream\r\n    {\r\n        // Existing:\r\n        // public FileStream(string path, FileMode mode)\r\n        // public FileStream(string path, FileMode mode, FileAccess access)\r\n        // public FileStream(string path, FileMode mode, FileAccess access, FileShare share)\r\n        // public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize)\r\n        // public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync)\r\n        // public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options)\r\n        public FileStream(string path, FileStreamOptions options);\r\n\r\n        // Hiding obsoleting APIs\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public FileStream(IntPtr handle, FileAccess access);\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 780000000,
        "Apis": [
          "M:FileStream.FileStream(IntPtr,FileAccess,bool,int,bool)",
          "M:FileStream.FileStream(IntPtr,FileAccess,bool,int)",
          "M:FileStream.FileStream(IntPtr,FileAccess,bool)",
          "M:FileStream.FileStream(IntPtr,FileAccess)",
          "M:FileStream.FileStream(string,FileStreamOptions)",
          "M:FileStreamOptions.FileStreamOptions()",
          "P:FileStreamOptions.Access",
          "P:FileStreamOptions.Mode",
          "P:FileStreamOptions.Options",
          "P:FileStreamOptions.PreAllocationSize",
          "P:FileStreamOptions.Share",
          "T:FileStream",
          "T:FileStreamOptions"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51945,
          "Title": "Provide fast-path serialization logic in JSON source generator",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-27T17:46:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51945",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-14T00:00:00-07:00",
        "FeedbackId": "841456779",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51945#issuecomment-841456779",
        "FeedbackMarkdown": "* Instead of generating a single \u0060JsonContext\u0060 type per assembly, we should let the user define the \u0060JsonContext\u0060 type (controlling namespace, type name, etc.) and apply the assembly level attributes to this type and have the generator fill in the body of the body. This allows the user to have multiple different JSON options for different types in a single assembly, e.g.\r\n    - \u0060Fabrikam.Telemetry.TelemetryJsonContext\u0060\r\n    - \u0060Fabrikam.Shopping.ShoppingJsonContext\u0060\r\n* We should rename \u0060JsonSerializerOptionsAttribute\u0060 the name implies that it\u0027s related to \u0060JsonSerializerOptions\u0060 but this describes the runtime serialization options while this attributes the static, source generator-based options that are similar, but generally disjoint because of the nature of needing to be statically describable (e.g. no converters, no polymorphic naming conventions etc).\r\n* In fact, we should consider taking all the attributes and base types that are relevant to source-generated JSON serializer into a dedicated namespace (e.g. \u0060System.Text.Json.Serialization.Generator\u0060 or \u0060System.Text.Json.Serialization.Metadata\u0060).\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public abstract partial class JsonTypeInfo\u003CT\u003E\r\n    {\r\n        // Existing:\r\n        // internal JsonTypeInfo() { }\r\n        public Action\u003CUtf8JsonWriter, T\u003E? Serialize { get; set; }\r\n    }\r\n    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]\r\n    public class JsonSerializerOptionsAttribute : JsonAttribute\r\n    {\r\n        public JsonIgnoreCondition DefaultIgnoreCondition { get; set; }\r\n        public bool IgnoreReadOnlyFields { get; set; }\r\n        public bool IgnoreReadOnlyProperties { get; set; }\r\n        public bool IgnoreRuntimeCustomConverters { get; set; }\r\n        public bool IncludeFields { get; set; }\r\n        public JsonKnownNamingPolicy NamingPolicy { get; set; }\r\n        public bool WriteIndented { get; set; }\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    // Existing: [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]\r\n    [AttributeUsage(AttributeTargets.Assembly |\r\n                    AttributeTargets.Class |\r\n                    AttributeTargets.Struct |\r\n                    AttributeTargets.Interface, AllowMultiple = true)]\r\n    public partial class JsonSerializableAttribute : Attribute\r\n    {\r\n        public JsonSourceGenerationMode GenerationMode { get; set; }\r\n    }\r\n    public enum JsonKnownNamingPolicy\r\n    {\r\n        Unspecified = 0,\r\n        BuiltInCamelCase = 1\r\n    }\r\n    public enum JsonSourceGenerationMode\r\n    {\r\n        MetadataAndSerialization = 0,\r\n        Metadata = 1,\r\n        Serialization = 2\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 34340000000,
        "Apis": [
          "F:JsonKnownNamingPolicy.BuiltInCamelCase",
          "F:JsonKnownNamingPolicy.Unspecified",
          "F:JsonSourceGenerationMode.Metadata",
          "F:JsonSourceGenerationMode.MetadataAndSerialization",
          "F:JsonSourceGenerationMode.Serialization",
          "P:JsonSerializableAttribute.GenerationMode",
          "P:JsonSerializerOptionsAttribute.DefaultIgnoreCondition",
          "P:JsonSerializerOptionsAttribute.IgnoreReadOnlyFields",
          "P:JsonSerializerOptionsAttribute.IgnoreReadOnlyProperties",
          "P:JsonSerializerOptionsAttribute.IgnoreRuntimeCustomConverters",
          "P:JsonSerializerOptionsAttribute.IncludeFields",
          "P:JsonSerializerOptionsAttribute.NamingPolicy",
          "P:JsonSerializerOptionsAttribute.WriteIndented",
          "P:JsonTypeInfo\u003CT\u003E.Serialize",
          "T:JsonKnownNamingPolicy",
          "T:JsonSerializableAttribute",
          "T:JsonSerializerOptionsAttribute",
          "T:JsonSourceGenerationMode",
          "T:JsonTypeInfo\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "by1CiPjnA08",
      "StartDateTime": "2021-05-18T10:06:19-07:00",
      "EndDateTime": "2021-05-18T12:22:05-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/by1CiPjnA08/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 15088,
          "Title": "Avoid unnecessary allocations when using FileStream",
          "Author": "ayende",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2015-08-25T09:35:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/15088",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843381781",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/15088#issuecomment-843381781",
        "FeedbackMarkdown": "@tannergooding mentioned that there may be a more generalized allocator/management feature in the works, so rather than accepting a buffer now as well as an allocator \u0022soon\u0022, we feel that the right answer for now is just to take the buffer size, not a user provided buffer.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    partial class FileStreamOptions\r\n    {\r\n       public int BufferSize { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:FileStreamOptions.BufferSize",
          "T:FileStreamOptions"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52775,
          "Title": "Consider making TryGetEnumeratedCount an interface method with default implementation",
          "Author": "agocke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-14T17:33:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52775",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843404922",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52775#issuecomment-843404922",
        "FeedbackMarkdown": "We currently have apprehension about adding DIMs at this level.  For this particular method we\u0027re concerned that the obvious solution would be to re-implement the methods in \u0060ICollection\u003CT\u003E\u0060 and \u0060IReadOnlyCollection\u003CT\u003E\u0060, which now provides multiple non-unified implementations to concrete types; so that would manifest as a runtime breaking change for any type that already implements those two interfaces.\r\n\r\nBut we agree that we could use some better concrete guidelines here going forward.",
        "TimeCode": 13220000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52773,
          "Title": "Support safe trimmability for System.Text.Json.Nodes.JsonValue",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-14T16:43:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52773",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843424777",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52773#issuecomment-843424777",
        "FeedbackMarkdown": "We didn\u0027t feel it was worth renaming the linker-unfriendly version.  So now it\u0027s just adding the specialized versions.\r\n\r\nWe discussed the operators, and had some mixed feelings.  Since they\u0027re not quite related to the rest of the changes we removed them from here (they can be brought up later as a separate issue).\r\n\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Text.Json.Nodes\r\n{\r\n  public partial class JsonValue\r\n  {\r\n\u002B  public static JsonValue? Create\u003CT\u003E(T? value, JsonTypeInfo\u003CT\u003E jsonTypeInfo, JsonNodeOptions? options = null)\r\n\r\n-  public static JsonValue? Create\u003CT\u003E(T? value, JsonNodeOptions? options = null)\r\n\u002B  public static JsonValue? Create\u003C[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.PublicFields | DynamicallyAccessedMemberTypes.PublicProperties)]T\u003E(T? value, JsonNodeOptions? options = null)\r\n\r\n\u002B  public static JsonValue Create(bool value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(byte value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(char value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(System.DateTime value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(System.DateTimeOffset value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(decimal value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(double value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(System.Guid value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(short value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(int value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(long value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(bool? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(byte? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(char? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(System.DateTimeOffset? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(System.DateTime? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(decimal? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(double? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(System.Guid? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(short? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(int? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(long? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue? Create(sbyte? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(float? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(System.Text.Json.JsonElement? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue? Create(ushort? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue? Create(uint? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue? Create(ulong? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue Create(sbyte value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue Create(float value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(string? value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  public static JsonValue? Create(System.Text.Json.JsonElement value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue Create(ushort value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue Create(uint value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n\u002B  [System.CLSCompliantAttribute(false)]\r\n\u002B  public static JsonValue Create(ulong value, JsonNodeOptions? options = default(JsonNodeOptions?));\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIt also looks like \u0060JsonArray.Add\u003CT\u003E\u0060 needs the dynamically accessed member attributes.  Adding the appropriate attributes is also approved with this issue.",
        "TimeCode": 30690000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1574,
          "Title": "Synchronous deserialize and serialize to a stream with JsonSerializer.",
          "Author": "niemyjski",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-09-24T13:08:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1574",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843447885",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1574#issuecomment-843447885",
        "FeedbackMarkdown": "Adding synchronous method parity sounds good.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    partial class JsonSerializer\r\n    {\r\n        // Proposal to add following synchronous APIs:\r\n        public static object Deserialize(Stream utf8Json, \r\n            Type returnType, \r\n            JsonSerializerOptions options = null);\r\n        \r\n        public static TValue Deserialize\u003CTValue\u003E(Stream utf8Json,\r\n            JsonSerializerOptions options = null);\r\n    \r\n        public static void Serialize(Stream utf8Json, \r\n            object value, \r\n            Type inputType, \r\n            JsonSerializerOptions options = null);\r\n        \r\n        public static void Serialize\u003CTValue\u003E(Stream utf8Json, \r\n            TValue value, \r\n            JsonSerializerOptions options = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAlso add the overloads for the new \u0060JsonTypeInfo\u003CT\u003E\u0060 versions from the source generator.",
        "TimeCode": 60410000000,
        "Apis": [
          "M:JsonSerializer.Deserialize(Stream,Type,JsonSerializerOptions)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(Stream,JsonSerializerOptions)",
          "M:JsonSerializer.Serialize(Stream,object,Type,JsonSerializerOptions)",
          "M:JsonSerializer.Serialize\u003CTValue\u003E(Stream,TValue,JsonSerializerOptions)",
          "T:JsonSerializer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40622,
          "Title": "Obsolete SuppressIldasmAttribute",
          "Author": "teo-tsirpanis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-10T18:54:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40622",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843449308",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40622#issuecomment-843449308",
        "FeedbackMarkdown": "Approved as proposed, but use the next available diagnostic ID.\r\n\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n\u002B   [Obsolete(\u0022SuppressIldasmAttribute has no effect in .NET 6.0\u002B applications.\u0022)]\r\n    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module)]\r\n    public sealed class SuppressIldasmAttribute : Attribute\r\n    {\r\n        public SuppressIldasmAttribute() { }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 63270000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33244,
          "Title": "Provide Marshal.Alloc api that accepts alignment argument",
          "Author": "tmds",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-05T16:40:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33244",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843465390",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33244#issuecomment-843465390",
        "FeedbackMarkdown": "* There was an argument that Alloc methods on Marshal should return IntPtr.  So we made a new type to allow it to use \u0060void*\u0060 and \u0060nuint\u0060.\r\n* We got rid of all of the \u0022Memory\u0022 words, since that\u0027s part of the type name.\r\n* We aligned with C runtime names (Alloc =\u003E Malloc, AllocAligned =\u003E AlignedAlloc)\r\n* We added Calloc, because why not?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public static class NativeMemory\r\n    {\r\n        public static unsafe void* Calloc(nuint elementCount, nuint elementSize);\r\n        public static unsafe void* Malloc(nuint byteCount);\r\n        public static unsafe void* Realloc(void* ptr, nuint byteCount);\r\n        public static unsafe void Free(void* ptr);\r\n\r\n        public static unsafe void* AlignedAlloc(nuint alignment, nuint byteCount);\r\n\r\n        // This may not be needed, if all of our runtimes guarantee that AlignedAlloc can be passed straight to Free.\r\n        public static unsafe void AlignedFree(void* ptr);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64530000000,
        "Apis": [
          "M:NativeMemory.AlignedAlloc(nuint,nuint)",
          "M:NativeMemory.AlignedFree(void*)",
          "M:NativeMemory.Calloc(nuint,nuint)",
          "M:NativeMemory.Free(void*)",
          "M:NativeMemory.Malloc(nuint)",
          "M:NativeMemory.Realloc(void*,nuint)",
          "T:NativeMemory"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17036,
          "Title": "Add StringContent ctor providing tighter control over charset",
          "Author": "guardrex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-19T16:57:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17036",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-18T00:00:00-07:00",
        "FeedbackId": "843487131",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17036#issuecomment-843487131",
        "FeedbackMarkdown": "Triage: We would like to know details about the user scenarios to make sure we understand which APIs we should add and why.\r\nIt was not clear if the current APIs are unusable, or if there is performance concern.\r\n\r\n@DaveSenn the above will block PR for now, sorry ... let\u0027s first clarify what we want to add properly. Thanks for understanding.",
        "TimeCode": 79100000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "IHRPmHuDQvU",
      "StartDateTime": "2021-05-19T10:04:39-07:00",
      "EndDateTime": "2021-05-19T12:15:54-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/IHRPmHuDQvU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52909,
          "Title": " Add public Architecture enum value for s390x",
          "Author": "uweigand",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-18T13:53:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52909",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-19T00:00:00-07:00",
        "FeedbackId": "844306365",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52909#issuecomment-844306365",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum Architecture\r\n    {\r\n        X86,\r\n        X64,\r\n        Arm,\r\n        Arm64,\r\n        Wasm,\r\n\u002B       S390x,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40012,
          "Title": "HMAC one-shot methods",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-28T14:40:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40012",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-19T00:00:00-07:00",
        "FeedbackId": "844312500",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40012#issuecomment-844312500",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography {\r\n    public partial class HMACMD5 {\r\n        public static byte[] HashData(byte[] key, byte[] source) =\u003E throw null;\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n        public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n    }\r\n\r\n    public partial class HMACSHA1 {\r\n        public static byte[] HashData(byte[] key, byte[] source) =\u003E throw null;\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n        public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n    }\r\n\r\n    public partial class HMACSHA256 {\r\n        public static byte[] HashData(byte[] key, byte[] source) =\u003E throw null;\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n        public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n    }\r\n\r\n    public partial class HMACSHA384 {\r\n        public static byte[] HashData(byte[] key, byte[] source) =\u003E throw null;\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n        public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n    }\r\n\r\n    public partial class HMACSHA512 {\r\n        public static byte[] HashData(byte[] key, byte[] source) =\u003E throw null;\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source) =\u003E throw null;\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination) =\u003E throw null;\r\n        public static bool TryHashData(ReadOnlySpan\u003Cbyte\u003E key, ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten) =\u003E throw null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7580000000,
        "Apis": [
          "M:HMACMD5.HashData(byte[],byte[])",
          "M:HMACMD5.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:HMACMD5.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HMACMD5.TryHashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:HMACSHA1.HashData(byte[],byte[])",
          "M:HMACSHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:HMACSHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HMACSHA1.TryHashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:HMACSHA256.HashData(byte[],byte[])",
          "M:HMACSHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:HMACSHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HMACSHA256.TryHashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:HMACSHA384.HashData(byte[],byte[])",
          "M:HMACSHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:HMACSHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HMACSHA384.TryHashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:HMACSHA512.HashData(byte[],byte[])",
          "M:HMACSHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:HMACSHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "M:HMACSHA512.TryHashData(ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "T:HMACMD5",
          "T:HMACSHA1",
          "T:HMACSHA256",
          "T:HMACSHA384",
          "T:HMACSHA512"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 147,
          "Title": "SecureString obsoletions and shrouded buffer proposal",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-07-21T19:19:53+00:00",
          "Url": "https://github.com/dotnet/designs/pull/147",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-19T00:00:00-07:00",
        "FeedbackId": "844392771",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/147#issuecomment-844392771",
        "FeedbackMarkdown": "* The System.Security namespace is largely CAS, and may have the same bad connotations as the \u0022Secure\u0022 in \u0022SecureString\u0022\r\n  * The type being \u0022System.Secret\u0022 seems like we\u0027re going to set up for too much conflict.\r\n  * \u0022System.Buffers.Secret\u0022\r\n  * If we wanted System, we need a suffix, like \u0022System.SecretBuffer\u0022, \u0022System.SecretData\u0022\r\n* Currently there\u0027s only one property (Length).  Changing it to a method means this will generally be considered an empty object to serializers.\r\n* We renamed SecretExtensions to Secret and added Secret.Create\u003CT\u003E to improve generic inference.\r\n* \u0022Unshroud\u0022 feels a little weird, but it does have value as being easy to search for.\r\n  * We seem to like \u0022Reveal\u0022, which still provides a search target.  \u0022Expose\u0022 was the runner up.\r\n* We added a \u0022RevealAnd\u0022 prefix to \u0022Use\u0022 so all of the data-exposing methods start with the same word.\r\n* We discussed the SecureString/Secret layering and decided to added the conversion methods on SecureString, even though they\u0027re .NET 6.0 only and the Secret type is .NET Standard 2.0\r\n* Discussing overloads/etc (impact of the new type) is pushed to a later date, because we hit the end of the meeting.\r\n* The ToString() method should just be the same answer as object.ToString() (nothing useful), but we should override it to Obsolete it (to point to RevealToString()).\r\n* A DebuggerDisplay attribute seems good.  \u0022Length={length}, Text={...}\u0022 for char, \u0022Length={length}\u0022 for other.  Or something.\r\n* The issue title talks about obsoleting SecureString.  We\u0027re not applying the attribute at this time, just starting down the road for doing it later.\r\n\r\nnetstandard2.0:\r\n\u0060\u0060\u0060C#\r\nnamespace System.Buffers\r\n{\r\n    public sealed partial class Secret\u003CT\u003E : System.IDisposable where T : unmanaged\r\n    {\r\n        public Secret(System.ReadOnlySpan\u003CT\u003E buffer) { }\r\n        public int GetLength() =\u003E throw null;\r\n        public System.Security.Secret\u003CT\u003E Clone() { throw null; }\r\n        public void Dispose() { }\r\n        public int RevealInto(System.Span\u003CT\u003E destination) { }\r\n        public T[] RevealToArray() { throw null; }\r\n        public void RevealAndUse\u003CTArg\u003E(TArg arg, System.Buffers.ReadOnlySpanAction\u003CT, TArg\u003E spanAction) { }\r\n\r\n        [Obsolete(\u0022Use RevealToString\u0022)]\r\n        [EditorBrowsable(Never)]\r\n        public override string ToString() =\u003E base.ToString();\r\n    }\r\n    public static partial class Secret\r\n    {\r\n        // ArgumentNullException\r\n        public static Secret\u003Cchar\u003E Create(string value) =\u003E throw null;\r\n        // ArgumentNullException\r\n        public static Secret\u003CT\u003E Create\u003CT\u003E(T[] buffer) where T : unmanaged =\u003E throw null;\r\n\r\n        public static Secret\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E buffer) where T : unmanaged =\u003E throw null;\r\n        public static string RevealToString(this System.Security.Secret\u003Cchar\u003E secret) { throw null; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nnet60:\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security\r\n{\r\n     partial class SecureString : System.IDisposable\r\n     {\r\n        public SecureString(System.Security.Secret\u003Cchar\u003E secret) { }\r\n        public System.Security.Secret\u003Cchar\u003E ToSecret() { throw null; }\r\n     }\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 12370000000,
        "Apis": [
          "M:Secret.Create(string)",
          "M:Secret.Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E)",
          "M:Secret.Create\u003CT\u003E(T[])",
          "M:Secret.RevealToString(this System.Security.Secret\u003Cchar\u003E)",
          "M:Secret\u003CT\u003E.Clone()",
          "M:Secret\u003CT\u003E.Dispose()",
          "M:Secret\u003CT\u003E.GetLength()",
          "M:Secret\u003CT\u003E.RevealAndUse\u003CTArg\u003E(TArg,System.Buffers.ReadOnlySpanAction\u003CT, TArg\u003E)",
          "M:Secret\u003CT\u003E.RevealInto(System.Span\u003CT\u003E)",
          "M:Secret\u003CT\u003E.RevealToArray()",
          "M:Secret\u003CT\u003E.Secret(System.ReadOnlySpan\u003CT\u003E)",
          "M:Secret\u003CT\u003E.ToString()",
          "M:SecureString.SecureString(System.Security.Secret\u003Cchar\u003E)",
          "M:SecureString.ToSecret()",
          "T:Secret",
          "T:Secret\u003CT\u003E",
          "T:SecureString"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "8bnQoGUMXgM",
      "StartDateTime": "2021-05-21T10:04:03-07:00",
      "EndDateTime": "2021-05-21T12:10:25-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8bnQoGUMXgM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 41529,
          "Title": "All inherited interface members should be implemented on an interface marked with DynamicInterfaceCastableImplementationAttribute",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-28T19:06:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/41529",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846114993",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/41529#issuecomment-846114993",
        "FeedbackMarkdown": "The analyzer looks good as proposed.\r\n\r\nRegarding Error vs Warning: @terrajobst can you chime in with what the heuristics are?  If there\u0027s a mode where we can be an on-by-default Error we think that might be the right answer.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51544,
          "Title": "Provide JsonContent\u003CT\u003E type that uses pre-generated serialization metadata",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-20T02:59:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51544",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846126667",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51544#issuecomment-846126667",
        "FeedbackMarkdown": "* Because the JsonContent type is currently sealed with a non-public constructor there\u0027s more flexibility and we can add the \u0060JsonContent\u003CT\u003E : JsonContent\u0060 relationship.\r\n* The JsonContent.Create that takes a TValue parameter should be declared generic (typo).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http.Json\r\n{\r\n    public sealed partial class JsonContent\u003CTValue\u003E : JsonContent\r\n    {\r\n        internal JsonContent() { }\r\n        public TValue? Value { get { throw null; } }\r\n    }\r\n    partial class JsonContent\r\n    {\r\n        public static JsonContent\u003Cobject?\u003E Create(object? inputValue, Type inputType, JsonSerializerContext context, MediaTypeHeaderValue? mediaType = null) { throw null; }\r\n        public static JsonContent\u003CTValue\u003E Create\u003CTValue\u003E(TValue? inputValue, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo, MediaTypeHeaderValue? mediaType = null) { throw null; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Net.Http.Json\r\n{\r\n-    public sealed partial class JsonContent\r\n\u002B    public abstract partial class JsonContent\r\n     {\r\n        internal JsonContent();\r\n     }\r\n\u002B   internal sealed partial class ReflectionBasedJsonContent  : JsonContent { ... }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8290000000,
        "Apis": [
          "M:JsonContent.Create(object?,Type,JsonSerializerContext,MediaTypeHeaderValue?)",
          "M:JsonContent.Create\u003CTValue\u003E(TValue?,JsonTypeInfo\u003CTValue\u003E,MediaTypeHeaderValue?)",
          "M:JsonContent\u003CTValue\u003E.JsonContent()",
          "P:JsonContent\u003CTValue\u003E.Value",
          "T:JsonContent",
          "T:JsonContent\u003CTValue\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40315,
          "Title": "string.NormalizeLineEndings",
          "Author": "Symbai",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-04T15:11:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40315",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846147770",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40315#issuecomment-846147770",
        "FeedbackMarkdown": "* Instead of default parameter, make a parameterless overload and make the parameter non-nullable\r\n* The word \u0022Normalize\u0022 is overloaded in this space, suggest ReplaceLineEndings instead of NormalizeLineEndings\r\n* Suggest \u0060replacementText\u0060 instead of \u0060lineEnding\u0060 in the ReplaceLineEndings method.\r\n* If a char overload seems reasonable, go ahead and add it, too.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    partial class String\r\n    {\r\n        public string ReplaceLineEndings() =\u003E ReplaceLineEndings(Environment.NewLine);\r\n        public string ReplaceLineEndings(string replacementText);\r\n    }\r\n    partial class MemoryExtensions\r\n    {\r\n        public System.Text.SpanLineEnumerator EnumerateLines(this ReadOnlySpan\u003Cchar\u003E span);\r\n        public System.Text.SpanLineEnumerator EnumerateLines(this Span\u003Cchar\u003E span);\r\n    }\r\n}\r\nnamespace System.Text\r\n{\r\n    public ref struct SpanLineEnumerator\r\n    {\r\n        public ReadOnlySpan\u003Cchar\u003E Current;\r\n        public SpanLineEnumerator GetEnumerator();\r\n        public bool MoveNext();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20790000000,
        "Apis": [
          "F:SpanLineEnumerator.Current",
          "M:MemoryExtensions.EnumerateLines(this ReadOnlySpan\u003Cchar\u003E)",
          "M:MemoryExtensions.EnumerateLines(this Span\u003Cchar\u003E)",
          "M:SpanLineEnumerator.GetEnumerator()",
          "M:SpanLineEnumerator.MoveNext()",
          "M:String.ReplaceLineEndings()",
          "M:String.ReplaceLineEndings(string)",
          "T:MemoryExtensions",
          "T:SpanLineEnumerator",
          "T:String"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42549,
          "Title": "Add ThreadPoolBoundHandle.AllocateUnsafeNativeOverlapped",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-21T18:53:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42549",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846152662",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42549#issuecomment-846152662",
        "FeedbackMarkdown": "* For pattern-matching, the \u0060Unsafe\u0060 should be a prefix instead of an infix.\r\n* PreAllocatedOverlapped.UnsafeCreate makes sense to add at the same time.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    partial class ThreadPoolBoundHandle\r\n    {\r\n       [CLSCompliant(false)]\r\n       public unsafe NativeOverlapped* UnsafeAllocateNativeOverlapped(IOCompletionCallback callback, object? state, object? pinData);\r\n    }\r\n}\r\nnamespace System.Threading\r\n{\r\n    partial class PreAllocatedOverlapped : IDisposable\r\n    {\r\n        [CLSCompliant(false)]\r\n        public static PreAllocatedOverlapped UnsafeCreate(IOCompletionCallback callback, object? state, object? pinData);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 44180000000,
        "Apis": [
          "M:PreAllocatedOverlapped.UnsafeCreate(IOCompletionCallback,object?,object?)",
          "M:ThreadPoolBoundHandle.UnsafeAllocateNativeOverlapped(IOCompletionCallback,object?,object?)",
          "T:PreAllocatedOverlapped",
          "T:ThreadPoolBoundHandle"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45771,
          "Title": "Add API to find MethodInfo on instantiated generic type from generic type definition",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-08T17:37:50+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45771",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846169871",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45771#issuecomment-846169871",
        "FeedbackMarkdown": "* We feel that the name \u0022GetMemberWithSameMetadataDefinitionAs\u0022 does a very good job of explaining that it\u0027s the same as HasSameMetadataDefinitionAs, but from a different perspective.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    partial class Type\r\n    {\r\n        public virtual MemberInfo? GetMemberWithSameMetadataDefinitionAs(MemberInfo member);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50700000000,
        "Apis": [
          "M:Type.GetMemberWithSameMetadataDefinitionAs(MemberInfo)",
          "T:Type"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48510,
          "Title": "Add public key methods for S.S.C.X509Certificates.PublicKey",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-19T15:32:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48510",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846171514",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48510#issuecomment-846171514",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public class PublicKey\r\n    {\r\n\u002B       public RSA? GetRSAPublicKey();\r\n\u002B       public ECDsa? GetECDsaPublicKey();\r\n\u002B       public DSA? GetDSAPublicKey();\r\n\u002B       public ECDiffieHellman? GetECDiffieHellmanPublicKey();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 64050000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 49397,
          "Title": "Expose cross-platform helpers for Vector64, Vector128, and Vector256",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-09T23:40:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/49397",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-21T00:00:00-07:00",
        "FeedbackId": "846184811",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/49397#issuecomment-846184811",
        "FeedbackMarkdown": "* Looks good as proposed, modulo typos.\r\n* There are some names that are changed (SquareRoot =\u003E Sqrt) and some members moved from instance to extension, but both of these changes make sense with recent API in similar scopes.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public static partial class Vector64\r\n    {\r\n        public bool IsHardwareAccelerated { get; }\r\n\r\n        public static Vector64\u003CT\u003E Abs(Vector64\u003CT\u003E value);\r\n        public static Vector64\u003CT\u003E Negate(Vector64\u003CT\u003E value);\r\n        public static Vector64\u003CT\u003E OnesComplement(Vector64\u003CT\u003E value);\r\n        public static Vector64\u003CT\u003E Sqrt(Vector64\u003CT\u003E value); // SquareRoot\r\n\r\n        public static Vector64\u003CT\u003E Add(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E Subtract(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E Multiply(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E Divide(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E Dot(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E AndNot(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E BitwiseAnd(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E BitwiseOr(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E Xor(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003Cdouble\u003E Ceiling(Vector64\u003Cdouble\u003E value);\r\n        public static Vector64\u003Cfloat\u003E Ceiling(Vector64\u003Cfloat\u003E value);\r\n\r\n        public static Vector64\u003Cdouble\u003E Floor(Vector64\u003Cdouble\u003E value);\r\n        public static Vector64\u003Cfloat\u003E Floor(Vector64\u003Cfloat\u003E value);\r\n\r\n        public static Vector64\u003CT\u003E ConditionalSelect(Vector64\u003CT\u003E condition, Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003Cdouble\u003E ConvertToDouble(Vector64\u003Clong\u003E value);\r\n        public static Vector64\u003Cdouble\u003E ConvertToDouble(Vector64\u003Culong\u003E value);\r\n\r\n        public static Vector64\u003Cint\u003E ConvertToInt32(Vector64\u003Cfloat\u003E value);\r\n        public static Vector64\u003Clong\u003E ConvertToInt64(Vector64\u003Cdouble\u003E value);\r\n\r\n        public static Vector64\u003Cfloat\u003E ConvertToSingle(Vector64\u003Cint\u003E value);\r\n        public static Vector64\u003Cfloat\u003E ConvertToSingle(Vector64\u003Cuint\u003E value);\r\n\r\n        public static Vector64\u003Cuint\u003E ConvertToUInt32(Vector64\u003Cfloat\u003E value);\r\n        public static Vector64\u003Culong\u003E ConvertToUInt64(Vector64\u003Cdouble\u003E value);\r\n\r\n        public static Vector64\u003CT\u003E Equals(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static bool EqualsAll(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool EqualsAny(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E GreaterThan(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanAll(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool GreaterThanAny(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E GreaterThanOrEqual(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanOrEqualAll(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool GreaterThanOrEqualAny(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E LessThan(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static bool LessThanAll(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool LessThanAny(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E LessThanOrEqual(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static bool LessThanOrEqualAll(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool LessThanOrEqualAny(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E Max(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E Min(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003Cfloat\u003E Narrow(Vector64\u003Cdouble\u003E lower, Vector64\u003CT\u003E upper);\r\n        public static Vector64\u003Csbyte\u003E Narrow(Vector64\u003Cshort\u003E lower, Vector64\u003Cshort\u003E upper);\r\n        public static Vector64\u003Cshort\u003E Narrow(Vector64\u003Cint\u003E lower, Vector64\u003Cint\u003E upper);\r\n        public static Vector64\u003Cint\u003E Narrow(Vector64\u003Clong\u003E lower, Vector64\u003Clong\u003E upper);\r\n        public static Vector64\u003Cbyte\u003E Narrow(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper);\r\n        public static Vector64\u003Cushort\u003E Narrow(Vector64\u003Cuint\u003E lower, Vector64\u003Cuint\u003E upper);\r\n        public static Vector64\u003Cuint\u003E Narrow(Vector64\u003Culong\u003E lower, Vector64\u003Culong\u003E upper);\r\n\r\n        public static (Vector64\u003Cshort\u003E Lower, Vector64\u003Cshort\u003E Upper) Widen(Vector64\u003Csbyte\u003E value);\r\n        public static (Vector64\u003Cint\u003E Lower, Vector64\u003Cint\u003E Upper) Widen(Vector64\u003Cshort\u003E value);\r\n        public static (Vector64\u003Clong\u003E Lower, Vector64\u003Clong\u003E Upper) Widen(Vector64\u003Cint\u003E value);\r\n        public static (Vector64\u003Cdouble\u003E Lower, Vector64\u003Cdouble\u003E Upper) Widen(Vector64\u003Cflaot\u003E value);\r\n        public static (Vector64\u003Cushort\u003E Lower, Vector64\u003Cushort\u003E Upper) Widen(Vector64\u003Cbyte\u003E value);\r\n        public static (Vector64\u003Cuint\u003E Lower, Vector64\u003Cuint\u003E Upper) Widen(Vector64\u003Cushort\u003E value);\r\n        public static (Vector64\u003Culong\u003E Lower, Vector64\u003Culong\u003E Upper) Widen(Vector64\u003Cuint\u003E value);\r\n\r\n        public static Vector64\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E values);\r\n        public static Vector64\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E values);\r\n        public static Vector64\u003CT\u003E Create\u003CT\u003E(T[] values);\r\n        public static Vector64\u003CT\u003E Create\u003CT\u003E(T[] values, int index);\r\n\r\n        public static void CopyTo\u003CT\u003E(this Vector64\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector64\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector64\u003CT\u003E vector, T[] destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector64\u003CT\u003E vector, T[] destination, int index);\r\n\r\n        public static bool TryCopyTo(this Vector64\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static bool TryCopyTo(this Vector64\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n    }\r\n\r\n    public partial struct Vector64\u003CT\u003E\r\n        where T : struct\r\n    {\r\n        public static Vector64\u003CT\u003E operator \u002B(Vector64\u003CT\u003E value);\r\n        public static Vector64\u003CT\u003E operator -(Vector64\u003CT\u003E value);\r\n\r\n        public static Vector64\u003CT\u003E operator ~(Vector64\u003CT\u003E value);\r\n\r\n        public static bool operator ==(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static bool operator !=(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E operator \u002B(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E operator -(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E operator *(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E operator /(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n\r\n        public static Vector64\u003CT\u003E operator \u0026(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E operator |(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n        public static Vector64\u003CT\u003E operator ^(Vector64\u003CT\u003E left, Vector64\u003CT\u003E right);\r\n    }\r\n    public static partial class Vector128\r\n    {\r\n        public bool IsHardwareAccelerated { get; }\r\n\r\n        public static Vector128\u003CT\u003E Abs(Vector128\u003CT\u003E value);\r\n        public static Vector128\u003CT\u003E Negate(Vector128\u003CT\u003E value);\r\n        public static Vector128\u003CT\u003E OnesComplement(Vector128\u003CT\u003E value);\r\n        public static Vector128\u003CT\u003E Sqrt(Vector128\u003CT\u003E value); // SquareRoot\r\n\r\n        public static Vector128\u003CT\u003E Add(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E Subtract(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E Multiply(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E Divide(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E Dot(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E AndNot(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E BitwiseAnd(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E BitwiseOr(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E Xor(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003Cdouble\u003E Ceiling(Vector128\u003Cdouble\u003E value);\r\n        public static Vector128\u003Cfloat\u003E Ceiling(Vector128\u003Cfloat\u003E value);\r\n\r\n        public static Vector128\u003Cdouble\u003E Floor(Vector128\u003Cdouble\u003E value);\r\n        public static Vector128\u003Cfloat\u003E Floor(Vector128\u003Cfloat\u003E value);\r\n\r\n        public static Vector128\u003CT\u003E ConditionalSelect(Vector128\u003CT\u003E condition, Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003Cdouble\u003E ConvertToDouble(Vector128\u003Clong\u003E value);\r\n        public static Vector128\u003Cdouble\u003E ConvertToDouble(Vector128\u003Culong\u003E value);\r\n\r\n        public static Vector128\u003Cint\u003E ConvertToInt32(Vector128\u003Cfloat\u003E value);\r\n        public static Vector128\u003Clong\u003E ConvertToInt64(Vector128\u003Cdouble\u003E value);\r\n\r\n        public static Vector128\u003Cfloat\u003E ConvertToSingle(Vector128\u003Cint\u003E value);\r\n        public static Vector128\u003Cfloat\u003E ConvertToSingle(Vector128\u003Cuint\u003E value);\r\n\r\n        public static Vector128\u003Cuint\u003E ConvertToUInt32(Vector128\u003Cfloat\u003E value);\r\n        public static Vector128\u003Culong\u003E ConvertToUInt64(Vector128\u003Cdouble\u003E value);\r\n\r\n        public static Vector128\u003CT\u003E Equals(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static bool EqualsAll(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool EqualsAny(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E GreaterThan(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanAll(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool GreaterThanAny(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E GreaterThanOrEqual(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanOrEqualAll(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool GreaterThanOrEqualAny(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E LessThan(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static bool LessThanAll(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool LessThanAny(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E LessThanOrEqual(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static bool LessThanOrEqualAll(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool LessThanOrEqualAny(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E Max(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E Min(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003Cfloat\u003E Narrow(Vector128\u003Cdouble\u003E lower, Vector128\u003CT\u003E upper);\r\n        public static Vector128\u003Csbyte\u003E Narrow(Vector128\u003Cshort\u003E lower, Vector128\u003Cshort\u003E upper);\r\n        public static Vector128\u003Cshort\u003E Narrow(Vector128\u003Cint\u003E lower, Vector128\u003Cint\u003E upper);\r\n        public static Vector128\u003Cint\u003E Narrow(Vector128\u003Clong\u003E lower, Vector128\u003Clong\u003E upper);\r\n        public static Vector128\u003Cbyte\u003E Narrow(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper);\r\n        public static Vector128\u003Cushort\u003E Narrow(Vector128\u003Cuint\u003E lower, Vector128\u003Cuint\u003E upper);\r\n        public static Vector128\u003Cuint\u003E Narrow(Vector128\u003Culong\u003E lower, Vector128\u003Culong\u003E upper);\r\n\r\n        public static (Vector128\u003Cshort\u003E Lower, Vector128\u003Cshort\u003E Upper) Widen(Vector128\u003Csbyte\u003E value);\r\n        public static (Vector128\u003Cint\u003E Lower, Vector128\u003Cint\u003E Upper) Widen(Vector128\u003Cshort\u003E value);\r\n        public static (Vector128\u003Clong\u003E Lower, Vector128\u003Clong\u003E Upper) Widen(Vector128\u003Cint\u003E value);\r\n        public static (Vector128\u003Cdouble\u003E Lower, Vector128\u003Cdouble\u003E Upper) Widen(Vector128\u003Cflaot\u003E value);\r\n        public static (Vector128\u003Cushort\u003E Lower, Vector128\u003Cushort\u003E Upper) Widen(Vector128\u003Cbyte\u003E value);\r\n        public static (Vector128\u003Cuint\u003E Lower, Vector128\u003Cuint\u003E Upper) Widen(Vector128\u003Cushort\u003E value);\r\n        public static (Vector128\u003Culong\u003E Lower, Vector128\u003Culong\u003E Upper) Widen(Vector128\u003Cuint\u003E value);\r\n\r\n        public static Vector128\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E values);\r\n        public static Vector128\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E values);\r\n        public static Vector128\u003CT\u003E Create\u003CT\u003E(T[] values);\r\n        public static Vector128\u003CT\u003E Create\u003CT\u003E(T[] values, int index);\r\n\r\n        public static void CopyTo\u003CT\u003E(this Vector128\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector128\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector128\u003CT\u003E vector, T[] destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector128\u003CT\u003E vector, T[] destination, int index);\r\n\r\n        public static bool TryCopyTo(this Vector128\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static bool TryCopyTo(this Vector128\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n    }\r\n\r\n    public partial struct Vector128\u003CT\u003E\r\n        where T : struct\r\n    {\r\n        public static Vector128\u003CT\u003E operator \u002B(Vector128\u003CT\u003E value);\r\n        public static Vector128\u003CT\u003E operator -(Vector128\u003CT\u003E value);\r\n\r\n        public static Vector128\u003CT\u003E operator ~(Vector128\u003CT\u003E value);\r\n\r\n        public static bool operator ==(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static bool operator !=(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E operator \u002B(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E operator -(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E operator *(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E operator /(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n\r\n        public static Vector128\u003CT\u003E operator \u0026(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E operator |(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n        public static Vector128\u003CT\u003E operator ^(Vector128\u003CT\u003E left, Vector128\u003CT\u003E right);\r\n    }\r\n    public static partial class Vector256\r\n    {\r\n        public bool IsHardwareAccelerated { get; }\r\n\r\n        public static Vector256\u003CT\u003E Abs(Vector256\u003CT\u003E value);\r\n        public static Vector256\u003CT\u003E Negate(Vector256\u003CT\u003E value);\r\n        public static Vector256\u003CT\u003E OnesComplement(Vector256\u003CT\u003E value);\r\n        public static Vector256\u003CT\u003E Sqrt(Vector256\u003CT\u003E value); // SquareRoot\r\n\r\n        public static Vector256\u003CT\u003E Add(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E Subtract(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E Multiply(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E Divide(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E Dot(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E AndNot(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E BitwiseAnd(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E BitwiseOr(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E Xor(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003Cdouble\u003E Ceiling(Vector256\u003Cdouble\u003E value);\r\n        public static Vector256\u003Cfloat\u003E Ceiling(Vector256\u003Cfloat\u003E value);\r\n\r\n        public static Vector256\u003Cdouble\u003E Floor(Vector256\u003Cdouble\u003E value);\r\n        public static Vector256\u003Cfloat\u003E Floor(Vector256\u003Cfloat\u003E value);\r\n\r\n        public static Vector256\u003CT\u003E ConditionalSelect(Vector256\u003CT\u003E condition, Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003Cdouble\u003E ConvertToDouble(Vector256\u003Clong\u003E value);\r\n        public static Vector256\u003Cdouble\u003E ConvertToDouble(Vector256\u003Culong\u003E value);\r\n\r\n        public static Vector256\u003Cint\u003E ConvertToInt32(Vector256\u003Cfloat\u003E value);\r\n        public static Vector256\u003Clong\u003E ConvertToInt64(Vector256\u003Cdouble\u003E value);\r\n\r\n        public static Vector256\u003Cfloat\u003E ConvertToSingle(Vector256\u003Cint\u003E value);\r\n        public static Vector256\u003Cfloat\u003E ConvertToSingle(Vector256\u003Cuint\u003E value);\r\n\r\n        public static Vector256\u003Cuint\u003E ConvertToUInt32(Vector256\u003Cfloat\u003E value);\r\n        public static Vector256\u003Culong\u003E ConvertToUInt64(Vector256\u003Cdouble\u003E value);\r\n\r\n        public static Vector256\u003CT\u003E Equals(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static bool EqualsAll(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool EqualsAny(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E GreaterThan(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanAll(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool GreaterThanAny(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E GreaterThanOrEqual(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static bool GreaterThanOrEqualAll(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool GreaterThanOrEqualAny(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E LessThan(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static bool LessThanAll(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool LessThanAny(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E LessThanOrEqual(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static bool LessThanOrEqualAll(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool LessThanOrEqualAny(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E Max(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E Min(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003Cfloat\u003E Narrow(Vector256\u003Cdouble\u003E lower, Vector256\u003CT\u003E upper);\r\n        public static Vector256\u003Csbyte\u003E Narrow(Vector256\u003Cshort\u003E lower, Vector256\u003Cshort\u003E upper);\r\n        public static Vector256\u003Cshort\u003E Narrow(Vector256\u003Cint\u003E lower, Vector256\u003Cint\u003E upper);\r\n        public static Vector256\u003Cint\u003E Narrow(Vector256\u003Clong\u003E lower, Vector256\u003Clong\u003E upper);\r\n        public static Vector256\u003Cbyte\u003E Narrow(Vector256\u003Cushort\u003E lower, Vector256\u003Cushort\u003E upper);\r\n        public static Vector256\u003Cushort\u003E Narrow(Vector256\u003Cuint\u003E lower, Vector256\u003Cuint\u003E upper);\r\n        public static Vector256\u003Cuint\u003E Narrow(Vector256\u003Culong\u003E lower, Vector256\u003Culong\u003E upper);\r\n\r\n        public static (Vector256\u003Cshort\u003E Lower, Vector256\u003Cshort\u003E Upper) Widen(Vector256\u003Csbyte\u003E value);\r\n        public static (Vector256\u003Cint\u003E Lower, Vector256\u003Cint\u003E Upper) Widen(Vector256\u003Cshort\u003E value);\r\n        public static (Vector256\u003Clong\u003E Lower, Vector256\u003Clong\u003E Upper) Widen(Vector256\u003Cint\u003E value);\r\n        public static (Vector256\u003Cdouble\u003E Lower, Vector256\u003Cdouble\u003E Upper) Widen(Vector256\u003Cflaot\u003E value);\r\n        public static (Vector256\u003Cushort\u003E Lower, Vector256\u003Cushort\u003E Upper) Widen(Vector256\u003Cbyte\u003E value);\r\n        public static (Vector256\u003Cuint\u003E Lower, Vector256\u003Cuint\u003E Upper) Widen(Vector256\u003Cushort\u003E value);\r\n        public static (Vector256\u003Culong\u003E Lower, Vector256\u003Culong\u003E Upper) Widen(Vector256\u003Cuint\u003E value);\r\n\r\n        public static Vector256\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E values);\r\n        public static Vector256\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E values);\r\n        public static Vector256\u003CT\u003E Create\u003CT\u003E(T[] values);\r\n        public static Vector256\u003CT\u003E Create\u003CT\u003E(T[] values, int index);\r\n\r\n        public static void CopyTo\u003CT\u003E(this Vector256\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector256\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector256\u003CT\u003E vector, T[] destination);\r\n        public static void CopyTo\u003CT\u003E(this Vector256\u003CT\u003E vector, T[] destination, int index);\r\n\r\n        public static bool TryCopyTo(this Vector256\u003CT\u003E vector, Span\u003Cbyte\u003E destination);\r\n        public static bool TryCopyTo(this Vector256\u003CT\u003E vector, Span\u003CT\u003E destination);\r\n    }\r\n\r\n    public partial struct Vector256\u003CT\u003E\r\n        where T : struct\r\n    {\r\n        public static Vector256\u003CT\u003E operator \u002B(Vector256\u003CT\u003E value);\r\n        public static Vector256\u003CT\u003E operator -(Vector256\u003CT\u003E value);\r\n\r\n        public static Vector256\u003CT\u003E operator ~(Vector256\u003CT\u003E value);\r\n\r\n        public static bool operator ==(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static bool operator !=(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E operator \u002B(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E operator -(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E operator *(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E operator /(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n\r\n        public static Vector256\u003CT\u003E operator \u0026(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E operator |(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n        public static Vector256\u003CT\u003E operator ^(Vector256\u003CT\u003E left, Vector256\u003CT\u003E right);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 66100000000,
        "Apis": [
          "M:Vector128.Abs(Vector128\u003CT\u003E)",
          "M:Vector128.Add(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.AndNot(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.BitwiseAnd(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.BitwiseOr(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Ceiling(Vector128\u003Cdouble\u003E)",
          "M:Vector128.Ceiling(Vector128\u003Cfloat\u003E)",
          "M:Vector128.ConditionalSelect(Vector128\u003CT\u003E,Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.ConvertToDouble(Vector128\u003Clong\u003E)",
          "M:Vector128.ConvertToDouble(Vector128\u003Culong\u003E)",
          "M:Vector128.ConvertToInt32(Vector128\u003Cfloat\u003E)",
          "M:Vector128.ConvertToInt64(Vector128\u003Cdouble\u003E)",
          "M:Vector128.ConvertToSingle(Vector128\u003Cint\u003E)",
          "M:Vector128.ConvertToSingle(Vector128\u003Cuint\u003E)",
          "M:Vector128.ConvertToUInt32(Vector128\u003Cfloat\u003E)",
          "M:Vector128.ConvertToUInt64(Vector128\u003Cdouble\u003E)",
          "M:Vector128.CopyTo\u003CT\u003E(this Vector128\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector128.CopyTo\u003CT\u003E(this Vector128\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector128.CopyTo\u003CT\u003E(this Vector128\u003CT\u003E,T[],int)",
          "M:Vector128.CopyTo\u003CT\u003E(this Vector128\u003CT\u003E,T[])",
          "M:Vector128.Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Vector128.Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E)",
          "M:Vector128.Create\u003CT\u003E(T[],int)",
          "M:Vector128.Create\u003CT\u003E(T[])",
          "M:Vector128.Divide(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Dot(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Equals(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.EqualsAll(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.EqualsAny(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Floor(Vector128\u003Cdouble\u003E)",
          "M:Vector128.Floor(Vector128\u003Cfloat\u003E)",
          "M:Vector128.GreaterThan(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.GreaterThanAll(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.GreaterThanAny(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.GreaterThanOrEqual(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.GreaterThanOrEqualAll(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.GreaterThanOrEqualAny(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThan(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThanAll(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThanAny(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThanOrEqual(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThanOrEqualAll(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.LessThanOrEqualAny(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Max(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Min(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Multiply(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Narrow(Vector128\u003Cdouble\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.Narrow(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Vector128.Narrow(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:Vector128.Narrow(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Vector128.Narrow(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:Vector128.Narrow(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:Vector128.Narrow(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:Vector128.Negate(Vector128\u003CT\u003E)",
          "M:Vector128.OnesComplement(Vector128\u003CT\u003E)",
          "M:Vector128.Sqrt(Vector128\u003CT\u003E)",
          "M:Vector128.Subtract(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128.TryCopyTo(this Vector128\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector128.TryCopyTo(this Vector128\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector128.Widen(Vector128\u003Cbyte\u003E)",
          "M:Vector128.Widen(Vector128\u003Cflaot\u003E)",
          "M:Vector128.Widen(Vector128\u003Cint\u003E)",
          "M:Vector128.Widen(Vector128\u003Csbyte\u003E)",
          "M:Vector128.Widen(Vector128\u003Cshort\u003E)",
          "M:Vector128.Widen(Vector128\u003Cuint\u003E)",
          "M:Vector128.Widen(Vector128\u003Cushort\u003E)",
          "M:Vector128.Xor(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.-(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.-(Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.!=(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.*(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E./(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.\u0026(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.^(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.\u002B(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.\u002B(Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.==(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.|(Vector128\u003CT\u003E,Vector128\u003CT\u003E)",
          "M:Vector128\u003CT\u003E.~(Vector128\u003CT\u003E)",
          "M:Vector256.Abs(Vector256\u003CT\u003E)",
          "M:Vector256.Add(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.AndNot(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.BitwiseAnd(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.BitwiseOr(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Ceiling(Vector256\u003Cdouble\u003E)",
          "M:Vector256.Ceiling(Vector256\u003Cfloat\u003E)",
          "M:Vector256.ConditionalSelect(Vector256\u003CT\u003E,Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.ConvertToDouble(Vector256\u003Clong\u003E)",
          "M:Vector256.ConvertToDouble(Vector256\u003Culong\u003E)",
          "M:Vector256.ConvertToInt32(Vector256\u003Cfloat\u003E)",
          "M:Vector256.ConvertToInt64(Vector256\u003Cdouble\u003E)",
          "M:Vector256.ConvertToSingle(Vector256\u003Cint\u003E)",
          "M:Vector256.ConvertToSingle(Vector256\u003Cuint\u003E)",
          "M:Vector256.ConvertToUInt32(Vector256\u003Cfloat\u003E)",
          "M:Vector256.ConvertToUInt64(Vector256\u003Cdouble\u003E)",
          "M:Vector256.CopyTo\u003CT\u003E(this Vector256\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector256.CopyTo\u003CT\u003E(this Vector256\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector256.CopyTo\u003CT\u003E(this Vector256\u003CT\u003E,T[],int)",
          "M:Vector256.CopyTo\u003CT\u003E(this Vector256\u003CT\u003E,T[])",
          "M:Vector256.Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Vector256.Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E)",
          "M:Vector256.Create\u003CT\u003E(T[],int)",
          "M:Vector256.Create\u003CT\u003E(T[])",
          "M:Vector256.Divide(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Dot(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Equals(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.EqualsAll(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.EqualsAny(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Floor(Vector256\u003Cdouble\u003E)",
          "M:Vector256.Floor(Vector256\u003Cfloat\u003E)",
          "M:Vector256.GreaterThan(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.GreaterThanAll(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.GreaterThanAny(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.GreaterThanOrEqual(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.GreaterThanOrEqualAll(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.GreaterThanOrEqualAny(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThan(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThanAll(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThanAny(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThanOrEqual(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThanOrEqualAll(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.LessThanOrEqualAny(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Max(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Min(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Multiply(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Narrow(Vector256\u003Cdouble\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.Narrow(Vector256\u003Cint\u003E,Vector256\u003Cint\u003E)",
          "M:Vector256.Narrow(Vector256\u003Clong\u003E,Vector256\u003Clong\u003E)",
          "M:Vector256.Narrow(Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E)",
          "M:Vector256.Narrow(Vector256\u003Cuint\u003E,Vector256\u003Cuint\u003E)",
          "M:Vector256.Narrow(Vector256\u003Culong\u003E,Vector256\u003Culong\u003E)",
          "M:Vector256.Narrow(Vector256\u003Cushort\u003E,Vector256\u003Cushort\u003E)",
          "M:Vector256.Negate(Vector256\u003CT\u003E)",
          "M:Vector256.OnesComplement(Vector256\u003CT\u003E)",
          "M:Vector256.Sqrt(Vector256\u003CT\u003E)",
          "M:Vector256.Subtract(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256.TryCopyTo(this Vector256\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector256.TryCopyTo(this Vector256\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector256.Widen(Vector256\u003Cbyte\u003E)",
          "M:Vector256.Widen(Vector256\u003Cflaot\u003E)",
          "M:Vector256.Widen(Vector256\u003Cint\u003E)",
          "M:Vector256.Widen(Vector256\u003Csbyte\u003E)",
          "M:Vector256.Widen(Vector256\u003Cshort\u003E)",
          "M:Vector256.Widen(Vector256\u003Cuint\u003E)",
          "M:Vector256.Widen(Vector256\u003Cushort\u003E)",
          "M:Vector256.Xor(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.-(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.-(Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.!=(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.*(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E./(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.\u0026(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.^(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.\u002B(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.\u002B(Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.==(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.|(Vector256\u003CT\u003E,Vector256\u003CT\u003E)",
          "M:Vector256\u003CT\u003E.~(Vector256\u003CT\u003E)",
          "M:Vector64.Abs(Vector64\u003CT\u003E)",
          "M:Vector64.Add(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.AndNot(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.BitwiseAnd(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.BitwiseOr(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Ceiling(Vector64\u003Cdouble\u003E)",
          "M:Vector64.Ceiling(Vector64\u003Cfloat\u003E)",
          "M:Vector64.ConditionalSelect(Vector64\u003CT\u003E,Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.ConvertToDouble(Vector64\u003Clong\u003E)",
          "M:Vector64.ConvertToDouble(Vector64\u003Culong\u003E)",
          "M:Vector64.ConvertToInt32(Vector64\u003Cfloat\u003E)",
          "M:Vector64.ConvertToInt64(Vector64\u003Cdouble\u003E)",
          "M:Vector64.ConvertToSingle(Vector64\u003Cint\u003E)",
          "M:Vector64.ConvertToSingle(Vector64\u003Cuint\u003E)",
          "M:Vector64.ConvertToUInt32(Vector64\u003Cfloat\u003E)",
          "M:Vector64.ConvertToUInt64(Vector64\u003Cdouble\u003E)",
          "M:Vector64.CopyTo\u003CT\u003E(this Vector64\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector64.CopyTo\u003CT\u003E(this Vector64\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector64.CopyTo\u003CT\u003E(this Vector64\u003CT\u003E,T[],int)",
          "M:Vector64.CopyTo\u003CT\u003E(this Vector64\u003CT\u003E,T[])",
          "M:Vector64.Create\u003CT\u003E(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Vector64.Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E)",
          "M:Vector64.Create\u003CT\u003E(T[],int)",
          "M:Vector64.Create\u003CT\u003E(T[])",
          "M:Vector64.Divide(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Dot(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Equals(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.EqualsAll(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.EqualsAny(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Floor(Vector64\u003Cdouble\u003E)",
          "M:Vector64.Floor(Vector64\u003Cfloat\u003E)",
          "M:Vector64.GreaterThan(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.GreaterThanAll(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.GreaterThanAny(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.GreaterThanOrEqual(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.GreaterThanOrEqualAll(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.GreaterThanOrEqualAny(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThan(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThanAll(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThanAny(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThanOrEqual(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThanOrEqualAll(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.LessThanOrEqualAny(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Max(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Min(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Multiply(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Narrow(Vector64\u003Cdouble\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.Narrow(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Vector64.Narrow(Vector64\u003Clong\u003E,Vector64\u003Clong\u003E)",
          "M:Vector64.Narrow(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Vector64.Narrow(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:Vector64.Narrow(Vector64\u003Culong\u003E,Vector64\u003Culong\u003E)",
          "M:Vector64.Narrow(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:Vector64.Negate(Vector64\u003CT\u003E)",
          "M:Vector64.OnesComplement(Vector64\u003CT\u003E)",
          "M:Vector64.Sqrt(Vector64\u003CT\u003E)",
          "M:Vector64.Subtract(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64.TryCopyTo(this Vector64\u003CT\u003E,Span\u003Cbyte\u003E)",
          "M:Vector64.TryCopyTo(this Vector64\u003CT\u003E,Span\u003CT\u003E)",
          "M:Vector64.Widen(Vector64\u003Cbyte\u003E)",
          "M:Vector64.Widen(Vector64\u003Cflaot\u003E)",
          "M:Vector64.Widen(Vector64\u003Cint\u003E)",
          "M:Vector64.Widen(Vector64\u003Csbyte\u003E)",
          "M:Vector64.Widen(Vector64\u003Cshort\u003E)",
          "M:Vector64.Widen(Vector64\u003Cuint\u003E)",
          "M:Vector64.Widen(Vector64\u003Cushort\u003E)",
          "M:Vector64.Xor(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.-(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.-(Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.!=(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.*(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E./(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.\u0026(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.^(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.\u002B(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.\u002B(Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.==(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.|(Vector64\u003CT\u003E,Vector64\u003CT\u003E)",
          "M:Vector64\u003CT\u003E.~(Vector64\u003CT\u003E)",
          "P:Vector128.IsHardwareAccelerated",
          "P:Vector256.IsHardwareAccelerated",
          "P:Vector64.IsHardwareAccelerated",
          "T:Vector128",
          "T:Vector128\u003CT\u003E",
          "T:Vector256",
          "T:Vector256\u003CT\u003E",
          "T:Vector64",
          "T:Vector64\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "kO1HyNmi7ww",
      "StartDateTime": "2021-05-25T10:06:02-07:00",
      "EndDateTime": "2021-05-25T12:14:09-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/kO1HyNmi7ww/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24847,
          "Title": "Async File IO APIs mimicking Win32 OVERLAPPED",
          "Author": "alexbudmsft",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-30T22:29:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24847",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-25T00:00:00-07:00",
        "FeedbackId": "848063507",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24847#issuecomment-848063507",
        "FeedbackMarkdown": "* On re-review we decided to remove the names Scatter and Gather, as we already have precedent for these concepts without the name.\r\n* On re-review we feel that, on the whole, the \u0022AtOffset\u0022 particles aren\u0027t necessary with the static method invocation.  Since there\u0027s a fair hesitation for having these as instance methods on the SafeHandle type or even extension methods, we can go ahead and remove the redundancy.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static class RandomAccess\r\n    {\r\n        public static long GetLength(SafeFileHandle handle) =\u003E throw null;\r\n\r\n        public static int Read(SafeFileHandle handle, Span\u003Cbyte\u003E buffer, long fileOffset);\r\n        public static int Read(SafeFileHandle handle, Span\u003Cbyte\u003E buffer, ulong fileOffset);\r\n        public static void Write(SafeFileHandle handle, ReadOnlySpan\u003Cbyte\u003E buffer, long fileOffset);\r\n        public static void Write(SafeFileHandle handle, ReadOnlySpan\u003Cbyte\u003E buffer, ulong fileOffset);\r\n\r\n        public static long Read(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, long fileOffset);\r\n        public static long Read(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset);\r\n        public static void Write(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, long fileOffset);\r\n        public static void Write(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset);\r\n    \r\n        public static ValueTask\u003Cint\u003E ReadAsync(SafeFileHandle handle, Memory\u003Cbyte\u003E buffer, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E ReadAsync(SafeFileHandle handle, Memory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAsync(SafeFileHandle handle, ReadOnlyMemory\u003Cbyte\u003E buffer, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAsync(SafeFileHandle handle, ReadOnlyMemory\u003Cbyte\u003E buffer, ulong fileOffset, CancellationToken cancellationToken = default);\r\n\r\n        public static ValueTask\u003Clong\u003E ReadAsync(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Clong\u003E ReadAsync(SafeFileHandle handle, IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAsync(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, long fileOffset, CancellationToken cancellationToken = default);\r\n        public static ValueTask WriteAsync(SafeFileHandle handle, IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E buffers, ulong fileOffset, CancellationToken cancellationToken = default);\r\n    }\r\n\r\n    partial class File\r\n    {\r\n        public static SafeFileHandle OpenHandle(string filePath, FileMode mode = FileMode.Open, FileAccess access = FileAccess.Read, FileShare share = FileShare.Read, FileOptions options = FileOptions.None, long preAllocationSize = 0)\r\n    }\r\n}\r\n\r\nnamespace Microsoft.Win32.SafeHandles\r\n{\r\n    partial class SafeFileHandle\r\n    {\r\n        public bool IsAsync { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:File.OpenHandle(string,FileMode,FileAccess,FileShare,FileOptions,long)",
          "M:RandomAccess.GetLength(SafeFileHandle)",
          "M:RandomAccess.Read(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,long)",
          "M:RandomAccess.Read(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,ulong)",
          "M:RandomAccess.Read(SafeFileHandle,Span\u003Cbyte\u003E,long)",
          "M:RandomAccess.Read(SafeFileHandle,Span\u003Cbyte\u003E,ulong)",
          "M:RandomAccess.ReadAsync(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,long,CancellationToken)",
          "M:RandomAccess.ReadAsync(SafeFileHandle,IReadOnlyList\u003CMemory\u003Cbyte\u003E\u003E,ulong,CancellationToken)",
          "M:RandomAccess.ReadAsync(SafeFileHandle,Memory\u003Cbyte\u003E,long,CancellationToken)",
          "M:RandomAccess.ReadAsync(SafeFileHandle,Memory\u003Cbyte\u003E,ulong,CancellationToken)",
          "M:RandomAccess.Write(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,long)",
          "M:RandomAccess.Write(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,ulong)",
          "M:RandomAccess.Write(SafeFileHandle,ReadOnlySpan\u003Cbyte\u003E,long)",
          "M:RandomAccess.Write(SafeFileHandle,ReadOnlySpan\u003Cbyte\u003E,ulong)",
          "M:RandomAccess.WriteAsync(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,long,CancellationToken)",
          "M:RandomAccess.WriteAsync(SafeFileHandle,IReadOnlyList\u003CReadOnlyMemory\u003Cbyte\u003E\u003E,ulong,CancellationToken)",
          "M:RandomAccess.WriteAsync(SafeFileHandle,ReadOnlyMemory\u003Cbyte\u003E,long,CancellationToken)",
          "M:RandomAccess.WriteAsync(SafeFileHandle,ReadOnlyMemory\u003Cbyte\u003E,ulong,CancellationToken)",
          "P:SafeFileHandle.IsAsync",
          "T:File",
          "T:RandomAccess",
          "T:SafeFileHandle"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51061,
          "Title": "String.{Try}CopyTo(Span\u003Cchar\u003E)",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-11T02:29:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51061",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-25T00:00:00-07:00",
        "FeedbackId": "848073697",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51061#issuecomment-848073697",
        "FeedbackMarkdown": "* While our newer Span-writing methods return the number of elements written (when there\u0027s not a better purpose for the return value) this has symmetry with the current Span methods.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public sealed class String\r\n    {\r\n        ...\r\n        public void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);\r\n\u002B       public void CopyTo(Span\u003Cchar\u003E destination);\r\n\u002B       public bool TryCopyTo(Span\u003Cchar\u003E destination);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8160000000,
        "Apis": [
          "M:String.CopyTo(int,char[],int,int)",
          "M:String.CopyTo(Span\u003Cchar\u003E)",
          "M:String.TryCopyTo(Span\u003Cchar\u003E)",
          "T:String"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47977,
          "Title": "Consider deprecating or annotating a few S.S.C.X509Certificates members",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-07T19:13:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47977",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-25T00:00:00-07:00",
        "FeedbackId": "848081543",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47977#issuecomment-848081543",
        "FeedbackMarkdown": "* The obsoletions should use the next available SYSLIB number\r\n* The SupportedOSPlatform attributes were moved from the property to just the property setter (so the getters are still allowed on all platforms, since they don\u0027t throw).\r\n\r\n\u0060\u0060\u0060diff\r\npublic class X509Certificate2\r\n{\r\n    public bool Archived {\r\n       get;\r\n\u002B   [SupportedOSPlatform(\u0022windows\u0022)]\r\n       set;\r\n }\r\n\r\n    public string FriendlyName\r\n     {\r\n         get;\r\n\u002B   [SupportedOSPlatform(\u0022windows\u0022)]\r\n         set;\r\n     }\r\n\r\n\u002B   [Obsolete(\u0022This is no longer the recommended way of retrieving the private key. Use the appropriate GetPrivateKey or CopyWithPrivateKey method instead.\u0022)]\r\n    public AsymmetricAlgorithm PrivateKey { get; set; }\r\n\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use a different constructor overload instead.\u0022)]\r\n    public X509Certificate2();\r\n\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(byte[] rawData);\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(string fileName);\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(string fileName, System.Security.SecureString? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate2 is immutable on this platform. Use the equivalent constructor instead.\u0022)]\r\n    public override void Import(string fileName, string? password, X509KeyStorageFlags keyStorageFlags);\r\n}\r\n\r\npublic class X509Certificate\r\n{\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use a different constructor overload instead.\u0022)]\r\n    public X509Certificate();\r\n\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(byte[] rawData);\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(byte[] rawData, SecureString? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(byte[] rawData, string? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(string fileName);\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(string fileName, System.Security.SecureString? password, X509KeyStorageFlags keyStorageFlags);\r\n\u002B   [Obsolete(\u0022X509Certificate is immutable on this platform. Use the equivalent constructor on X509Certificate2 instead.\u0022)]\r\n    public void Import(string fileName, string? password, X509KeyStorageFlags keyStorageFlags);\r\n}\r\n\r\npublic class PublicKey\r\n{\r\n\u002B   [Obsolete(\u0022The key property is no longer recommended for use. Use the appropriate GetPublicKey method instead.\u0022)]\r\n    public AsymmetricAlgorithm Key { get; }\r\n}",
        "TimeCode": 15660000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48913,
          "Title": "Add PipeWriter.UnflushedBytes",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-01T16:12:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48913",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Pipelines",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-25T00:00:00-07:00",
        "FeedbackId": "848161253",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48913#issuecomment-848161253",
        "FeedbackMarkdown": "* The discussion favored this being a Try method to better communicate to the caller (and code reviewer) that the implementation might not have an answer; then circled back and split the Nullable into a virtual Can property and a virtual throwing property.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Pipelines\r\n{\r\n    partial class PipeWriter \r\n    {\r\n         public virtual bool CanGetUnflushedBytes =\u003E false;\r\n         public virtual long UnflushedBytes =\u003E throw new NotImplementedException(some message here);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 22220000000,
        "Apis": [
          "P:PipeWriter.CanGetUnflushedBytes",
          "P:PipeWriter.UnflushedBytes",
          "T:PipeWriter"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48615,
          "Title": "Add blittable Color to System.Numerics",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-22T19:35:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48615",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-25T00:00:00-07:00",
        "FeedbackId": "848191829",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48615#issuecomment-848191829",
        "FeedbackMarkdown": "It seems like there may be scenarios, but we should reconcile the layering (above or below Color) and determine if we need this, or a companion, for MAUI.",
        "TimeCode": 64500000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "wY0t4bkXzS4",
      "StartDateTime": "2021-05-27T10:05:17-07:00",
      "EndDateTime": "2021-05-27T11:59:12-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/wY0t4bkXzS4/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24271,
          "Title": "Proposed API for symbolic links",
          "Author": "carlreinke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-11-29T05:50:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24271",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849816518",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24271#issuecomment-849816518",
        "FeedbackMarkdown": "* \u0022GetLinkTargetPath\u0022 had some naming concerns for being too close to \u0022GetLinkTarget\u0022\r\n  * The resolution to this was to rename \u0022GetLinkTarget\u0022 to \u0022ResolveLinkTarget\u0022 since it resolves the target into a FileSystemInfo, and to change the GetLinkTargetPath method a LinkTarget property\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.IO\r\n{\r\n    public abstract partial class FileSystemInfo\r\n    {\r\n        public void CreateAsSymbolicLink(string pathToTarget); // Already approved\r\n\r\n-       public FileSystemInfo? GetSymbolicLinkTarget(bool returnFinalTarget = false); // Already approved\r\n\u002B       public FileSystemInfo? ResolveLinkTarget(bool returnFinalTarget = false); // Rename\r\n\r\n\u002B       public string? LinkTarget { get; }\r\n    }\r\n    public static class File\r\n    {\r\n        public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget); // Already approved\r\n\r\n-       public static FileSystemInfo? GetSymbolicLinkTarget(string linkPath, bool returnFinalTarget = false); // Already approved\r\n\u002B       public static FileSystemInfo? ResolveLinkTarget(string linkPath, bool returnFinalTarget = false); // Rename\r\n    }\r\n    public static class Directory\r\n    {\r\n        public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget); // Already approved\r\n\r\n-       public static FileSystemInfo? GetSymbolicLinkTarget(string linkPath, bool returnFinalTarget = false); // Already approved\r\n\u002B       public static FileSystemInfo? ResolveLinkTarget(string linkPath, bool returnFinalTarget = false); // Rename\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 17036,
          "Title": "Add StringContent ctor providing tighter control over charset",
          "Author": "guardrex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-04-19T16:57:23+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/17036",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849820882",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/17036#issuecomment-849820882",
        "FeedbackMarkdown": "Looks good as proposed.  We even discussed the casing on \u0022charSet\u0022, and decided it\u0027s correct since it matches the existing property.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Net.Http.Headers\r\n{\r\n    public class StringContent\r\n    {\r\n       public StringContent(string content);\r\n\u002B      public StringContent(string content, MediaTypeHeaderValue mediaType); // Already approved in iteration 1\r\n       public StringContent(string content, Encoding encoding);\r\n       public StringContent(string content, Encoding encoding);\r\n       public StringContent(string content, Encoding encoding, string mediaType);\r\n\u002B      public StringContent(string content, Encoding encoding, MediaTypeHeaderValue mediaType); // NEW API proposal\r\n    }\r\n    \r\n    public class MediaTypeHeaderValue\r\n    {\r\n        public MediaTypeHeaderValue(string mediaType)\r\n\u002B       public MediaTypeHeaderValue(string mediaType, string charSet);  // NEW API proposal\r\n    }\r\n}",
        "TimeCode": 20300000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24698,
          "Title": "Add isAsync overload for Create/Open/etc.",
          "Author": "Duranom",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-01-17T16:53:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24698",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849822584",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24698#issuecomment-849822584",
        "FeedbackMarkdown": "Trusting that all of the removals are not yet implemented, or were to be new for .NET 6, the update looks good as proposed.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.IO\r\n{\r\n    public static partial class File\r\n    {\r\n-        public StreamWriter AppendText(string path, FileOptions options)\r\n\u002B        public StreamWriter AppendText(string path, FileStreamOptions options)\r\n-        public static FileStream Create(string path, FileOptions options)\r\n\u002B        public static FileStream Create(string path, FileStreamOptions options)\r\n-        public static StreamWriter CreateText(string path, FileOptions options)   \r\n\u002B        public static StreamWriter CreateText(string path, FileStreamOptions options)  \r\n-        public static FileStream Open(string path, FileMode mode, FileOptions options)\r\n-        public static FileStream Open(string path, FileMode mode, FileAccess access, FileOptions options)\r\n-        public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options)\r\n\u002B        public static FileStream Open(string path, FileMode mode, FileStreamOptions options)\r\n-        public static FileStream OpenRead(string path, FileOptions options)\r\n\u002B        public static FileStream OpenRead(string path, FileStreamOptions options)\r\n-        public static StreamReader OpenText(string path, FileOptions options)\r\n\u002B        public static StreamReader OpenText(string path, FileStreamOptions options)\r\n-        public static FileStream OpenWrite(string path, FileOptions options)\r\n\u002B        public static FileStream OpenWrite(string path, FileStreamOptions options)\r\n    }\r\n    public sealed partial class FileInfo : FileSystemInfo\r\n    {\r\n-        public StreamWriter AppendText(FileOptions options)\r\n\u002B        public StreamWriter AppendText(FileStreamOptions options)\r\n-        public FileStream Create(FileOptions options)\r\n\u002B        public FileStream Create(FileStreamOptions options)\r\n-        public StreamWriter CreateText(FileOptions options)\r\n\u002B        public StreamWriter CreateText(FileStreamOptions options)\r\n-        public FileStream Open(FileMode mode, FileOptions options)\r\n-        public FileStream Open(FileMode mode, FileAccess access, FileOptions options)\r\n-        public FileStream Open(FileMode mode, FileAccess access, FileShare share, FileOptions options)\r\n\u002B        public FileStream Open(FileMode mode, FileStreamOptions options)\r\n-        public FileStream OpenRead(FileOptions options)\r\n\u002B        public FileStream OpenRead(FileStreamOptions options)\r\n-        public StreamReader OpenText(FileOptions options)    \r\n\u002B        public StreamReader OpenText(FileStreamOptions options)    \r\n-        public FileStream OpenWrite(FileOptions options)\r\n\u002B        public FileStream OpenWrite(FileStreamOptions options)\r\n    }\r\n    public partial class StreamReader : TextReader\r\n    {\r\n-        public StreamReader(string path, FileOptions options)\r\n\u002B        public StreamReader(string path, FileStreamOptions options)\r\n-        public StreamReader(string path, bool detectEncodingFromByteOrderMarks, FileOptions options)\r\n-        public StreamReader(string path, System.Text.Encoding encoding, FileOptions options)\r\n-        public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, FileOptions options)\r\n-        public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, FileOptions options)\r\n\u002B        public StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, FileStreamOptions options)\r\n    }\r\n    public partial class StreamWriter : TextWriter\r\n    {\r\n-        public StreamWriter(string path, FileOptions options)\r\n\u002B        public StreamWriter(string path, FileStreamOptions options)\r\n-        public StreamWriter(string path, bool append, FileOptions options)\r\n-        public StreamWriter(string path, bool append, System.Text.Encoding encoding, FileOptions options)\r\n-        public StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize, FileOptions options)\r\n\u002B        public StreamWriter(string path, System.Text.Encoding encoding, FileStreamOptions options)\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24700000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44094,
          "Title": "Added cookie accessor/iterator to CookieContainer",
          "Author": "shravan2x",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-31T01:11:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44094",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849825241",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44094#issuecomment-849825241",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net\r\n{\r\n    partial class CookieContainer\r\n    {\r\n        public CookieCollection GetAllCookies();\r\n    }\r\n}",
        "TimeCode": 26470000000,
        "Apis": [
          "M:CookieContainer.GetAllCookies()",
          "T:CookieContainer"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50428,
          "Title": "Add more AsSpan overloads to StringSegment",
          "Author": "BrennanConroy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-30T16:29:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50428",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Primitives",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849827151",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50428#issuecomment-849827151",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Primitives\r\n{\r\n    partial struct StringSegment : IEquatable\u003CStringSegment\u003E, IEquatable\u003Cstring\u003E\r\n    {\r\n       public ReadOnlySpan\u003Cchar\u003E AsSpan(int start);\r\n       public ReadOnlySpan\u003Cchar\u003E AsSpan(int start, int length);\r\n    }\r\n}",
        "TimeCode": 29020000000,
        "Apis": [
          "M:StringSegment.AsSpan(int,int)",
          "M:StringSegment.AsSpan(int)",
          "T:StringSegment"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50590,
          "Title": "Allow replacing IExternalScopeProvider via DI",
          "Author": "shirhatti",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-01T17:55:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50590",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849832463",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50590#issuecomment-849832463",
        "FeedbackMarkdown": "The existing longest constructor needs to have its default removed to follow the guidance for how to add new defaulted parameters safely.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    public partial class LoggerFactory : Microsoft.Extensions.Logging.ILoggerFactory\r\n    {\r\n         public LoggerFactory(\r\n             IEnumerable\u003CILoggerProvider\u003E providers,\r\n             IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption,\r\n-            IOptions\u003CLoggerFactoryOptions\u003E options = null)\r\n\u002B            IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n\r\n\u002B        public LoggerFactory(\r\n\u002B            IEnumerable\u003CILoggerProvider\u003E providers,\r\n\u002B            IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption,\r\n\u002B            LoggerFactoryOptions\u003E options = null,\r\n\u002B            IExternalScopeProvider scopeProvider = null) { }\r\n\r\n        }\r\n    }\r\n}",
        "TimeCode": 30960000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51581,
          "Title": "Array.Clear(Array)",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-20T21:08:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51581",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849834961",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51581#issuecomment-849834961",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    partial class Array\r\n    {\r\n        public static void Clear(Array array);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 36140000000,
        "Apis": [
          "M:Array.Clear(Array)",
          "T:Array"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52017,
          "Title": "Extend Vector64\u003CT\u003E, Vector128\u003CT\u003E, and Vector256\u003CT\u003E to support nint and nuint",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-28T22:44:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52017",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849839836",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52017#issuecomment-849839836",
        "FeedbackMarkdown": "Looks good as proposed.  A *very* forward looking question of \u0022what about when nint is bigger than 64 bits?\u0022 was asked, and deferred to such a hypothetical date.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public static partial class Vector64\r\n    {\r\n        public static Vector64\u003Cnint\u003E AsNInt\u003CT\u003E(Vector64\u003CT\u003E value);\r\n        public static Vector64\u003Cnuint\u003E AsNUInt\u003CT\u003E(Vector64\u003CT\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E Create(nint value);\r\n        public static Vector64\u003Cnuint\u003E Create(nuint value);\r\n\r\n        public static Vector64\u003Cnint\u003E CreateScalar(nint value);\r\n        public static Vector64\u003Cnuint\u003E CreateScalar(nuint value);\r\n\r\n        public static Vector64\u003Cnint\u003E CreateScalarUnsafe(nint value);\r\n        public static Vector64\u003Cnuint\u003E CreateScalarUnsafe(nuint value);\r\n    }\r\n\r\n    public static partial class Vector128\r\n    {\r\n        public static Vector128\u003Cnint\u003E AsNInt\u003CT\u003E(Vector128\u003CT\u003E value);\r\n        public static Vector128\u003Cnuint\u003E AsNUInt\u003CT\u003E(Vector128\u003CT\u003E value);\r\n\r\n        public static Vector128\u003Cnint\u003E Create(nint value);\r\n        public static Vector128\u003Cnuint\u003E Create(nuint value);\r\n\r\n        public static Vector128\u003Cnint\u003E Create(Vector64\u003Cnint\u003E lower, Vector64\u003Cnint\u003E upper);\r\n        public static Vector128\u003Cnuint\u003E Create(Vector64\u003Cnuint\u003E lower, Vector64\u003Cnuint\u003E upper);\r\n\r\n        public static Vector128\u003Cnint\u003E CreateScalar(nint value);\r\n        public static Vector128\u003Cnuint\u003E CreateScalar(nuint value);\r\n\r\n        public static Vector128\u003Cnint\u003E CreateScalarUnsafe(nint value);\r\n        public static Vector128\u003Cnuint\u003E CreateScalarUnsafe(nuint value);\r\n    }\r\n\r\n    public static partial class Vector256\r\n    {\r\n        public static Vector256\u003Cnint\u003E AsNInt\u003CT\u003E(Vector256\u003CT\u003E value);\r\n        public static Vector256\u003Cnuint\u003E AsNUInt\u003CT\u003E(Vector256\u003CT\u003E value);\r\n\r\n        public static Vector256\u003Cnint\u003E Create(nint value);\r\n        public static Vector256\u003Cnuint\u003E Create(nuint value);\r\n\r\n        public static Vector256\u003Cnint\u003E Create(Vector128\u003Cnint\u003E lower, Vector128\u003Cnint\u003E upper);\r\n        public static Vector256\u003Cnuint\u003E Create(Vector128\u003Cnuint\u003E lower, Vector128\u003Cnuint\u003E upper);\r\n\r\n        public static Vector256\u003Cnint\u003E CreateScalar(nint value);\r\n        public static Vector256\u003Cnuint\u003E CreateScalar(nuint value);\r\n\r\n        public static Vector256\u003Cnint\u003E CreateScalarUnsafe(nint value);\r\n        public static Vector256\u003Cnuint\u003E CreateScalarUnsafe(nuint value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 38100000000,
        "Apis": [
          "M:Vector128.AsNInt\u003CT\u003E(Vector128\u003CT\u003E)",
          "M:Vector128.AsNUInt\u003CT\u003E(Vector128\u003CT\u003E)",
          "M:Vector128.Create(nint)",
          "M:Vector128.Create(nuint)",
          "M:Vector128.Create(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:Vector128.Create(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:Vector128.CreateScalar(nint)",
          "M:Vector128.CreateScalar(nuint)",
          "M:Vector128.CreateScalarUnsafe(nint)",
          "M:Vector128.CreateScalarUnsafe(nuint)",
          "M:Vector256.AsNInt\u003CT\u003E(Vector256\u003CT\u003E)",
          "M:Vector256.AsNUInt\u003CT\u003E(Vector256\u003CT\u003E)",
          "M:Vector256.Create(nint)",
          "M:Vector256.Create(nuint)",
          "M:Vector256.Create(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Vector256.Create(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Vector256.CreateScalar(nint)",
          "M:Vector256.CreateScalar(nuint)",
          "M:Vector256.CreateScalarUnsafe(nint)",
          "M:Vector256.CreateScalarUnsafe(nuint)",
          "M:Vector64.AsNInt\u003CT\u003E(Vector64\u003CT\u003E)",
          "M:Vector64.AsNUInt\u003CT\u003E(Vector64\u003CT\u003E)",
          "M:Vector64.Create(nint)",
          "M:Vector64.Create(nuint)",
          "M:Vector64.CreateScalar(nint)",
          "M:Vector64.CreateScalar(nuint)",
          "M:Vector64.CreateScalarUnsafe(nint)",
          "M:Vector64.CreateScalarUnsafe(nuint)",
          "T:Vector128",
          "T:Vector256",
          "T:Vector64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52021,
          "Title": "Extend System.Runtime.Intrinsics.X86 to support nint and nuint",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-28T23:31:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52021",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849843507",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52021#issuecomment-849843507",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract partial class Sse\r\n    {\r\n        public static Vector128\u003Cfloat\u003E ConvertScalarToVector128Single(Vector128\u003Cfloat\u003E upper, nint value);\r\n\r\n        public static nint ConvertToNInt(Vector128\u003Cfloat\u003E value);\r\n        public static nint ConvertToNIntWithTruncation(Vector128\u003Cfloat\u003E value);\r\n    }\r\n\r\n    public abstract partial class Sse2\r\n    {\r\n        public static Vector128\u003Cdouble\u003E ConvertScalarToVector128Double(Vector128\u003Cdouble\u003E upper, nint value);\r\n\r\n        public static Vector128\u003Cnint\u003E ConvertScalarToVector128NInt(nint value);\r\n        public static Vector128\u003Cnuint\u003E ConvertScalarToVector128NUInt(nuint value);\r\n\r\n        public static nint ConvertToNInt(Vector128\u003Cdouble\u003E value);\r\n        public static nint ConvertToNIntWithTruncation(Vector128\u003Cdouble\u003E value);\r\n\r\n        public static nint ConvertToNInt(Vector128\u003Cnint\u003E value);\r\n        public static nuint ConvertToNUInt(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static unsafe void StoreNonTemporal(nint* address, nint value);\r\n        public static unsafe void StoreNonTemporal(nuint* address, nuint value);\r\n\r\n        public static Vector128\u003Cnint\u003E Add(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Add(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E And(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E And(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E AndNot(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E AndNot(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E LoadVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadVector128(nuint* address);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E LoadAlignedVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadAlignedVector128(nuint* address);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E LoadScalarVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadScalarVector128(nuint* address);\r\n\r\n        public static Vector128\u003Cnint\u003E MoveScalar(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E MoveScalar(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector128\u003Cnint\u003E Or(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Or(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogical(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogical(Vector128\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogical(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogical(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogical128BitLane(Vector128\u003Cnint\u003E value, byte numBytes);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogical128BitLane(Vector128\u003Cnuint\u003E value, byte numBytes);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogical(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogical(Vector128\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogical(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogical(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogical128BitLane(Vector128\u003Cnint\u003E value, byte numBytes);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogical128BitLane(Vector128\u003Cnuint\u003E value, byte numBytes);\r\n\r\n        public static unsafe void StoreScalar(nint* address, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void StoreScalar(nuint* address, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void StoreAligned(nint* address, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void StoreAligned(nuint* address, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void StoreAlignedNonTemporal(nint* address, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void StoreAlignedNonTemporal(nuint* address, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void Store(nint* address, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void Store(nuint* address, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static Vector128\u003Cnint\u003E Subtract(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Subtract(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E UnpackHigh(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E UnpackHigh(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E UnpackLow(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E UnpackLow(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E Xor(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Xor(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n    }\r\n\r\n    public abstract partial class Sse3\r\n    {\r\n        public static unsafe Vector128\u003Cnint\u003E LoadDquVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadDquVector128(nuint* address);\r\n    }\r\n\r\n    public abstract partial class Ssse3\r\n    {\r\n        public static Vector128\u003Cnint\u003E AlignRight(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right, byte mask);\r\n        public static Vector128\u003Cnuint\u003E AlignRight(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right, byte mask);\r\n    }\r\n\r\n    public abstract partial class Sse41\r\n    {\r\n        public static nint Extract(Vector128\u003Cnint\u003E value, byte index);\r\n        public static nuint Extract(Vector128\u003Cnuint\u003E value, byte index);\r\n\r\n        public static Vector128\u003Cnint\u003E Insert(Vector128\u003Cnint\u003E value, nint data, byte index);\r\n        public static Vector128\u003Cnuint\u003E Insert(Vector128\u003Cnuint\u003E value, nuint data, byte index);\r\n\r\n        public static Vector128\u003Cnint\u003E BlendVariable(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right, Vector128\u003Cnint\u003E mask);\r\n        public static Vector128\u003Cnuint\u003E BlendVariable(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right, Vector128\u003Cnuint\u003E mask);\r\n\r\n        public static Vector128\u003Cnint\u003E CompareEqual(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareEqual(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Csbyte\u003E value);\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Cbyte\u003E value);\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Cshort\u003E value);\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Cushort\u003E value);\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Cint\u003E value);\r\n        public static Vector128\u003Cnint\u003E ConvertToVector128NInt(Vector128\u003Cuint\u003E value);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(sbyte* address);\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(byte* address);\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(short* address);\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(ushort* address);\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(int* address);\r\n        public static unsafe Vector128\u003Cnint\u003E ConvertToVector128NInt(uint* address);\r\n\r\n        public static Vector128\u003Cnint\u003E Multiply(Vector128\u003Cint\u003E left, Vector128\u003Cint\u003E right);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E LoadAlignedVector128NonTemporal(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadAlignedVector128NonTemporal(nuint* address);\r\n\r\n        public static bool TestC(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static bool TestC(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static bool TestNotZAndNotC(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static bool TestNotZAndNotC(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static bool TestZ(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static bool TestZ(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n    }\r\n\r\n    public abstract partial class Sse42\r\n    {\r\n        public static Vector128\u003Cnint\u003E CompareGreaterThan(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n\r\n        public static nuint Crc32(nuint crc, nuint data);\r\n    }\r\n\r\n    public abstract partial class Avx\r\n    {\r\n        public static Vector128\u003Cnint\u003E ExtractVector128(Vector256\u003Cnint\u003E value, byte index);\r\n        public static Vector128\u003Cnuint\u003E ExtractVector128(Vector256\u003Cnuint\u003E value, byte index);\r\n\r\n        public static Vector256\u003Cnint\u003E InsertVector128(Vector256\u003Cnint\u003E value, Vector128\u003Cnint\u003E data, byte index);\r\n        public static Vector256\u003Cnuint\u003E InsertVector128(Vector256\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E data, byte index);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E LoadVector256(nint* address);\r\n        public static unsafe Vector256\u003Cnuint\u003E LoadVector256(nuint* address);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E LoadAlignedVector256(nint* address);\r\n        public static unsafe Vector256\u003Cnuint\u003E LoadAlignedVector256(nuint* address);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E LoadDquVector256(nint* address);\r\n        public static unsafe Vector256\u003Cnuint\u003E LoadDquVector256(nuint* address);\r\n\r\n        public static Vector256\u003Cnint\u003E Permute2x128(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right, byte control);\r\n        public static Vector256\u003Cnuint\u003E Permute2x128(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right, byte control);\r\n\r\n        public static unsafe void StoreAligned(nint* address, Vector256\u003Cnint\u003E source);\r\n        public static unsafe void StoreAligned(nuint* address, Vector256\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void StoreAlignedNonTemporal(nint* address, Vector256\u003Cnint\u003E source);\r\n        public static unsafe void StoreAlignedNonTemporal(nuint* address, Vector256\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void Store(nint* address, Vector256\u003Cnint\u003E source);\r\n        public static unsafe void Store(nuint* address, Vector256\u003Cnuint\u003E source);\r\n\r\n        public static bool TestC(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static bool TestC(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static bool TestNotZAndNotC(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static bool TestNotZAndNotC(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static bool TestZ(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static bool TestZ(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n    }\r\n\r\n    public abstract partial class Avx2\r\n    {\r\n        public static Vector256\u003Cnint\u003E Add(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E Add(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E AlignRight(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right, byte mask);\r\n        public static Vector256\u003Cnuint\u003E AlignRight(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right, byte mask);\r\n\r\n        public static Vector256\u003Cnint\u003E And(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E And(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E AndNot(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E AndNot(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E BlendVariable(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right, Vector256\u003Cnint\u003E mask);\r\n        public static Vector256\u003Cnuint\u003E BlendVariable(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right, Vector256\u003Cnuint\u003E mask);\r\n\r\n        public static Vector128\u003Cnint\u003E BroadcastScalarToVector128(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E BroadcastScalarToVector128(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E BroadcastScalarToVector128(nint* source);\r\n        public static unsafe Vector128\u003Cnuint\u003E BroadcastScalarToVector128(nuint* source);\r\n\r\n        public static Vector256\u003Cnint\u003E BroadcastScalarToVector256(Vector128\u003Cnint\u003E value);\r\n        public static Vector256\u003Cnuint\u003E BroadcastScalarToVector256(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E BroadcastScalarToVector256(nint* source);\r\n        public static unsafe Vector256\u003Cnuint\u003E BroadcastScalarToVector256(nuint* source);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E BroadcastVector128ToVector256(nint* address);\r\n        public static unsafe Vector256\u003Cnuint\u003E BroadcastVector128ToVector256(nuint* address);\r\n\r\n        public static Vector256\u003Cnint\u003E CompareEqual(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E CompareEqual(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E CompareGreaterThan(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Csbyte\u003E value);\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Cbyte\u003E value);\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Cshort\u003E value);\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Cushort\u003E value);\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Cint\u003E value);\r\n        public static Vector256\u003Cnint\u003E ConvertToVector256NInt(Vector128\u003Cuint\u003E value);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(sbyte* address);\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(byte* address);\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(short* address);\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(ushort* address);\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(int* address);\r\n        public static unsafe Vector256\u003Cnint\u003E ConvertToVector256NInt(uint* address);\r\n\r\n        public static new Vector128\u003Cnint\u003E ExtractVector128(Vector256\u003Cnint\u003E value, byte index);\r\n        public static new Vector128\u003Cnuint\u003E ExtractVector128(Vector256\u003Cnuint\u003E value, byte index);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E GatherVector128(nint* baseAddress, Vector128\u003Cint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cnuint\u003E GatherVector128(nuint* baseAddress, Vector128\u003Cint\u003E index, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cint\u003E GatherVector128(int* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cuint\u003E GatherVector128(uint* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cnint\u003E GatherVector128(long* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cnuint\u003E GatherVector128(ulong* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cnint\u003E GatherVector128(nint* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cnuint\u003E GatherVector128(nuint* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cfloat\u003E GatherVector128(float* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cdouble\u003E GatherVector128(double* baseAddress, Vector128\u003Cnint\u003E index, byte scale);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E GatherVector256(nint* baseAddress, Vector128\u003Cint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cnuint\u003E GatherVector256(nuint* baseAddress, Vector128\u003Cint\u003E index, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cint\u003E GatherVector128(int* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cuint\u003E GatherVector128(uint* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cnint\u003E GatherVector256(long* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cnuint\u003E GatherVector256(ulong* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cnint\u003E GatherVector256(nint* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cnuint\u003E GatherVector256(nuint* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector128\u003Cfloat\u003E GatherVector128(float* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n        public static unsafe Vector256\u003Cdouble\u003E GatherVector256(double* baseAddress, Vector256\u003Cnint\u003E index, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E GatherMaskVector128(Vector128\u003Cnint\u003E source, nint* baseAddress, Vector128\u003Cint\u003E index, Vector128\u003Cnint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cnuint\u003E GatherMaskVector128(Vector128\u003Cnuint\u003E source, nuint* baseAddress, Vector128\u003Cint\u003E index, Vector128\u003Cnuint\u003E mask, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cint\u003E GatherMaskVector128(Vector128\u003Cint\u003E source, int* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cuint\u003E GatherMaskVector128(Vector128\u003Cuint\u003E source, uint* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cuint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Clong\u003E GatherMaskVector128(Vector128\u003Clong\u003E source, long* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Clong\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Culong\u003E GatherMaskVector128(Vector128\u003Culong\u003E source, ulong* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Clong\u003E mask, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E GatherMaskVector128(Vector128\u003Cnint\u003E source, nint* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cnint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cnuint\u003E GatherMaskVector128(Vector128\u003Cnuint\u003E source, nuint* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cnuint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cfloat\u003E GatherMaskVector128(Vector128\u003Cfloat\u003E source, float* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cfloat\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cdouble\u003E GatherMaskVector128(Vector128\u003Cdouble\u003E source, double* baseAddress, Vector128\u003Cnint\u003E index, Vector128\u003Cdouble\u003E mask, byte scale);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E GatherMaskVector256(Vector256\u003Cnint\u003E source, nint* baseAddress, Vector128\u003Cint\u003E index, Vector256\u003Cnint\u003E mask, byte scale);\r\n        public static unsafe Vector256\u003Cnuint\u003E GatherMaskVector256(Vector256\u003Cnuint\u003E source, nuint* baseAddress, Vector128\u003Cint\u003E index, Vector256\u003Cnuint\u003E mask, byte scale);\r\n\r\n        public static unsafe Vector128\u003Cint\u003E GatherMaskVector128(Vector128\u003Cint\u003E source, int* baseAddress, Vector256\u003Cnint\u003E index, Vector128\u003Cint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cuint\u003E GatherMaskVector128(Vector128\u003Cuint\u003E source, uint* baseAddress, Vector256\u003Cnint\u003E index, Vector128\u003Cuint\u003E mask, byte scale);\r\n        public static unsafe Vector256\u003Clong\u003E GatherMaskVector256(Vector256\u003Clong\u003E source, long* baseAddress, Vector256\u003Cnint\u003E index, Vector256\u003Clong\u003E mask, byte scale);\r\n        public static unsafe Vector256\u003Culong\u003E GatherMaskVector256(Vector256\u003Culong\u003E source, ulong* baseAddress, Vector256\u003Cnint\u003E index, Vector256\u003Culong\u003E mask, byte scale);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E GatherMaskVector256(Vector256\u003Cnint\u003E source, nint* baseAddress, Vector256\u003Cnint\u003E index, Vector256\u003Cnint\u003E mask, byte scale);\r\n        public static unsafe Vector256\u003Cnuint\u003E GatherMaskVector256(Vector256\u003Cnuint\u003E source, nuint* baseAddress, Vector256\u003Cnint\u003E index, Vector256\u003Cnuint\u003E mask, byte scale);\r\n        public static unsafe Vector128\u003Cfloat\u003E GatherMaskVector128(Vector128\u003Cfloat\u003E source, float* baseAddress, Vector256\u003Cnint\u003E index, Vector128\u003Cfloat\u003E mask, byte scale);\r\n        public static unsafe Vector256\u003Cdouble\u003E GatherMaskVector256(Vector256\u003Cdouble\u003E source, double* baseAddress, Vector256\u003Cnint\u003E index, Vector256\u003Cdouble\u003E mask, byte scale);\r\n\r\n        public static new Vector256\u003Cnint\u003E InsertVector128(Vector256\u003Cnint\u003E value, Vector128\u003Cnint\u003E data, byte index);\r\n        public static new Vector256\u003Cnuint\u003E InsertVector128(Vector256\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E data, byte index);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E LoadAlignedVector256NonTemporal(nint* address);\r\n        public static unsafe Vector256\u003Cnuint\u003E LoadAlignedVector256NonTemporal(nuint* address);\r\n\r\n        public static unsafe Vector128\u003Cnint\u003E MaskLoad(nint* address, Vector128\u003Cnint\u003E mask);\r\n        public static unsafe Vector128\u003Cnuint\u003E MaskLoad(nuint* address, Vector128\u003Cnuint\u003E mask);\r\n\r\n        public static unsafe Vector256\u003Cnint\u003E MaskLoad(nint* address, Vector256\u003Cnint\u003E mask);\r\n        public static unsafe Vector256\u003Cnuint\u003E MaskLoad(nuint* address, Vector256\u003Cnuint\u003E mask);\r\n\r\n        public static unsafe void MaskStore(nint* address, Vector128\u003Cnint\u003E mask, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void MaskStore(nuint* address, Vector128\u003Cnuint\u003E mask, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void MaskStore(nint* address, Vector256\u003Cnint\u003E mask, Vector256\u003Cnint\u003E source);\r\n        public static unsafe void MaskStore(nuint* address, Vector256\u003Cnuint\u003E mask, Vector256\u003Cnuint\u003E source);\r\n\r\n        public static Vector256\u003Cnint\u003E Or(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E Or(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static new Vector256\u003Cnint\u003E Permute2x128(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right, byte control);\r\n        public static new Vector256\u003Cnuint\u003E Permute2x128(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right, byte control);\r\n\r\n        public static Vector256\u003Cnint\u003E Permute4x64(Vector256\u003Cnint\u003E value, byte control);\r\n        public static Vector256\u003Cnuint\u003E Permute4x64(Vector256\u003Cnuint\u003E value, byte control);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftLeftLogical(Vector256\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector256\u003Cnuint\u003E ShiftLeftLogical(Vector256\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftLeftLogical(Vector256\u003Cnint\u003E value, byte count);\r\n        public static Vector256\u003Cnuint\u003E ShiftLeftLogical(Vector256\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftLeftLogical128BitLane(Vector256\u003Cnint\u003E value, byte numBytes);\r\n        public static Vector256\u003Cnuint\u003E ShiftLeftLogical128BitLane(Vector256\u003Cnuint\u003E value, byte numBytes);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftLeftLogicalVariable(Vector256\u003Cnint\u003E value, Vector256\u003Cnuint\u003E count);\r\n        public static Vector256\u003Cnuint\u003E ShiftLeftLogicalVariable(Vector256\u003Cnuint\u003E value, Vector256\u003Cnuint\u003E count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogicalVariable(Vector128\u003Cnint\u003E value, Vector128\u003Cnuint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogicalVariable(Vector128\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftRightLogical(Vector256\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector256\u003Cnuint\u003E ShiftRightLogical(Vector256\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftRightLogical(Vector256\u003Cnint\u003E value, byte count);\r\n        public static Vector256\u003Cnuint\u003E ShiftRightLogical(Vector256\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftRightLogical128BitLane(Vector256\u003Cnint\u003E value, byte numBytes);\r\n        public static Vector256\u003Cnuint\u003E ShiftRightLogical128BitLane(Vector256\u003Cnuint\u003E value, byte numBytes);\r\n\r\n        public static Vector256\u003Cnint\u003E ShiftRightLogicalVariable(Vector256\u003Cnint\u003E value, Vector256\u003Cnuint\u003E count);\r\n        public static Vector256\u003Cnuint\u003E ShiftRightLogicalVariable(Vector256\u003Cnuint\u003E value, Vector256\u003Cnuint\u003E count);\r\n\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogicalVariable(Vector128\u003Cnint\u003E value, Vector128\u003Cnuint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogicalVariable(Vector128\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E count);\r\n\r\n        public static Vector256\u003Cnint\u003E Subtract(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E Subtract(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E UnpackHigh(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E UnpackHigh(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E UnpackLow(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E UnpackLow(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n\r\n        public static Vector256\u003Cnint\u003E Xor(Vector256\u003Cnint\u003E left, Vector256\u003Cnint\u003E right);\r\n        public static Vector256\u003Cnuint\u003E Xor(Vector256\u003Cnuint\u003E left, Vector256\u003Cnuint\u003E right);\r\n    }\r\n\r\n    public abstract partial class Bmi1\r\n    {\r\n        public static nuint AndNot(nuint left, nuint right);\r\n\r\n        public static nuint BitFieldExtract(nuint value, byte start, byte length);\r\n        public static nuint BitFieldExtract(nuint value, ushort control);\r\n\r\n        public static nuint ExtractLowestSetBit(nuint value);\r\n\r\n        public static nuint GetMaskUpToLowestSetBit(nuint value);\r\n\r\n        public static nuint ResetLowestSetBit(nuint value);\r\n\r\n        public static nuint TrailingZeroCount(nuint value);\r\n    }\r\n\r\n    public abstract partial class Bmi2\r\n    {\r\n        public static nuint ZeroHighBits(nuint value, nuint index);\r\n\r\n        public static nuint MultiplyNoFlags(nuint left, nuint right);\r\n        public static unsafe nuint MultiplyNoFlags(nuint left, nuint right, nuint* low);\r\n\r\n        public static nuint ParallelBitDeposit(nuint value, nuint mask);\r\n\r\n        public static nuint ParallelBitExtract(nuint value, nuint mask);\r\n    }\r\n\r\n    public abstract partial class Lzcnt\r\n    {\r\n        public static nuint LeadingZeroCount(nuint value);\r\n    }\r\n\r\n    public abstract partial class Popcnt\r\n    {\r\n        public static nuint PopCount(nuint value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 41820000000,
        "Apis": [
          "M:Avx.ExtractVector128(Vector256\u003Cnint\u003E,byte)",
          "M:Avx.ExtractVector128(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx.InsertVector128(Vector256\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:Avx.InsertVector128(Vector256\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:Avx.LoadAlignedVector256(nint*)",
          "M:Avx.LoadAlignedVector256(nuint*)",
          "M:Avx.LoadDquVector256(nint*)",
          "M:Avx.LoadDquVector256(nuint*)",
          "M:Avx.LoadVector256(nint*)",
          "M:Avx.LoadVector256(nuint*)",
          "M:Avx.Permute2x128(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E,byte)",
          "M:Avx.Permute2x128(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E,byte)",
          "M:Avx.Store(nint*,Vector256\u003Cnint\u003E)",
          "M:Avx.Store(nuint*,Vector256\u003Cnuint\u003E)",
          "M:Avx.StoreAligned(nint*,Vector256\u003Cnint\u003E)",
          "M:Avx.StoreAligned(nuint*,Vector256\u003Cnuint\u003E)",
          "M:Avx.StoreAlignedNonTemporal(nint*,Vector256\u003Cnint\u003E)",
          "M:Avx.StoreAlignedNonTemporal(nuint*,Vector256\u003Cnuint\u003E)",
          "M:Avx.TestC(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx.TestC(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx.TestNotZAndNotC(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx.TestNotZAndNotC(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx.TestZ(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx.TestZ(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.Add(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.Add(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.AlignRight(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.AlignRight(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.And(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.And(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.AndNot(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.AndNot(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.BlendVariable(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.BlendVariable(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.BroadcastScalarToVector128(nint*)",
          "M:Avx2.BroadcastScalarToVector128(nuint*)",
          "M:Avx2.BroadcastScalarToVector128(Vector128\u003Cnint\u003E)",
          "M:Avx2.BroadcastScalarToVector128(Vector128\u003Cnuint\u003E)",
          "M:Avx2.BroadcastScalarToVector256(nint*)",
          "M:Avx2.BroadcastScalarToVector256(nuint*)",
          "M:Avx2.BroadcastScalarToVector256(Vector128\u003Cnint\u003E)",
          "M:Avx2.BroadcastScalarToVector256(Vector128\u003Cnuint\u003E)",
          "M:Avx2.BroadcastVector128ToVector256(nint*)",
          "M:Avx2.BroadcastVector128ToVector256(nuint*)",
          "M:Avx2.CompareEqual(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.CompareEqual(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.CompareGreaterThan(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.ConvertToVector256NInt(byte*)",
          "M:Avx2.ConvertToVector256NInt(int*)",
          "M:Avx2.ConvertToVector256NInt(sbyte*)",
          "M:Avx2.ConvertToVector256NInt(short*)",
          "M:Avx2.ConvertToVector256NInt(uint*)",
          "M:Avx2.ConvertToVector256NInt(ushort*)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Cbyte\u003E)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Cint\u003E)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Csbyte\u003E)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Cshort\u003E)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Cuint\u003E)",
          "M:Avx2.ConvertToVector256NInt(Vector128\u003Cushort\u003E)",
          "M:Avx2.ExtractVector128(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.ExtractVector128(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cdouble\u003E,double*,Vector128\u003Cnint\u003E,Vector128\u003Cdouble\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cfloat\u003E,float*,Vector128\u003Cnint\u003E,Vector128\u003Cfloat\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cfloat\u003E,float*,Vector256\u003Cnint\u003E,Vector128\u003Cfloat\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cint\u003E,int*,Vector128\u003Cnint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cint\u003E,int*,Vector256\u003Cnint\u003E,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Clong\u003E,long*,Vector128\u003Cnint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cnint\u003E,nint*,Vector128\u003Cint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cnint\u003E,nint*,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cnuint\u003E,nuint*,Vector128\u003Cint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cnuint\u003E,nuint*,Vector128\u003Cnint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cuint\u003E,uint*,Vector128\u003Cnint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Cuint\u003E,uint*,Vector256\u003Cnint\u003E,Vector128\u003Cuint\u003E,byte)",
          "M:Avx2.GatherMaskVector128(Vector128\u003Culong\u003E,ulong*,Vector128\u003Cnint\u003E,Vector128\u003Clong\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Cdouble\u003E,double*,Vector256\u003Cnint\u003E,Vector256\u003Cdouble\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Clong\u003E,long*,Vector256\u003Cnint\u003E,Vector256\u003Clong\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Cnint\u003E,nint*,Vector128\u003Cint\u003E,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Cnint\u003E,nint*,Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Cnuint\u003E,nuint*,Vector128\u003Cint\u003E,Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Cnuint\u003E,nuint*,Vector256\u003Cnint\u003E,Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.GatherMaskVector256(Vector256\u003Culong\u003E,ulong*,Vector256\u003Cnint\u003E,Vector256\u003Culong\u003E,byte)",
          "M:Avx2.GatherVector128(double*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(float*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(float*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(int*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(int*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(long*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(nint*,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherVector128(nint*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(nuint*,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherVector128(nuint*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(uint*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(uint*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector128(ulong*,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector256(double*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector256(long*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector256(nint*,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherVector256(nint*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector256(nuint*,Vector128\u003Cint\u003E,byte)",
          "M:Avx2.GatherVector256(nuint*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.GatherVector256(ulong*,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.InsertVector128(Vector256\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:Avx2.InsertVector128(Vector256\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:Avx2.LoadAlignedVector256NonTemporal(nint*)",
          "M:Avx2.LoadAlignedVector256NonTemporal(nuint*)",
          "M:Avx2.MaskLoad(nint*,Vector128\u003Cnint\u003E)",
          "M:Avx2.MaskLoad(nint*,Vector256\u003Cnint\u003E)",
          "M:Avx2.MaskLoad(nuint*,Vector128\u003Cnuint\u003E)",
          "M:Avx2.MaskLoad(nuint*,Vector256\u003Cnuint\u003E)",
          "M:Avx2.MaskStore(nint*,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Avx2.MaskStore(nint*,Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.MaskStore(nuint*,Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.MaskStore(nuint*,Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.Or(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.Or(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.Permute2x128(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.Permute2x128(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.Permute4x64(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.Permute4x64(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.ShiftLeftLogical(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.ShiftLeftLogical(Vector256\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Avx2.ShiftLeftLogical(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.ShiftLeftLogical(Vector256\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftLeftLogical128BitLane(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.ShiftLeftLogical128BitLane(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.ShiftLeftLogicalVariable(Vector128\u003Cnint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftLeftLogicalVariable(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftLeftLogicalVariable(Vector256\u003Cnint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.ShiftLeftLogicalVariable(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.ShiftRightLogical(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.ShiftRightLogical(Vector256\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Avx2.ShiftRightLogical(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.ShiftRightLogical(Vector256\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftRightLogical128BitLane(Vector256\u003Cnint\u003E,byte)",
          "M:Avx2.ShiftRightLogical128BitLane(Vector256\u003Cnuint\u003E,byte)",
          "M:Avx2.ShiftRightLogicalVariable(Vector128\u003Cnint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftRightLogicalVariable(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Avx2.ShiftRightLogicalVariable(Vector256\u003Cnint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.ShiftRightLogicalVariable(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.Subtract(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.Subtract(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.UnpackHigh(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.UnpackHigh(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.UnpackLow(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.UnpackLow(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Avx2.Xor(Vector256\u003Cnint\u003E,Vector256\u003Cnint\u003E)",
          "M:Avx2.Xor(Vector256\u003Cnuint\u003E,Vector256\u003Cnuint\u003E)",
          "M:Bmi1.AndNot(nuint,nuint)",
          "M:Bmi1.BitFieldExtract(nuint,byte,byte)",
          "M:Bmi1.BitFieldExtract(nuint,ushort)",
          "M:Bmi1.ExtractLowestSetBit(nuint)",
          "M:Bmi1.GetMaskUpToLowestSetBit(nuint)",
          "M:Bmi1.ResetLowestSetBit(nuint)",
          "M:Bmi1.TrailingZeroCount(nuint)",
          "M:Bmi2.MultiplyNoFlags(nuint,nuint,nuint*)",
          "M:Bmi2.MultiplyNoFlags(nuint,nuint)",
          "M:Bmi2.ParallelBitDeposit(nuint,nuint)",
          "M:Bmi2.ParallelBitExtract(nuint,nuint)",
          "M:Bmi2.ZeroHighBits(nuint,nuint)",
          "M:Lzcnt.LeadingZeroCount(nuint)",
          "M:Popcnt.PopCount(nuint)",
          "M:Sse.ConvertScalarToVector128Single(Vector128\u003Cfloat\u003E,nint)",
          "M:Sse.ConvertToNInt(Vector128\u003Cfloat\u003E)",
          "M:Sse.ConvertToNIntWithTruncation(Vector128\u003Cfloat\u003E)",
          "M:Sse2.Add(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.Add(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.And(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.And(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.AndNot(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.AndNot(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.ConvertScalarToVector128Double(Vector128\u003Cdouble\u003E,nint)",
          "M:Sse2.ConvertScalarToVector128NInt(nint)",
          "M:Sse2.ConvertScalarToVector128NUInt(nuint)",
          "M:Sse2.ConvertToNInt(Vector128\u003Cdouble\u003E)",
          "M:Sse2.ConvertToNInt(Vector128\u003Cnint\u003E)",
          "M:Sse2.ConvertToNIntWithTruncation(Vector128\u003Cdouble\u003E)",
          "M:Sse2.ConvertToNUInt(Vector128\u003Cnuint\u003E)",
          "M:Sse2.LoadAlignedVector128(nint*)",
          "M:Sse2.LoadAlignedVector128(nuint*)",
          "M:Sse2.LoadScalarVector128(nint*)",
          "M:Sse2.LoadScalarVector128(nuint*)",
          "M:Sse2.LoadVector128(nint*)",
          "M:Sse2.LoadVector128(nuint*)",
          "M:Sse2.MoveScalar(Vector128\u003Cnint\u003E)",
          "M:Sse2.MoveScalar(Vector128\u003Cnuint\u003E)",
          "M:Sse2.Or(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.Or(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.ShiftLeftLogical(Vector128\u003Cnint\u003E,byte)",
          "M:Sse2.ShiftLeftLogical(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.ShiftLeftLogical(Vector128\u003Cnuint\u003E,byte)",
          "M:Sse2.ShiftLeftLogical(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.ShiftLeftLogical128BitLane(Vector128\u003Cnint\u003E,byte)",
          "M:Sse2.ShiftLeftLogical128BitLane(Vector128\u003Cnuint\u003E,byte)",
          "M:Sse2.ShiftRightLogical(Vector128\u003Cnint\u003E,byte)",
          "M:Sse2.ShiftRightLogical(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.ShiftRightLogical(Vector128\u003Cnuint\u003E,byte)",
          "M:Sse2.ShiftRightLogical(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.ShiftRightLogical128BitLane(Vector128\u003Cnint\u003E,byte)",
          "M:Sse2.ShiftRightLogical128BitLane(Vector128\u003Cnuint\u003E,byte)",
          "M:Sse2.Store(nint*,Vector128\u003Cnint\u003E)",
          "M:Sse2.Store(nuint*,Vector128\u003Cnuint\u003E)",
          "M:Sse2.StoreAligned(nint*,Vector128\u003Cnint\u003E)",
          "M:Sse2.StoreAligned(nuint*,Vector128\u003Cnuint\u003E)",
          "M:Sse2.StoreAlignedNonTemporal(nint*,Vector128\u003Cnint\u003E)",
          "M:Sse2.StoreAlignedNonTemporal(nuint*,Vector128\u003Cnuint\u003E)",
          "M:Sse2.StoreNonTemporal(nint*,nint)",
          "M:Sse2.StoreNonTemporal(nuint*,nuint)",
          "M:Sse2.StoreScalar(nint*,Vector128\u003Cnint\u003E)",
          "M:Sse2.StoreScalar(nuint*,Vector128\u003Cnuint\u003E)",
          "M:Sse2.Subtract(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.Subtract(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.UnpackHigh(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.UnpackHigh(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.UnpackLow(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.UnpackLow(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse2.Xor(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse2.Xor(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse3.LoadDquVector128(nint*)",
          "M:Sse3.LoadDquVector128(nuint*)",
          "M:Sse41.BlendVariable(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse41.BlendVariable(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse41.CompareEqual(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse41.CompareEqual(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse41.ConvertToVector128NInt(byte*)",
          "M:Sse41.ConvertToVector128NInt(int*)",
          "M:Sse41.ConvertToVector128NInt(sbyte*)",
          "M:Sse41.ConvertToVector128NInt(short*)",
          "M:Sse41.ConvertToVector128NInt(uint*)",
          "M:Sse41.ConvertToVector128NInt(ushort*)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Cbyte\u003E)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Cint\u003E)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Csbyte\u003E)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Cshort\u003E)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Cuint\u003E)",
          "M:Sse41.ConvertToVector128NInt(Vector128\u003Cushort\u003E)",
          "M:Sse41.Extract(Vector128\u003Cnint\u003E,byte)",
          "M:Sse41.Extract(Vector128\u003Cnuint\u003E,byte)",
          "M:Sse41.Insert(Vector128\u003Cnint\u003E,nint,byte)",
          "M:Sse41.Insert(Vector128\u003Cnuint\u003E,nuint,byte)",
          "M:Sse41.LoadAlignedVector128NonTemporal(nint*)",
          "M:Sse41.LoadAlignedVector128NonTemporal(nuint*)",
          "M:Sse41.Multiply(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Sse41.TestC(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse41.TestC(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse41.TestNotZAndNotC(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse41.TestNotZAndNotC(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse41.TestZ(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse41.TestZ(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:Sse42.CompareGreaterThan(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:Sse42.Crc32(nuint,nuint)",
          "M:Ssse3.AlignRight(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:Ssse3.AlignRight(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "T:Avx",
          "T:Avx2",
          "T:Bmi1",
          "T:Bmi2",
          "T:Lzcnt",
          "T:Popcnt",
          "T:Sse",
          "T:Sse2",
          "T:Sse3",
          "T:Sse41",
          "T:Sse42",
          "T:Ssse3"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52027,
          "Title": "Extend System.Runtime.Intrinsics.Arm to support nint and nuint",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-29T00:36:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52027",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-arm64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849844261",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52027#issuecomment-849844261",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.Arm\r\n{\r\n    public abstract partial class ArmBase\r\n    {\r\n        public abstract partial class Arm64\r\n        {\r\n            public static int LeadingSignCount(nint value);\r\n        }\r\n\r\n        public static int LeadingZeroCount(nint value);\r\n        public static int LeadingZeroCount(nuint value);\r\n\r\n        public static nint ReverseElementBits(nint value);\r\n        public static nuint ReverseElementBits(nuint value)\r\n    }\r\n\r\n    public abstract partial class AdvSimd\r\n    {\r\n        public abstract partial class Arm64\r\n        {\r\n            public static Vector128\u003Cnint\u003E AddPairwise(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E AddPairwise(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E AddSaturate(Vector64\u003Cnint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E AddSaturate(Vector64\u003Cnuint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnint\u003E AddSaturate(Vector128\u003Cnint\u003E left, Vector128\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E AddSaturate(Vector128\u003Cnuint\u003E left, Vector128\u003Cnint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E InsertSelectedScalar(Vector64\u003Cnint\u003E result, byte resultIndex, Vector64\u003Cnint\u003E value, byte valueIndex);\r\n            public static Vector64\u003Cnuint\u003E InsertSelectedScalar(Vector64\u003Cnuint\u003E result, byte resultIndex, Vector64\u003Cnuint\u003E value, byte valueIndex);\r\n            public static Vector128\u003Cnint\u003E InsertSelectedScalar(Vector128\u003Cnint\u003E result, byte resultIndex, Vector128\u003Cnint\u003E value, byte valueIndex);\r\n            public static Vector128\u003Cnuint\u003E InsertSelectedScalar(Vector128\u003Cnuint\u003E result, byte resultIndex, Vector128\u003Cnuint\u003E value, byte valueIndex);\r\n\r\n            public static unsafe void StorePair(nint* address, Vector64\u003Cnint\u003E value1, Vector64\u003Cnint\u003E value2);\r\n            public static unsafe void StorePair(nuint* address, Vector64\u003Cnuint\u003E value1, Vector64\u003Cnuint\u003E value2);\r\n            public static unsafe void StorePair(nint* address, Vector128\u003Cnint\u003E value1, Vector128\u003Cnint\u003E value2);\r\n            public static unsafe void StorePair(nuint* address, Vector128\u003Cnuint\u003E value1, Vector128\u003Cnuint\u003E value2);\r\n\r\n            public static unsafe void StorePairNonTemporal(nint* address, Vector64\u003Cnint\u003E value1, Vector64\u003Cnint\u003E value2);\r\n            public static unsafe void StorePairNonTemporal(nuint* address, Vector64\u003Cnuint\u003E value1, Vector64\u003Cnuint\u003E value2);\r\n            public static unsafe void StorePairNonTemporal(nint* address, Vector128\u003Cnint\u003E value1, Vector128\u003Cnint\u003E value2);\r\n            public static unsafe void StorePairNonTemporal(nuint* address, Vector128\u003Cnuint\u003E value1, Vector128\u003Cnuint\u003E value2);\r\n\r\n            public static Vector64\u003Cnint\u003E TransposeEven(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E TransposeEven(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E TransposeEven(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E TransposeEven(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E TransposeOdd(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E TransposeOdd(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E TransposeOdd(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E TransposeOdd(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E UnzipEven(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E UnzipEven(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E UnzipEven(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E UnzipEven(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E UnzipOdd(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E UnzipOdd(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E UnzipOdd(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E UnzipOdd(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E ZipHigh(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E ZipHigh(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E ZipHigh(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E ZipHigh(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n            public static Vector64\u003Cnint\u003E ZipLow(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n            public static Vector64\u003Cnuint\u003E ZipLow(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n            public static Vector128\u003Cnint\u003E ZipLow(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n            public static Vector128\u003Cnuint\u003E ZipLow(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n        }\r\n\r\n        public static Vector64\u003Cnuint\u003E Abs(Vector64\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E Abs(Vector128\u003Cnint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E AbsSaturate(Vector64\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnint\u003E AbsSaturate(Vector128\u003Cnint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E Add(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E Add(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E Add(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Add(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E AddPairwiseScalar(Vector128\u003Cnint\u003E value);\r\n        public static Vector64\u003Cnuint\u003E AddPairwiseScalar(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E AddSaturate(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E AddSaturate(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E AddSaturate(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E AddSaturate(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E And(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E And(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E And(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E And(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E BitwiseClear(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E mask);\r\n        public static Vector64\u003Cnuint\u003E BitwiseClear(Vector64\u003Cnuint\u003E value, Vector64\u003Cnuint\u003E mask);\r\n        public static Vector128\u003Cnint\u003E BitwiseClear(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E mask);\r\n        public static Vector128\u003Cnuint\u003E BitwiseClear(Vector128\u003Cnuint\u003E value, Vector128\u003Cnuint\u003E mask);\r\n\r\n        public static Vector64\u003Cnint\u003E BitwiseSelect(Vector64\u003Cnint\u003E select, Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E BitwiseSelect(Vector64\u003Cnuint\u003E select, Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E BitwiseSelect(Vector128\u003Cnint\u003E select, Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E BitwiseSelect(Vector128\u003Cnuint\u003E select, Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareEqual(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareEqual(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareEqual(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareEqual(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareGreaterThan(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareGreaterThan(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareGreaterThan(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareGreaterThan(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareGreaterThanOrEqual(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareGreaterThanOrEqual(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareGreaterThanOrEqual(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareGreaterThanOrEqual(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareLessThan(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareLessThan(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareLessThan(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareLessThan(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareLessThanOrEqual(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareLessThanOrEqual(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareLessThanOrEqual(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareLessThanOrEqual(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E CompareTest(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E CompareTest(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E CompareTest(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E CompareTest(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E DuplicateSelectedScalarToVector64(Vector128\u003Cnint\u003E value, byte index);\r\n        public static Vector64\u003Cnuint\u003E DuplicateSelectedScalarToVector64(Vector128\u003Cnuint\u003E value, byte index);\r\n        public static Vector128\u003Cnint\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cnint\u003E value, byte index);\r\n        public static Vector128\u003Cnuint\u003E DuplicateSelectedScalarToVector128(Vector128\u003Cnuint\u003E value, byte index);\r\n\r\n        public static Vector64\u003Cnint\u003E DuplicateToVector64(nint value);\r\n        public static Vector64\u003Cnuint\u003E DuplicateToVector64(nuint value);\r\n        public static Vector128\u003Cnint\u003E DuplicateToVector128(nint value);\r\n        public static Vector128\u003Cnuint\u003E DuplicateToVector128(nuint value);\r\n\r\n        public static nint Extract(Vector64\u003Cnint\u003E vector, byte index);\r\n        public static nuint Extract(Vector64\u003Cnuint\u003E vector, byte index);\r\n        public static nint Extract(Vector128\u003Cnint\u003E vector, byte index);\r\n        public static nuint Extract(Vector128\u003Cnuint\u003E vector, byte index);\r\n\r\n        public static Vector64\u003Cnint\u003E ExtractVector64(Vector64\u003Cnint\u003E upper, Vector64\u003Cnint\u003E lower, byte index);\r\n        public static Vector64\u003Cnuint\u003E ExtractVector64(Vector64\u003Cnuint\u003E upper, Vector64\u003Cnuint\u003E lower, byte index);\r\n        public static Vector128\u003Cnint\u003E ExtractVector128(Vector128\u003Cnint\u003E upper, Vector128\u003Cnint\u003E lower, byte index);\r\n        public static Vector128\u003Cnuint\u003E ExtractVector128(Vector128\u003Cnuint\u003E upper, Vector128\u003Cnuint\u003E lower, byte index);\r\n\r\n        public static Vector64\u003Cnint\u003E Insert(Vector64\u003Cnint\u003E vector, byte index, nint data);\r\n        public static Vector64\u003Cnuint\u003E Insert(Vector64\u003Cnuint\u003E vector, byte index, nuint data);\r\n        public static Vector128\u003Cnint\u003E Insert(Vector128\u003Cnint\u003E vector, byte index, nint data);\r\n        public static Vector128\u003Cnuint\u003E Insert(Vector128\u003Cnuint\u003E vector, byte index, nuint data);\r\n\r\n        public static unsafe Vector64\u003Cnint\u003E LoadAndInsertScalar(Vector64\u003Cnint\u003E value, byte index, nint* address);\r\n        public static unsafe Vector64\u003Cnuint\u003E LoadAndInsertScalar(Vector64\u003Cnuint\u003E value, byte index, nuint* address);\r\n        public static unsafe Vector128\u003Cnint\u003E LoadAndInsertScalar(Vector128\u003Cnint\u003E value, byte index, nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadAndInsertScalar(Vector128\u003Cnuint\u003E value, byte index, nuint* address);\r\n\r\n        public static unsafe Vector64\u003Cnint\u003E LoadAndReplicateToVector64(nint* address);\r\n        public static unsafe Vector64\u003Cnuint\u003E LoadAndReplicateToVector64(nuint* address);\r\n        public static unsafe Vector128\u003Cnint\u003E LoadAndReplicateToVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadAndReplicateToVector128(nuint* address);\r\n\r\n        public static unsafe Vector64\u003Cnint\u003E LoadVector64(nint* address);\r\n        public static unsafe Vector64\u003Cnuint\u003E LoadVector64(nuint* address);\r\n        public static unsafe Vector128\u003Cnint\u003E LoadVector128(nint* address);\r\n        public static unsafe Vector128\u003Cnuint\u003E LoadVector128(nuint* address);\r\n\r\n        public static Vector64\u003Cnint\u003E Negate(Vector64\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnint\u003E Negate(Vector128\u003Cnint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E NegateSaturate(Vector64\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnint\u003E NegateSaturate(Vector128\u003Cnint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E Not(Vector64\u003Cnint\u003E value);\r\n        public static Vector64\u003Cnuint\u003E Not(Vector64\u003Cnuint\u003E value);\r\n        public static Vector128\u003Cnint\u003E Not(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E Not(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E Or(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E Or(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E Or(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Or(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E OrNot(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E OrNot(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E OrNot(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E OrNot(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E ReverseElement8(Vector64\u003Cnint\u003E value);\r\n        public static Vector64\u003Cnuint\u003E ReverseElement8(Vector64\u003Cnuint\u003E value);\r\n        public static Vector128\u003Cnint\u003E ReverseElement8(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E ReverseElement8(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E ReverseElement16(Vector64\u003Cnint\u003E value);\r\n        public static Vector64\u003Cnuint\u003E ReverseElement16(Vector64\u003Cnuint\u003E value);\r\n        public static Vector128\u003Cnint\u003E ReverseElement16(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E ReverseElement16(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E ReverseElement32(Vector64\u003Cnint\u003E value);\r\n        public static Vector64\u003Cnuint\u003E ReverseElement32(Vector64\u003Cnuint\u003E value);\r\n        public static Vector128\u003Cnint\u003E ReverseElement32(Vector128\u003Cnint\u003E value);\r\n        public static Vector128\u003Cnuint\u003E ReverseElement32(Vector128\u003Cnuint\u003E value);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftArithmetic(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftArithmetic(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftArithmeticRounded(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftArithmeticRounded(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftArithmeticRoundedSaturate(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftArithmeticRoundedSaturate(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftArithmeticSaturate(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftArithmeticSaturate(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLeftAndInsert(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right, byte shift);\r\n        public static Vector64\u003Cnuint\u003E ShiftLeftAndInsert(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right, byte shift);\r\n        public static Vector128\u003Cnint\u003E ShiftLeftAndInsert(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right, byte shift);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftAndInsert(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right, byte shift);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLeftLogical(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLeftLogical(Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogical(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogical(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLeftLogicalSaturate(Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogicalSaturate(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cnint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLogical(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLogical(Vector64\u003Cnuint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftLogical(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLogical(Vector128\u003Cnuint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLogicalRounded(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLogicalRounded(Vector64\u003Cnuint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftLogicalRounded(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLogicalRounded(Vector128\u003Cnuint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLogicalRoundedSaturate(Vector64\u003Cnuint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLogicalRoundedSaturate(Vector128\u003Cnuint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftLogicalSaturate(Vector64\u003Cnint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector64\u003Cnuint\u003E ShiftLogicalSaturate(Vector64\u003Cnuint\u003E value, Vector64\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnint\u003E ShiftLogicalSaturate(Vector128\u003Cnint\u003E value, Vector128\u003Cnint\u003E count);\r\n        public static Vector128\u003Cnuint\u003E ShiftLogicalSaturate(Vector128\u003Cnuint\u003E value, Vector128\u003Cnint\u003E count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightAndInsert(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right, byte shift);\r\n        public static Vector64\u003Cnuint\u003E ShiftRightAndInsert(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right, byte shift);\r\n        public static Vector128\u003Cnint\u003E ShiftRightAndInsert(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right, byte shift);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightAndInsert(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right, byte shift);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightArithmetic(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightArithmetic(Vector128\u003Cnint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightArithmeticAdd(Vector64\u003Cnint\u003E addend, Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightArithmeticAdd(Vector128\u003Cnint\u003E addend, Vector128\u003Cnint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightArithmeticRounded(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightArithmeticRounded(Vector128\u003Cnint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightArithmeticRoundedAdd(Vector64\u003Cnint\u003E addend, Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightArithmeticRoundedAdd(Vector128\u003Cnint\u003E addend, Vector128\u003Cnint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightLogical(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftRightLogical(Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogical(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogical(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightLogicalAdd(Vector64\u003Cnint\u003E addend, Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftRightLogicalAdd(Vector64\u003Cnuint\u003E addend, Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogicalAdd(Vector128\u003Cnint\u003E addend, Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogicalAdd(Vector128\u003Cnuint\u003E addend, Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightLogicalRounded(Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftRightLogicalRounded(Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogicalRounded(Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogicalRounded(Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static Vector64\u003Cnint\u003E ShiftRightLogicalRoundedAddScalar(Vector64\u003Cnint\u003E addend, Vector64\u003Cnint\u003E value, byte count);\r\n        public static Vector64\u003Cnuint\u003E ShiftRightLogicalRoundedAddScalar(Vector64\u003Cnuint\u003E addend, Vector64\u003Cnuint\u003E value, byte count);\r\n        public static Vector128\u003Cnint\u003E ShiftRightLogicalRoundedAdd(Vector128\u003Cnint\u003E addend, Vector128\u003Cnint\u003E value, byte count);\r\n        public static Vector128\u003Cnuint\u003E ShiftRightLogicalRoundedAdd(Vector128\u003Cnuint\u003E addend, Vector128\u003Cnuint\u003E value, byte count);\r\n\r\n        public static unsafe void Store(nint* address, Vector64\u003Cnint\u003E source);\r\n        public static unsafe void Store(nuint* address, Vector64\u003Cnuint\u003E source);\r\n        public static unsafe void Store(nint* address, Vector128\u003Cnint\u003E source);\r\n        public static unsafe void Store(nuint* address, Vector128\u003Cnuint\u003E source);\r\n\r\n        public static unsafe void StoreSelectedScalar(nint* address, Vector128\u003Cnint\u003E value, byte index);\r\n        public static unsafe void StoreSelectedScalar(nuint* address, Vector128\u003Cnuint\u003E value, byte index);\r\n        public static unsafe void StoreSelectedScalar(nint* address, Vector128\u003Cnint\u003E value, byte index);\r\n        public static unsafe void StoreSelectedScalar(nuint* address, Vector128\u003Cnuint\u003E value, byte index);\r\n\r\n        public static Vector64\u003Cnint\u003E Subtract(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E Subtract(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E Subtract(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Subtract(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E SubtractSaturate(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E SubtractSaturate(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E SubtractSaturate(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E SubtractSaturate(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n\r\n        public static Vector64\u003Cnint\u003E Xor(Vector64\u003Cnint\u003E left, Vector64\u003Cnint\u003E right);\r\n        public static Vector64\u003Cnuint\u003E Xor(Vector64\u003Cnuint\u003E left, Vector64\u003Cnuint\u003E right);\r\n        public static Vector128\u003Cnint\u003E Xor(Vector128\u003Cnint\u003E left, Vector128\u003Cnint\u003E right);\r\n        public static Vector128\u003Cnuint\u003E Xor(Vector128\u003Cnuint\u003E left, Vector128\u003Cnuint\u003E right);\r\n    }\r\n\r\n    public abstract partial class Crc32\r\n    {\r\n        public static uint ComputeCrc32(uint crc, nuint data);\r\n        public static uint ComputeCrc32C(uint crc, nuint data);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45440000000,
        "Apis": [
          "M:AdvSimd.Abs(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Abs(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.AbsSaturate(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.AbsSaturate(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Add(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Add(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Add(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Add(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.AddPairwiseScalar(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.AddPairwiseScalar(Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.AddSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.AddSaturate(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.AddSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.AddSaturate(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.And(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.And(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.And(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.And(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.AddPairwise(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.AddPairwise(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.AddSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.AddSaturate(Vector128\u003Cnuint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.AddSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.AddSaturate(Vector64\u003Cnuint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cnint\u003E,byte,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector128\u003Cnuint\u003E,byte,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector64\u003Cnint\u003E,byte,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.Arm64.InsertSelectedScalar(Vector64\u003Cnuint\u003E,byte,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Arm64.StorePair(nint*,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.StorePair(nint*,Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.StorePair(nuint*,Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.StorePair(nuint*,Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.StorePairNonTemporal(nint*,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.StorePairNonTemporal(nint*,Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.StorePairNonTemporal(nuint*,Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.StorePairNonTemporal(nuint*,Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.TransposeEven(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.TransposeOdd(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.UnzipEven(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.UnzipOdd(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.ZipHigh(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Arm64.ZipLow(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.BitwiseClear(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.BitwiseClear(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.BitwiseClear(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.BitwiseClear(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.BitwiseSelect(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.BitwiseSelect(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.BitwiseSelect(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.BitwiseSelect(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareEqual(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareEqual(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareEqual(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareEqual(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareGreaterThan(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareGreaterThan(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareGreaterThan(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareGreaterThan(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareGreaterThanOrEqual(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareGreaterThanOrEqual(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareGreaterThanOrEqual(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareGreaterThanOrEqual(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareLessThan(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareLessThan(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareLessThan(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareLessThan(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareLessThanOrEqual(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareLessThanOrEqual(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareLessThanOrEqual(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareLessThanOrEqual(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.CompareTest(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.CompareTest(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.CompareTest(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.CompareTest(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector128(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.DuplicateSelectedScalarToVector64(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.DuplicateToVector128(nint)",
          "M:AdvSimd.DuplicateToVector128(nuint)",
          "M:AdvSimd.DuplicateToVector64(nint)",
          "M:AdvSimd.DuplicateToVector64(nuint)",
          "M:AdvSimd.Extract(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.Extract(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Extract(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.Extract(Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ExtractVector128(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ExtractVector128(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ExtractVector64(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ExtractVector64(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Insert(Vector128\u003Cnint\u003E,byte,nint)",
          "M:AdvSimd.Insert(Vector128\u003Cnuint\u003E,byte,nuint)",
          "M:AdvSimd.Insert(Vector64\u003Cnint\u003E,byte,nint)",
          "M:AdvSimd.Insert(Vector64\u003Cnuint\u003E,byte,nuint)",
          "M:AdvSimd.LoadAndInsertScalar(Vector128\u003Cnint\u003E,byte,nint*)",
          "M:AdvSimd.LoadAndInsertScalar(Vector128\u003Cnuint\u003E,byte,nuint*)",
          "M:AdvSimd.LoadAndInsertScalar(Vector64\u003Cnint\u003E,byte,nint*)",
          "M:AdvSimd.LoadAndInsertScalar(Vector64\u003Cnuint\u003E,byte,nuint*)",
          "M:AdvSimd.LoadAndReplicateToVector128(nint*)",
          "M:AdvSimd.LoadAndReplicateToVector128(nuint*)",
          "M:AdvSimd.LoadAndReplicateToVector64(nint*)",
          "M:AdvSimd.LoadAndReplicateToVector64(nuint*)",
          "M:AdvSimd.LoadVector128(nint*)",
          "M:AdvSimd.LoadVector128(nuint*)",
          "M:AdvSimd.LoadVector64(nint*)",
          "M:AdvSimd.LoadVector64(nuint*)",
          "M:AdvSimd.Negate(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Negate(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.NegateSaturate(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.NegateSaturate(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Not(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Not(Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Not(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Not(Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Or(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Or(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Or(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Or(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.OrNot(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.OrNot(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.OrNot(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.OrNot(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement16(Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement32(Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement32(Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ReverseElement8(Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmetic(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticRounded(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticRoundedSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftArithmeticSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLeftAndInsert(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftAndInsert(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftAndInsert(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftAndInsert(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogical(Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturate(Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLeftLogicalSaturateUnsigned(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector128\u003Cnuint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogical(Vector64\u003Cnuint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector128\u003Cnuint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRounded(Vector64\u003Cnuint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector128\u003Cnuint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalRoundedSaturate(Vector64\u003Cnuint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector128\u003Cnuint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftLogicalSaturate(Vector64\u003Cnuint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightAndInsert(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmetic(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticAdd(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRounded(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRoundedAdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightArithmeticRoundedAdd(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogical(Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalAdd(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRounded(Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedAdd(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedAdd(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedAddScalar(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E,byte)",
          "M:AdvSimd.ShiftRightLogicalRoundedAddScalar(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Store(nint*,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Store(nint*,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Store(nuint*,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Store(nuint*,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.StoreSelectedScalar(nint*,Vector128\u003Cnint\u003E,byte)",
          "M:AdvSimd.StoreSelectedScalar(nuint*,Vector128\u003Cnuint\u003E,byte)",
          "M:AdvSimd.Subtract(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Subtract(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Subtract(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Subtract(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.SubtractSaturate(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:AdvSimd.Xor(Vector128\u003Cnint\u003E,Vector128\u003Cnint\u003E)",
          "M:AdvSimd.Xor(Vector128\u003Cnuint\u003E,Vector128\u003Cnuint\u003E)",
          "M:AdvSimd.Xor(Vector64\u003Cnint\u003E,Vector64\u003Cnint\u003E)",
          "M:AdvSimd.Xor(Vector64\u003Cnuint\u003E,Vector64\u003Cnuint\u003E)",
          "M:ArmBase.Arm64.LeadingSignCount(nint)",
          "M:ArmBase.LeadingZeroCount(nint)",
          "M:ArmBase.LeadingZeroCount(nuint)",
          "M:ArmBase.ReverseElementBits(nint)",
          "M:ArmBase.ReverseElementBits(nuint)",
          "M:Crc32.ComputeCrc32(uint,nuint)",
          "M:Crc32.ComputeCrc32C(uint,nuint)",
          "T:AdvSimd",
          "T:AdvSimd.Arm64",
          "T:ArmBase",
          "T:ArmBase.Arm64",
          "T:Crc32"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 864,
          "Title": "UdpClient - add Span support",
          "Author": "billknye",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-03-16T02:45:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/864",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849850488",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/864#issuecomment-849850488",
        "FeedbackMarkdown": "* The CancellationToken parameters should have defaults, particularly in the ones where \u0060byte[]\u0060 becomes \u0060ReadOnlyMemory\u003Cbyte\u003E\u0060\r\n* There was some debate as to the mismatch between current Task-returning members and new ValueTask-returning members, and \u0022all the new ones here are ValueTask\u0022 was determined to be acceptable.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    partial class UdpClient\r\n    {\r\n\t// existing: public int Send(byte[] dgram, int bytes);\r\n\tpublic int Send(ReadOnlySpan\u003Cbyte\u003E datagram);\r\n\t\r\n\t// existing: public int Send(byte[] dgram, int bytes, IPEndPoint endPoint);\r\n\tpublic int Send(ReadOnlySpan\u003Cbyte\u003E datagram, IPEndPoint endPoint);\r\n\t\r\n\t// existing: public int Send(byte[] dgram, int bytes, string hostname, int port);\r\n\tpublic int Send(ReadOnlySpan\u003Cbyte\u003E datagram, string hostname, int port);\r\n\t\r\n\t// existing: public Task\u003Cint\u003E SendAsync(byte[] datagram, int bytes);\r\n\tpublic ValueTask\u003Cint\u003E SendAsync(ReadOnlyMemory\u003Cbyte\u003E datagram, CancellationToken cancellationToken = default);\r\n\t\r\n\t// existing: public Task\u003Cint\u003E SendAsync(byte[] datagram, int bytes, IPEndPoint endPoint);\r\n\tpublic ValueTask\u003Cint\u003E SendAsync(ReadOnlyMemory\u003Cbyte\u003E datagram, IPEndPoint endPoint, CancellationToken cancellationToken = default);\r\n\r\n\t// existing: public Task\u003CUdpReceiveResult\u003E ReceiveAsync();\r\n\tpublic ValueTask\u003CUdpReceiveResult\u003E ReceiveAsync(CancellationToken cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46290000000,
        "Apis": [
          "M:UdpClient.ReceiveAsync(CancellationToken)",
          "M:UdpClient.Send(ReadOnlySpan\u003Cbyte\u003E,IPEndPoint)",
          "M:UdpClient.Send(ReadOnlySpan\u003Cbyte\u003E,string,int)",
          "M:UdpClient.Send(ReadOnlySpan\u003Cbyte\u003E)",
          "M:UdpClient.SendAsync(ReadOnlyMemory\u003Cbyte\u003E,CancellationToken)",
          "M:UdpClient.SendAsync(ReadOnlyMemory\u003Cbyte\u003E,IPEndPoint,CancellationToken)",
          "T:UdpClient"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 27292,
          "Title": "Add DivMod instrinct for intel x86/x64",
          "Author": "Daniel-Svensson",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2018-09-02T20:23:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/27292",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "arch-x64",
              "Color": "eb6420",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849856474",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/27292#issuecomment-849856474",
        "FeedbackMarkdown": "* Since the original proposal, the return\u002Bout style for intrinsics has changed to named tuples \u0060(Quotient, Remainder)\u0060 for these.\r\n* \u0022hi\u0022 should be \u0022upper\u0022, \u0022low\u0022 should be \u0022lower\u0022\r\n* The canonical order in these APIs is (lower, upper), not (upper, lower).\r\n* Added n(u)int as well\r\n* The signedness of things is probably correct, but if not, it\u0027s an API review typo and should just be fixed as appropriate.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n  partial class X86Base \r\n  { \r\n    public (uint Quotient, uint Remainder) DivRem(uint lower, uint upper, uint divisor);\r\n\r\n    public (int Quotient, int Remainder) DivRem(uint lower, int upper, int divisor);\r\n\r\n    public (nuint Quotient, nuint Remainder) DivRem(nuint lower, nuint upper, nuint divisor);\r\n\r\n    public (nint Quotient, nint Remainder) DivRem(nuint lower, nint upper, nint divisor);\r\n \r\n    [Intrinsic]\r\n    public static class X64\r\n    {\r\n        public (ulong Quotient, ulong Remainder) DivRem(ulong lower, ulong upper, ulong divisor);\r\n\r\n        public (long Quotient, long Remainder) DivRem(ulong lower, long upper, long divisor);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 52290000000,
        "Apis": [
          "M:X86Base.DivRem(nuint,nint,nint)",
          "M:X86Base.DivRem(nuint,nuint,nuint)",
          "M:X86Base.DivRem(uint,int,int)",
          "M:X86Base.DivRem(uint,uint,uint)",
          "M:X86Base.X64.DivRem(ulong,long,long)",
          "M:X86Base.X64.DivRem(ulong,ulong,ulong)",
          "T:X86Base",
          "T:X86Base.X64"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29756,
          "Title": "AssemblyMetadataAttribute should be applicable to everything",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-04T00:27:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29756",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849858838",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29756#issuecomment-849858838",
        "FeedbackMarkdown": "The general feeling was that since the name says \u0022Assembly\u0022 the target being Assembly-only is appropriate.  If we want a more general key-value pair bucket then we can make a more general name for a new thing.",
        "TimeCode": 58600000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35528,
          "Title": "Proposal: MemoryMarshal.GetArrayDataReference\u003CT\u003E(T[,]) overload",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-27T18:07:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35528",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-05-27T00:00:00-07:00",
        "FeedbackId": "849865575",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35528#issuecomment-849865575",
        "FeedbackMarkdown": "Approved as a System.Array-based overload of GetArrayDataReference.\r\n\r\nThere\u0027s an open question of what happens if the array is an array of reference types: is byte the right answer for the return type?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    partial class MemoryMarshal\r\n    {\r\n        public static ref byte GetArrayDataReference(Array arr);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 60920000000,
        "Apis": [
          "M:MemoryMarshal.GetArrayDataReference(Array)",
          "T:MemoryMarshal"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "8K42B4aH34s",
      "StartDateTime": "2021-06-01T10:07:06-07:00",
      "EndDateTime": "2021-06-01T12:21:38-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/8K42B4aH34s/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 24328,
          "Title": "General purpose non-cryptographic hashing API for .NET",
          "Author": "jamesqo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-12-03T20:42:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/24328",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-01T00:00:00-07:00",
        "FeedbackId": "852297606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/24328#issuecomment-852297606",
        "FeedbackMarkdown": "* Since the ctors for XxHash* are being overloaded for usability, also overload the \u0060byte[] =\u003E byte[]\u0060 statics for usability.  The other versions are complicated enough that the default is OK.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO.Hashing\r\n{\r\n    public abstract class NonCryptographicHashAlgorithm\r\n    {\r\n        public int HashLengthInBytes { get; }\r\n\r\n        protected NonCryptographicHashAlgorithm(int hashLengthInBytes);\r\n\r\n        public abstract void Append(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public abstract void Reset();\r\n        protected abstract void GetCurrentHashCore(Span\u003Cbyte\u003E destination);\r\n\r\n        public void Append(byte[] source);\r\n        public void Append(Stream stream);\r\n        public Task AppendAsync(Stream stream, CancellationToken cancellationToken = default);\r\n        public byte[] GetCurrentHash();\r\n        public bool TryGetCurrentHash(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetCurrentHash(Span\u003Cbyte\u003E destination);\r\n        public byte[] GetHashAndReset();\r\n        public bool TryGetHashAndReset(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public int GetHashAndReset(Span\u003Cbyte\u003E destination);\r\n\r\n        protected virtual void GetHashAndResetCore(Span\u003Cbyte\u003E destination);\r\n\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        [Obsolete(\u0022Use GetCurrentHash() to retrieve the computed hash code.\u0022, true)]\r\n        public int GetHashCode();\r\n    }\r\n    public sealed class XxHash32 : NonCryptographicHashAlgorithm\r\n    {\r\n        public XxHash32();\r\n        public XxHash32(int seed);\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(byte[] source, int seed = 0);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source, int seed = 0);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten, int seed = 0);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, int seed = 0);\r\n    }\r\n    public sealed class XxHash64 : NonCryptographicHashAlgorithm\r\n    {\r\n        public XxHash64();\r\n        public XxHash64(long seed);\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(byte[] source, long seed);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source, long seed = 0);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten, long seed = 0);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, long seed = 0);\r\n    }\r\n    public sealed class Crc32 : NonCryptographicHashAlgorithm\r\n    {\r\n        public Crc32();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n    public sealed class Crc64 : NonCryptographicHashAlgorithm\r\n    {\r\n        public Crc64();\r\n        public static byte[] Hash(byte[] source);\r\n        public static byte[] Hash(ReadOnlySpan\u003Cbyte\u003E source);\r\n        public static bool TryHash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n        public static int Hash(ReadOnlySpan\u003Cbyte\u003E source, Span\u003Cbyte\u003E destination);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Crc32.Crc32()",
          "M:Crc32.Hash(byte[])",
          "M:Crc32.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Crc32.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Crc32.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:Crc64.Crc64()",
          "M:Crc64.Hash(byte[])",
          "M:Crc64.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E)",
          "M:Crc64.Hash(ReadOnlySpan\u003Cbyte\u003E)",
          "M:Crc64.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int)",
          "M:NonCryptographicHashAlgorithm.Append(byte[])",
          "M:NonCryptographicHashAlgorithm.Append(ReadOnlySpan\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.Append(Stream)",
          "M:NonCryptographicHashAlgorithm.AppendAsync(Stream,CancellationToken)",
          "M:NonCryptographicHashAlgorithm.GetCurrentHash()",
          "M:NonCryptographicHashAlgorithm.GetCurrentHash(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetCurrentHashCore(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashAndReset()",
          "M:NonCryptographicHashAlgorithm.GetHashAndReset(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashAndResetCore(Span\u003Cbyte\u003E)",
          "M:NonCryptographicHashAlgorithm.GetHashCode()",
          "M:NonCryptographicHashAlgorithm.NonCryptographicHashAlgorithm(int)",
          "M:NonCryptographicHashAlgorithm.Reset()",
          "M:NonCryptographicHashAlgorithm.TryGetCurrentHash(Span\u003Cbyte\u003E,out int)",
          "M:NonCryptographicHashAlgorithm.TryGetHashAndReset(Span\u003Cbyte\u003E,out int)",
          "M:XxHash32.Hash(byte[],int)",
          "M:XxHash32.Hash(byte[])",
          "M:XxHash32.Hash(ReadOnlySpan\u003Cbyte\u003E,int)",
          "M:XxHash32.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,int)",
          "M:XxHash32.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,int)",
          "M:XxHash32.XxHash32()",
          "M:XxHash32.XxHash32(int)",
          "M:XxHash64.Hash(byte[],long)",
          "M:XxHash64.Hash(byte[])",
          "M:XxHash64.Hash(ReadOnlySpan\u003Cbyte\u003E,long)",
          "M:XxHash64.Hash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,long)",
          "M:XxHash64.TryHash(ReadOnlySpan\u003Cbyte\u003E,Span\u003Cbyte\u003E,out int,long)",
          "M:XxHash64.XxHash64()",
          "M:XxHash64.XxHash64(long)",
          "P:NonCryptographicHashAlgorithm.HashLengthInBytes",
          "T:Crc32",
          "T:Crc64",
          "T:NonCryptographicHashAlgorithm",
          "T:XxHash32",
          "T:XxHash64"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52079,
          "Title": "Rate limit APIs",
          "Author": "JunTaoLuo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-29T21:30:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52079",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-01T00:00:00-07:00",
        "FeedbackId": "852384542",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52079#issuecomment-852384542",
        "FeedbackMarkdown": "API Review notes:\r\n\r\n* The current design says that Dispose must be called only once.  That is against our general IDisposable guidelines, because sometimes the state of things gets tied together.  (The first Dispose should do the release semantics, subsequent calls should no-op).\r\n  * There was discussion that it should look like IValueTaskSource, with the struct just having an incremented ID that represents which request it is.  (e.g. \u0060public long LeaseId { get; }\u0060)\r\n  * Another alternative is just making ResourceLease be a class, especially if \u0022state\u0022 is allocated for each call to Acquire.\r\n* The \u0060public object State\u0060 on the lease doesn\u0027t feel like it\u0027s set up to be successful in solving the scenarios that it is projected for.\r\n  * One suggested approach is an \u0060IReadOnlyDictionary\u003CSomeKey,object\u003E\u0060, where \u0060SomeKey\u0060 is a strongly typed string.\r\n* \u0022EstimatedCount\u0022 isn\u0027t really clear (available?, total? currently consumed?)\r\n  * Something like EstimatedAvailability would better say what it is a count of.\r\n* EstimatedCount also probably shouldn\u0027t be a property, so that it can better convey it\u0027s a point-in-time (and thus shouldn\u0027t be used in a for loop condition).\r\n  * Together, this becomes something like \u0060GetEstimatedAvailability()\u0060\r\n* \u0022ResourceLimiter\u0022 feels a bit over-reaching.  \u0022RateLimiter\u0022 seems more appropriate to the described situations. (Though \u0022RateLease\u0022 does feel odd)\r\n* The namespace has both concern with \u0022Threading\u0022 and \u0022ResourceLimits\u0022, the \u0022ResourceLimits\u0022 being the same over-reaching concern of ResourceLimiter.\r\n* Next time @bartonjs will probably suggest that Acquire and WaitAsync use the template method pattern.\r\n  * public ResourceLease Acquire(int requestedCount) { if (requestedCount \u003C 0) { throw new ArgumentOutOfRangeException(nameof(requestedCount) } return AcquireCore(requestedCount); }\r\n  * protected abstract ResourceLease AcquireCore(int requestedCount);\r\n  * Same for WaitAsync",
        "TimeCode": 4570000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "m8JAKGO8zrI",
      "StartDateTime": "2021-06-03T10:00:57-07:00",
      "EndDateTime": "2021-06-03T11:58:23-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/m8JAKGO8zrI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35126,
          "Title": "Non-validated HttpHeaders enumeration",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-17T19:32:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35126",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854040319",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35126#issuecomment-854040319",
        "FeedbackMarkdown": "The proposed amendments look good.  The constructors can always be added later when there\u0027s a compelling scenario.\r\n\r\nThe net approved shape is now\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http.Headers\r\n{\r\n    public partial class HttpHeaders\r\n    {\r\n        public HttpHeadersNonValidated NonValidated { get; }\r\n    }\r\n\r\n    public readonly struct HttpHeadersNonValidated : \r\n         IReadOnlyDictionary\u003Cstring, HeaderStringValues\u003E\r\n    {\r\n         public int Count { get; }\r\n         public bool Contains(string headerName);\r\n         public bool TryGetValues(string headerName, out HeaderStringValues values);\r\n         public HeaderStringValues this[string headerName];\r\n         public Enumerator GetEnumerator();\r\n         public readonly struct Enumerator : IEnumerator\u003CKeyValuePair\u003Cstring, HeaderStringValues\u003E\u003E\r\n         {\r\n             public bool MoveNext();\r\n             public KeyValuePair\u003Cstring, HeaderStringValues\u003E Current { get; }\r\n             public void Dispose();\r\n             ... // explicitly implemented interface members\r\n         }\r\n         ... // explicitly implemented interface members\r\n    }\r\n\r\n    public readonly struct HeaderStringValues : \r\n        IReadOnlyCollection\u003Cstring\u003E\r\n    {\r\n         public int Count { get; }\r\n         public override string ToString();\r\n         public Enumerator GetEnumerator();\r\n         public readonly struct Enumerator : IEnumerator\u003Cstring\u003E\r\n         {\r\n             public bool MoveNext();\r\n             public string Current { get; }\r\n             public void Dispose();\r\n             ... // explicitly implemented interface members\r\n         }\r\n         ... // explicitly implemented interface members\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:HeaderStringValues.Enumerator.Dispose()",
          "M:HeaderStringValues.Enumerator.MoveNext()",
          "M:HeaderStringValues.GetEnumerator()",
          "M:HeaderStringValues.ToString()",
          "M:HttpHeadersNonValidated.Contains(string)",
          "M:HttpHeadersNonValidated.Enumerator.Dispose()",
          "M:HttpHeadersNonValidated.Enumerator.MoveNext()",
          "M:HttpHeadersNonValidated.GetEnumerator()",
          "M:HttpHeadersNonValidated.TryGetValues(string,out HeaderStringValues)",
          "P:HeaderStringValues.Count",
          "P:HeaderStringValues.Enumerator.Current",
          "P:HttpHeaders.NonValidated",
          "P:HttpHeadersNonValidated.Count",
          "P:HttpHeadersNonValidated.Enumerator.Current",
          "P:HttpHeadersNonValidated[string]",
          "T:HeaderStringValues",
          "T:HeaderStringValues.Enumerator",
          "T:HttpHeaders",
          "T:HttpHeadersNonValidated",
          "T:HttpHeadersNonValidated.Enumerator"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33764,
          "Title": "Do not do math with local DateTime",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33764",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854046706",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33764#issuecomment-854046706",
        "FeedbackMarkdown": "It\u0027s unclear what is being proposed here.  The examples seem to focus on the interaction with DateTimeKind.Local and DateTimeKind.Utc, not \u0022do[ing] math with local DateTime\u0022, as the title suggests.\r\n\r\nIt\u0027s also not clear if this is realistically achievable, since any DateTime that comes in as a method parameter has a DateTimeKind that is not known to the called method (unless something coerced it).\r\n\r\nPerhaps an updated title, or more clear examples would help drive a discussion.",
        "TimeCode": 8430000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33772,
          "Title": "Do not pass Utf8JsonReader by value",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33772",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854061368",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33772#issuecomment-854061368",
        "FeedbackMarkdown": "Severity: Warning\r\nCategory: Reliability\r\n\r\n* The analyzer, and the messaging, should be more generalized, like \u0022Do not pass mutable value type \u0027{0}\u0027 by value.\u0022\r\n* We should have a list of well-known problematic types, like Utf8JsonReader, but also support loading other types from config.\r\n  * Some types may be able to be identified heuristically, like \u0022ends in Enumerator, is a value type, and is a nested type\u0022\r\n  * The list should also include SpinLock\r\n* The analyzer should look for method parameter declarations where the parameter is of one of these types and the parameter mode is not ref or out (either by-value or in/readonly-ref).\r\n  * It should also look for these types in \u0022output positions\u0022, like property declared types or method returns.\r\n* The fixer should change the parameter to be by ref, and then (as a stretch goal) update calls appropriately (if able).",
        "TimeCode": 13440000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33780,
          "Title": "Prefer static ReadOnlySpan\u003Cbyte\u003E properties over static readonly byte[] fields",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:43+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33780",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854077948",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33780#issuecomment-854077948",
        "FeedbackMarkdown": "Category: Performance\r\nLevel: Info\r\n\r\n* The analyzer should look at all static readonly field declarations where the field type is an array of byte/sbyte/bool, the array is initialized with a literal array initializer.  (Note that in the future some other types may also be allowed, but that will depend on the presence of a RuntimeFeatures feature)\r\n  *  Then do a candidate elimination round: Any time that the array was passed to some other method as an array (vs going through AsSpan explicitly or implicitly) then do not report on this field.\r\n* Any remaining fields can be changed to the new pattern.",
        "TimeCode": 28420000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33783,
          "Title": "Avoid unnecessary string concatenation",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33783",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854088293",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33783#issuecomment-854088293",
        "FeedbackMarkdown": "It\u0027s not clear that the resulting code is \u0022better\u0022, especially if it inlines a concatenation across conditional statements (duplicated code costs vs performance benefits).  There may be room for \u0022StringBuilder would be better here\u0022, but they\u0027re hard to describe.\r\n\r\nSeparating out the unconditional (unobserved) concatenation into a distinct analyzer/diagnostic would be less controversial; but the conditional cases are definitely more complicated.",
        "TimeCode": 43890000000,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33788,
          "Title": "Override Stream.ReadByte/WriteByte",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33788",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854101396",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33788#issuecomment-854101396",
        "FeedbackMarkdown": "Knowing to override ReadByte and WriteByte is something that would show up in a performance analysis, and a performance-improvements focus would likely have already highlighted it.\r\n\r\nWithout usage on a specific Stream-derived type saying that ReadByte/WriteByte were even called, this is too low value considering the already high cost of implementing a Stream \u0022properly\u0022, and so doesn\u0027t seem justified.\r\n\r\nThe group got sidetracked by theorizing about a \u0060DelgatingStream : Stream\u0060 type and a new intermediate \u0060Stream\u0060 type that rewrites everything in terms of fewer protected abstract methods focused on Span/Memory... but that\u0027s not really what this issue was about.",
        "TimeCode": 54950000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33813,
          "Title": "Prefer Span\u003CT\u003E.Clear() over Span\u003CT\u003E.Fill(default)",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T17:17:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33813",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Memory",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-03T00:00:00-07:00",
        "FeedbackId": "854102050",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33813#issuecomment-854102050",
        "FeedbackMarkdown": "Level: Info\r\nCategory: Performance\r\n\r\nLooks good as proposed.",
        "TimeCode": 68720000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "VBY0iuBMqi8",
      "StartDateTime": "2021-06-08T10:06:59-07:00",
      "EndDateTime": "2021-06-08T12:04:37-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VBY0iuBMqi8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52079,
          "Title": "Rate limit APIs",
          "Author": "JunTaoLuo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-29T21:30:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52079",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-08T00:00:00-07:00",
        "FeedbackId": "857020857",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52079#issuecomment-857020857",
        "FeedbackMarkdown": "API Review notes:\r\n\r\n* Looking at System.Runtime.* again, we feel that implies something too low level, so we changed back to System.Threading.*\r\n* Now that it\u0027s in System.Threading, we believe that System.Threading.RateLimiting rolls off the tongue better than System.Threading.RateLimits.\r\n* All of the extension methods should be non-virtual instance methods, or default parameters\r\n* AvailablePermits needs a verb =\u003E GetAvailablePermits\r\n* We felt that the self-documenting behavior of default parameters was better for Acquire and WaitAsync, which justified keeping the template method pattern.\r\n* We did a pretty hefty adjustment to the PermitLease.TryGetMetadata shape to allow the well known keys to indicate what types the metadata value for each key uses.\r\n* We made PermitLease.Dispose follow the Dispose pattern, because that\u0027s the pattern.\r\n* We renamed PermitLease to RateLimitLease to give it better affinity to the RateLimiter type.\r\n  * There may be a better name for the permitCount parameters given this rename, but we don\u0027t have\r\n* There\u0027s a slightly open question as to whether \u0022MetadataName\u0022 is overly general, and warrants an affinitized name.\r\n\r\n\r\nPackage name: System.Threading.RateLimiting\r\nPrimary namespace: System.Threading.RateLimiting\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.RateLimiting\r\n{\r\n    public abstract class RateLimiter\r\n    {\r\n        public abstract int GetAvailablePermits();\r\n        public RateLimitLease Acquire(int permitCount = 1);\r\n        protected abstract RateLimitLease AcquireCore(int permitCount);\r\n        public ValueTask\u003CRateLimitLease\u003E WaitAsync(int permitCount = 1, CancellationToken cancellationToken = default);\r\n        protected abstract ValueTask\u003CRateLimitLease\u003E WaitAsyncCore(int permitCount, CancellationToken cancellationToken);\r\n    }\r\n    public abstract class RateLimitLease : IDisposable\r\n    {\r\n        public abstract bool IsAcquired { get; }\r\n\r\n        public abstract bool TryGetMetadata(string metadataName, out object? metadata);\r\n        public bool TryGetMetadata\u003CT\u003E(MetadataName\u003CT\u003E metadataName, [MaybeNullWhen(false)] out T metadata);            \r\n\r\n        public abstract IEnumerable\u003Cstring\u003E MetadataNames { get; }\r\n        public virtual IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E GetAllMetadata();\r\n\r\n        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }\r\n        protected virtual void Dispose(bool disposing);\r\n    }\r\n    public static class MetadataName\r\n    {\r\n        public static MetadataName\u003CTimeSpan\u003E RetryAfter { get; } = Create\u003CTimeSpan\u003E(\u0022RETRY_AFTER\u0022);\r\n        public static MetadataName\u003Cstring\u003E ReasonPhrase { get; } = Create\u003Cstring\u003E(\u0022REASON_PHRASE\u0022);\r\n\r\n        public static MetadataName\u003CT\u003E Create\u003CT\u003E(string name) =\u003E new MetadataName\u003CT\u003E(name);\r\n    }\r\n    public sealed class MetadataName\u003CT\u003E : IEquatable\u003CMetadataName\u003CT\u003E\u003E\r\n    {\r\n        public MetadataName(string name);\r\n        public string Name { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MetadataName.Create\u003CT\u003E(string)",
          "M:MetadataName\u003CT\u003E.MetadataName(string)",
          "M:RateLimiter.Acquire(int)",
          "M:RateLimiter.AcquireCore(int)",
          "M:RateLimiter.GetAvailablePermits()",
          "M:RateLimiter.WaitAsync(int,CancellationToken)",
          "M:RateLimiter.WaitAsyncCore(int,CancellationToken)",
          "M:RateLimitLease.Dispose()",
          "M:RateLimitLease.Dispose(bool)",
          "M:RateLimitLease.GetAllMetadata()",
          "M:RateLimitLease.TryGetMetadata(string,out object?)",
          "M:RateLimitLease.TryGetMetadata\u003CT\u003E(MetadataName\u003CT\u003E,out T)",
          "P:MetadataName.ReasonPhrase",
          "P:MetadataName.RetryAfter",
          "P:MetadataName\u003CT\u003E.Name",
          "P:RateLimitLease.IsAcquired",
          "P:RateLimitLease.MetadataNames",
          "T:MetadataName",
          "T:MetadataName\u003CT\u003E",
          "T:RateLimiter",
          "T:RateLimitLease"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "YRcGjsFbx4Y",
      "StartDateTime": "2021-06-10T10:07:39-07:00",
      "EndDateTime": "2021-06-10T12:10:06-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/YRcGjsFbx4Y/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53984,
          "Title": "Minor cleanups for System.Runtime.Numerics",
          "Author": "huoyaoyuan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-10T07:54:08+00:00",
          "Url": "https://github.com/dotnet/runtime/pull/53984",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "community-contribution",
              "Color": "c2e0c6",
              "Description": "Indicates that the PR has been added by a community member"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-10T00:00:00-07:00",
        "FeedbackId": "858849057",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53984#issuecomment-858849057",
        "FeedbackMarkdown": "Thanks for the cleanup here!",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53919,
          "Title": "Add ability to detect if a service is registered in the DI container",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-09T06:16:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53919",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-DependencyInjection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-10T00:00:00-07:00",
        "FeedbackId": "858861117",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53919#issuecomment-858861117",
        "FeedbackMarkdown": "* The existing ISupportRequiredService is used with an as-cast from IServiceProvider, so this shouldn\u0027t start with ISupport if it\u0027s used in a different way.\r\n  * Either a different naming pattern, or change the usage to be as-based instead of GetService-based.\r\n  * Last minute proposal was \u0022IServiceProvider[PrimaryMethodName]\u0022 for this new kind of thing.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.DependencyInjection\r\n{\r\n     public interface IServiceProviderIsService\r\n     {\r\n         bool IsService(Type serviceType);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 33130000000,
        "Apis": [
          "M:IServiceProviderIsService.IsService(Type)",
          "T:IServiceProviderIsService"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29723,
          "Title": "Expose top-level nullability information from reflection",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-05-31T03:07:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29723",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-10T00:00:00-07:00",
        "FeedbackId": "858930248",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29723#issuecomment-858930248",
        "FeedbackMarkdown": "* [MaybeNullWhen] should count as a \u0022maybe null\u0022 return answer.\r\n* We changed NullabilityInfo.GenericTypeArguments to a non-nullable array to match standard reflection API practices.\r\n  * We discussed the caching strategy, and since NullabilityInfo objects are expected to be freshly returned each time there\u0027s no parallel-caller mutation concern.\r\n* We renamed the MaybeNull member to Nullable\r\n* Once we renamed the member the type name for the enum seemed wrong, so we renamed that to NullabilityState.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection\r\n{\r\n    public sealed class NullabilityInfoContext\r\n    {\r\n        public NullabilityInfo Create(ParameterInfo parameterInfo);\r\n        public NullabilityInfo Create(PropertyInfo propertyInfo);\r\n        public NullabilityInfo Create(EventInfo eventInfo);\r\n        public NullabilityInfo Create(FieldInfo parameterInfo);\r\n    }\r\n\r\n    public sealed class NullabilityInfo\r\n    {\r\n        public Type Type { get; }\r\n        public NullableState ReadState { get; }\r\n        public NullableState WriteState { get; }\r\n        public NullabilityInfo? ElementType { get; }\r\n        public NullabilityInfo[] GenericTypeArguments { get; }\r\n    }\r\n\r\n    public enum NullabilityState\r\n    {\r\n        Unknown,\r\n        NotNull,\r\n        Nullable\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40270000000,
        "Apis": [
          "F:NullabilityState.NotNull",
          "F:NullabilityState.Nullable",
          "F:NullabilityState.Unknown",
          "M:NullabilityInfoContext.Create(EventInfo)",
          "M:NullabilityInfoContext.Create(FieldInfo)",
          "M:NullabilityInfoContext.Create(ParameterInfo)",
          "M:NullabilityInfoContext.Create(PropertyInfo)",
          "P:NullabilityInfo.ElementType",
          "P:NullabilityInfo.GenericTypeArguments",
          "P:NullabilityInfo.ReadState",
          "P:NullabilityInfo.Type",
          "P:NullabilityInfo.WriteState",
          "T:NullabilityInfo",
          "T:NullabilityInfoContext",
          "T:NullabilityState"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "OF1RNuK0zhQ",
      "StartDateTime": "2021-06-14T10:04:36-07:00",
      "EndDateTime": "2021-06-14T12:05:37-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/OF1RNuK0zhQ/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29932,
          "Title": "JsonSerializer support for TimeSpan in 3.0?",
          "Author": "martincostello",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-18T14:13:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29932",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "json-functionality-doc",
              "Color": "fbca04",
              "Description": "Missing JSON specific functionality that needs documenting"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-14T00:00:00-07:00",
        "FeedbackId": "860853752",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29932#issuecomment-860853752",
        "FeedbackMarkdown": "* We believe it\u0027s an acceptable breaking change even though we serialized \u0060TimeSpan\u0060 before as a POCO. If developers don\u0027t want the new behavior, they can register their own \u0060TimeSpan\u0060 converter. We may want to provide a \u0022generic\u0022 converter that provides POCO style-serialization for any type (e.g. \u0060DefaultPropertyConverter\u003CT\u003E\u0060). The source generator is new, so it\u0027s not a breaking change there regardless.\r\n    - @layomia could you file a separate issue for this?\r\n* There is no way to configure the emitted format of the the time span (we emit it as \u0060days:hours:minute:seconds\u0060). We could add an API to configure this later, but we don\u0027t believe it\u0027s needed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public static class JsonMetadataServices\r\n    {\r\n        public static JsonConverter\u003CTimeSpan\u003E TimeSpanConverter { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:JsonMetadataServices.TimeSpanConverter",
          "T:JsonMetadataServices"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53539,
          "Title": "Support DateOnly and TimeOnly in JsonSerializer",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-01T17:08:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53539",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:2",
              "Color": "e99695",
              "Description": "Work that is important, but not critical for the release"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-14T00:00:00-07:00",
        "FeedbackId": "860868464",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53539#issuecomment-860868464",
        "FeedbackMarkdown": "* This is the first time where we split the reference assembly between .NET Core and .NET Standard so we should make sure we\u0027re happy with that added complexity.\r\n    - Alternatively, we could make \u0060DateOnly\u0060 and \u0060TimeOnly\u0060 available as a .NET Standard 2.0 package.\r\n    - Or we maybe we change the source generator to bind via method syntax (rather than a property) so that they could be provided as extension methods, that, for example, the user provides.\r\n    - Or we could expose a generic method like \u0060JsonConverter\u003CT\u003E JsonMetadataServices.GetConverter\u003CT\u003E()\u0060 that can return built-in generators without having to talk about the type.\r\n    - Or we could source generator them in case \u0060DateOnly\u0060/\u0060TimeOnly\u0060 exists but those properties don\u0027t.\r\n* We need think about how we can support types that aren\u0027t in the .NET Standard 2.0 API surface\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public static partial class JsonMetadataServices\r\n    {\r\n        public static JsonConverter\u003CDateOnly\u003E DateOnlyConverter { get; }\r\n        public static JsonConverter\u003CTimeOnly\u003E TimeOnlyConverter { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8790000000,
        "Apis": [
          "P:JsonMetadataServices.DateOnlyConverter",
          "P:JsonMetadataServices.TimeOnlyConverter",
          "T:JsonMetadataServices"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1784,
          "Title": "Writing raw JSON values when using Utf8JsonWriter",
          "Author": "nahk-ivanov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-15T23:18:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1784",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-14T00:00:00-07:00",
        "FeedbackId": "860908002",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1784#issuecomment-860908002",
        "FeedbackMarkdown": "* We should rename \u0060skipValidation\u0060 to \u0060skipInputValidation\u0060 to make it clear that this about catching issues with untrusted user input, rather than structural coding issues from the side of the caller.\r\n* When \u0060skipInputValidation\u0060 is set to \u0060false\u0060 we should enforce that no comments are present (or alternatively we strip them).\r\n* If we need to add options, we can either add an overload with an enum, a struct, or just more Booleans\r\n* The name \u0060RawValue\u0060 is fine, but if we ever add the overload that takes a property name the convention would be to call it \u0060WriteRaw\u0060 which is a bit odd\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public sealed partial class Utf8JsonWriter\r\n    {\r\n        public void WriteRawValue(ReadOnlySpan\u003Cbyte\u003E utf8Json, bool skipInputValidation = false);\r\n        public void WriteRawValue(ReadOnlySpan\u003Cchar\u003E json, bool skipInputValidation = false);\r\n        public void WriteRawValue(string json, bool skipInputValidation = false);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 21860000000,
        "Apis": [
          "M:Utf8JsonWriter.WriteRawValue(ReadOnlySpan\u003Cbyte\u003E,bool)",
          "M:Utf8JsonWriter.WriteRawValue(ReadOnlySpan\u003Cchar\u003E,bool)",
          "M:Utf8JsonWriter.WriteRawValue(string,bool)",
          "T:Utf8JsonWriter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53372,
          "Title": "Minimalistic HTTP2 flow control API",
          "Author": "antonfirsov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-27T17:56:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53372",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-14T00:00:00-07:00",
        "FeedbackId": "860917481",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53372#issuecomment-860917481",
        "FeedbackMarkdown": "* We believe \u0060EnableDynamicHttp2StreamWindowSizing\u0060 could be served as an app context switch, because it\u0027s just an escape hatch\r\n    - The name should follow app context switch naming conventions but use \u0022Disable\u0022 rather than \u0022Enable\u0022 naming, because it\u0027s about turning it off.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public partial class SocketsHttpHandler\r\n    {\r\n        public int InitialHttp2StreamWindowSize { get; set; } // = 65535;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58730000000,
        "Apis": [
          "P:SocketsHttpHandler.InitialHttp2StreamWindowSize",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48702,
          "Title": "Add a method consuming ReadOnlySpan\u003Cbyte\u003E to System.HashCode",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-24T14:46:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48702",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-14T00:00:00-07:00",
        "FeedbackId": "860922933",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48702#issuecomment-860922933",
        "FeedbackMarkdown": "* We don\u0027t believe we\u0027ll ever need to add \u0060Add\u003CT\u003E(ReadOnlySpan\u003CT\u003E value)\u0060\r\n* We don\u0027t want to constrain the implementation to do the same as calling \u0060Add\u003CT\u003E(T value)\u0060 in a loop\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct HashCode\r\n    {\r\n         public void Add(ReadOnlySpan\u003Cbyte\u003E value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 67350000000,
        "Apis": [
          "M:HashCode.Add(ReadOnlySpan\u003Cbyte\u003E)",
          "T:HashCode"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "bWpUl-P-zo8",
      "StartDateTime": "2021-06-15T10:29:35-07:00",
      "EndDateTime": "2021-06-15T12:24:18-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/bWpUl-P-zo8/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52079,
          "Title": "Rate limit APIs",
          "Author": "JunTaoLuo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-29T21:30:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52079",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-15T00:00:00-07:00",
        "FeedbackId": "861747307",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52079#issuecomment-861747307",
        "FeedbackMarkdown": "* We decided to rename the QueueProcessingOrder members from { ProcessOldest, ProcessNewest } to { OldestFirst, NewestFirst }\r\n* Instead of having a base \u0060RateLimiterOptions\u0060 class, just copy the properties into the derived types.\r\n* The mutability of the options types raised some supportability questions. So we recommend sealing all the options types and removing the property setters.\r\n  * There was further discussion around removing the options types altogether and collapsing them into ctor parameters.\r\n* TokenBucket\u0027s settings shouldn\u0027t mix the names \u0022permit\u0022 and \u0022token\u0022.  Unify on \u0022token\u0022.\r\n* There was a discussion around the exposed options and the limits to the Acquire method.\r\n  * Since the rate limiters do not expose the PermitLimit (max) value a call to Acquire that exceeds the PermitLimit shouldn\u0027t be an ArgumentException (ArgumentExceptions generally mean \u0022caller bug\u0022, and in this case the caller couldn\u0027t know the input was out of bounds)\r\n    * InvalidOperationException is OK\r\n    * Returning the RateLimitLease saying that it couldn\u0027t be acquired is potentially also OK, but there was a suggestion that might lead to infinite/excessive retries on a case that will never succeed.\r\n* TokenBucketLimiter.Replenish isn\u0027t authoritative (whether it replenishes or not depends on configuration), but the method name doesn\u0027t suggest that.\r\n  * It became \u0060public bool TryReplenish()\u0060\r\n* During discussion the need to pulse/refresh the fixed and sliding window timers came up, which added TryRefresh methods and AutoRefresh configuration properties.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.RateLimiting\r\n{\r\n    // This specifies the behaviour of \u0060WaitAsync\u0060 When PermitLimit has been reached\r\n    public enum QueueProcessingOrder\r\n    {\r\n        ProcessOldest,\r\n        ProcessNewest\r\n    }\r\n\r\n    public sealed class ConcurrencyLimiterOptions\r\n    {\r\n        public ConcurrencyLimiterOptions(int permitLimit, QueueProcessingOrder queueProcessingOrder, int queueLimit);\r\n\r\n        // Specifies the maximum number of permits for the limiter\r\n        public int PermitLimit { get; }\r\n        // Permits exhausted mode, configures \u0060WaitAsync\u0060 behaviour\r\n        public QueueProcessingOrder QueueProcessingOrder { get; }\r\n        // Queue limit when queuing is enabled\r\n        public int QueueLimit { get; }\r\n    }\r\n\r\n    public sealed class TokenBucketRateLimiterOptions\r\n    {\r\n        public TokenBucketRateLimiterOptions(\r\n            int tokenLimit, \r\n            QueueProcessingOrder queueProcessingOrder, \r\n            int queueLimit,\r\n            TimeSpan replenishmentPeriod,\r\n            int tokensPerPeriod,\r\n            bool autoReplenishment = true);\r\n\r\n        // Specifies the maximum number of permits for the limiter\r\n        public int TokenLimit { get; }\r\n        // Permits exhausted mode, configures \u0060WaitAsync\u0060 behaviour\r\n        public QueueProcessingOrder QueueProcessingOrder { get; }\r\n        // Queue limit when queuing is enabled\r\n        public int QueueLimit { get; }\r\n        // Specifies the period between replenishments\r\n        public TimeSpan ReplenishmentPeriod { get; }\r\n        // Specifies how many tokens to restore each replenishment\r\n        public int TokensPerPeriod { get; }\r\n        // Whether to create a timer to trigger replenishment automatically\r\n        // This parameter is optional\r\n        public bool AutoReplenishment { get; }\r\n    }\r\n    \r\n    // Window based rate limiter options\r\n    public sealed class FixedWindowRateLimiterOptions\r\n    {\r\n        public FixedWindowRateLimiterOptions(\r\n            int permitLimit, \r\n            QueueProcessingOrder queueProcessingOrder, \r\n            int queueLimit,\r\n            TimeSpan window,\r\n            bool autoRefresh = true);\r\n        \r\n        // Specifies the maximum number of permits for the limiter\r\n        public int PermitLimit { get; }\r\n        // Permits exhausted mode, configures \u0060WaitAsync\u0060 behaviour\r\n        public QueueProcessingOrder QueueProcessingOrder { get; }\r\n        // Queue limit when queuing is enabled\r\n        public int QueueLimit { get; }\r\n        // Specifies the duration of the window where the rate limit is applied\r\n        public TimeSpan Window { get; }\r\n\r\n        public bool AutoRefresh { get; }\r\n    }\r\n\r\n    public sealed class SlidingWindowRateLimiterOptions\r\n    {\r\n        public SlidingWindowRateLimiterOptions(\r\n            int permitLimit, \r\n            QueueProcessingOrder queueProcessingOrder, \r\n            int queueLimit,\r\n            TimeSpan window,\r\n            int segmentsPerWindow,\r\n            bool autoRefresh = true);\r\n\r\n        // Specifies the maximum number of permits for the limiter\r\n        public int PermitLimit { get; }\r\n        // Permits exhausted mode, configures \u0060WaitAsync\u0060 behaviour\r\n        public QueueProcessingOrder QueueProcessingOrder { get; }\r\n        // Queue limit when queuing is enabled\r\n        public int QueueLimit { get; }\r\n        // Specifies the duration of the window where the rate limit is applied\r\n        public TimeSpan Window { get; }\r\n        // Specifies the number of segments the Window should be divided into\r\n        public int SegmentsPerWindow { get; }\r\n        \r\n        public bool AutoRefresh { get; }\r\n    }\r\n\r\n    // Limiter implementations\r\n    public sealed class ConcurrencyLimiter : RateLimiter \r\n    { \r\n        public ConcurrencyLimiter(ConcurrencyLimiterOptions options);\r\n        public override int GetAvailablePermits();\r\n        protected override RateLimitLease AcquireCore(int permitCount);\r\n        protected override ValueTask\u003CRateLimitLease\u003E WaitAsyncCore(int permitCount, CancellationToken cancellationToken = default);\r\n    }\r\n    public sealed class TokenBucketRateLimiter : RateLimiter \r\n    { \r\n        public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options);\r\n        // Attempts replenish the bucket, returns true if enough time had elapsed and it replenishes; otherwise, false.\r\n        public bool TryReplenish();\r\n        public override int GetAvailablePermits();\r\n        protected override RateLimitLease AcquireCore(int permitCount);\r\n        protected override ValueTask\u003CRateLimitLease\u003E WaitAsyncCore(int permitCount, CancellationToken cancellationToken = default);\r\n    }\r\n    public sealed class FixedWindowRateLimiter : RateLimiter \r\n    { \r\n        public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options);\r\n        public bool TryRefresh();\r\n        public override int GetAvailablePermits();\r\n        protected override RateLimitLease AcquireCore(int permitCount);\r\n        protected override ValueTask\u003CRateLimitLease\u003E WaitAsyncCore(int permitCount, CancellationToken cancellationToken = default);\r\n    }\r\n    public sealed class SlidingWindowRateLimiter : RateLimiter \r\n    { \r\n        public SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions options);\r\n        public bool TryRefresh();\r\n        public override int GetAvailablePermits();\r\n        protected override RateLimitLease AcquireCore(int permitCount);\r\n        protected override ValueTask\u003CRateLimitLease\u003E WaitAsyncCore(int permitCount, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:QueueProcessingOrder.ProcessNewest",
          "F:QueueProcessingOrder.ProcessOldest",
          "M:ConcurrencyLimiter.AcquireCore(int)",
          "M:ConcurrencyLimiter.ConcurrencyLimiter(ConcurrencyLimiterOptions)",
          "M:ConcurrencyLimiter.GetAvailablePermits()",
          "M:ConcurrencyLimiter.WaitAsyncCore(int,CancellationToken)",
          "M:ConcurrencyLimiterOptions.ConcurrencyLimiterOptions(int,QueueProcessingOrder,int)",
          "M:FixedWindowRateLimiter.AcquireCore(int)",
          "M:FixedWindowRateLimiter.FixedWindowRateLimiter(FixedWindowRateLimiterOptions)",
          "M:FixedWindowRateLimiter.GetAvailablePermits()",
          "M:FixedWindowRateLimiter.TryRefresh()",
          "M:FixedWindowRateLimiter.WaitAsyncCore(int,CancellationToken)",
          "M:FixedWindowRateLimiterOptions.FixedWindowRateLimiterOptions(int,QueueProcessingOrder,int,TimeSpan,bool)",
          "M:SlidingWindowRateLimiter.AcquireCore(int)",
          "M:SlidingWindowRateLimiter.GetAvailablePermits()",
          "M:SlidingWindowRateLimiter.SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions)",
          "M:SlidingWindowRateLimiter.TryRefresh()",
          "M:SlidingWindowRateLimiter.WaitAsyncCore(int,CancellationToken)",
          "M:SlidingWindowRateLimiterOptions.SlidingWindowRateLimiterOptions(int,QueueProcessingOrder,int,TimeSpan,int,bool)",
          "M:TokenBucketRateLimiter.AcquireCore(int)",
          "M:TokenBucketRateLimiter.FixedWindowRateLimiter(FixedWindowRateLimiterOptions)",
          "M:TokenBucketRateLimiter.GetAvailablePermits()",
          "M:TokenBucketRateLimiter.TryReplenish()",
          "M:TokenBucketRateLimiter.WaitAsyncCore(int,CancellationToken)",
          "M:TokenBucketRateLimiterOptions.TokenBucketRateLimiterOptions(int,QueueProcessingOrder,int,TimeSpan,int,bool)",
          "P:ConcurrencyLimiterOptions.PermitLimit",
          "P:ConcurrencyLimiterOptions.QueueLimit",
          "P:ConcurrencyLimiterOptions.QueueProcessingOrder",
          "P:FixedWindowRateLimiterOptions.AutoRefresh",
          "P:FixedWindowRateLimiterOptions.PermitLimit",
          "P:FixedWindowRateLimiterOptions.QueueLimit",
          "P:FixedWindowRateLimiterOptions.QueueProcessingOrder",
          "P:FixedWindowRateLimiterOptions.Window",
          "P:SlidingWindowRateLimiterOptions.AutoRefresh",
          "P:SlidingWindowRateLimiterOptions.PermitLimit",
          "P:SlidingWindowRateLimiterOptions.QueueLimit",
          "P:SlidingWindowRateLimiterOptions.QueueProcessingOrder",
          "P:SlidingWindowRateLimiterOptions.SegmentsPerWindow",
          "P:SlidingWindowRateLimiterOptions.Window",
          "P:TokenBucketRateLimiterOptions.AutoReplenishment",
          "P:TokenBucketRateLimiterOptions.QueueLimit",
          "P:TokenBucketRateLimiterOptions.QueueProcessingOrder",
          "P:TokenBucketRateLimiterOptions.ReplenishmentPeriod",
          "P:TokenBucketRateLimiterOptions.TokenLimit",
          "P:TokenBucketRateLimiterOptions.TokensPerPeriod",
          "T:ConcurrencyLimiter",
          "T:ConcurrencyLimiterOptions",
          "T:FixedWindowRateLimiter",
          "T:FixedWindowRateLimiterOptions",
          "T:QueueProcessingOrder",
          "T:SlidingWindowRateLimiter",
          "T:SlidingWindowRateLimiterOptions",
          "T:TokenBucketRateLimiter",
          "T:TokenBucketRateLimiterOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51927,
          "Title": "Logging-Generator should allow to skip the IsEnabled check",
          "Author": "gfoidl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-27T15:10:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51927",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-15T00:00:00-07:00",
        "FeedbackId": "861750391",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51927#issuecomment-861750391",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed class LoggerMessageAttribute : Attribute\r\n    {\r\n        public LoggerMessageAttribute() { }\r\n        public int EventId { get; set; } = -1;\r\n        public string? EventName { get; set; }\r\n        public LogLevel Level { get; set; } = LogLevel.None;\r\n        public string Message { get; set; } = \u0022\u0022;\r\n\u002B       public bool SkipEnabledCheck { get; set; } = false;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46680000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53875,
          "Title": "Obsolete HMACSHA1 constructor with \u0060useManagedSha1\u0060",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-08T15:20:16+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53875",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-15T00:00:00-07:00",
        "FeedbackId": "861751965",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53875#issuecomment-861751965",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n* Use a new ID for HMACSHA1..ctor\r\n* Use a different new ID for all the ProduceLegacyHmacValues properties.\r\n  *  Double check that HMACSHA256 doesn\u0027t have one, too.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography {\r\n    public class HMACSHA1 : HMAC {\r\n\u002B       [Obsolete(\u0022HMACSHA1 always uses the algorithm implementation provided by the platform. Use the constructor without the useManagedSha1 parameter.\u0022)]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public HMACSHA1(byte[] key, bool useManagedSha1);\r\n    }\r\n\r\n    public class HMACSHA384 : HMAC {\r\n\u002B       [Obsolete(\u0022Producing legacy HMAC values is no longer supported.\u0022)]\r\n        public bool ProduceLegacyHmacValues { get; set; }\r\n    }\r\n\r\n    public class HMACSHA512 : HMAC {\r\n\u002B       [Obsolete(\u0022Producing legacy HMAC values is no longer supported.\u0022)]\r\n        public bool ProduceLegacyHmacValues { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 49350000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 19459,
          "Title": "New Type \u0060System.Runtime.CompilerServices.DependentHandle\u003CTPrimary, TSecondary\u003E\u0060",
          "Author": "shmuelie",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-11-23T17:55:03+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19459",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-15T00:00:00-07:00",
        "FeedbackId": "861769544",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/19459#issuecomment-861769544",
        "FeedbackMarkdown": "* Based on the usage, there\u0027s a recommendation to change the \u0060Target\u0060 and \u0060Dependent\u0060 properties to method pairs to avoid debugger inspection introducing Heisenbugs.\r\n* There are a lot of mixed feelings about the \u0060TargetAndDependent\u0060 property.  The most popular opinion is to be \u0060GetTargetAndDependent()\u0060, but \u0022be Decompose\u0022 and \u0022be a property\u0022 also have their camps.\r\n* There was a suggestion that \u0060Free\u0060 should be \u0060Dispose\u0060, but there is pushback on that.\r\n  * \u0022Dispose\u0022 should be from IDisposable.\r\n  * IDisposable.Dispose() should support multiple calls without negative side effects.\r\n  * Since the idempotentcy seems unlikely given the raw state of this type, it should not be IDisposable.\r\n* Recommend moving the type to \u0060System.Runtime\u0060 since it has nothing / very little to do with compilers, but has to do with garbage collection.  \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime\r\n{\r\n    public struct DependentHandle\r\n    {\r\n        public DependentHandle(object? target, object? dependent);\r\n\r\n        public bool IsAllocated { get; }\r\n\r\n        public object? Target { get; set; }\r\n        public object? Dependent { get; set; }\r\n\r\n        (object? Target, object? Dependent) TargetAndDependent { get; }\r\n\r\n        public void Free();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50800000000,
        "Apis": [
          "M:DependentHandle.DependentHandle(object?,object?)",
          "M:DependentHandle.Free()",
          "P:DependentHandle.Dependent",
          "P:DependentHandle.IsAllocated",
          "P:DependentHandle.Target",
          "P:DependentHandle.TargetAndDependent",
          "T:DependentHandle"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "VUefFIL86go",
      "StartDateTime": "2021-06-17T10:04:29-07:00",
      "EndDateTime": "2021-06-17T11:49:51-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/VUefFIL86go/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 29937,
          "Title": "Support polymorphic serialization through new option",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-06-18T17:24:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/29937",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "json-functionality-doc",
              "Color": "fbca04",
              "Description": "Missing JSON specific functionality that needs documenting"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-17T00:00:00-07:00",
        "FeedbackId": "863459930",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/29937#issuecomment-863459930",
        "FeedbackMarkdown": "API Review Feedback:\r\n\r\n* We\u0027re concerned that the model as proposed is still too open for accidental data exposure, and so we recommend a \u0022closed hierarchy\u0022 approach, similar to DataContractSerializer\u0027s known-types attribute.\r\n  *  The \u0022late-bound\u0022 doodle for this was \u0060public Dictionary\u003CType, IEnumerable\u003CType\u003E\u003E PolymorphicSerialization { get; }\u0060\r\n* Given that the same closed hierarchy would apply to deserialization, we feel that the two should be reviewed together, and that a simplified serialization-only can be designed later... but not first.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53211,
          "Title": "Debug.Assert overloads with interpolated string handler",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-25T02:08:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53211",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-17T00:00:00-07:00",
        "FeedbackId": "863481970",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53211#issuecomment-863481970",
        "FeedbackMarkdown": "* We acknowledge that there\u0027s a mild risk of breaking programs (e.g. \u0060Trace.Assert(condition, $\u0022Condition failed on iteration {x\u002B\u002B}\u0022);\u0060), but think it\u0027s generally good.\r\n* Approved as-is, plus all the \u0022we could\u0022s\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public static class Debug\r\n    {\r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void Assert(\r\n            [DoesNotReturnIf(false)] bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler message);\r\n \r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void Assert(\r\n            [DoesNotReturnIf(false)] bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler message,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler detailedMessage);\r\n\r\n        [InterpolatedStringHandlerAttribute]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public struct AssertInterpolatedStringHandler\r\n        {\r\n            public AssertInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool assert);\r\n            public void AppendLiteral(string value);\r\n            public void AppendFormatted\u003CT\u003E(T value);\r\n            public void AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(string? value);\r\n            public void AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n        }\r\n\r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void WriteIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message);\r\n\r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void WriteIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message,\r\n            string category);\r\n\r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void WriteLineIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message);\r\n\r\n        [Conditional(\u0022DEBUG\u0022)]\r\n        public static void WriteLineIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message,\r\n            string category);\r\n\r\n        [InterpolatedStringHandlerAttribute]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public struct WriteIfInterpolatedStringHandler\r\n        {\r\n            public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool assert);\r\n            public void AppendLiteral(string value);\r\n            public void AppendFormatted\u003CT\u003E(T value);\r\n            public void AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(string? value);\r\n            public void AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n        }\r\n    }\r\n\r\n    public static class Trace\r\n    {\r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void Assert(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler message);\r\n \r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void Assert(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler message, [InterpolatedStringHandlerArgument(\u0022condition\u0022)] AssertInterpolatedStringHandler detailedMessage);\r\n\r\n        [InterpolatedStringHandlerAttribute]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public struct AssertInterpolatedStringHandler\r\n        {\r\n            public AssertInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool assert);\r\n            public void AppendLiteral(string value);\r\n            public void AppendFormatted\u003CT\u003E(T value);\r\n            public void AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(string? value);\r\n            public void AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n        }\r\n\r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void WriteIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message);\r\n\r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void WriteIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message,\r\n            string category);\r\n\r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void WriteLineIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message);\r\n\r\n        [Conditional(\u0022TRACE\u0022)]\r\n        public static void WriteLineIf(\r\n            bool condition,\r\n            [InterpolatedStringHandlerArgument(\u0022condition\u0022)] WriteIfInterpolatedStringHandler message,\r\n            string category);\r\n\r\n        [InterpolatedStringHandlerAttribute]\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public struct WriteIfInterpolatedStringHandler\r\n        {\r\n            public WriteIfInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, out bool assert);\r\n            public void AppendLiteral(string value);\r\n            public void AppendFormatted\u003CT\u003E(T value);\r\n            public void AppendFormatted\u003CT\u003E(T value, string? format);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment);\r\n            public void AppendFormatted\u003CT\u003E(T value, int alignment, string? format);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value);\r\n            public void AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(object? value, int alignment = 0, string? format = null);\r\n            public void AppendFormatted(string? value);\r\n            public void AppendFormatted(string? value, int alignment = 0, string? format = null);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 45610000000,
        "Apis": [
          "M:Debug.Assert(bool,AssertInterpolatedStringHandler,AssertInterpolatedStringHandler)",
          "M:Debug.Assert(bool,AssertInterpolatedStringHandler)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted(object?,int,string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted(string?,int,string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted(string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,string?)",
          "M:Debug.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T)",
          "M:Debug.AssertInterpolatedStringHandler.AppendLiteral(string)",
          "M:Debug.AssertInterpolatedStringHandler.AssertInterpolatedStringHandler(int,int,bool,out bool)",
          "M:Debug.WriteIf(bool,WriteIfInterpolatedStringHandler,string)",
          "M:Debug.WriteIf(bool,WriteIfInterpolatedStringHandler)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted(object?,int,string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted(string?,int,string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted(string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,string?)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T)",
          "M:Debug.WriteIfInterpolatedStringHandler.AppendLiteral(string)",
          "M:Debug.WriteIfInterpolatedStringHandler.WriteIfInterpolatedStringHandler(int,int,bool,out bool)",
          "M:Debug.WriteLineIf(bool,WriteIfInterpolatedStringHandler,string)",
          "M:Debug.WriteLineIf(bool,WriteIfInterpolatedStringHandler)",
          "M:Trace.Assert(bool,AssertInterpolatedStringHandler,AssertInterpolatedStringHandler)",
          "M:Trace.Assert(bool,AssertInterpolatedStringHandler)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted(object?,int,string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted(string?,int,string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted(string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,string?)",
          "M:Trace.AssertInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T)",
          "M:Trace.AssertInterpolatedStringHandler.AppendLiteral(string)",
          "M:Trace.AssertInterpolatedStringHandler.AssertInterpolatedStringHandler(int,int,bool,out bool)",
          "M:Trace.WriteIf(bool,WriteIfInterpolatedStringHandler,string)",
          "M:Trace.WriteIf(bool,WriteIfInterpolatedStringHandler)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted(object?,int,string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted(string?,int,string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted(string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E,int,string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted(System.ReadOnlySpan\u003Cchar\u003E)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int,string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,int)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T,string?)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendFormatted\u003CT\u003E(T)",
          "M:Trace.WriteIfInterpolatedStringHandler.AppendLiteral(string)",
          "M:Trace.WriteIfInterpolatedStringHandler.WriteIfInterpolatedStringHandler(int,int,bool,out bool)",
          "M:Trace.WriteLineIf(bool,WriteIfInterpolatedStringHandler,string)",
          "M:Trace.WriteLineIf(bool,WriteIfInterpolatedStringHandler)",
          "T:Debug",
          "T:Debug.AssertInterpolatedStringHandler",
          "T:Debug.WriteIfInterpolatedStringHandler",
          "T:Trace",
          "T:Trace.AssertInterpolatedStringHandler",
          "T:Trace.WriteIfInterpolatedStringHandler"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54219,
          "Title": "Add API to control trust during TLS handshake",
          "Author": "wfurt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-15T12:34:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54219",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Security",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-22T00:00:00-07:00",
        "FeedbackId": "866187863",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54219#issuecomment-866187863",
        "FeedbackMarkdown": "* Let\u0027s make it an overload of \u0060SslStreamCertificateContext.Create()\u0060 and apply the versioning rules of methods with optional parameters.\r\n* We don\u0027t believe we need the \u0060trustMode\u0060 on \u0060SslCertificateTrust\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Security\r\n{\r\n    public partial class SslStreamCertificateContext\r\n    {\r\n        // Existing API:\r\n        // - Hide and remove default-ness\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public static SslStreamCertificateContext Create(\r\n            X509Certificate2 target, \r\n            X509Certificate2Collection? additionalCertificates, \r\n            bool offline\r\n        );\r\n        public static SslStreamCertificateContext Create( \r\n            X509Certificate2 target,  \r\n            X509Certificate2Collection? additionalCertificates,  \r\n            bool offline = false,\r\n            SslCertificateTrust? trust = null\r\n        );\r\n    }\r\n\r\n    public sealed class SslCertificateTrust\r\n    {\r\n        public static SslCertificateTrust CreateForX509Store(\r\n            X509Store store, \r\n            bool sendTrustInHandshake = false\r\n        );\r\n \r\n        [UnsupportedPlatform(\u0022windows\u0022)]\r\n        public static SslCertificateTrust CreateForX509Collection(\r\n            X509Certificate2Collection trustList,\r\n            bool sendTrustInHandshake = false\r\n        );\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:SslCertificateTrust.CreateForX509Collection(X509Certificate2Collection,bool)",
          "M:SslCertificateTrust.CreateForX509Store(X509Store,bool)",
          "M:SslStreamCertificateContext.Create(X509Certificate2,X509Certificate2Collection?,bool,SslCertificateTrust?)",
          "M:SslStreamCertificateContext.Create(X509Certificate2,X509Certificate2Collection?,bool)",
          "T:SslCertificateTrust",
          "T:SslStreamCertificateContext"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51159,
          "Title": "Consider a hot reload feature switch for linking",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-13T03:06:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51159",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "linkable-framework",
              "Color": "1ae80b",
              "Description": "Issues associated with delivering a linker friendly framework"
            },
            {
              "Name": "size-reduction",
              "Color": "85144b",
              "Description": "Issues impacting final app size primary for size sensitive workloads"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-22T00:00:00-07:00",
        "FeedbackId": "866199485",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51159#issuecomment-866199485",
        "FeedbackMarkdown": "* At this point it seems better to make a dedicated type\r\n    - Let\u0027s move the already approved \u0060AssemblyExtensions.ApplyUpdate()\u0060\r\n* Let\u0027s rename the property to \u0060IsSupported\u0060\r\n* We may want to leave the old APIs until preview 7 so that we keep infrastructure working\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata\r\n{\r\n    public static class MetadataUpdater\r\n    {\r\n        public static void ApplyUpdate(Assembly assembly, ReadOnlySpan\u003Cbyte\u003E metadataDelta, ReadOnlySpan\u003Cbyte\u003E ilDelta, ReadOnlySpan\u003Cbyte\u003E pdbDelta);\r\n        public static bool IsSupported { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MetadataUpdater.ApplyUpdate(Assembly,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E,ReadOnlySpan\u003Cbyte\u003E)",
          "P:MetadataUpdater.IsSupported",
          "T:MetadataUpdater"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 22928,
          "Title": "Add ImmutableArray Span-based APIs",
          "Author": "jamesqo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-07-26T01:06:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22928",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-22T00:00:00-07:00",
        "FeedbackId": "866221826",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/22928#issuecomment-866221826",
        "FeedbackMarkdown": "* Let\u0027s add \u0060ImmutableArray\u003CT\u003E.AsSpan(int, int)\u0060 to match arrays\r\n* We\u0027re not sure we can add \u0060Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E items)\u0060 and \u0060ToImmutableArray\u003CT\u003E(this ReadOnlySpan\u003CT\u003E items)\u0060\r\n    - They might cause ambiguities with existing ones over \u0060IEnumerable\u003CT\u003E\u0060. We can, of, course address those by adding overloads for common concrete types that have implicit conversion to \u0060ReadOnlySpan\u003CT\u003E\u0060 (e.g. \u0060string\u0060 and array).\r\n    - @333fred will investigate\r\n* Let\u0027s not add methods to any other types because we haven\u0027t done this for the mutable collections either (mostly lack of feedback but also due to performance considerations)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Immutable\r\n{\r\n    public static partial class ImmutableArray\r\n    {\r\n        // Open question:\r\n        // public static ImmutableArray\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E items);\r\n        // public static ImmutableArray\u003CT\u003E ToImmutableArray\u003CT\u003E(this ReadOnlySpan\u003CT\u003E items);\r\n    }\r\n\r\n    public partial struct ImmutableArray\u003CT\u003E\r\n    {\r\n        public ReadOnlySpan\u003CT\u003E AsSpan(int start, int length);\r\n        public ImmutableArray\u003CT\u003E AddRange(ReadOnlySpan\u003CT\u003E items);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n        public ImmutableArray\u003CT\u003E RemoveRange(ReadOnlySpan\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n        public ImmutableArray\u003CT\u003E Slice(int start, int length);\r\n        public sealed partial class Builder\r\n        {\r\n            public void AddRange(ReadOnlySpan\u003CT\u003E items);\r\n            public void AddRange\u003CTDerived\u003E(ReadOnlySpan\u003CTDerived\u003E items) where TDerived : T;\r\n            public void CopyTo(Span\u003CT\u003E destination);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ImmutableArray\u003CT\u003E.AddRange(ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.AsSpan(int,int)",
          "M:ImmutableArray\u003CT\u003E.Builder.AddRange(ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.AddRange\u003CTDerived\u003E(ReadOnlySpan\u003CTDerived\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.CopyTo(Span\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.RemoveRange(ReadOnlySpan\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Slice(int,int)",
          "T:ImmutableArray",
          "T:ImmutableArray\u003CT\u003E",
          "T:ImmutableArray\u003CT\u003E.Builder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54444,
          "Title": "Add JIT Metrics APIs",
          "Author": "josalem",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-19T00:41:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54444",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-22T00:00:00-07:00",
        "FeedbackId": "866244391",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54444#issuecomment-866244391",
        "FeedbackMarkdown": "* It seems we can\u0027t meaningfully return information on a per-thread basis\r\n    - If we do, we\u0027d add a parameter rather than a new set of methods, probably defaulted such that it would return the global state when called without specifying.\r\n* We should probably put this in \u0060System.Runtime\u0060 as \u0060System.Runtime.CompilerServices\u0060 is largely for APIs we expect to be used by compilers (or by people who want write very low level code). These seem on par with GC information APIs.\r\n* Let\u0027s expose them as static methods so if we need to expose more information that needs snapshot semantics, we can make it struct/class and add corresponding instance properties.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime\r\n{\r\n    public static class JitInfo\r\n    {\r\n        public static long GetCompiledILBytes();\r\n        public static long GetCompiledMethodCount();\r\n        public static TimeSpan GetCompilationTime();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JitInfo.GetCompilationTime()",
          "M:JitInfo.GetCompiledILBytes()",
          "M:JitInfo.GetCompiledMethodCount()",
          "T:JitInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54528,
          "Title": "Add support for POCO serialization callbacks",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-21T23:35:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54528",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-22T00:00:00-07:00",
        "FeedbackId": "866260736",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54528#issuecomment-866260736",
        "FeedbackMarkdown": "* We should make sure this feature works well in source generation\r\n    - We can either say we don\u0027t support private/internal at all\r\n    - We could say we support private/internal only when used in reflection mode\r\n    - Or we could change the shape of the feature for this problem to disappear, for example, by using interfaces instead.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public interface IJsonOnDeserializing\r\n    {\r\n        void OnDeserializing();\r\n    }\r\n\r\n    public interface IJsonOnDeserialized\r\n    {\r\n        void OnDeserialized();\r\n    }\r\n\r\n    public interface IJsonOnSerializing\r\n    {\r\n        void OnSerializing();\r\n    }\r\n\r\n    public interface IJsonOnSerialized\r\n    {\r\n        void OnSerialized();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:IJsonOnDeserialized.OnDeserialized()",
          "M:IJsonOnDeserializing.OnDeserializing()",
          "M:IJsonOnSerialized.OnSerialized()",
          "M:IJsonOnSerializing.OnSerializing()",
          "T:IJsonOnDeserialized",
          "T:IJsonOnDeserializing",
          "T:IJsonOnSerialized",
          "T:IJsonOnSerializing"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 22928,
          "Title": "Add ImmutableArray Span-based APIs",
          "Author": "jamesqo",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-07-26T01:06:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22928",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870794413",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/22928#issuecomment-870794413",
        "FeedbackMarkdown": "* **Source Breaking Change**. We discussed several options, such as adding as a suffix like \u0060AddRangeFromSpan\u0060 as well as extension methods that could help to have tie breakers, but it seems the break would be rare in practice:\r\n    - It\u0027s only ambiguous for types that have an implicit conversion to \u0060IEnumerable\u003CT\u003E\u0060 and \u0060ReadOnlySpan\u003CT\u003E\u0060. We only ship two types, arrays and strings. For arrays, we can add a tie breaker \u0060AddRange(T[])\u0060 to avoid ambiguity issues. The string one in practice feels super rare that asking the consumer to add a cast or adding \u0060.AsSpan()\u0060 seems acceptable and preferable over adding a new method group.\r\n* We should align the API surface of the builder with immutable, as per #822.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Immutable\r\n{\r\n    public static partial class ImmutableArray\r\n    {\r\n        public static ImmutableArray\u003CT\u003E Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E items);\r\n        public static ImmutableArray\u003CT\u003E Create\u003CT\u003E(Span\u003CT\u003E items);\r\n        public static ImmutableArray\u003CT\u003E ToImmutableArray\u003CT\u003E(this ReadOnlySpan\u003CT\u003E items);\r\n        public static ImmutableArray\u003CT\u003E ToImmutableArray\u003CT\u003E(this Span\u003CT\u003E items);\r\n    }\r\n\r\n    public partial struct ImmutableArray\u003CT\u003E\r\n    {\r\n        // Existing:\r\n        // public ImmutableArray\u003CT\u003E AddRange(IEnumerable\u003CT\u003E items);\r\n        // public ImmutableArray\u003CT\u003E AddRange(ImmutableArray\u003CT\u003E items);      \r\n        public ImmutableArray\u003CT\u003E AddRange(ReadOnlySpan\u003CT\u003E items);\r\n        public ImmutableArray\u003CT\u003E AddRange(params T[] items);\r\n\r\n        public ReadOnlySpan\u003CT\u003E AsSpan(int start, int length);\r\n        public ReadOnlySpan\u003CT\u003E AsSpan(Range range);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n\r\n        // Existing:\r\n        // public ImmutableArray\u003CT\u003E InsertRange(int index, IEnumerable\u003CT\u003E items);\r\n        // public ImmutableArray\u003CT\u003E InsertRange(int index, ImmutableArray\u003CT\u003E items);\r\n        public ImmutableArray\u003CT\u003E InsertRange(int index, T[] items);\r\n        public ImmutableArray\u003CT\u003E InsertRange(int index, ReadOnlySpan\u003CT\u003E items);\r\n        \r\n        // Existing:\r\n        // public ImmutableArray\u003CT\u003E RemoveRange(int index, int length);\r\n        // public ImmutableArray\u003CT\u003E RemoveRange(IEnumerable\u003CT\u003E items);\r\n        // public ImmutableArray\u003CT\u003E RemoveRange(ImmutableArray\u003CT\u003E items);\r\n        // public ImmutableArray\u003CT\u003E RemoveRange(IEnumerable\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n        // public ImmutableArray\u003CT\u003E RemoveRange(ImmutableArray\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer);\r\n        public ImmutableArray\u003CT\u003E RemoveRange(ReadOnlySpan\u003CT\u003E items, IEqualityComparer\u003CT\u003E? equalityComparer = null);\r\n        public ImmutableArray\u003CT\u003E RemoveRange(T[] items, IEqualityComparer\u003CT\u003E? equalityComparer = null);\r\n\r\n        public ImmutableArray\u003CT\u003E Slice(int start, int length);\r\n        public sealed partial class Builder\r\n        {\r\n            // Existing:\r\n            // public void AddRange(T[] items);\r\n            // public void AddRange(T[] items, int length);\r\n            // public void AddRange(IEnumerable\u003CT\u003E items);\r\n            // public void AddRange(ImmutableArray\u003CT\u003E items);\r\n            // public void AddRange(ImmutableArray\u003CT\u003E items, int length);\r\n            public void AddRange(ReadOnlySpan\u003CT\u003E items);\r\n\r\n            // Existing:\r\n            // public void AddRange\u003CTDerived\u003E(Builder! items) where TDerived: T;\r\n            // public void AddRange\u003CTDerived\u003E(ImmutableArray\u003CTDerived\u003E items) where TDerived: T;\r\n            // public void AddRange\u003CTDerived\u003E(TDerived[] items) where TDerived: T;\r\n            public void AddRange\u003CTDerived\u003E(ReadOnlySpan\u003CTDerived\u003E items) where TDerived : T;\r\n\r\n            // TODO: As per https://github.com/dotnet/runtime/issues/822, we should add the corresponding\r\n            //       methods on the builder as well.\r\n\r\n            public void CopyTo\u003CT\u003E(Span\u003CT\u003E destination);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ImmutableArray.Create\u003CT\u003E(ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray.Create\u003CT\u003E(Span\u003CT\u003E)",
          "M:ImmutableArray.ToImmutableArray\u003CT\u003E(this ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray.ToImmutableArray\u003CT\u003E(this Span\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.AddRange(params T[])",
          "M:ImmutableArray\u003CT\u003E.AddRange(ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.AsSpan(int,int)",
          "M:ImmutableArray\u003CT\u003E.AsSpan(Range)",
          "M:ImmutableArray\u003CT\u003E.Builder.AddRange(ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.AddRange\u003CTDerived\u003E(ReadOnlySpan\u003CTDerived\u003E)",
          "M:ImmutableArray\u003CT\u003E.Builder.CopyTo\u003CT\u003E(Span\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.InsertRange(int,ReadOnlySpan\u003CT\u003E)",
          "M:ImmutableArray\u003CT\u003E.InsertRange(int,T[])",
          "M:ImmutableArray\u003CT\u003E.RemoveRange(ReadOnlySpan\u003CT\u003E,IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.RemoveRange(T[],IEqualityComparer\u003CT\u003E?)",
          "M:ImmutableArray\u003CT\u003E.Slice(int,int)",
          "T:ImmutableArray",
          "T:ImmutableArray\u003CT\u003E",
          "T:ImmutableArray\u003CT\u003E.Builder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33112,
          "Title": "Add AttributeTargets.Interface to JsonConverterAttribute",
          "Author": "dlyz",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-03T17:17:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33112",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870805991",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33112#issuecomment-870805991",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    // Adding AttributeTargets.Interface\r\n    [AttributeUsage(AttributeTargets.Class |\r\n                    AttributeTargets.Struct |\r\n                    AttributeTargets.Interface |\r\n                    AttributeTargets.Enum |\r\n                    AttributeTargets.Property |\r\n                    AttributeTargets.Field, AllowMultiple = false)]\r\n    public class JsonConverterAttribute : JsonAttribute\r\n    {        \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:JsonConverterAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30486,
          "Title": "Unseal JsonStringEnumConverter",
          "Author": "josundt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-08-05T14:46:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30486",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870804137",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30486#issuecomment-870804137",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    // Unsealed\r\n    public class JsonStringEnumConverter : JsonConverterFactory\r\n    {\r\n        // Existing:\r\n        // public JsonStringEnumConverter();\r\n        // public JsonStringEnumConverter(JsonNamingPolicy? namingPolicy = null, bool allowIntegerValues = true);\r\n\r\n        // Existing methods, now sealed\r\n        public sealed override bool CanConvert(Type typeToConvert);\r\n        public sealed override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonStringEnumConverter.CanConvert(Type)",
          "M:JsonStringEnumConverter.CreateConverter(Type,JsonSerializerOptions)",
          "T:JsonStringEnumConverter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54633,
          "Title": "Consider Reloadable Attribute for Hot Reload ",
          "Author": "tommcdon",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-23T18:23:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54633",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870814731",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54633#issuecomment-870814731",
        "FeedbackMarkdown": "* We should avoid \u0022good names\u0022, that is single word names like \u0060[Reloadable]\u0060.\r\n* Assuming you don\u0027t like \u0060EditMetadataByCreatingNewTypeAttribute\u0060 come back with a few proposals and we can pick one over email\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{  \r\n    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false)]  \r\n    public class EditMetadataByCreatingNewTypeAttribute : Attribute  \r\n    {  \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:EditMetadataByCreatingNewTypeAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54748,
          "Title": "Support property ordering on POCOs",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-25T16:05:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54748",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870827031",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54748#issuecomment-870827031",
        "FeedbackMarkdown": "* It seems the default value shouldn\u0027t be zero, but a high enough number (e.g. \u0060int.MaxValue / 2\u0060) so that people can force fields to be at the beginning or the end without having to apply the attribute to all properties\r\n* We should consider having an analyzer that checks that no duplicates exist\r\n    - However, properties/fields without the attribute should be ignored\r\n* The sort order should be across the hierarchy, e.g. a derived type should be able to inject a member between members coming from the base\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]\r\n    public sealed class JsonPropertyOrderAttribute : JsonAttribute\r\n    {\r\n        public JsonPropertyNameAttribute(int order);\r\n        public int Order { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonPropertyOrderAttribute.JsonPropertyNameAttribute(int)",
          "P:JsonPropertyOrderAttribute.Order",
          "T:JsonPropertyOrderAttribute"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 40555,
          "Title": "FORMATEC should define cfFormat as a ushort",
          "Author": "jeffschwMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-08-07T23:27:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/40555",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "area-Interop-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870829690",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/40555#issuecomment-870829690",
        "FeedbackMarkdown": "It\u0027s a breaking change and it seems this isn\u0027t the only place where we don\u0027t match the signedness of the native implementation. Considering this type was shipped in 2005 it seems the downsides of the breaking change outweigh the potential benefits.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 52276,
          "Title": "LoggerMessageAttribute should have a constructor that takes EventId, LogLevel, and Message",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-04T23:07:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/52276",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-06-29T00:00:00-07:00",
        "FeedbackId": "870849586",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/52276#issuecomment-870849586",
        "FeedbackMarkdown": "* We don\u0027t want to add another overload because the design of attributes is that optional parameters are settable properties and this one is optional for some consumers\r\n* It seems for library developers it would be beneficial to have an analyzer that flags code that doesn\u0027t initialize \u0060EventName\u0060 to a literal string. And with that, it wouldn\u0027t matter if it\u0027s a constructor or a property.\r\n* Aesthetically, we can see the argument for wanting a constructor argument but we feel the added complexity isn\u0027t worth it.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50658,
          "Title": "Developers will be able to control how distributed tracing information is propagated",
          "Author": "shirhatti",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-02T19:27:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50658",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-06T00:00:00-07:00",
        "FeedbackId": "875007158",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50658#issuecomment-875007158",
        "FeedbackMarkdown": "* Since there\u0027s already a strong delegate type for the getter, let\u0027s use a strong delegate type for the setter to name the string parameters.\r\n* Extract(out id, out state) should use the \u0022trace\u0022 prefix to help callers understand the alignment to (e.g.) Activity.TraceStateString\r\n* Instead of relying on the shape of the out parameters, the different Extract methods should use purpose names\r\n* We renamed CreateLegacyPropagator() to CreateDefaultPropagator()\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public abstract class TextMapPropagator\r\n    {\r\n      public delegate void PropagatorGetterCallback(object carrier, string fieldName, out string? fieldValue, out IEnumerable\u003Cstring\u003E? fieldValues);\r\n      public delegate void PropagatorSetterCallback(object carrier, string fieldName, string fieldValue);\r\n\r\n      public abstract IReadOnlyCollection\u003Cstring\u003E Fields { get; }\r\n      public abstract void Inject(Activity activity, object carrier, PropagatorSetterCallback setter);\r\n      public abstract void ExtractTraceIdAndState(object carrier, PropagatorGetterCallback getter, out string? traceId, out string? traceState);\r\n      public abstract IEnumerable\u003CKeyValuePair\u003Cstring, string?\u003E\u003E? ExtractBaggage(object carrier, PropagatorGetterCallback getter);\r\n\r\n      public static TextMapPropagator Current { get; set; }\r\n      public static TextMapPropagator CreateDefaultPropagator() { throw null; }\r\n      public static TextMapPropagator CreatePassThroughPropagator() { throw null; }\r\n      public static TextMapPropagator CreateNoOutputPropagator() { throw null; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:TextMapPropagator.CreateDefaultPropagator()",
          "M:TextMapPropagator.CreateNoOutputPropagator()",
          "M:TextMapPropagator.CreatePassThroughPropagator()",
          "M:TextMapPropagator.ExtractBaggage(object,PropagatorGetterCallback)",
          "M:TextMapPropagator.ExtractTraceIdAndState(object,PropagatorGetterCallback,out string?,out string?)",
          "M:TextMapPropagator.Inject(Activity,object,PropagatorSetterCallback)",
          "P:TextMapPropagator.Current",
          "P:TextMapPropagator.Fields",
          "T:TextMapPropagator",
          "T:TextMapPropagator.PropagatorGetterCallback(object,string,out string?,out IEnumerable\u003Cstring\u003E?)",
          "T:TextMapPropagator.PropagatorSetterCallback(object,string,string)"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 4720,
          "Title": "[MDI] Add possibility to align minimized child to default location (TOP LEFT)",
          "Author": "kirsan31",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-24T11:41:28+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/4720",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "design-discussion",
              "Color": "f7b7ee",
              "Description": "Ongoing discussion about design without consensus"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "area: MDI",
              "Color": "86e891",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879265522",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/4720#issuecomment-879265522",
        "FeedbackMarkdown": "* It seems beneficial to indicate the Windows Forms behavior instead of describing the Win32 default. This way, should Windows change the behavior we don\u0027t have an incorrect description. Hence, the property should flip the default value and describe what Windows Forms does\r\n* Should be in the same property grid category as \u0060MdiChildren\u0060\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class Form\r\n    {\r\n        [SRCategory(nameof(SR.CatWindowStyle))]\r\n        [DefaultValue(true)]\r\n        [SRDescription(nameof(SR.FormMdiChildrenMinimizedAnchorTopDescr))]\r\n        public bool MdiChildrenMinimizedAnchorBottom { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:Form.MdiChildrenMinimizedAnchorBottom",
          "T:Form"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 55522,
          "Title": "API that returns framework version",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-12T17:40:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/55522",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879274336",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/55522#issuecomment-879274336",
        "FeedbackMarkdown": "* We concluded we don\u0027t need a new API, we\u0027ll just use \u0060Environment.Version\u0060 which exposes the platform version\r\n* WinForms/WPF can decide to support an \u0060AppContext\u0060 switch so that both that if the new string returned via the UIA\u0027s \u0060FrameworkId\u0060 property breaks people, they can get back the old behavior.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 55274,
          "Title": "Unify RequiresUnreferencedCode and RequiresAssemblyFiles attributes",
          "Author": "vitek-karas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-07T16:04:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/55274",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Single-File",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879282507",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/55274#issuecomment-879282507",
        "FeedbackMarkdown": "* We\u0027re happy with the default message most of the time, so we shouldn\u0027t remove the parameterless constructor.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    public sealed class RequiresAssemblyFilesAttribute : Attribute\r\n    {\r\n        public RequiresAssemblyFilesAttribute();\r\n        public RequiresAssemblyFilesAttribute(string message);\r\n        public string Message { get; }\r\n        public string Url { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:RequiresAssemblyFilesAttribute.RequiresAssemblyFilesAttribute()",
          "M:RequiresAssemblyFilesAttribute.RequiresAssemblyFilesAttribute(string)",
          "P:RequiresAssemblyFilesAttribute.Message",
          "P:RequiresAssemblyFilesAttribute.Url",
          "T:RequiresAssemblyFilesAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 55556,
          "Title": "Allow specifying a context propagator on SocketsHttpHandler",
          "Author": "MihaZupan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-13T07:16:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/55556",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Http",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879287421",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/55556#issuecomment-879287421",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Http\r\n{\r\n    public sealed class SocketsHttpHandler\r\n    {\r\n        public DistributedContextPropagator? ActivityHeadersPropagator { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:SocketsHttpHandler.ActivityHeadersPropagator",
          "T:SocketsHttpHandler"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43997,
          "Title": "EventWaitHandle can be named, but has no Name property",
          "Author": "erikness",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-29T00:00:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43997",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "os-windows",
              "Color": "fef2c0",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879290343",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43997#issuecomment-879290343",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - But do we need a protected constructor that takes the name, will we use an internal setter, or should we make the property virtual? Any of these are fine with us.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading\r\n{\r\n    public partial class WaitHandle\r\n    {\r\n        public string? Name { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:WaitHandle.Name",
          "T:WaitHandle"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36134,
          "Title": "Specify SizeConst when marshalling field as ByValArray",
          "Author": "elinor-fung",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-08T18:42:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36134",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879294790",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36134#issuecomment-879294790",
        "FeedbackMarkdown": "* The analyzer should probably also handle \u0060UnmanagedType.ByValTStr\u0060\r\n    - Should be the same diagnostic ID with a slightly different message\r\n* Assuming code like this wouldn\u0027t work at runtime, turning the rule on by default seems fine\r\n    - If code like this works today, then on by default might be noisy",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48573,
          "Title": "Introduce static methods to allocate and throw key exception types.",
          "Author": "geeknoid",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-21T17:09:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48573",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "size-reduction",
              "Color": "85144b",
              "Description": "Issues impacting final app size primary for size sensitive workloads"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879305700",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48573#issuecomment-879305700",
        "FeedbackMarkdown": "* Let\u0027s scope this to just \u0060ArgumentNullException\u0060\r\n* This API might be less useful with C#\u0027 upcoming parameter \u0060null\u0060-validation feature\r\n    - Still useful for other languages or potentially useful for letting the compiler use a centralized method\r\n    - Also useful in cases the compiler injected validation wouldn\u0027t work, e.g. due to ordering\r\n* We can do it for .NET 6 \u0027cause it\u0027s cheap\r\n* We might be able to mark this API as \u0022doesn\u0027t change between versions\u0022 so that there is no penalty for ready-to-run\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ArgumentNullException\r\n    {\r\n        public static void ThrowIfNull([NotNull] object? argument,\r\n                                       [CallerArgumentExpression(\u0022argument\u0022)] string? paramName = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ArgumentNullException.ThrowIfNull(object?,string?)",
          "T:ArgumentNullException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 55579,
          "Title": "Obsolete CryptoConfig.EncodeOID",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-13T16:11:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/55579",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879308889",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/55579#issuecomment-879308889",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* Just dispense another diagnostic ID :-)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class CryptoConfig\r\n    {\r\n        [Obsolete(\u0022EncodeOID is obsolete. Use the ASN.1 functionality provided in System.Formats.Asn1.\u0022)]\r\n        public static byte[] EncodeOID(string str);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CryptoConfig.EncodeOID(string)",
          "T:CryptoConfig"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51630,
          "Title": "APIs for exporting certificates and keys to PEM",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-21T16:04:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51630",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879312802",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51630#issuecomment-879312802",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public partial class AsymmetricAlgorithm\r\n    {\r\n        public string ExportPkcs8PrivateKeyPem();\r\n        public bool TryExportPkcs8PrivateKeyPem(Span\u003Cchar\u003E buffer, out int charsWritten);\r\n        public string ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan\u003Cchar\u003E password, PbeParameters pbeParameters);\r\n        public bool TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan\u003Cchar\u003E password, PbeParameters pbeParameters, Span\u003Cchar\u003E destination, out int charsWritten);\r\n        public string ExportSubjectPublicKeyInfoPem();\r\n        public bool TryExportSubjectPublicKeyInfoPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n    public partial class RSA\r\n    {\r\n        public string ExportRSAPrivateKeyPem();\r\n        public string ExportRSAPublicKeyPem();\r\n        public bool TryExportRSAPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n        public bool TryExportRSAPublicKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n    public partial class ECDsa\r\n    {\r\n        public string ExportECPrivateKeyPem();\r\n        public bool TryExportECPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n    public partial class ECDiffieHellman\r\n    {\r\n        public string ExportECPrivateKeyPem();\r\n        public bool TryExportECPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n}\r\nnamespace System.Security.Cryptography.X509Certificates\r\n{\r\n    public partial class X509Certificate2\r\n    {\r\n        public string ExportCertificatePem();\r\n        public bool TryExportCertificatePem(Span\u003Cchar\u003E buffer, out int charsWritten);\r\n    }\r\n    public partial class X509Certificate2Collection\r\n    {\r\n        public string ExportCertificatePems();\r\n        public bool TryExportCertificatePems(Span\u003Cchar\u003E buffer, out int charsWritten);\r\n        public string ExportPkcs7Pem();\r\n        public bool TryExportPkcs7Pem(Span\u003Cchar\u003E buffer, out int charsWritten);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:AsymmetricAlgorithm.ExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan\u003Cchar\u003E,PbeParameters)",
          "M:AsymmetricAlgorithm.ExportPkcs8PrivateKeyPem()",
          "M:AsymmetricAlgorithm.ExportSubjectPublicKeyInfoPem()",
          "M:AsymmetricAlgorithm.TryExportEncryptedPkcs8PrivateKeyPem(ReadOnlySpan\u003Cchar\u003E,PbeParameters,Span\u003Cchar\u003E,out int)",
          "M:AsymmetricAlgorithm.TryExportPkcs8PrivateKeyPem(Span\u003Cchar\u003E,out int)",
          "M:AsymmetricAlgorithm.TryExportSubjectPublicKeyInfoPem(Span\u003Cchar\u003E,out int)",
          "M:ECDiffieHellman.ExportECPrivateKeyPem()",
          "M:ECDiffieHellman.TryExportECPrivateKeyPem(Span\u003Cchar\u003E,out int)",
          "M:ECDsa.ExportECPrivateKeyPem()",
          "M:ECDsa.TryExportECPrivateKeyPem(Span\u003Cchar\u003E,out int)",
          "M:RSA.ExportRSAPrivateKeyPem()",
          "M:RSA.ExportRSAPublicKeyPem()",
          "M:RSA.TryExportRSAPrivateKeyPem(Span\u003Cchar\u003E,out int)",
          "M:RSA.TryExportRSAPublicKeyPem(Span\u003Cchar\u003E,out int)",
          "M:X509Certificate2.ExportCertificatePem()",
          "M:X509Certificate2.TryExportCertificatePem(Span\u003Cchar\u003E,out int)",
          "M:X509Certificate2Collection.ExportCertificatePems()",
          "M:X509Certificate2Collection.ExportPkcs7Pem()",
          "M:X509Certificate2Collection.TryExportCertificatePems(Span\u003Cchar\u003E,out int)",
          "M:X509Certificate2Collection.TryExportPkcs7Pem(Span\u003Cchar\u003E,out int)",
          "T:AsymmetricAlgorithm",
          "T:ECDiffieHellman",
          "T:ECDsa",
          "T:RSA",
          "T:X509Certificate2",
          "T:X509Certificate2Collection"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51700,
          "Title": "Add new ObjectDisposedException constructor overload",
          "Author": "marek-safar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-22T17:38:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51700",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879318401",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51700#issuecomment-879318401",
        "FeedbackMarkdown": "* Let\u0027s also add an overload that takes \u0060Type\u0060 directly\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ObjectDisposedException\r\n    {\r\n        public ObjectDisposedException(object instance);\r\n        public ObjectDisposedException(Type type);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ObjectDisposedException.ObjectDisposedException(object)",
          "M:ObjectDisposedException.ObjectDisposedException(Type)",
          "T:ObjectDisposedException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54792,
          "Title": "Add Dispose/IDisposable to GCHandle",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-27T16:55:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54792",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879319758",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54792#issuecomment-879319758",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public struct GCHandle : IDisposable\r\n    {\r\n        public void Dispose();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:GCHandle.Dispose()",
          "T:GCHandle"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 19089,
          "Title": "Add IReadOnlyList\u003CT\u003E constructor to ReadOnlyCollection\u003CT\u003E",
          "Author": "bartdesmet",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2016-10-25T16:35:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/19089",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-13T00:00:00-07:00",
        "FeedbackId": "879333755",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/19089#issuecomment-879333755",
        "FeedbackMarkdown": "* This API has the issue that it would be ambiguous for common types, such as \u0060List\u003CT\u003E\u0060\r\n* This would also force the implementation to grow by a field or having to type cast in every operation between \u0060IList\u003CT\u003E\u0060 and \u0060IReadOnlyList\u003CT\u003E\u0060\r\n* Instead of this, we probably should expose an API that allows adapting an \u0060IList\u003CT\u003E\u0060 to an \u0060IReadOnlyList\u003CT\u003E\u0060 by casting or wrapping (and vice versa)\r\n     - @terrajobst will make separate API proposal for this.\r\n* Hence we wouldn\u0027t do this API",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "B5gKYCMoh3c",
      "StartDateTime": "2021-07-15T10:06:45-07:00",
      "EndDateTime": "2021-07-15T11:51:37-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/B5gKYCMoh3c/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "designs",
          "Id": 205,
          "Title": "Adding a rough draft of the \u0022minimum viable product\u0022 for the .NET Libraries APIs to support generic math",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-15T04:09:21+00:00",
          "Url": "https://github.com/dotnet/designs/pull/205",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-15T00:00:00-07:00",
        "FeedbackId": "880930751",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/designs/issues/205#issuecomment-880930751",
        "FeedbackMarkdown": "Notes from today\u0027s review:\r\n\r\n* We\u0027d like to keep the split of \u0060IParseable\u003CTSelf\u003E\u0060 and \u0060ISpanParseable\u003CTSelf\u003E\u0060 because spans are more advanced and we don\u0027t want to force span processing on everyone\r\n    - However, if there is a limitation on number of interfaces, then this is a good candidate to collapse\r\n    - There is also an argument one could make that span is a core concept and we generally want type providers to support it moving forward and collapsing would make that mandate more explicit. However, this might have implications on languages that don\u0027t support spans.\r\n* We should extract the \u0060Create\u0060 methods to an \u0060IConvertible\u003CTSelf\u003E\u0060, akin to \u0060IParseable\u003CTSelf\u003E\u0060\r\n    - This would make conversion of types without boxing available outside of generic math and not be limited to numbers\r\n    - We should probably use the \u0060Convert\u0060 verb, rather than \u0060Create\u0060\r\n* For converting, we have three behaviors when the value doesn\u0027t fit:\r\n    1. Truncating/wrapping\r\n    2. Saturating\r\n    3. Throwing\r\n* It seems we can\u0027t agree on the default, so it seems we should have three differently named methods:\r\n    - \u0060CreateTruncated\u0060\r\n    - \u0060CreateClamped\u0060\r\n    - \u0060CreateChecked\u0060\r\n* We talked about which members we\u0027d implement explicitly vs implicitly\r\n    - We\u0027re generally OK with implementing most implicitly, which would increase the API surface of the primitive types, but that seems fine\r\n    - However, we should implement members explicitly that are nonsensical or aren\u0027t needed outside of a generic context, such as most of the \u0060Create\u0060 methods",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54390,
          "Title": "Expose nint/nuint overloads for BitOperations",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-18T02:16:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54390",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-15T00:00:00-07:00",
        "FeedbackId": "880933389",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54390#issuecomment-880933389",
        "FeedbackMarkdown": "Looks good as proposed:\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static partial class BitOperations\r\n    {\r\n        public static bool IsPow2(nint value);\r\n        public static bool IsPow2(nuint value);\r\n\r\n        public static nuint RoundUpToPowerOf2(nuint value);\r\n\r\n        public static int LeadingZeroCount(nuint value);\r\n\r\n        public static int Log2(nuint value);\r\n\r\n        public static int PopCount(nuint value);\r\n\r\n        public static int TrailingZeroCount(nint value);\r\n        public static int TrailingZeroCount(nuint value);\r\n\r\n        public static nuint RotateLeft(nuint value, int offset);\r\n        public static nuint RotateRight(nuint value, int offset);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59760000000,
        "Apis": [
          "M:BitOperations.IsPow2(nint)",
          "M:BitOperations.IsPow2(nuint)",
          "M:BitOperations.LeadingZeroCount(nuint)",
          "M:BitOperations.Log2(nuint)",
          "M:BitOperations.PopCount(nuint)",
          "M:BitOperations.RotateLeft(nuint,int)",
          "M:BitOperations.RotateRight(nuint,int)",
          "M:BitOperations.RoundUpToPowerOf2(nuint)",
          "M:BitOperations.TrailingZeroCount(nint)",
          "M:BitOperations.TrailingZeroCount(nuint)",
          "T:BitOperations"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "POU7RxyBAoI",
      "StartDateTime": "2021-07-20T10:04:57-07:00",
      "EndDateTime": "2021-07-20T12:25:11-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/POU7RxyBAoI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 5069,
          "Title": "Introduce ApplyApplicationDefaults Event to the Application Framework",
          "Author": "KlausLoeffelmann",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-09T20:17:42+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/5069",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-20T00:00:00-07:00",
        "FeedbackId": "883569659",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/5069#issuecomment-883569659",
        "FeedbackMarkdown": "API Review:\r\n\r\n* \u0060ApplyApplicationDefaultsEventHandler\u0060 should be \u0060EventHandler\u003CApplyApplicationDefaults\u003E\u0060, but since the rest of the events on this type are custom delegates doing this one that way is OK (and may be needed due to an IDE limitation)\r\n* Ideally \u0060MinimumSplashScreenDisplayTime\u0060 would be a \u0060TimeSpan\u0060, but since it\u0027s just echoing an existing unitless \u0060int\u0060 property it\u0027s OK.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.VisualBasic.ApplicationServices\r\n{\r\n    public partial class WindowsFormsApplicationBase\r\n    {\r\n        public event EventHandler\u003CApplyDefaultsEventArgs\u003E ApplyApplicationDefaults;\r\n        \r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        protected HighDpiMode HighDpiMode { get; set; }\r\n\r\n        // Existing property, but new attribute\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        public int MinimumSplashScreenDisplayTime { get; set; }\r\n    }\r\n\r\n    public class ApplyApplicationDefaultsEventArgs : EventArgs\r\n    {\r\n        public Font DefaultFont { get; set; }\r\n        public HighDpiMode HighDpiMode { get; set; }\r\n        public int MinimumSplashScreenDisplayTime { get; set; }\r\n    }\r\n\r\n    [EditorBrowsable(EditorBrowsableState.Advanced)]\r\n    public delegate void ApplyApplicationDefaultsEventHandler(object sender, ApplyDefaultsEventArgs e);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:ApplyApplicationDefaultsEventArgs.DefaultFont",
          "P:ApplyApplicationDefaultsEventArgs.HighDpiMode",
          "P:ApplyApplicationDefaultsEventArgs.MinimumSplashScreenDisplayTime",
          "P:WindowsFormsApplicationBase.HighDpiMode",
          "P:WindowsFormsApplicationBase.MinimumSplashScreenDisplayTime",
          "T:ApplyApplicationDefaultsEventArgs",
          "T:ApplyApplicationDefaultsEventHandler(object,ApplyDefaultsEventArgs)",
          "T:WindowsFormsApplicationBase"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 31274,
          "Title": "We should be able serialize and deserialize from DOM",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-10-23T18:53:38+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/31274",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-20T00:00:00-07:00",
        "FeedbackId": "883578067",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/31274#issuecomment-883578067",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public static partial class JsonSerializer\r\n    {\r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonDocument document, JsonSerializerOptions? options = null);\r\n\t       public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerOptions? options = null);\r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonDocument document, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerContext context);\r\n\t  \r\n\t       public static JsonDocument SerializeToDocument\u003CTValue\u003E(TValue value, JsonSerializerOptions? options = null);\r\n\t       public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerOptions? options = null);\r\n\t       public static JsonDocument SerializeToDocument\u003CTValue\u003E(TValue value, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerContext context);\r\n\t  \r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonElement element, JsonSerializerOptions? options = null);\r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonElement element, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerOptions? options = null);\r\n\t       public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerContext context);\r\n\t  \r\n\t       public static JsonElement SerializeToElement\u003CTValue\u003E(TValue value, JsonSerializerOptions? options = null);\r\n\t       public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerOptions? options = null);\r\n\t       public static JsonElement SerializeToElement\u003CTValue\u003E(TValue value, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerContext context);\r\n\t  \r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonNode node, JsonSerializerOptions? options = null);\r\n\t       public static TValue? Deserialize\u003CTValue\u003E(this JsonNode node, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static object? Deserialize(this JsonNode node, Type returnType, JsonSerializerOptions? options = null);\r\n\t       public static object? Deserialize(this JsonNode node, Type returnType, JsonSerializerContext context);\r\n\t  \r\n\t       public static JsonNode? SerializeToNode\u003CTValue\u003E(TValue value, JsonSerializerOptions? options = null);\r\n\t       public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerOptions? options = null);\r\n\t       public static JsonNode? SerializeToNode\u003CTValue\u003E(TValue value, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo);\r\n\t       public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17090000000,
        "Apis": [
          "M:JsonSerializer.Deserialize(this JsonDocument,Type,JsonSerializerContext)",
          "M:JsonSerializer.Deserialize(this JsonDocument,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize(this JsonElement,Type,JsonSerializerContext)",
          "M:JsonSerializer.Deserialize(this JsonElement,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize(this JsonNode,Type,JsonSerializerContext)",
          "M:JsonSerializer.Deserialize(this JsonNode,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonDocument,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonDocument,JsonTypeInfo\u003CTValue\u003E)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonElement,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonElement,JsonTypeInfo\u003CTValue\u003E)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonNode,JsonSerializerOptions?)",
          "M:JsonSerializer.Deserialize\u003CTValue\u003E(this JsonNode,JsonTypeInfo\u003CTValue\u003E)",
          "M:JsonSerializer.SerializeToDocument(object?,Type,JsonSerializerContext)",
          "M:JsonSerializer.SerializeToDocument(object?,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToDocument\u003CTValue\u003E(TValue,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToDocument\u003CTValue\u003E(TValue,JsonTypeInfo\u003CTValue\u003E)",
          "M:JsonSerializer.SerializeToElement(object?,Type,JsonSerializerContext)",
          "M:JsonSerializer.SerializeToElement(object?,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToElement\u003CTValue\u003E(TValue,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToElement\u003CTValue\u003E(TValue,JsonTypeInfo\u003CTValue\u003E)",
          "M:JsonSerializer.SerializeToNode(object?,Type,JsonSerializerContext)",
          "M:JsonSerializer.SerializeToNode(object?,Type,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToNode\u003CTValue\u003E(TValue,JsonSerializerOptions?)",
          "M:JsonSerializer.SerializeToNode\u003CTValue\u003E(TValue,JsonTypeInfo\u003CTValue\u003E)",
          "T:JsonSerializer"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48615,
          "Title": "Add blittable Color to System.Numerics",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-22T19:35:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48615",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-20T00:00:00-07:00",
        "FeedbackId": "883635884",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48615#issuecomment-883635884",
        "FeedbackMarkdown": "We lost quorum during the API Review meeting for this.  There was concern that it\u0027s proposed as a primitive and there\u0027s not clear evidence that the interested parties have signed off that it\u0027s usable for them.  So it\u0027d be great to get that feedback from someone before approval.\r\n\r\nNotes we took when discussing the proposal:\r\n\r\n\r\n* The types should be ISpanFormattable\r\n* The constraints on these types would ideally be \u0060IScalar\u0060.  If we can get the constraint more constrained that would be great.\r\n* They\u0027re IFormattable, should they be IParsable?\r\n* The Argb and Rgba non-generic types should also have BigEndian versions of their routines.\r\n* The System.Drawing.Color from \u0060Argb\u003Cbyte\u003E\u0060 should be an overload of \u0060Color.FromArgb\u0060\r\n* Eliminate the RGBA interaction to System.Drawing.Color in favor of conversions from RGBA to ARGB\r\n  * Argb\u003CT\u003E.ToRgba\u003CT\u003E, and Rgba\u003CT\u003E.ToArgb\u003CT\u003E.  Don\u0027t need the Froms.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing\r\n{\r\n    partial struct Color : IEquatable\u003CColor\u003E\r\n    {\r\n        public static Color FromArgb(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n        public static implicit operator Color(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n\r\n        // ToNumericsArgb? ToArgbNumerics?\r\n        public System.Numerics.Colors.Argb\u003Cbyte\u003E ToArgbValue();\r\n        public static explicit operator System.Numerics.Colors.Argb\u003Cbyte\u003E(in Color color);\r\n    }\r\n}\r\n\r\nnamespace System.Numerics.Colors\r\n{\r\n    public static class Argb\r\n    {\r\n        public static Argb\u003Cbyte\u003E CreateBigEndian(uint color);\r\n        public static Argb\u003Cbyte\u003E CreateLittleEndian(uint color);\r\n        public static uint ToUInt32LittleEndian(this Argb\u003Cbyte\u003E color);\r\n        public static uint ToUInt32BigEndian(this Argb\u003Cbyte\u003E color);\r\n    }\r\n\r\n    public readonly struct Argb\u003CT\u003E : IEquatable\u003CArgb\u003CT\u003E\u003E, IFormattable, ISpanFormattable where T : struct\r\n    {\r\n        public T A { get; }\r\n        public T R { get; }\r\n        public T G { get; }\r\n        public T B { get; }\r\n\r\n        public Argb(T a, T r, T g, T b);\r\n        public Argb(ReadOnlySpan\u003CT\u003E values);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n        public bool Equals(Argb\u003CT\u003E other);\r\n        public string ToString(string format, IFormatProvider formatProvider);\r\n        // whatever ISpanFormattable says\r\n        public Rgba\u003CT\u003E ToRgba();\r\n    }\r\n\r\n    public static class Rgba\r\n    {\r\n        public static Rgba\u003Cbyte\u003E CreateLittleEndian(uint color);\r\n        public static Rgba\u003Cbyte\u003E CreateBigEndian(uint color);\r\n        public static uint ToUInt32LittleEndian(this Rgba\u003Cbyte\u003E color);\r\n        public static uint ToUInt32BigEndian(this Rgba\u003Cbyte\u003E color);\r\n    }\r\n\r\n    public readonly struct Rgba\u003CT\u003E : IEquatable\u003CRgba\u003CT\u003E\u003E, IFormattable, ISpanFormattable where T : struct\r\n    {\r\n        public T R { get; }\r\n        public T G { get; }\r\n        public T B { get; }\r\n        public T A { get; }\r\n\r\n        public Rgba(T r, T g, T b, T a);\r\n        public Rgba(ReadOnlySpan\u003CT\u003E values);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n        public bool Equals(Rgba\u003CT\u003E other);\r\n        public string ToString(string format, IFormatProvider formatProvider);\r\n        // whatever ISpanFormattable says\r\n        public Argb\u003CT\u003E ToArgb();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24940000000,
        "Apis": [
          "M:Argb.CreateBigEndian(uint)",
          "M:Argb.CreateLittleEndian(uint)",
          "M:Argb.ToUInt32BigEndian(this Argb\u003Cbyte\u003E)",
          "M:Argb.ToUInt32LittleEndian(this Argb\u003Cbyte\u003E)",
          "M:Argb\u003CT\u003E.Argb(ReadOnlySpan\u003CT\u003E)",
          "M:Argb\u003CT\u003E.Argb(T,T,T,T)",
          "M:Argb\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:Argb\u003CT\u003E.Equals(Argb\u003CT\u003E)",
          "M:Argb\u003CT\u003E.ToRgba()",
          "M:Argb\u003CT\u003E.ToString(string,IFormatProvider)",
          "M:Color.explicit(in Color)",
          "M:Color.FromArgb(System.Numerics.Colors.Argb\u003Cbyte\u003E)",
          "M:Color.implicit(System.Numerics.Colors.Argb\u003Cbyte\u003E)",
          "M:Color.ToArgbValue()",
          "M:Rgba.CreateBigEndian(uint)",
          "M:Rgba.CreateLittleEndian(uint)",
          "M:Rgba.ToUInt32BigEndian(this Rgba\u003Cbyte\u003E)",
          "M:Rgba.ToUInt32LittleEndian(this Rgba\u003Cbyte\u003E)",
          "M:Rgba\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Equals(Rgba\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Rgba(ReadOnlySpan\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Rgba(T,T,T,T)",
          "M:Rgba\u003CT\u003E.ToArgb()",
          "M:Rgba\u003CT\u003E.ToString(string,IFormatProvider)",
          "P:Argb\u003CT\u003E.A",
          "P:Argb\u003CT\u003E.B",
          "P:Argb\u003CT\u003E.G",
          "P:Argb\u003CT\u003E.R",
          "P:Rgba\u003CT\u003E.A",
          "P:Rgba\u003CT\u003E.B",
          "P:Rgba\u003CT\u003E.G",
          "P:Rgba\u003CT\u003E.R",
          "T:Argb",
          "T:Argb\u003CT\u003E",
          "T:Color",
          "T:Rgba",
          "T:Rgba\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "fnqHXFKSpaw",
      "StartDateTime": "2021-07-27T10:05:32-07:00",
      "EndDateTime": "2021-07-27T12:21:33-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/fnqHXFKSpaw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36064,
          "Title": "Finalize logging analyzers",
          "Author": "pakrym",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-09-20T19:29:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36064",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "area-Extensions-Logging",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887699727",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36064#issuecomment-887699727",
        "FeedbackMarkdown": "API Review notes\r\n\r\n\r\n* Diagnostic 1\r\n  * A fixer seems doable here.\r\n  * A level higher than Disabled seems warranted.  (Hidden?)\r\n  * Category: Naming\r\n* Diagnostic 2\r\n  * A fixer seems possible here, but the resolution should create a static field for the defined message, not a local variable.\r\n  * Should be Hidden, not Disabled.\r\n  * Category: Performance\r\n* Diagnostic 3\r\n  * The example should be updated.  \u0060logger.LogTrace(\u0022{0}\u0022, value)\u0060 =\u003E \u0060logger.LogTrace(\u0022{Value}\u0022, value)\u0060\r\n  * Information / Usage\r\n* Diagnostic 4\r\n  * This should not apply to LoggerMessage.Define, just LogTrace (and friends).\r\n  * Information / Usage\r\n* Diagnostic 5\r\n  * Warning does seems appropriate when/since you can prove it\u0027s a guaranteed exception.\r\n  * Since it\u0027s about an exception, let\u0027s use Reliability instead of Usage.\r\n  * Warning / Reliability",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33792,
          "Title": "Prefer Nullable\u003CT\u003E.GetValueOrDefault() over manual checking",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33792",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887702637",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33792#issuecomment-887702637",
        "FeedbackMarkdown": "The feeling in the room during API review is we should just fix the JIT here.  The resulting code this suggests looks rather unnatural.",
        "TimeCode": 17310000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33793,
          "Title": "Avoid implicitly allocating params arrays in loops",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33793",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887713862",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33793#issuecomment-887713862",
        "FeedbackMarkdown": "The proposed fixes, and situations where they won\u0027t fix things, seem a bit strange.  There\u0027s value in highlighting that the array allocation is happening in a loop, but the manner in which it gets fixed (or ignored) is too variable.  So we shouldn\u0027t have a fixer at this time.  (Ideally we\u0027ll get params-span and that\u0027ll make this go away)\r\n\r\n* Category: Performance\r\n* Severity: Hidden",
        "TimeCode": 19990000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33800,
          "Title": "Prefer Dictionary.Remove(key, out value) over Dictionary.this[key], followed by Dictionary.Remove(key)",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:05+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33800",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887733349",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33800#issuecomment-887733349",
        "FeedbackMarkdown": "We came up with a lot of cases where the fixer can cause surprising functional changes, so this really only applies when there\u0027s an indexer followed by a call to Remove with no other method calls in between (because any method call could have modified the dictionary).  As a specific example, in https://github.com/dotnet/runtime/issues/33800#issuecomment-853477405 if \u0060Foo\u0060 throws then in the before case the dictionary is not modified, but in the after case it is.\r\n\r\nThe case of \u0060x = dict[key]; dict.Remove(key);\u0060 isn\u0027t safe to replace, because the exception is lost.\r\n\r\nConclusion:\r\n\r\nIf we find a dictionary call to TryGetValue that is immediately followed by a call to Remove (and the dictionary and the key are both simple variable or parameter expressions) then suggest collapsing them to Remove(key, out T).  (\u0022immediate\u0022 definitely means that there are no method calls or delegate invocations between those two expressions)\r\n\r\n* Category: Performance\r\n* Severity: Information",
        "TimeCode": 30510000000,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44194,
          "Title": "Proposal: reconsider CLSCompliant and CA1014",
          "Author": "huoyaoyuan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-03T13:26:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44194",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887742046",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44194#issuecomment-887742046",
        "FeedbackMarkdown": "Removing the rule from AllEnabledByDefault, if possible, is reasonable.  But otherwise this is tightly coupled to the still in progress question of what we\u0027re doing with CLS compliance and we can\u0027t really take action at this time.",
        "TimeCode": 48830000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47927,
          "Title": "Add analyzer: Prevent wrong usage of string Split",
          "Author": "Mrxx99",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-05T19:15:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47927",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887754040",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47927#issuecomment-887754040",
        "FeedbackMarkdown": "Using a messaging along the lines of \u0022suspicious cast\u0022, having the rule identify calls to string.Split or StringBuilder..ctor that involves an implicit conversion from char to int seems like goodness (and we may add more specific API over time).  All of the methods/constructors that we group together in this rule will use the same diagnostic ID.\r\n\r\nThere are some generalizations (any implicit char-\u003Eint in an argument; or that but only when there\u0027s an overload that takes char/string) which would be good to follow up on, but they\u0027re out of scope for this issue.\r\n\r\n* Category: Correctness\r\n* Severity: Warning",
        "TimeCode": 55760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51193,
          "Title": "Recommend use of concrete types to maximize devirtualization potential",
          "Author": "geeknoid",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-13T20:32:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51193",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-07-27T00:00:00-07:00",
        "FeedbackId": "887770999",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51193#issuecomment-887770999",
        "FeedbackMarkdown": "As far as performance is concerned, the best results happen when this goes from an interface to a sealed type, but there\u0027s still goodness in moving up to a more-derived type (and less so for a more-derived interface).\r\n\r\nThe main identified complication is when a field, auto-property or variable is declared of an interface and changing it to a concrete type causes a compile failure (or runtime behavior) because of explicit interface implementations.\r\n\r\n* Look at all assignments into the field or variable\r\n* Find the most specific common type for all of those assignments\r\n* If that type is not the current declaration type, trigger the diagnostic.  (And the fixer does that substitution)\r\n\r\nDo not run on public or protected fields (or auto-properties) -- or \u0060internal\u0060 if the assembly has any InternalsVisibleTo.\r\n\r\nThis may, in the case of explicit interface implementations, cause code to change or fail to compile, but we think we\u0027re OK with that.\r\n\r\n* Category: Performance\r\n* Severity: Information",
        "TimeCode": 65360000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9nVhHuAqblA",
      "StartDateTime": "2021-08-03T10:07:50-07:00",
      "EndDateTime": "2021-08-03T12:18:30-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9nVhHuAqblA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56498,
          "Title": "Add description to RequiresPreviewFeaturesAttribute",
          "Author": "JamesNK",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-28T22:09:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56498",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-03T00:00:00-07:00",
        "FeedbackId": "892025270",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56498#issuecomment-892025270",
        "FeedbackMarkdown": "* We discussed whether or not the analyzer should also offer a diagnostic ID, akin to \u0060ObsoleteAttribute\u0060\r\n    - We\u0027re leaning towards no, because that seems to re-introduce the feature names that we considered in the design and decided against due to complexity and test matrix concerns\r\n    - That means we wouldn\u0027t have \u0060UrlFormat\u0060 but just \u0060Url\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Versioning\r\n{\r\n    public sealed class RequiresPreviewFeaturesAttribute : Attribute\r\n    {\r\n        // Existing\r\n        // public RequiresPreviewFeaturesAttribute();\r\n        public RequiresPreviewFeaturesAttribute(string? message);\r\n        public string? Message { get; }\r\n        public string? Url { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:RequiresPreviewFeaturesAttribute.RequiresPreviewFeaturesAttribute(string?)",
          "P:RequiresPreviewFeaturesAttribute.Message",
          "P:RequiresPreviewFeaturesAttribute.Url",
          "T:RequiresPreviewFeaturesAttribute"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46520,
          "Title": "Allow custom converters for dictionary keys",
          "Author": "NN---",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-03T13:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46520",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-03T00:00:00-07:00",
        "FeedbackId": "892058319",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46520#issuecomment-892058319",
        "FeedbackMarkdown": "* This is a regression from .NET 5\r\n    - Should we just fix the regression or at least fix a subset of the regression (e.g. have string-based keys just work)?\r\n* This needs more thought\r\n    - We should consider more JSON like names, such \u0060XxxAsPropertyName\u0060\r\n    - We should consider a generic \u0022to string\u0022 conversion so that the serializer can do The Right Thing \u2122\uFE0F\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public partial class JsonConverter\u003CT\u003E\r\n    {\r\n        protected virtual T ReadAsDictionaryKey(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);\r\n        protected virtual void WriteAsDictionaryKey(Utf8JsonWriter writer, [DisallowNull] T value, JsonSerializerOptions options);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9660000000,
        "Apis": [
          "M:JsonConverter\u003CT\u003E.ReadAsDictionaryKey(ref Utf8JsonReader,Type,JsonSerializerOptions)",
          "M:JsonConverter\u003CT\u003E.WriteAsDictionaryKey(Utf8JsonWriter,T,JsonSerializerOptions)",
          "T:JsonConverter\u003CT\u003E"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45448,
          "Title": "Compile-time source generation for System.Text.Json",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-02T00:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45448",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-03T00:00:00-07:00",
        "FeedbackId": "892099426",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45448#issuecomment-892099426",
        "FeedbackMarkdown": "* \u0060JsonTypeInfo\u003CT\u003E\u0060\r\n    - The \u0060Serialize\u0060 property can be null if we can\u0027t support the fast-path serialization, but that seems subtle. We may want to use a different name or throw an exception with more details.\r\n* \u0060JsonObjectInfoValues\u003CT\u003E\u0060\r\n    - We should replace the \u0060Func\u0060 suffix with \u0060Handler\u0060, \u0060Callback\u0060, or \u0060Factory\u0060. Some names, such as \u0060Getter\u0060 or \u0060Setter\u0060 are fine too.\r\n    - We should expand name such as \u0060Ctor\u0060, \u0060Prop\u0060, \u0060Param\u0060, \u0060Init\u0060 (in fact, do we need that in the name at all?)\r\n* \u0060JsonSerializerContext\u0060\r\n    - \u0060DesignTimeOptions\u0060 should be renamed to something like \u0060SourceGeneratedOptions\u0060 or \u0060GeneratedSerializerOptions\u0060\r\n* \u0060JsonMetadataServices\u0060\r\n    - \u0060CreateStackOrQueueInfo\u0060 should be split into two methods so that it matches the generic versions\r\n* We should decide whether we should use classes or structs; there are performance trade offs for either choice (e.g. should it be passed by \u0060ref\u0060)?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    // Provides serialization info about a type\r\n    public partial class JsonTypeInfo\r\n    {\r\n        internal JsonTypeInfo();\r\n    }\r\n\r\n    // Provides serialization info about a type\r\n    public abstract partial class JsonTypeInfo\u003CT\u003E : JsonTypeInfo\r\n    {\r\n        internal JsonTypeInfo();\r\n        public Action\u003CUtf8JsonWriter, T\u003E? Serialize { get; }\r\n    }\r\n\r\n    // Provide serialization info about a property or field of a POCO\r\n    public abstract partial class JsonPropertyInfo\r\n    {\r\n        internal JsonPropertyInfo();\r\n    }\r\n\r\n\u002B   // The list of parameters in \u0060CreatePropertyInfo\u003CT\u003E\u0060 below is too long, so we move the data to a struct. This should help with forward-compat since we can add members representing new serializer features.\r\n\u002B   public readonly struct JsonPropertyInfoValues\u003CT\u003E\r\n\u002B   {\r\n\u002B       public bool IsProperty { get; init; }\r\n\u002B       public bool IsPublic { get; init; }\r\n\u002B       public bool IsVirtual { get; init; }\r\n\u002B       public Type DeclaringType { get; init; }\r\n\u002B       public JsonTypeInfo PropertyTypeInfo { get; init; }\r\n\u002B       public JsonConverter\u003CT\u003E? Converter { get; init; }\r\n\u002B       public Func\u003Cobject, T\u003E? Getter { get; init; }\r\n\u002B       public Action\u003Cobject, T\u003E? Setter { get; init; }\r\n\u002B       public JsonIgnoreCondition? IgnoreCondition { get; init; }\r\n\u002B       public bool IsExtensionDataProperty { get; init; }\r\n\u002B       public JsonNumberHandling? NumberHandling { get; init; }\r\n\u002B       // The property\u0027s statically-declared name.\r\n\u002B       public string PropertyName { get; init; }\r\n\u002B       // The name to use when processing the property, specified by [JsonPropertyName(string)].\r\n\u002B       public string? JsonPropertyName { get; init; }\r\n\u002B   }\r\n\r\n\u002B   // For the same reason as \u0060JsonPropertyInfoValues\u003CT\u003E\u0060 above, move object info to a struct.\r\n\u002B   // Configures information about an object with members that is deserialized using a parameterless ctor.\r\n\u002B   public readonly struct JsonObjectInfoValues\u003CT\u003E\r\n\u002B   {\r\n\u002B       // A method to create an instance of the type, using a parameterless ctor\r\n\u002B       public Func\u003CT\u003E? CreateObjectFunc { get; init; }\r\n\r\n\u002B       // A method to create an instance of the type, using a parameterized ctor\r\n\u002B       public Func\u003Cobject[], T\u003E? CreateObjectFunc { get; init; }\r\n\r\n\u002B       // Provides information about the type\u0027s properties and fields.\r\n\u002B       public Func\u003CJsonSerializerContext, JsonPropertyInfo[]\u003E? PropInitFunc { get; init; }\r\n\r\n\u002B       // Provides information about the type\u0027s ctor params.\r\n\u002B       public Func\u003CJsonParameterInfo[]\u003E? CtorParamInitFunc { get; init; }\r\n\r\n\u002B       // The number-handling setting for the type\u0027s properties and fields.\r\n\u002B       public JsonNumberHandling NumberHandling { get; init; }\r\n\r\n\u002B       // An optimized method to serialize instances of the type, given pre-defined serialization settings.\r\n\u002B       public Action\u003CUtf8JsonWriter, T\u003E? SerializeFunc { get; init; }\r\n\u002B   }\r\n\r\n\u002B   // Configures information about a collection\r\n\u002B   public readonly struct JsonCollectionInfo\u003CT\u003E\r\n\u002B   {\r\n\u002B       // A method to create an instance of the collection  \r\n\u002B       public Func\u003CT\u003E? CreateObjectFunc { get; init; }\r\n\r\n\u002B       // Serialization metadata about the collection key type, if a dictionary.\r\n\u002B       public JsonTypeInfo? KeyInfo { get; init; }\r\n\r\n\u002B       // Serialization metadata about the collection element/value type.\r\n\u002B       public JsonTypeInfo ElementInfo { get; init; }\r\n\r\n\u002B       // The number-handling setting for the collection\u0027s elements.\r\n\u002B       public JsonNumberHandling NumberHandling { get; init; }\r\n\r\n\u002B       // An optimized method to serialize instances of the collection, given pre-defined serialization settings.\r\n\u002B       public Action\u003CUtf8JsonWriter, T\u003E? SerializeFunc { get; init; }\r\n\u002B   }\r\n\r\n\u002B   // Provides serialization info about a constructor parameter\r\n\u002B   public readonly struct JsonParameterInfo\r\n\u002B   {\r\n\u002B       public object? DefaultValue { readonly get; init; }\r\n\u002B       public bool HasDefaultValue { readonly get; init; }\r\n\u002B       public string Name { readonly get; init; }\r\n\u002B       public Type ParameterType { readonly get; init; }\r\n\u002B       public int Position { readonly get; init; }\r\n\u002B   }\r\n\r\n    // Object type and property info creators\r\n    public static partial class JsonMetadataServices\r\n    {\r\n        // Creator for an object type\r\n-       public static JsonTypeInfo\u003CT\u003E CreateObjectInfo\u003CT\u003E(JsonSerializerOptions options, Func\u003CT\u003E? createObjectFunc, Func\u003CJsonSerializerContext, JsonPropertyInfo[]\u003E? propInitFunc, JsonNumberHandling numberHandling, Action\u003CUtf8JsonWriter, T\u003E? serializeFunc) where T : notnull;\r\n\u002B       public static JsonTypeInfo\u003CT\u003E CreateObjectInfo\u003CT\u003E(JsonSerializerOptions options, JsonObjectInfoValues\u003CT\u003E objectInfo) where T : notnull;\r\n        \r\n        // Creator for an object property\r\n-       public static JsonPropertyInfo CreatePropertyInfo\u003CT\u003E(JsonSerializerOptions options, bool isProperty, bool isPublic, bool isVirtual, Type declaringType, JsonTypeInfo propertyTypeInfo, JsonConverter\u003CT\u003E? converter, Func\u003Cobject, T\u003E? getter, Action\u003Cobject, T\u003E? setter, JsonIgnoreCondition? ignoreCondition, bool hasJsonInclude, JsonNumberHandling? numberHandling, string propertyName, string? jsonPropertyName);\r\n\u002B       public static JsonPropertyInfo CreatePropertyInfo\u003CT\u003E(JsonSerializerOptions options, JsonPropertyInfoValues\u003CT\u003E propertyInfo);\r\n    }\r\n\r\n    // Collection type info creators\r\n    public static partial class JsonMetadataServices\r\n    {\r\n-       public static JsonTypeInfo\u003CTElement[]\u003E CreateArrayInfo\u003CTElement\u003E(JsonSerializerOptions options, JsonTypeInfo elementInfo, JsonNumberHandling numberHandling, Action\u003CUtf8JsonWriter, TElement[]\u003E? serializeFunc);\r\n\u002B       public static JsonTypeInfo\u003CTElement[]\u003E CreateArrayInfo\u003CTElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTElement[]\u003E info);\r\n\r\n-       public static JsonTypeInfo\u003CTCollection\u003E CreateDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions options, Func\u003CTCollection\u003E createObjectFunc, JsonTypeInfo keyInfo, JsonTypeInfo valueInfo, JsonNumberHandling numberHandling, Action\u003CUtf8JsonWriter, TCollection\u003E? serializeFunc) where TCollection : Dictionary\u003CTKey, TValue\u003E where TKey : notnull;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : Dictionary\u003CTKey, TValue\u003E where TKey : notnull;\r\n\r\n-       public static JsonTypeInfo\u003CTCollection\u003E CreateListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, Func\u003CTCollection\u003E? createObjectFunc, JsonTypeInfo elementInfo, JsonNumberHandling numberHandling, Action\u003CUtf8JsonWriter, TCollection\u003E? serializeFunc) where TCollection : List\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : List\u003CTElement\u003E;\r\n\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateConcurrentQueueInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : ConcurrentQueue\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateConcurrentStackInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : ConcurrentStack\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateICollectionInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : ICollection\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIDictionaryInfo\u003CTCollection\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IDictionary;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IDictionary\u003CTKey, TValue\u003E where TKey : notnull;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIEnumerableInfo\u003CTCollection\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IEnumerable;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIEnumerableInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IEnumerable\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIListInfo\u003CTCollection\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IList;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IList\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateImmutableDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info, Func\u003CIEnumerable\u003CKeyValuePair\u003CTKey, TValue\u003E\u003E, TCollection\u003E createRangeFunc) where TCollection : IReadOnlyDictionary\u003CTKey, TValue\u003E where TKey : notnull;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateImmutableEnumerableInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info, Func\u003CIEnumerable\u003CTElement\u003E, TCollection\u003E createRangeFunc) where TCollection : IEnumerable\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateIReadOnlyDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : IReadOnlyDictionary\u003CTKey, TValue\u003E where TKey : notnull;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateISetInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : ISet\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateQueueInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : Queue\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateStackInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info) where TCollection : Stack\u003CTElement\u003E;\r\n\u002B       public static JsonTypeInfo\u003CTCollection\u003E CreateStackOrQueueInfo\u003CTCollection\u003E(JsonSerializerOptions options, JsonCollectionInfo\u003CTCollection\u003E info, Action\u003CTCollection, object?\u003E addFunc) where TCollection : IEnumerable;\r\n    }\r\n}\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    public enum JsonKnownNamingPolicy\r\n    {\r\n        Unspecified = 0,\r\n        CamelCase = 1,\r\n    }\r\n\r\n    public abstract partial class JsonSerializerContext\r\n    {\r\n-       protected JsonSerializerContext(JsonSerializerOptions? instanceOptions, JsonSerializerOptions? defaultOptions);\r\n\u002B       protected JsonSerializerContext(JsonSerializerOptions? options);\r\n        public JsonSerializerOptions Options { get; }\r\n        public abstract JsonTypeInfo? GetTypeInfo(Type type);\r\n\u002B       // The set of options that are compatible with generated serialization and (future) deserialization logic for types in the context.\r\n\u002B       protected abstract JsonSerializerOptions? DesignTimeOptions { get; }\r\n    }\r\n\r\n    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false)]\r\n    public partial sealed class JsonSourceGenerationOptionsAttribute : JsonAttribute\r\n    {\r\n        public JsonSourceGenerationOptionsAttribute();\r\n        public JsonIgnoreCondition DefaultIgnoreCondition { get; set; }\r\n        public bool IgnoreReadOnlyFields { get; set; }\r\n        public bool IgnoreReadOnlyProperties { get; set; }\r\n-       // Whether the generated source code should ignore converters added at runtime.\r\n-       public bool IgnoreRuntimeCustomConverters { get; set; }\r\n        public bool IncludeFields { get; set; }\r\n        public JsonKnownNamingPolicy PropertyNamingPolicy { get; set; }\r\n        public bool WriteIndented { get; set; }\r\n        public JsonSourceGenerationMode GenerationMode { get; set; }\r\n    }\r\n\r\n    [Flags]\r\n    public enum JsonSourceGenerationMode\r\n    {\r\n        Default = 0,\r\n        Metadata = 1,\r\n        Serialization = 2,\r\n        // Future\r\n        // Deserialization = 4\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 39720000000,
        "Apis": [
          "F:JsonKnownNamingPolicy.CamelCase",
          "F:JsonKnownNamingPolicy.Unspecified",
          "F:JsonSourceGenerationMode.Default",
          "F:JsonSourceGenerationMode.Metadata",
          "F:JsonSourceGenerationMode.Serialization",
          "M:JsonMetadataServices.CreateArrayInfo\u003CTElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTElement[]\u003E)",
          "M:JsonMetadataServices.CreateArrayInfo\u003CTElement\u003E(JsonSerializerOptions,JsonTypeInfo,JsonNumberHandling,Action\u003CUtf8JsonWriter, TElement[]\u003E?)",
          "M:JsonMetadataServices.CreateConcurrentQueueInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateConcurrentStackInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions,Func\u003CTCollection\u003E,JsonTypeInfo,JsonTypeInfo,JsonNumberHandling,Action\u003CUtf8JsonWriter, TCollection\u003E?)",
          "M:JsonMetadataServices.CreateDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateICollectionInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIDictionaryInfo\u003CTCollection\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIEnumerableInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIEnumerableInfo\u003CTCollection\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateIListInfo\u003CTCollection\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateImmutableDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E,Func\u003CIEnumerable\u003CKeyValuePair\u003CTKey, TValue\u003E\u003E, TCollection\u003E)",
          "M:JsonMetadataServices.CreateImmutableEnumerableInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E,Func\u003CIEnumerable\u003CTElement\u003E, TCollection\u003E)",
          "M:JsonMetadataServices.CreateIReadOnlyDictionaryInfo\u003CTCollection, TKey, TValue\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateISetInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,Func\u003CTCollection\u003E?,JsonTypeInfo,JsonNumberHandling,Action\u003CUtf8JsonWriter, TCollection\u003E?)",
          "M:JsonMetadataServices.CreateListInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateObjectInfo\u003CT\u003E(JsonSerializerOptions,Func\u003CT\u003E?,Func\u003CJsonSerializerContext, JsonPropertyInfo[]\u003E?,JsonNumberHandling,Action\u003CUtf8JsonWriter, T\u003E?)",
          "M:JsonMetadataServices.CreateObjectInfo\u003CT\u003E(JsonSerializerOptions,JsonObjectInfoValues\u003CT\u003E)",
          "M:JsonMetadataServices.CreatePropertyInfo\u003CT\u003E(JsonSerializerOptions,bool,bool,bool,Type,JsonTypeInfo,JsonConverter\u003CT\u003E?,Func\u003Cobject, T\u003E?,Action\u003Cobject, T\u003E?,JsonIgnoreCondition?,bool,JsonNumberHandling?,string,string?)",
          "M:JsonMetadataServices.CreatePropertyInfo\u003CT\u003E(JsonSerializerOptions,JsonPropertyInfoValues\u003CT\u003E)",
          "M:JsonMetadataServices.CreateQueueInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateStackInfo\u003CTCollection, TElement\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E)",
          "M:JsonMetadataServices.CreateStackOrQueueInfo\u003CTCollection\u003E(JsonSerializerOptions,JsonCollectionInfo\u003CTCollection\u003E,Action\u003CTCollection, object?\u003E)",
          "M:JsonPropertyInfo.JsonPropertyInfo()",
          "M:JsonSerializerContext.GetTypeInfo(Type)",
          "M:JsonSerializerContext.JsonSerializerContext(JsonSerializerOptions?,JsonSerializerOptions?)",
          "M:JsonSerializerContext.JsonSerializerContext(JsonSerializerOptions?)",
          "M:JsonSourceGenerationOptionsAttribute.JsonSourceGenerationOptionsAttribute()",
          "M:JsonTypeInfo.JsonTypeInfo()",
          "M:JsonTypeInfo\u003CT\u003E.JsonTypeInfo()",
          "P:.Converter",
          "P:.CreateObjectFunc",
          "P:.CtorParamInitFunc",
          "P:.DeclaringType",
          "P:.DefaultValue",
          "P:.ElementInfo",
          "P:.Getter",
          "P:.HasDefaultValue",
          "P:.IgnoreCondition",
          "P:.IsExtensionDataProperty",
          "P:.IsProperty",
          "P:.IsPublic",
          "P:.IsVirtual",
          "P:.JsonPropertyName",
          "P:.KeyInfo",
          "P:.Name",
          "P:.NumberHandling",
          "P:.ParameterType",
          "P:.Position",
          "P:.PropertyName",
          "P:.PropertyTypeInfo",
          "P:.PropInitFunc",
          "P:.SerializeFunc",
          "P:.Setter",
          "P:JsonSerializerContext.DesignTimeOptions",
          "P:JsonSerializerContext.Options",
          "P:JsonSourceGenerationOptionsAttribute.DefaultIgnoreCondition",
          "P:JsonSourceGenerationOptionsAttribute.GenerationMode",
          "P:JsonSourceGenerationOptionsAttribute.IgnoreReadOnlyFields",
          "P:JsonSourceGenerationOptionsAttribute.IgnoreReadOnlyProperties",
          "P:JsonSourceGenerationOptionsAttribute.IgnoreRuntimeCustomConverters",
          "P:JsonSourceGenerationOptionsAttribute.IncludeFields",
          "P:JsonSourceGenerationOptionsAttribute.PropertyNamingPolicy",
          "P:JsonSourceGenerationOptionsAttribute.WriteIndented",
          "P:JsonTypeInfo\u003CT\u003E.Serialize",
          "T:JsonCollectionInfo\u003CT\u003E",
          "T:JsonKnownNamingPolicy",
          "T:JsonMetadataServices",
          "T:JsonObjectInfoValues\u003CT\u003E",
          "T:JsonParameterInfo",
          "T:JsonPropertyInfo",
          "T:JsonPropertyInfoValues\u003CT\u003E",
          "T:JsonSerializerContext",
          "T:JsonSourceGenerationMode",
          "T:JsonSourceGenerationOptionsAttribute",
          "T:JsonTypeInfo",
          "T:JsonTypeInfo\u003CT\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56914,
          "Title": "Provide a way to create types from the MetadataLoadContext",
          "Author": "msedi",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-05T16:13:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56914",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56914#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56936,
          "Title": "Add Metrics overloads taking more tags",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-05T22:31:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56936",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "area-System.Diagnostics.Metric",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896190227",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56936#issuecomment-896190227",
        "FeedbackMarkdown": "Based on the size of the parameters and the cost of passing all of those KeyValuePairs, we feel that an approach similar to\r\n\r\n\r\n\u0060\u0060\u0060C#\r\ncounter.Add(\r\n    10,\r\n    new TagSet\r\n    {\r\n        { \u0022K1\u0022, \u0022V1\u0022 },\r\n        { \u0022K2\u0022, \u0022V2\u0022 },\r\n        { \u0022K3\u0022, \u0022V3\u0022 },\r\n        { \u0022K4\u0022, \u0022V4\u0022 },\r\n        { \u0022K5\u0022, \u0022V5\u0022 },\r\n        { \u0022K6\u0022, \u0022V6\u0022 },\r\n        { \u0022K7\u0022, \u0022V7\u0022 },\r\n        { \u0022K8\u0022, \u0022V8\u0022 },\r\n    });\r\n);\r\n\r\nnamespace System.Diagnostics.Metrics\r\n{\r\n    public struct TagList : IList\u003CKeyValuePair\u003Cstring, object?\u003E\u003E, IReadOnlyList\u003CKVP\u003C\u003E\u003E\r\n    {\r\n        private KVP\u003C\u003E _kvp1;\r\n        private KVP\u003C\u003E ...\r\n        private KVP\u003C\u003E _kvp8;\r\n        private List\u003CKVP\u003C\u003E\u003E? _spill;\r\n\r\n        public TagList(ReadOnlySpan\u003CKVP\u003C\u003E\u003E);\r\n        // other ctors as appropriate\r\n    \r\n        public void Add(string key, object? value);\r\n        public void Add(KeyValuePair\u003C\u003E);\r\n\r\n        // optional bulk adders\r\n        //public void AddRange(ReadOnlySpan\u003CKVP\u003C\u003E\u003E);\r\n        //public void AddRange(IEnumerable\u003CKVP\u003C\u003E\u003E);\r\n\r\n        // struct enumerator goes here.\r\n        public CopyTo(Span\u003CKVP\u003C\u003E\u003E)\r\n\r\n        // indexer, etc.\r\n    }\r\n\r\n    partial class Counter\u003CT\u003E\r\n    {\r\n        public void Add(T value, in TagList tags);\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nwill give better results and future expansion as needed.",
        "TimeCode": 0,
        "Apis": [
          "F:TagList._kvp1",
          "F:TagList._kvp8",
          "F:TagList._spill",
          "M:Counter\u003CT\u003E.Add(T,in TagList)",
          "M:TagList.Add(KeyValuePair\u003C\u003E)",
          "M:TagList.Add(string,object?)",
          "M:TagList.CopyTo(Span\u003CKVP\u003C\u003E\u003E)",
          "M:TagList.TagList(ReadOnlySpan\u003CKVP\u003C\u003E\u003E)",
          "T:Counter\u003CT\u003E",
          "T:TagList"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46520,
          "Title": "Allow custom converters for dictionary keys",
          "Author": "NN---",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-03T13:33:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46520",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896196155",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46520#issuecomment-896196155",
        "FeedbackMarkdown": "* \u0022WriteTo\u0022 felt weird, so changed to \u0022WriteAs\u0022.\r\n* \u0022ReadFrom\u0022 got changed to \u0022ReadAs\u0022 for symmetry\r\n* Nullability of the Ts was stated as not necessarily accurate.  Fix as appropriate.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization\r\n{\r\n    partial class JsonConverter\u003CT\u003E\r\n    {\r\n        protected virtual T? ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) =\u003E throw null;\r\n        protected virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options) { }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:JsonConverter\u003CT\u003E.ReadAsPropertyName(ref Utf8JsonReader,Type,JsonSerializerOptions)",
          "M:JsonConverter\u003CT\u003E.WriteAsPropertyName(Utf8JsonWriter,T,JsonSerializerOptions)",
          "T:JsonConverter\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45592,
          "Title": "[MemoryCache] Add possibility to disable linked cache entries",
          "Author": "adamsitnik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-04T13:22:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45592",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "area-Extensions-Caching",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896214586",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45592#issuecomment-896214586",
        "FeedbackMarkdown": "Since this is proposing a breaking change (making the default be non-tracked), going with one centralized option seems the most sensible.\r\nAdding an overload of \u0060MemoryCache.CreateEntry(object key, bool linked)\u0060 (or something like that) can be done in the future if entry-level support feels warranted.\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Caching.Memory\r\n{\r\n    partial class MemoryCacheOptions\r\n    {\r\n        public bool TrackLinkedCacheEntries { get ; set; } = false;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:MemoryCacheOptions.TrackLinkedCacheEntries",
          "T:MemoryCacheOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56331,
          "Title": "Provide an API to get the native module handle of the native process entry-point module",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-26T21:49:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56331",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896219066",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56331#issuecomment-896219066",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n     public static class NativeLibrary\r\n     {\r\n          public static IntPtr GetEntryPointModuleHandle();\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:NativeLibrary.GetEntryPointModuleHandle()",
          "T:NativeLibrary"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20510,
          "Title": "ShiftLeft, ShiftRight for Vector\u003CT\u003E",
          "Author": "mjmckp",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-07T22:15:08+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20510",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896224123",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20510#issuecomment-896224123",
        "FeedbackMarkdown": "Looks good as proposed, but we normalized to the current parameter names (value and shiftCount, respectively).\r\n\r\n\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public static class Vector\r\n    {\r\n        public static Vector\u003Cbyte\u003E ShiftLeft(Vector\u003Cbyte\u003E value, int shiftCount);\r\n        public static Vector\u003Cshort\u003E ShiftLeft(Vector\u003Cshort\u003E value, int shiftCount);\r\n        public static Vector\u003Cint\u003E ShiftLeft(Vector\u003Cint\u003E value, int shiftCount);\r\n        public static Vector\u003Clong\u003E ShiftLeft(Vector\u003Clong\u003E value, int shiftCount);\r\n        public static Vector\u003Cnint\u003E ShiftLeft(Vector\u003Cnint\u003E value, int shiftCount);\r\n        public static Vector\u003Csbyte\u003E ShiftLeft(Vector\u003Csbyte\u003E value, int shiftCount);\r\n        public static Vector\u003Cushort\u003E ShiftLeft(Vector\u003Cushort\u003E value, int shiftCount);\r\n        public static Vector\u003Cuint\u003E ShiftLeft(Vector\u003Cuint\u003E value, int shiftCount);\r\n        public static Vector\u003Culong\u003E ShiftLeft(Vector\u003Culong\u003E value, int shiftCount);\r\n        public static Vector\u003Cnuint\u003E ShiftLeft(Vector\u003Cnuint\u003E value, int shiftCount);\r\n\r\n        public static Vector\u003Cbyte\u003E ShiftRightLogical(Vector\u003Cbyte\u003E value, int shiftCount);\r\n        public static Vector\u003Cshort\u003E ShiftRightLogical(Vector\u003Cshort\u003E value, int shiftCount);\r\n        public static Vector\u003Cint\u003E ShiftRightLogical(Vector\u003Cint\u003E value, int shiftCount);\r\n        public static Vector\u003Clong\u003E ShiftRightLogical(Vector\u003Clong\u003E value, int shiftCount);\r\n        public static Vector\u003Cnint\u003E ShiftRightLogical(Vector\u003Cnint\u003E value, int shiftCount);\r\n        public static Vector\u003Csbyte\u003E ShiftRightLogical(Vector\u003Csbyte\u003E value, int shiftCount);\r\n        public static Vector\u003Cushort\u003E ShiftRightLogical(Vector\u003Cushort\u003E value, int shiftCount);\r\n        public static Vector\u003Cuint\u003E ShiftRightLogical(Vector\u003Cuint\u003E value, int shiftCount);\r\n        public static Vector\u003Culong\u003E ShiftRightLogical(Vector\u003Culong\u003E value, int shiftCount);\r\n        public static Vector\u003Cnuint\u003E ShiftRightLogical(Vector\u003Cnuint\u003E value, int shiftCount);\r\n\r\n        public static Vector\u003Cshort\u003E ShiftRightArithmetic(Vector\u003Cshort\u003E value, int shiftCount);\r\n        public static Vector\u003Cint\u003E ShiftRightArithmetic(Vector\u003Cint\u003E value, int shiftCount);\r\n        public static Vector\u003Clong\u003E ShiftRightArithmetic(Vector\u003Clong\u003E value, int shiftCount);\r\n        public static Vector\u003Cnint\u003E ShiftRightArithmetic(Vector\u003Cnint\u003E value, int shiftCount);\r\n        public static Vector\u003Csbyte\u003E ShiftRightArithmetic(Vector\u003Csbyte\u003E value, int shiftCount);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Vector.ShiftLeft(Vector\u003Cbyte\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cint\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Clong\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cnint\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cnuint\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Csbyte\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cshort\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cuint\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Culong\u003E,int)",
          "M:Vector.ShiftLeft(Vector\u003Cushort\u003E,int)",
          "M:Vector.ShiftRightArithmetic(Vector\u003Cint\u003E,int)",
          "M:Vector.ShiftRightArithmetic(Vector\u003Clong\u003E,int)",
          "M:Vector.ShiftRightArithmetic(Vector\u003Cnint\u003E,int)",
          "M:Vector.ShiftRightArithmetic(Vector\u003Csbyte\u003E,int)",
          "M:Vector.ShiftRightArithmetic(Vector\u003Cshort\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cbyte\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cint\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Clong\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cnint\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cnuint\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Csbyte\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cshort\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cuint\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Culong\u003E,int)",
          "M:Vector.ShiftRightLogical(Vector\u003Cushort\u003E,int)",
          "T:Vector"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35324,
          "Title": "UnreachableException",
          "Author": "carlreinke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-23T02:50:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35324",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-10T00:00:00-07:00",
        "FeedbackId": "896240974",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35324#issuecomment-896240974",
        "FeedbackMarkdown": "* This exception made us muse for a long time on wishing that we had better language support for showing that control won\u0027t come back. (General ThrowHelper problem)\r\n* We didn\u0027t add a static Throw method yet, because of the ThrowHelper control flow problem\r\n* We might want to get the runtime to consider it uncatchable, like StackOverflowException (or what @bartonjs remembers ThreadAbortException doing: you can catch it to log it, but it\u0027s being propagated unconditionally at the end of the catch block).\r\n* Since the type is just a .NET N type (not netstandard2.0) the serialization ctor and attr aren\u0027t needed\r\n* We discussed UnreachableException vs UnreachableCodeException.  We were split 50/50, so let the tie break go to the proposer\r\n* We\u0027re approving it as deriving from SystemException on the assumption we\u0027ll give it special treatment.  If it\u0027s \u0022just another exception\u0022 at the end of the day we should derive directly from Exception.\r\n\r\n\u0060\u0060\u0060C#\r\n#nullable enable\r\nusing System.Runtime.Serialization;\r\n\r\nnamespace System\r\n{\r\n    public sealed class UnreachableException : SystemException\r\n    {\r\n        public UnreachableException()\r\n            : base(\u0022The program executed an instruction that was thought to be unreachable.\u0022)\r\n        {\r\n        }\r\n\r\n        public UnreachableException(string? message)\r\n            : base(message)\r\n        {\r\n        }\r\n\r\n        public UnreachableException(string? message, Exception? innerException)\r\n            : base(message, innerException)\r\n        {\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:UnreachableException.UnreachableException()",
          "M:UnreachableException.UnreachableException(string?,Exception?)",
          "M:UnreachableException.UnreachableException(string?)",
          "T:UnreachableException"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "ztrfSfgXjFU",
      "StartDateTime": "2021-08-17T10:03:54-07:00",
      "EndDateTime": "2021-08-17T12:02:31-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/ztrfSfgXjFU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57538,
          "Title": "Pass interpolated string handlers by ref",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-17T01:17:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57538",
          "Milestone": "6.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900481517",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57538#issuecomment-900481517",
        "FeedbackMarkdown": "Looks good as proposed.  Hopefully we\u0027ll be diligent in the future at always using pass-by-ref when the handler is a struct.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57325,
          "Title": "Add feature to bind a single element to an array on ConfigurationBinder.",
          "Author": "safern",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-12T23:24:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57325",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900508614",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57325#issuecomment-900508614",
        "FeedbackMarkdown": "We feel that the behavior isn\u0027t something that people really want to switch on/off, this is just for compatibility across an upgrade boundary.\r\n\r\nEither just make the breaking change, or use an AppContext switch to provide \u0022temporary\u0022 access to the previous behavior.  (API can be added if we\u0027re proven wrong).",
        "TimeCode": 4960000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57253,
          "Title": "Quaternion.Zero is missing",
          "Author": "michael-hawker",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-12T01:15:02+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57253",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900511049",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57253#issuecomment-900511049",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n     partial struct Quaternion\r\n     {\r\n        /// \u003Csummary\u003EGets a newly initialized quaternion.\u003C/summary\u003E\r\n        /// \u003Cvalue\u003EA quaternion whose values are \u003Cc\u003E(0, 0, 0, 0)\u003C/c\u003E.\u003C/value\u003E\r\n        public static Quaternion Zero\r\n        {\r\n            get =\u003E new();\r\n        }\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27690000000,
        "Apis": [
          "P:Quaternion.Zero",
          "T:Quaternion"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57448,
          "Title": "X509Certificate2.RawDataMemory",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-15T20:35:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57448",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900529048",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57448#issuecomment-900529048",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\nThere was much debate over ReadOnlyMemory/ReadOnlySpan/ImmutableArray and just making the existing property not return defensive copies.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.X509Certificates {\r\n    partial class X509Certificate2 : X509Certificate {\r\n       public ReadOnlyMemory\u003Cbyte\u003E RawDataMemory { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 30040000000,
        "Apis": [
          "P:X509Certificate2.RawDataMemory",
          "T:X509Certificate2"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43934,
          "Title": "Consider adding Socket Send/ReceiveAsync overloads that elide SocketFlags argument",
          "Author": "geoffkizer",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-28T04:35:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43934",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net.Sockets",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900535135",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43934#issuecomment-900535135",
        "FeedbackMarkdown": "* We discussed defaulting the parameter where possible, and landed on overloading for symmetry with existing things.\r\n* We moved everything from the extensions class to the main class as instance methods\r\n* Please double check that on ReceiveMessageFrom it\u0027s not important that the ref SocketFlags is not used, since that could have been passing data back to the caller.\r\n* Also, let\u0027s paint the current extensions type as EB-Never\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Net.Sockets\r\n{\r\n    // Existing overloads in comments\r\n    partial class Socket\r\n    {\r\n    //  public Task\u003Cint\u003E ReceiveAsync(ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags);\r\n        public Task\u003Cint\u003E ReceiveAsync(ArraySegment\u003Cbyte\u003E buffer);\r\n        \r\n    //  public Task\u003Cint\u003E ReceiveAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E buffers, SocketFlags socketFlags);\r\n        public Task\u003Cint\u003E ReceiveAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E buffers);\r\n        \r\n    //  public ValueTask\u003Cint\u003E ReceiveAsync(Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default(CancellationToken));\r\n        public ValueTask\u003Cint\u003E ReceiveAsync(Memory\u003Cbyte\u003E buffer, CancellationToken cancellationToken = default(CancellationToken));\r\n        \r\n    //  public Task\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public Task\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(ArraySegment\u003Cbyte\u003E buffer, EndPoint remoteEndPoint);\r\n        \r\n    //  public Task\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);\r\n        public Task\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(ArraySegment\u003Cbyte\u003E buffer, EndPoint remoteEndPoint);\r\n        \r\n    //  public Task\u003Cint\u003E SendAsync(ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags);\r\n        public Task\u003Cint\u003E SendAsync(ArraySegment\u003Cbyte\u003E buffer);\r\n        \r\n    //  public Task\u003Cint\u003E SendAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E buffers, SocketFlags socketFlags);\r\n        public Task\u003Cint\u003E SendAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E buffers);\r\n        \r\n    //  public ValueTask\u003Cint\u003E SendAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, SocketFlags socketFlags, CancellationToken cancellationToken = default(CancellationToken));\r\n        public ValueTask\u003Cint\u003E SendAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, CancellationToken cancellationToken = default(CancellationToken));\r\n        \r\n    //  public Task\u003Cint\u003E SendToAsync(ArraySegment\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP);\r\n        public Task\u003Cint\u003E SendToAsync(ArraySegment\u003Cbyte\u003E buffer, EndPoint remoteEP);\r\n\r\n    //  public ValueTask\u003Cint\u003E SendToAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n        public ValueTask\u003Cint\u003E SendToAsync(ReadOnlyMemory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n\r\n    //  public ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n        public ValueTask\u003CSocketReceiveFromResult\u003E ReceiveFromAsync(Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n\r\n    //  public ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(Memory\u003Cbyte\u003E buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n        public ValueTask\u003CSocketReceiveMessageFromResult\u003E ReceiveMessageFromAsync(Memory\u003Cbyte\u003E buffer, EndPoint remoteEP, CancellationToken cancellationToken = default);\r\n\r\n\r\n/*** DOUBLE CHECK THAT THIS ONE IS OK, SINCE IT IS NO LONGER \u0022RETURNING\u0022 DATA ***/\r\n\r\n    //  public int ReceiveMessageFrom(Span\u003Cbyte\u003E buffer, ref SocketFlags socketFlags, ref EndPoint remoteEP, out IPPacketInformation ipPacketInformation);\r\n        public int ReceiveMessageFrom(Span\u003Cbyte\u003E buffer, ref EndPoint remoteEP, out IPPacketInformation ipPacketInformation);\r\n    }\r\n\r\n    [EditorBrowsable(EditorBrowsableState.Never)]\r\n    partial class SocketTaskExtensions\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46760000000,
        "Apis": [
          "M:Socket.ReceiveAsync(ArraySegment\u003Cbyte\u003E)",
          "M:Socket.ReceiveAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E)",
          "M:Socket.ReceiveAsync(Memory\u003Cbyte\u003E,CancellationToken)",
          "M:Socket.ReceiveFromAsync(ArraySegment\u003Cbyte\u003E,EndPoint)",
          "M:Socket.ReceiveFromAsync(Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:Socket.ReceiveMessageFrom(Span\u003Cbyte\u003E,ref EndPoint,out IPPacketInformation)",
          "M:Socket.ReceiveMessageFromAsync(ArraySegment\u003Cbyte\u003E,EndPoint)",
          "M:Socket.ReceiveMessageFromAsync(Memory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "M:Socket.SendAsync(ArraySegment\u003Cbyte\u003E)",
          "M:Socket.SendAsync(IList\u003CArraySegment\u003Cbyte\u003E\u003E)",
          "M:Socket.SendAsync(ReadOnlyMemory\u003Cbyte\u003E,CancellationToken)",
          "M:Socket.SendToAsync(ArraySegment\u003Cbyte\u003E,EndPoint)",
          "M:Socket.SendToAsync(ReadOnlyMemory\u003Cbyte\u003E,EndPoint,CancellationToken)",
          "T:Socket",
          "T:SocketTaskExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45593,
          "Title": "Add .Clear() method to MemoryCache",
          "Author": "adamsitnik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-04T13:41:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45593",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Extensions-Caching",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900541842",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45593#issuecomment-900541842",
        "FeedbackMarkdown": "* The interface can\u0027t be changed, per our breaking change rules.\r\n* The method also can\u0027t be added as a DIM, because the library targets .NET Standard 2.0\r\n* The primary method is OK.\r\n* Perhaps it\u0027s time to mark the interface as \u0060[Obsolete]\u0060?  Something to think about.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Caching.Memory\r\n{\r\n    partial class MemoryCache\r\n    {\r\n        public void Clear();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 53030000000,
        "Apis": [
          "M:MemoryCache.Clear()",
          "T:MemoryCache"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 47922,
          "Title": "Proposal: AppContext.SetData",
          "Author": "Sergio0694",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-05T18:14:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/47922",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900544874",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/47922#issuecomment-900544874",
        "FeedbackMarkdown": "Looks good as proposed, for symmetry.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class AppContext\r\n    {\r\n        public static void SetData(string name, object? data);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 58550000000,
        "Apis": [
          "M:AppContext.SetData(string,object?)",
          "T:AppContext"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50454,
          "Title": "Add DiagnosticSource.Write\u003CT\u003E API to assist with trimming",
          "Author": "eerhardt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-30T22:51:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50454",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900552943",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50454#issuecomment-900552943",
        "FeedbackMarkdown": "These new overloads don\u0027t quite solve the problem (recursive preservation, polymorphism), but it\u0027s an improvement at low cost.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Diagnostics\r\n{\r\n    public abstract class DiagnosticSource\r\n    {\r\n        [RequiresUnreferencedCode]\r\n        public abstract void Write(string name, object? value);\r\n\r\n\u002B       [RequiresUnreferencedCode]\r\n\u002B       public void Write\u003C[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T\u003E(string name, T? value);\r\n\r\n        [RequiresUnreferencedCode]\r\n        public Activity StartActivity(Activity activity, object? args);\r\n\r\n\u002B       [RequiresUnreferencedCode]\r\n\u002B       public Activity StartActivity\u003C[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T\u003E(Activity activity, T? args);\r\n\r\n        [RequiresUnreferencedCode]\r\n        public void StopActivity(Activity activity, object? args);\r\n\r\n\u002B       [RequiresUnreferencedCode]\r\n\u002B       public void StopActivity\u003C[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T\u003E(Activity activity, T? args);\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 61230000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56082,
          "Title": "Make DependencyModel.Dependency readonly and implement IEquatable\u003C\u003E",
          "Author": "hrrrrustic",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-21T11:10:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56082",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-DependencyModel",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900554070",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56082#issuecomment-900554070",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.Extensions.DependencyModel\r\n{\r\n-    public struct Dependency {}\r\n\u002B    public readonly struct Dependency : IEquatable\u003CDependency\u003E {}\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 68490000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53532,
          "Title": "Introduce pause intrinsics in order to support spin wait loop indication",
          "Author": "zpodlovics",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-01T15:24:54+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53532",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-17T00:00:00-07:00",
        "FeedbackId": "900555431",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53532#issuecomment-900555431",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\r\n\u0060\u0060\u0060diff\r\n{\r\n    public abstract class ArmBase \r\n    {\r\n\u002B        public static void Yield();\r\n    }\r\n }\r\n\r\n    public abstract partial class X86Base \r\n    {\r\n\u002B        public static void Pause();\r\n    }\r\n }\r\n\u0060\u0060\u0060",
        "TimeCode": 69460000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "6l_654hvx0g",
      "StartDateTime": "2021-08-24T11:04:42-07:00",
      "EndDateTime": "2021-08-24T12:05:58-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/6l_654hvx0g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 53432,
          "Title": "Allow for atomic appends to end of file",
          "Author": "adamsitnik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-05-28T16:10:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/53432",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-24T00:00:00-07:00",
        "FeedbackId": "904876479",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/53432#issuecomment-904876479",
        "FeedbackMarkdown": "* We should measure the performance overhead and establish clarity on what we believe the \u0022right behavior\u0022 is for new code. One option, that we shouldn\u0027t dismiss, is doing a behavior breaking change in .NET 7 and provide compat switch. However, that\u0027s only appropriate if we believe being broken is a fringe case and code should generally use the atomic append behavior. There are conceivable scenarios where someone might open multiple handles within the same process and the new behavior would regress performance.\r\n* Another middle ground option is to expose the new setting and change the behavior of higher level APIs, such as \u0060File.AppendLines\u0060. This way, we don\u0027t make the average person\u0027s code more complex while also giving the power users the control they need.\r\n* @adamsitnik will do some benchmarking and come back with findings.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57046,
          "Title": "Obsolete Rfc2898DeriveBytes constructors with unsafe defaults",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-08T20:24:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57046",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-24T00:00:00-07:00",
        "FeedbackId": "904885558",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57046#issuecomment-904885558",
        "FeedbackMarkdown": "* Looks good.\r\n* We should change the wording to what Jeremy suggested:\r\n   \u003E The default hash algorithm and iteration counts in Rfc2898DeriveBytes constructors are outdated and insecure. Use a constructor that accepts the hash algorithm and the number of iterations.\r\n* We might want to consider calling out the defaults in the obsolete message so that people can apply the current defaults (having a fixer would be even better though)\r\n* We should assign a custom diagnostic ID",
        "TimeCode": 14860000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57609,
          "Title": "Add UnicodeRanges.ArabicExtendedB to System.Text.Encodings.Web",
          "Author": "GrabYourPitchforks",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-17T22:09:26+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57609",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Encodings.Web",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-24T00:00:00-07:00",
        "FeedbackId": "904887016",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57609#issuecomment-904887016",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Unicode\r\n{\r\n    // existing type\r\n    public static class UnicodeRanges\r\n    {\r\n        // new API\r\n        public static UnicodeRange ArabicExtendedB { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 23700000000,
        "Apis": [
          "P:UnicodeRanges.ArabicExtendedB",
          "T:UnicodeRanges"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57891,
          "Title": "RegexOptions.Constrained",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-22T02:16:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57891",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-24T00:00:00-07:00",
        "FeedbackId": "904900270",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57891#issuecomment-904900270",
        "FeedbackMarkdown": "* It seems we need to find a name that makes it clear what it does; also it seems we want most people to pick this for new regexes, assuming they can live with the caveats.\r\n* We should discuss this with @stephentoub and others\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    public enum RegexOptions\r\n    {\r\n        Constrained = 0x0400\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 24930000000,
        "Apis": [
          "F:RegexOptions.Constrained",
          "T:RegexOptions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57046,
          "Title": "Obsolete Rfc2898DeriveBytes constructors with unsafe defaults",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-08T20:24:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57046",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-25T00:00:00-07:00",
        "FeedbackId": "905106244",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57046#issuecomment-905106244",
        "FeedbackMarkdown": "__tl;dr:__ I\u0027m good with these obsoletions and the proposed fixer which rewrites them using the newer overloads.\r\n\r\n### Words, words, words\r\n\r\nI see this API as a fundamental building block. Cryptographic specs are usually written in terms of families of algorithms which have various configuration knobs. Sometimes the knobs should be tweaked depending on the various user scenario (CBC vs CTS padding modes for symmetric algorithms) or as a security / performance tradeoff (key length or iteration count).\r\n\r\nIMO, .NET should not be in the business of prescribing defaults for cryptographic primitives. By setting such defaults, we\u0027re either lifting one scenario to be the One True Scenario\u2122 that should be preferred above all others, or we\u0027re locking in a security / performance tradeoff that might only make sense at a snapshot in time. (The defaults in this API fall under this latter bucket.)\r\n\r\nIdeally our basic cryptographic primitive APIs (including this!) should require callers to specify all configuration knobs as appropriate for their scenario. Yes, it\u0027s verbose, but it\u0027s the right thing to do to ensure that the caller is fully aware of what they\u0027re doing and that they understand they take full responsibility for its applicability to their scenario. This gatekeeps these APIs to an extent, but I am ok with that given that only knowledgeable people should be using the primitives directly.\r\n\r\nBy forcing callers to set parameters explicitly, we also make it easier for code reviewers or automated tools to audit the call sites for appropriateness. This could include mandating a minimum iteration count or banning certain algorithm families. We have such rules within Microsoft, for instance.\r\n\r\nThe vast majority of our users - those who are scenario-driven rather than trying to adhere to a particular protocol - would be better served by an opinionated crypto stack. Opinionated stacks are somewhat opaque in that they hide the complexity of choosing appropriate defaults, but they\u0027re usually _much_ easier to use and expose only pit-of-success APIs. (The aspnet crypto stack is the best example of an opinionated crypto stack within .NET, but I\u0027m also biased here, soooooo... \uD83D\uDE03)\r\n\r\nGiven that this is a building block and not an opinionated API, I\u0027m not terribly concerned with keeping it approachable. It should be as verbose as necessary to make the call site understandable, with appropriate documentation updates if needed.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56331,
          "Title": "Provide an API to get the native module handle of the native process entry-point module",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-26T21:49:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56331",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-08-25T00:00:00-07:00",
        "FeedbackId": "905849011",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56331#issuecomment-905849011",
        "FeedbackMarkdown": "* It was requested to rename the API from \u0060GetEntryPointModuleHandle()\u0060 to \u0060GetMainProgramHandle()\u0060.\r\n* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n     public static class NativeLibrary\r\n     {\r\n          public static IntPtr GetMainProgramHandle();\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:NativeLibrary.GetMainProgramHandle()",
          "T:NativeLibrary"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "AGFnSBdnJ6o",
      "StartDateTime": "2021-09-07T11:03:50-07:00",
      "EndDateTime": "2021-09-07T12:16:30-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/AGFnSBdnJ6o/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 43669,
          "Title": "Port ObjectSerializer abstraction from the Azure SDK",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-10-21T00:04:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/43669",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-Serialization",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-07T00:00:00-07:00",
        "FeedbackId": "914555568",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/43669#issuecomment-914555568",
        "FeedbackMarkdown": "* We should have a list of places where we\u0027d **implement** the abstraction:\r\n    - \u0060System.Text.Json\u0060\r\n    - XML serializer?\r\n    - Data contract serialization?\r\n* We should have a list of placed where we\u0027d **accept** the abstraction\r\n    - Azure SDK (such as Cosmos)\r\n    - ASP.NET Core\u0027s model binder?\r\n    - \u0060HttpClientJsonExtensions\u0060?\r\n* We should validate that the abstraction works well with the feature set of the serializers we have. There shouldn\u0027t be a bias towards just JSON. Also, we\u0027ve added a ton of features to \u0060System.Text.Json\u0060. Would these all work?\r\n* Can we make \u0060ObjectSerializer\u0060 friendly for the linker?\r\n    - At the minimum, we\u0027d need generic overloads\r\n* Is \u0060Stream\u0060 the correct type? Should we also support span?\r\n* If we were to ship this, which binaries would this ship in?\r\n    - Azure SDK would need a .NET Standard 2.0 package.\r\n    - Could we just make it part of the same package that provided \u0060BinaryData\u0060?",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "0UAoOvgn_7g",
      "StartDateTime": "2021-09-14T11:02:30-07:00",
      "EndDateTime": "2021-09-14T12:12:02-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/0UAoOvgn_7g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59099,
          "Title": "UriCreationOptions",
          "Author": "MihaZupan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-14T17:06:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59099",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Net",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-14T00:00:00-07:00",
        "FeedbackId": "919412394",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59099#issuecomment-919412394",
        "FeedbackMarkdown": "* The struct should be a mutable struct\r\n    - We should pass it in via \u0060in\u0060, which means we should mark the getter as \u0060readonly\u0060\r\n* \u0060GetComponents()\u0060 should throw \u0060InvaliOperationException\u0060\r\n    - Note: even \u0060UriFormat.Unescaped\u0060 does some transformations, so this also doesn\u0027t make sense to allow\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct UriCreationOptions\r\n    {\r\n        public UriKind UriKind { readonly get; set; }\r\n        public bool AllowImplicitFilePaths { readonly get; set; }\r\n        public bool DangerousDisablePathAndQueryCanonicalization { readonly get; set; }\r\n    }\r\n\r\n    public partial class Uri\r\n    {\r\n        // Existing\r\n        // public Uri(string uriString);\r\n        // public Uri(string uriString, UriKind uriKind);\r\n        public Uri(string uriString, in UriCreationOptions creationOptions);\r\n        \r\n        // Existing\r\n        // public static bool TryCreate(string? uriString, UriKind uriKind, out Uri? result);\r\n        public static bool TryCreate(string? uriString, in UriCreationOptions creationOptions, out Uri? result);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Uri.TryCreate(string?,in UriCreationOptions,out Uri?)",
          "M:Uri.Uri(string,in UriCreationOptions)",
          "P:UriCreationOptions.AllowImplicitFilePaths",
          "P:UriCreationOptions.DangerousDisablePathAndQueryCanonicalization",
          "P:UriCreationOptions.UriKind",
          "T:Uri",
          "T:UriCreationOptions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45448,
          "Title": "Compile-time source generation for System.Text.Json",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-12-02T00:24:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45448",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-14T00:00:00-07:00",
        "FeedbackId": "919421589",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45448#issuecomment-919421589",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    // Provides serialization info about a type\r\n    public abstract partial class JsonTypeInfo\u003CT\u003E : JsonTypeInfo\r\n    {\r\n        internal JsonTypeInfo();\r\n-       public Action\u003CUtf8JsonWriter, T\u003E? Serialize { get; }\r\n\u002B       // Rename to SerializeHandler\r\n\u002B       public Action\u003CUtf8JsonWriter, T\u003E? SerializeHandler { get; }\r\n    }\r\n\r\n    public static partial class JsonMetadataServices\r\n    {\r\n\u002B       // Converter that handles JsonArray\r\n\u002B       public static JsonConverter\u003CJsonArray\u003E JsonArrayConverter { get; }\r\n\r\n\u002B       // Converter that handles JsonNode\r\n\u002B       public static JsonConverter\u003CJsonNode\u003E JsonNodeConverter { get; }\r\n\r\n\u002B       // Converter that handles JsonObject\r\n\u002B       public static JsonConverter\u003CJsonObject\u003E JsonObjectConverter { get; }\r\n\r\n\u002B       // Converter that handles JsonValue\r\n\u002B       public static JsonConverter\u003CJsonValue\u003E JsonValueConverter { get; }\r\n\r\n\u002B       // Converter that handles unsupported types.\r\n\u002B       public static JsonConverter\u003CT\u003E GetUnsupportedTypeConverter\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18670000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58853,
          "Title": "System.Numerics.Vector2.Equals doesn\u0027t use float.Equals in Equals implementation ",
          "Author": "rotanov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-09T06:59:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58853",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "breaking-change",
              "Color": "ffa500",
              "Description": "Issue or PR that represents a breaking API or functional change over a prerelease."
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-14T00:00:00-07:00",
        "FeedbackId": "919426955",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58853#issuecomment-919426955",
        "FeedbackMarkdown": "* We\u0027re OK with taking this breaking change for .NET 7.0\r\n* Should we add an analyzer that flags usages of \u0060==\u0060 when comparing floating point data types in the body of an \u0060Equals\u0060 method?",
        "TimeCode": 25990000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58880,
          "Title": "[RegexGenerator(...)] attribute",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-09T15:06:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58880",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-14T00:00:00-07:00",
        "FeedbackId": "919438549",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58880#issuecomment-919438549",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - We should rename \u0060matchTimeout\u0060 to \u0060matchTimeoutMilliseconds\u0060 as we can\u0027t use a \u0060TimeSpan\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n    public sealed class RegexGeneratorAttribute : Attribute\r\n    {\r\n        public RegexGeneratorAttribute(string pattern);\r\n        public RegexGeneratorAttribute(string pattern, RegexOptions options);\r\n        public RegexGeneratorAttribute(string pattern, RegexOptions options, int matchTimeoutMilliseconds);\r\n\r\n        public string Pattern { get; }\r\n        public RegexOptions Options { get; }\r\n        public int MatchTimeoutMilliseconds { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 30410000000,
        "Apis": [
          "M:RegexGeneratorAttribute.RegexGeneratorAttribute(string,RegexOptions,int)",
          "M:RegexGeneratorAttribute.RegexGeneratorAttribute(string,RegexOptions)",
          "M:RegexGeneratorAttribute.RegexGeneratorAttribute(string)",
          "P:RegexGeneratorAttribute.MatchTimeoutMilliseconds",
          "P:RegexGeneratorAttribute.Options",
          "P:RegexGeneratorAttribute.Pattern",
          "T:RegexGeneratorAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "-t3ELCIJpZo",
      "StartDateTime": "2021-09-21T11:02:52-07:00",
      "EndDateTime": "2021-09-21T11:46:22-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/-t3ELCIJpZo/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51700,
          "Title": "Add new ObjectDisposedException constructor overload",
          "Author": "marek-safar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-22T17:38:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51700",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924242084",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51700#issuecomment-924242084",
        "FeedbackMarkdown": "We discussed the method pattern here, and debated for a bit on whether the parameters should be nullable and we concluded no.  Since we\u0027re early in the release we have time to learn that was wrong.  (And going \u0022more nullable\u0022 is not breaking)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ObjectDisposedException\r\n    {\r\n        [System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]\r\n        [System.Diagnostics.StackTraceHidden]\r\n        public static void Throw(System.Object instance) =\u003E throw null;\r\n        [System.Diagnostics.StackTraceHidden]\r\n        [System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]\r\n        public static void Throw(System.Type type) =\u003E throw null;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nOne notable change from the PR state: We added StackTraceHidden to both methods.",
        "TimeCode": 0,
        "Apis": [
          "M:ObjectDisposedException.Throw(System.Object)",
          "M:ObjectDisposedException.Throw(System.Type)",
          "T:ObjectDisposedException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58607,
          "Title": "Add reciprocal and SinCos methods to IFloatingPoint",
          "Author": "lilinus",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-03T08:22:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58607",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924245358",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58607#issuecomment-924245358",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System\r\n{\r\n    public interface IFloatingPoint\u003CTSelf\u003E\r\n    {\r\n\u002B        (TSelf Sin, TSelf Cos) SinCos(TSelf x);\r\n\u002B        TSelf ReciprocalEstimate(TSelf x);\r\n\u002B        TSelf ReciprocalSqrtEstimate(TSelf x);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9960000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59061,
          "Title": "Obsolete thumbtacked AssemblyName properties ",
          "Author": "jkotas",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-13T20:06:36+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59061",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924248304",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59061#issuecomment-924248304",
        "FeedbackMarkdown": "Looks good as proposed (though we moved the obsoletions to the properties instead of the accessors\r\n\r\n\u0060\u0060\u0060diff\r\n    public sealed partial class AssemblyName\r\n    {\r\n\u002B       [Obsolete(\u0022AssemblyName.HashAlgorithm has been deprecated and is not supported.\u0022, DiagnosticId = next available)]\r\n        public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }\r\n\u002B       [Obsolete(\u0022AssemblyName.ProcessorArchitecture has been deprecated and is not supported.\u0022, DiagnosticId = same as above)]\r\n        public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }\r\n\u002B       [Obsolete(\u0022AssemblyName.VersionCompatibility has been deprecated and is not supported.\u0022, DiagnosticId = same as above)]\r\n        public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set;}\r\n    }\r\n\u0060\u0060\u0060",
        "TimeCode": 11500000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58047,
          "Title": "Additional ArgumentNullException.ThrowIfNull overloads",
          "Author": "DaZombieKiller",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-24T18:01:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58047",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924251709",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58047#issuecomment-924251709",
        "FeedbackMarkdown": "We think that the \u0060void*\u0060 version makes sense, but the \u0060Nullable\u003CT\u003E\u0060 version doesn\u0027t (any message associated with that error should be more complicated than the default).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ArgumentNullException : ArgumentException\r\n    {\r\n        /// \u003Csummary\u003EThrows an \u003Csee cref=\u0022ArgumentNullException\u0022/\u003E if \u003Cparamref name=\u0022argument\u0022/\u003E is null.\u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022argument\u0022\u003EThe pointer argument to validate as non-null.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022paramName\u0022\u003EThe name of the parameter with which \u003Cparamref name=\u0022argument\u0022/\u003E corresponds.\u003C/param\u003E\r\n        public static unsafe void ThrowIfNull(void* argument, [CallerArgumentExpression(\u0022argument\u0022)] string? paramName = null);\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 13990000000,
        "Apis": [
          "M:ArgumentNullException.ThrowIfNull(void*,string?)",
          "T:ArgumentNullException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1547,
          "Title": "Add the ArchiveComment property for ZipArchive class",
          "Author": "Aimeast",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-01-29T05:30:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1547",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO.Compression",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924273994",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1547#issuecomment-924273994",
        "FeedbackMarkdown": "Since the spec says that there\u0027s always a comment (but it can be zero length) we don\u0027t think the properties should be nullable (null-returning).  The setters can certainly accept null to normalize to whatever the default we have historically done.  (string.Empty / \u0022Built with .NET\u0022, whatever it is we do...)\r\n\r\nIf you don\u0027t want to do null-normalization, then remove the \u0060[AllowNull]\u0060s, but it\u0027s probably nice to do.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.IO.Compression\r\n{\r\n    public partial class ZipArchive : IDisposable\r\n    {\r\n        public ZipArchive(Stream stream);\r\n        public ZipArchive(Stream stream, ZipArchiveMode mode);\r\n        public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);\r\n        public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding? entryNameEncoding);\r\n\u002B       [AllowNull]\r\n\u002B       public string Comment { get; set; }\r\n        public ReadOnlyCollection\u003CZipArchiveEntry\u003E Entries { get; }\r\n        public ZipArchiveMode Mode { get; }\r\n        public ZipArchiveEntry CreateEntry(string entryName);\r\n        public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);\r\n        public void Dispose();\r\n        protected virtual void Dispose(bool disposing);\r\n        public ZipArchiveEntry? GetEntry(string entryName);\r\n    }\r\n    public partial class ZipArchiveEntry\r\n    {\r\n        internal ZipArchiveEntry() { }\r\n        public ZipArchive Archive { get ; }\r\n\u002B       [AllowNull]\r\n\u002B       public string Comment { get; set; }\r\n        public long CompressedLength { get ; }\r\n        public uint Crc32 { get; }\r\n        public int ExternalAttributes { get; set; }\r\n        public string FullName { get; }\r\n        public DateTimeOffset LastWriteTime { get; set; }\r\n        public long Length { get; }\r\n        public string Name { get; }\r\n        public void Delete();\r\n        public Stream Open();\r\n        public override string ToString();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 16710000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44738,
          "Title": "Make it safer and easier to build an X500DistinguishedName",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-16T17:15:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44738",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-21T00:00:00-07:00",
        "FeedbackId": "924277199",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44738#issuecomment-924277199",
        "FeedbackMarkdown": "Clicking\u0027s hard, mm\u0027kay?  :smile:",
        "TimeCode": 25440000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "modnFoA7Qts",
      "StartDateTime": "2021-09-28T11:06:31-07:00",
      "EndDateTime": "2021-09-28T11:40:52-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/modnFoA7Qts/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59454,
          "Title": "Custom attribute for Pre-compile AOP",
          "Author": "wsq003",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-22T02:33:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59454",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-28T00:00:00-07:00",
        "FeedbackId": "",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59454#issuecomment-",
        "FeedbackMarkdown": "",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50535,
          "Title": "Obsolete Regex.CompileToAssembly",
          "Author": "buyaa-n",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-01T01:02:09+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50535",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-28T00:00:00-07:00",
        "FeedbackId": "929507983",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50535#issuecomment-929507983",
        "FeedbackMarkdown": "* Looks good\r\n    - We should add a diagnostic ID for all these obsoletions.\r\n    - Adjust message as needed to be consistent\r\n* Should we also obsolete the other APIs that persist an assembly to disk, such as\r\n    -  \u0060AssemblyBuilder.Save\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    public partial class Regex\r\n    {\r\n        [Obsolete(\u0022This API isn\u0027t supported anymore. Please use source generated regexes instead.\u0022, DiagnosticId = \u0022TBD\u0022)]\r\n        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);\r\n        [Obsolete(\u0022This API isn\u0027t supported anymore. Please use source generated regexes instead.\u0022, DiagnosticId = \u0022TBD\u0022)]\r\n        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes);\r\n        [Obsolete(\u0022This API isn\u0027t supported anymore. Please use source generated regexes instead.\u0022, DiagnosticId = \u0022TBD\u0022)]\r\n        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[]? attributes, string? resourceFile);\r\n    }\r\n    [Obsolete(\u0022This API isn\u0027t supported anymore. Please use source generated regexes instead.\u0022, DiagnosticId = \u0022TBD\u0022)]\r\n    public partial class RegexCompilationInfo\r\n    {\r\n\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060",
        "TimeCode": 4740000000,
        "Apis": [
          "M:Regex.CompileToAssembly(RegexCompilationInfo[],AssemblyName,CustomAttributeBuilder[]?,string?)",
          "M:Regex.CompileToAssembly(RegexCompilationInfo[],AssemblyName,CustomAttributeBuilder[]?)",
          "M:Regex.CompileToAssembly(RegexCompilationInfo[],AssemblyName)",
          "T:Regex",
          "T:RegexCompilationInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 51700,
          "Title": "Add new ObjectDisposedException constructor overload",
          "Author": "marek-safar",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-04-22T17:38:27+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/51700",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-28T00:00:00-07:00",
        "FeedbackId": "929511062",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/51700#issuecomment-929511062",
        "FeedbackMarkdown": "* Makese sense. It seems we should establish as a general pattern for throw helpers.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ObjectDisposedException\r\n    {\r\n        public static void ThrowIf([DoesNotReturnIf(true)] bool condition, object instance);\r\n        public static void ThrowIf([DoesNotReturnIf(true)] bool condition, Type type);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6710000000,
        "Apis": [
          "M:ObjectDisposedException.ThrowIf(bool,object)",
          "M:ObjectDisposedException.ThrowIf(bool,Type)",
          "T:ObjectDisposedException"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58426,
          "Title": "Add RemoveAt() and Insert() to IList by using Index struct",
          "Author": "sps014",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-31T09:46:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58426",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-09-28T00:00:00-07:00",
        "FeedbackId": "929521369",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58426#issuecomment-929521369",
        "FeedbackMarkdown": "* The concept makes sense, but we should avoid forcing consumers through interface dispatch\r\n    - At least for low-overhead types such as \u0060List\u003CT\u003E\u0060 we should consider adding matching instance methods\r\n    - Also, are these really all the ones that are missing?\r\n    - Alternatively, could this be done by the compiler?\r\n\r\n\u0060\u0060\u0060C#\r\n\r\nnamespace System.Collections.Generic\r\n{\r\n    public static  class CollectionExtensions\r\n    {\r\n        public static void RemoveAt\u003CT\u003E(this IList\u003CT\u003E list, Index index);\r\n        public static void Insert\u003CT\u003E(this IList\u003CT\u003E list, Index index, T data);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 9290000000,
        "Apis": [
          "M:CollectionExtensions.Insert\u003CT\u003E(this IList\u003CT\u003E,Index,T)",
          "M:CollectionExtensions.RemoveAt\u003CT\u003E(this IList\u003CT\u003E,Index)",
          "T:CollectionExtensions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "1-PVX45YGcU",
      "StartDateTime": "2021-10-05T11:04:01-07:00",
      "EndDateTime": "2021-10-05T12:03:06-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/1-PVX45YGcU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1290,
          "Title": "Add ResourceManager.TryGetString API to avoid exceptions",
          "Author": "AArnott",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-03T23:19:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1290",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Resources",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-05T00:00:00-07:00",
        "FeedbackId": "934650085",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1290#issuecomment-934650085",
        "FeedbackMarkdown": "Since the existing \u0060GetString\u0060 returns \u0060null\u0060 (vs throwing) when a specific resource is missing, it\u0027s unclear what the Try is trying... so we\u0027d need more information to discuss this further.\r\n\r\nSpecific examples of where the exceptions are occurring would be useful, so we can decide what the appropriate remediation is.",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59924,
          "Title": "Add Indexer to Vectors",
          "Author": "Avid29",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-04T10:28:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59924",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-05T00:00:00-07:00",
        "FeedbackId": "934656109",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59924#issuecomment-934656109",
        "FeedbackMarkdown": "Looks good as proposed.  We went ahead and added read-only indexers on the other Vector types\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Numerics\r\n{\r\n    public partial struct Vector2\r\n    {\r\n        public float this[int index] { get; set; }\r\n    }\r\n\r\n    public partial struct Vector3\r\n    {\r\n        public float this[int index] { get; set; }\r\n    }\r\n    \r\n    public partial struct Vector4\r\n    {\r\n        public float this[int index] { get; set; }\r\n    }\r\n\r\n    public partial struct Quaternion\r\n    {\r\n        public float this[int index] { get; set; }\r\n    }\r\n\r\n    public partial struct Matrix3x2\r\n    {\r\n        public float this[int row, int column] { get; set; }\r\n    }\r\n\r\n    public partial struct Matrix4x4\r\n    {\r\n        public float this[int row, int column] { get; set; }\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public partial struct Vector64\u003CT\u003E\r\n    {\r\n        public T this[int index] { get; }\r\n    }\r\n\r\n    public partial struct Vector128\u003CT\u003E\r\n    {\r\n        public T this[int index] { get; }\r\n    }\r\n\r\n    public partial struct Vector256\u003CT\u003E\r\n    {\r\n        public T this[int index] { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6790000000,
        "Apis": [
          "P:Matrix3x2[int,int]",
          "P:Matrix4x4[int,int]",
          "P:Quaternion[int]",
          "P:Vector128\u003CT\u003E[int]",
          "P:Vector2[int]",
          "P:Vector256\u003CT\u003E[int]",
          "P:Vector3[int]",
          "P:Vector4[int]",
          "P:Vector64\u003CT\u003E[int]",
          "T:Matrix3x2",
          "T:Matrix4x4",
          "T:Quaternion",
          "T:Vector128\u003CT\u003E",
          "T:Vector2",
          "T:Vector256\u003CT\u003E",
          "T:Vector3",
          "T:Vector4",
          "T:Vector64\u003CT\u003E"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 30381,
          "Title": "Add WhereNotNull to help with nullability tracking",
          "Author": "YairHalberstadt",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-07-26T06:09:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/30381",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-05T00:00:00-07:00",
        "FeedbackId": "934681792",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/30381#issuecomment-934681792",
        "FeedbackMarkdown": "Given that it would require people to change their code, and the current analysis says it\u0027s only about 3% of libraries where it\u0027s even possibly related; and that the main use should ideally be solved by the compiler... there\u0027s no need for it in the BCL.",
        "TimeCode": 11690000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "sh6LRNVf8NA",
      "StartDateTime": "2021-10-12T11:04:48-07:00",
      "EndDateTime": "2021-10-12T12:19:10-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/sh6LRNVf8NA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59954,
          "Title": "JsonSerializer support for JsonDocument types in source generation mode",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-04T17:28:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59954",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "Priority:1",
              "Color": "d93f0b",
              "Description": "Work that is critical for the release, but we could probably ship without"
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941250320",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59954#issuecomment-941250320",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Serialization.Metadata\r\n{\r\n    public static partial class JsonMetadataServices\r\n    {\r\n        // Existing\r\n        // public JsonConverter\u003CJsonElement\u003E JsonElementConverter { get; }\r\n        public JsonConverter\u003CJsonDocument\u003E JsonDocumentConverter { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:JsonMetadataServices.JsonDocumentConverter",
          "T:JsonMetadataServices"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60279,
          "Title": "Add string indexers for JsonElement",
          "Author": "layomia",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-12T01:49:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60279",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941256995",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60279#issuecomment-941256995",
        "FeedbackMarkdown": "* We don\u0027t think this is a good idea because name lookups are a \u0060O(n)\u0060 complexity, which will result in people accidentally creating \u0060O(n^2)\u0060 algorithms when being used in a loop.\r\n* The general guidance is that property access should \u0022cheap\u0022 or \u0022reasonably fast\u0022, which basically means \u0060O(n)\u0060 is a bad idea...\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public readonly partial struct JsonElement\r\n    {\r\n        // Existing API\r\n        // public JsonElement this[int index] { get; }\r\n        public JsonElement this[string propertyName] { get; }  \r\n        public JsonElement this[ReadOnlySpan\u003Cchar\u003E propertyName] { get; }  \r\n        public JsonElement this[ReadOnlySpan\u003Cbyte\u003E utf8PropertyName] { get; }  \r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 2430000000,
        "Apis": [
          "P:JsonElement[ReadOnlySpan\u003Cbyte\u003E]",
          "P:JsonElement[ReadOnlySpan\u003Cchar\u003E]",
          "P:JsonElement[string]",
          "T:JsonElement"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60065,
          "Title": "Customizable IConfigurationRoot.GetDebugView() for hiding the value",
          "Author": "oskrabanek",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-06T11:08:41+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60065",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941273491",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60065#issuecomment-941273491",
        "FeedbackMarkdown": "* The scenario makes sense but we don\u0027t like the use of \u0060Func\u0060 because it\u0027s not clear what the first three strings\r\n* Should \u0060Value\u0060 be nullable?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public readonly struct ConfigurationDebugViewContext\r\n    {\r\n        public ConfigurationDebugViewContext(string path, string key, string value, IConfigurationProvider configurationProvider);\r\n        public string Path { get; }\r\n        public string Key { get; }\r\n        public string Value { get; }\r\n        public IConfigurationProvider ConfigurationProvider { get; }\r\n    }\r\n\r\n    public static class ConfigurationRootExtensions\r\n    {\r\n        // Existing\r\n        // public static string GetDebugView(this IConfigurationRoot root);\r\n        public static string GetDebugView(this IConfigurationRoot root, Func\u003CConfigurationDebugViewContext, string\u003E processValue);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6650000000,
        "Apis": [
          "M:ConfigurationDebugViewContext.ConfigurationDebugViewContext(string,string,string,IConfigurationProvider)",
          "M:ConfigurationRootExtensions.GetDebugView(this IConfigurationRoot,Func\u003CConfigurationDebugViewContext, string\u003E)",
          "P:ConfigurationDebugViewContext.ConfigurationProvider",
          "P:ConfigurationDebugViewContext.Key",
          "P:ConfigurationDebugViewContext.Path",
          "P:ConfigurationDebugViewContext.Value",
          "T:ConfigurationDebugViewContext",
          "T:ConfigurationRootExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60106,
          "Title": "Add an IAsyncEnumerable\u003CT\u003E.ToEnumerable extension method.",
          "Author": "davidfowl",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-07T00:12:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60106",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941288052",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60106#issuecomment-941288052",
        "FeedbackMarkdown": "* We think \u0060ToListAsync\u0060 goes down path of \u0060System.Linq.Async\u0060. It seems once you want this functionality, you\u0027re better off adding a reference to that.\r\n* \u0060System.Linq.Async\u0060 already has \u0060ToEnumerable\u0060 method (even though it doesn\u0027t take a cancellation token), so we\u0027d prefer adding \u0060Blocking\u0060 to avoid any ambiguity errors in case they ever add an overload with a cancellation token. It also puts more attention of the potentially problematic blocking behavior.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Threading.Tasks\r\n{\r\n    public static class TaskAsyncEnumerableExtensions\r\n    {\r\n        public static IEnumerable\u003CT\u003E ToBlockingEnumerable\u003CT\u003E(this IAsyncEnumerable\u003CT\u003E source, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15950000000,
        "Apis": [
          "M:TaskAsyncEnumerableExtensions.ToBlockingEnumerable\u003CT\u003E(this IAsyncEnumerable\u003CT\u003E,CancellationToken)",
          "T:TaskAsyncEnumerableExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60125,
          "Title": "SignedCms:  does not enable RSASSA-PSS signing",
          "Author": "dtivel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-07T13:57:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60125",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941291692",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60125#issuecomment-941291692",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography.Pkcs\r\n{\r\n    public partial class CmsSigner\r\n    {\r\n        // Existing ctors:\r\n        // public CmsSigner();\r\n        // public CmsSigner(SubjectIdentifierType signerIdentifierType);\r\n        // public CmsSigner(X509Certificate2? certificate);\r\n        // public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2? certificate);\r\n        //\r\n        // public CmsSigner(\r\n        //     SubjectIdentifierType signerIdentifierType,\r\n        //     X509Certificate2? certificate,\r\n        //     AsymmetricAlgorithm? privateKey);\r\n\r\n        public CmsSigner(\r\n            SubjectIdentifierType signerIdentifierType,\r\n            X509Certificate2? certificate,\r\n            RSA? privateKey,\r\n            RSASignaturePadding? signaturePadding);\r\n\r\n        public RSASignaturePadding? SignaturePadding { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25750000000,
        "Apis": [
          "M:CmsSigner.CmsSigner(SubjectIdentifierType,X509Certificate2?,RSA?,RSASignaturePadding?)",
          "P:CmsSigner.SignaturePadding",
          "T:CmsSigner"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33767,
          "Title": "Do not double-return arrays to ArrayPool",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33767",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Buffers",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941297075",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33767#issuecomment-941297075",
        "FeedbackMarkdown": "* We believe this is going to be difficult, given that the compiler/analyzer doesn\u0027t expose flow in a way where we could easily tell whether something is called more than once.\r\n* Another way of solving this problem is returning a disposable value from a method that helps manage the lifetime\r\n* Hence we don\u0027t believe it\u0027s worth investing in as of this moment\r\n\r\n\u0060\u0060\u0060text\r\nAnalzyer: Do not double-return arrays to ArrayPool \r\n\u0060\u0060\u0060",
        "TimeCode": 28090000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58962,
          "Title": "System.Collections.Generic.SortedList\u003CTKey, TValue\u003E should have SetByIndex(Int32,TValue)",
          "Author": "rhaokiel",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-10T19:06:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58962",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "easy",
              "Color": "90eeff",
              "Description": "Issue should be easy to implement, good for first-time contributors"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-12T00:00:00-07:00",
        "FeedbackId": "941332116",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58962#issuecomment-941332116",
        "FeedbackMarkdown": "* It seems \u0060GetByIndex()\u0060 can already be achieved by indexing into the \u0060Values\u0060 and \u0060Keys\u0060 properties.\r\n    - So we don\u0027t need to expose \u0060GetByIndex\u0060, but feels good for symmetry\r\n* The \u0060Values\u0060 throws NotSupportedException on writes\r\n    - We could make this writable but this would be odd\r\n* We should add \u0060SetValueByIndex\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public partial class SortedList\u003CTKey, TValue\u003E\r\n    {\r\n        public TKey GetKeyAtIndex(int index);\r\n        public TValue GetValueAtIndex(int index);\r\n        public void SetValueAtIndex(int index, TValue value);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 31270000000,
        "Apis": [
          "M:SortedList\u003CTKey, TValue\u003E.GetKeyAtIndex(int)",
          "M:SortedList\u003CTKey, TValue\u003E.GetValueAtIndex(int)",
          "M:SortedList\u003CTKey, TValue\u003E.SetValueAtIndex(int,TValue)",
          "T:SortedList\u003CTKey, TValue\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "etwMhIKj0tI",
      "StartDateTime": "2021-10-19T10:59:38-07:00",
      "EndDateTime": "2021-10-19T11:58:29-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/etwMhIKj0tI/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 54220,
          "Title": "Add Enumerable.Concat \u0026 Flatten overloads",
          "Author": "TonyValenti",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-06-15T14:09:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/54220",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-19T00:00:00-07:00",
        "FeedbackId": "946994846",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/54220#issuecomment-946994846",
        "FeedbackMarkdown": "* We changed the signature of the params overload to Concat to support extension invocation and look like an easier overload.\r\n* We renamed the \u0060Concat(IEnumerable\u003CIEnumerable\u003CT\u003E\u003E)\u0060 to \u0060Flatten\u0060 to better describe its use.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq \r\n{\r\n    public static partial class Enumerable \r\n    {\r\n        public static IEnumerable\u003CTSource\u003E Concat\u003CTSource\u003E(\r\n            this IEnumerable\u003CTSource\u003E first,\r\n             IEnumerable\u003CTSource\u003E second,\r\n             params IEnumerable\u003CTSource\u003E[] rest);\r\n\r\n\r\n        public static IEnumerable\u003CTSource\u003E Flatten\u003CTSource\u003E(this IEnumerable\u003CIEnumerable\u003CTSource\u003E\u003E sources);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Enumerable.Concat\u003CTSource\u003E(this IEnumerable\u003CTSource\u003E,IEnumerable\u003CTSource\u003E,params IEnumerable\u003CTSource\u003E[])",
          "M:Enumerable.Flatten\u003CTSource\u003E(this IEnumerable\u003CIEnumerable\u003CTSource\u003E\u003E)",
          "T:Enumerable"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60531,
          "Title": "HttpClient.PatchAsJsonAsync()",
          "Author": "ikesnowy",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-18T05:15:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60531",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-19T00:00:00-07:00",
        "FeedbackId": "947000766",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60531#issuecomment-947000766",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace  System.Net.Http.Json\r\n{\r\n    public static partial class HttpClientJsonExtensions\r\n    {\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, string? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default);\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, Uri? requestUri, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default);\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, string? requestUri, TValue value, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo = null, CancellationToken cancellationToken = default);\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, Uri? requestUri, TValue value, JsonTypeInfo\u003CTValue\u003E jsonTypeInfo = null, CancellationToken cancellationToken = default);\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, string? requestUri, TValue value, CancellationToken cancellationToken = default);\r\n        public Task\u003CHttpResponseMessage\u003E PatchAsJsonAsync\u003CTValue\u003E(this HttpClient client, Uri? requestUri, TValue value, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 17990000000,
        "Apis": [
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,string?,TValue,CancellationToken)",
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,string?,TValue,JsonSerializerOptions?,CancellationToken)",
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,string?,TValue,JsonTypeInfo\u003CTValue\u003E,CancellationToken)",
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,Uri?,TValue,CancellationToken)",
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,Uri?,TValue,JsonSerializerOptions?,CancellationToken)",
          "M:HttpClientJsonExtensions.PatchAsJsonAsync\u003CTValue\u003E(this HttpClient,Uri?,TValue,JsonTypeInfo\u003CTValue\u003E,CancellationToken)",
          "T:HttpClientJsonExtensions"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 22144,
          "Title": "Support await\u0027ing a Task without throwing",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-06-06T13:54:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/22144",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Threading.Tasks",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-19T00:00:00-07:00",
        "FeedbackId": "947018377",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/22144#issuecomment-947018377",
        "FeedbackMarkdown": "We discussed this today, and one of the main feelings is that the ConfigureAwait(NoThrow) feels like a pit of failure.  One piece of that is it invalidates the nullability annotations, since nulls will start appearing out of non-null-returning members.\r\n\r\nSomething like an extension method that changes from an \u0060awaitable\u003CT\u003E\u0060 to an \u0060awaitable\u003C(T?, Exception)\u003E\u0060, or at least \u0060awaitable\u003C(bool, T?)\u003E\u0060 might be reasonable, but that can\u0027t be described as a flags flag.  This is, in particular, important for the ValueTask versions, since the Exception cannot otherwise be recovered.\r\n\r\nWe probably want to try this out on non-public code first to get an idea of what\u0027s really needed.",
        "TimeCode": 21030000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "MrStTiZcpuU",
      "StartDateTime": "2021-10-26T11:31:58-07:00",
      "EndDateTime": "2021-10-26T11:55:59-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/MrStTiZcpuU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 45167,
          "Title": "Expose the field \u0060_stringHasEscaping\u0060 of the \u0060Utf8JsonReader\u0060 struct",
          "Author": "ycrumeyrolle",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-24T20:58:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/45167",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-10-26T00:00:00-07:00",
        "FeedbackId": "952220732",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/45167#issuecomment-952220732",
        "FeedbackMarkdown": "* It should return \u0060false\u0060 when the current token isn\u0027t a string.\r\n* It would be beneficial to align the name with \u0060ValueSpan\u0060. This also solves the issue if we ever have any other token types that are escaped, so let\u0027s rename this to \u0060ValueIsEscaped\u0060\r\n* Do we need an \u0060Unescape\u0060 API that allows unescaping in a non-allocating way. We can treat this a separate API request.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial ref struct Utf8JsonReader\r\n    {\r\n        public bool ValueIsEscaped { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:Utf8JsonReader.ValueIsEscaped",
          "T:Utf8JsonReader"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "cH20Po63ymw",
      "StartDateTime": "2021-11-02T11:00:51-07:00",
      "EndDateTime": "2021-11-02T11:48:03-07:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/cH20Po63ymw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33033,
          "Title": "Add extension method AsReadOnly() for IDictionary\u003CTKey, TValue\u003E",
          "Author": "Mrxx99",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-01T21:14:10+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33033",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-02T00:00:00-07:00",
        "FeedbackId": "958004623",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33033#issuecomment-958004623",
        "FeedbackMarkdown": "* This makes sense, but it seems we should be consistent and offer one for \u0060ReadOnlyCollection\u003CT\u003E\u0060, which today only exists as instance methods on \u0060List\u003CT\u003E\u0060 and \u0060Array\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public static class CollectionExtensions\r\n    {\r\n        public static ReadOnlyCollection\u003CT\u003E AsReadOnly\u003CT\u003E(this IList\u003CT\u003E list);\r\n        public static ReadOnlyDictionary\u003CTKey, TValue\u003E AsReadOnly\u003CTKey, TValue\u003E(this IDictionary\u003CTKey, TValue\u003E dictionary);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:CollectionExtensions.AsReadOnly\u003CT\u003E(this IList\u003CT\u003E)",
          "M:CollectionExtensions.AsReadOnly\u003CTKey, TValue\u003E(this IDictionary\u003CTKey, TValue\u003E)",
          "T:CollectionExtensions"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 44947,
          "Title": "Add MaxDepth to JsonWriterOptions",
          "Author": "amosonn",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-11-19T15:11:24+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/44947",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-02T00:00:00-07:00",
        "FeedbackId": "958009583",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/44947#issuecomment-958009583",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial struct JsonWriterOptions\r\n    {\r\n        public int MaxDepth { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7170000000,
        "Apis": [
          "P:JsonWriterOptions.MaxDepth",
          "T:JsonWriterOptions"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 55510,
          "Title": "Add unbounded SortedSet\u003CT\u003E.TreeSubSet API",
          "Author": "kzrnm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-12T13:44:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/55510",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Collections",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-02T00:00:00-07:00",
        "FeedbackId": "958020733",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/55510#issuecomment-958020733",
        "FeedbackMarkdown": "* It seems unfortunate to force the caller to inspect the values to decide which of the three methods to call. It would be nicer if we could pass in \u0022null\u0022 to indicate that the value is missing and have the method do the right thing.\r\n    - I put \u0022null\u0022 in quotes because the \u0060T\u0060 is unconstrained so we can\u0027t actually make it nullable if \u0060T\u0060 is a value type.\r\n* Can we make this better with extension methods? Or should we accept a boolean for lower/upper bound?\r\n* How do these virtuals behave when someone overrode \u0060IsViewBetween()\u0060?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Collections.Generic\r\n{\r\n    public partial class SortedSet\u003CT\u003E\r\n    {\r\n        public virtual SortedSet\u003CT\u003E GetViewUntil(T? lowerValue);\r\n        public virtual SortedSet\u003CT\u003E GetViewFrom(T? upperValue);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10440000000,
        "Apis": [
          "M:SortedSet\u003CT\u003E.GetViewFrom(T?)",
          "M:SortedSet\u003CT\u003E.GetViewUntil(T?)",
          "T:SortedSet\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61093,
          "Title": "Expose a JsonSerializerOptions.Default property",
          "Author": "eiriktsarpalis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-02T11:56:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61093",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Cost:S",
              "Color": "00CC00",
              "Description": "Work that requires one engineer up to 1 week"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-02T00:00:00-07:00",
        "FeedbackId": "958028498",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61093#issuecomment-958028498",
        "FeedbackMarkdown": "* We need to make sure the instance is marked as \u0022you can\u0027t touch this anymore\u0022\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json\r\n{\r\n    public partial class JsonSerializerOptions\r\n    {\r\n        public static JsonSerializerOptions Default { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 15970000000,
        "Apis": [
          "P:JsonSerializerOptions.Default",
          "T:JsonSerializerOptions"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "d1hJwHDz5Wc",
      "StartDateTime": "2021-11-16T10:04:01-08:00",
      "EndDateTime": "2021-11-16T12:03:40-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/d1hJwHDz5Wc/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60639,
          "Title": "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute.DisableRuntimeMarshalling",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-19T17:24:06+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60639",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-16T00:00:00-08:00",
        "FeedbackId": "970569985",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60639#issuecomment-970569985",
        "FeedbackMarkdown": "* We changed this to be a separate attribute because of how it composes with the compiler-emitted \u0060RuntimeCompatibilityAttribute\u0060\r\n* We had a philosophical discussion about generators emitting attributes like this, and concluded that they shouldn\u0027t because of the generator source-view model and composability.  (When they\u0027re required that should be detected by an analyzer)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple = false, Inherited = false)]\r\n    public sealed class DisableRuntimeMarshallingAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "T:DisableRuntimeMarshallingAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61239,
          "Title": "Add RequiresDynamicCodeAttribute",
          "Author": "MichalStrehovsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-05T01:20:34+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61239",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-NativeAOT-coreclr",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-16T00:00:00-08:00",
        "FeedbackId": "970579765",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61239#issuecomment-970579765",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Indicates that the specified method requires the ability to generate new code at runtime,\r\n    /// for example through \u003Csee cref=\u0022System.Reflection\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// This allows tools to understand which methods are unsafe to call when compiling ahead of time.\r\n    /// \u003C/remarks\u003E\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor, Inherited = false)]\r\n    public sealed class RequiresDynamicCodeAttribute : Attribute\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022RequiresDynamicCodeAttribute\u0022/\u003E class\r\n        /// with the specified message.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022message\u0022\u003E\r\n        /// A message that contains information about the usage of dynamic code.\r\n        /// \u003C/param\u003E\r\n        public RequiresDynamicCodeAttribute(string message)\r\n        {\r\n            Message = message;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets a message that contains information about the usage of dynamic code.\r\n        /// \u003C/summary\u003E\r\n        public string Message { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Gets or sets an optional URL that contains more information about the method,\r\n        /// why it requries dynamic code, and what options a consumer has to deal with it.\r\n        /// \u003C/summary\u003E\r\n        public string? Url { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 27630000000,
        "Apis": [
          "M:RequiresDynamicCodeAttribute.RequiresDynamicCodeAttribute(string)",
          "P:RequiresDynamicCodeAttribute.Message",
          "P:RequiresDynamicCodeAttribute.Url",
          "T:RequiresDynamicCodeAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61516,
          "Title": "Introduce a common base type for ECDsa and ECDiffieHellman",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-12T16:26:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61516",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-16T00:00:00-08:00",
        "FeedbackId": "970588262",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61516#issuecomment-970588262",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography\r\n{\r\n\u002B    public abstract class ECAlgorithm : AsymmetricAlgorithm\r\n\u002B    {\r\n#       Existing implementations on ECDsa and ECDiffieHellman that throw NotImplementedException\r\n#       These will throw NotImplementedException, as they do now.\r\n\u002B       public virtual void ImportParameters(ECParameters parameters);\r\n\u002B       public virtual ECParameters ExportParameters(bool includePrivateParameters);\r\n\u002B       public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);\r\n\u002B       public virtual void GenerateKey(ECCurve curve);\r\n\r\n#       Virtuals on ECDsa and ECDiffieHellman with identical implementations.\r\n#       We could push the implementation down to this type.\r\n\u002B       public virtual void ImportECPrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n\u002B       public virtual byte[] ExportECPrivateKey();\r\n\u002B       public virtual bool TryExportECPrivateKey(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#       Overrides from ECDsa and ECDiffieHellman that have identical implementation and\r\n#       can be pushed down to this type.\r\n\u002B       public override void ImportFromPem(ReadOnlySpan\u003Cchar\u003E input);\r\n\u002B       public override void ImportSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n\u002B       public override bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\u002B       public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E passwordBytes, ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n\u002B       public override void ImportPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n\u002B       public override void TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cchar\u003E password, PbeParameters pbeParameters, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#       APIs that are new in .NET 7 and are not too late to move from ECDsa and ECDiffieHellman\r\n#       since they are non-virtual but identical implementation.\r\n\u002B       public string ExportECPrivateKeyPem();\r\n\u002B       public bool TryExportECPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n\u002B    }\r\n\r\n-   public abstract class ECDsa : AsymmetricAlgorithm\r\n\u002B   public abstract class ECDsa : ECAlgorithm\r\n    {\r\n#       existing virtuals that are now handled by the base class.\r\n#       if we need the members to explicitly exist on this type, then they\r\n#       can become overrides that simply call \u0060base.\u0060 I\u0027ve been told that the\r\n#       CLR correctly handles dispatching to the base type when virtuals are removed.\r\n-       public virtual void ImportParameters(ECParameters parameters);\r\n-       public virtual ECParameters ExportParameters(bool includePrivateParameters);\r\n-       public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);\r\n-       public virtual void GenerateKey(ECCurve curve);\r\n-       public virtual void ImportECPrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-       public virtual byte[] ExportECPrivateKey();\r\n-       public virtual bool TryExportECPrivateKey(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#      overrides that can be removed since they are now handled by the base\r\n-      public override void ImportFromPem(ReadOnlySpan\u003Cchar\u003E input);\r\n-      public override void ImportSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n-      public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E passwordBytes, ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override void ImportPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override void TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cchar\u003E password, PbeParameters pbeParameters, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#      These are non virtual with identical implementations between ECDsa and ECDiffieHellman\r\n#      They have not shipped in any .NET 7 so we can move them down if this proposal gets accepted for .NET 7.\r\n-      public string ExportECPrivateKeyPem();\r\n-      public bool TryExportECPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n\r\n-   public abstract class ECDiffieHellman : AsymmetricAlgorithm\r\n\u002B   public abstract class ECDiffieHellman : ECAlgorithm\r\n    {\r\n#       existing virtuals that are now handled by the base class.\r\n#       if we need the members to explicitly exist on this type, then they\r\n#       can become overrides that simply call \u0060base.\u0060 I\u0027ve been told that the\r\n#       CLR correctly handles dispatching to the base type when virtuals are removed.\r\n-       public virtual void ImportParameters(ECParameters parameters);\r\n-       public virtual ECParameters ExportParameters(bool includePrivateParameters);\r\n-       public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);\r\n-       public virtual void GenerateKey(ECCurve curve);\r\n-       public virtual void ImportECPrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-       public virtual byte[] ExportECPrivateKey();\r\n-       public virtual bool TryExportECPrivateKey(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#      overrides that can be removed since they are now handled by the base\r\n-      public override void ImportFromPem(ReadOnlySpan\u003Cchar\u003E input);\r\n-      public override void ImportSubjectPublicKeyInfo(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override bool TryExportSubjectPublicKeyInfo(Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n-      public override void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E passwordBytes, ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override void ImportPkcs8PrivateKey(ReadOnlySpan\u003Cbyte\u003E source, out int bytesRead);\r\n-      public override void TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan\u003Cchar\u003E password, PbeParameters pbeParameters, Span\u003Cbyte\u003E destination, out int bytesWritten);\r\n\r\n#      These are non virtual with identical implementations between ECDsa and ECDiffieHellman\r\n#      They have not shipped in any .NET 7 so we can move them down if this proposal gets accepted for .NET 7.\r\n-      public string ExportECPrivateKeyPem();\r\n-      public bool TryExportECPrivateKeyPem(Span\u003Cchar\u003E destination, out int charsWritten);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 35700000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 5912,
          "Title": "\u0060ErrorProvider\u0060 extend with \u0060HasErrors\u0060 property",
          "Author": "tugibaev",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-04T07:33:49+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/5912",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-16T00:00:00-08:00",
        "FeedbackId": "970593748",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/5912#issuecomment-970593748",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms {\r\n   public class ErrorProvider {\r\n       public bool HasErrors { get; }\r\n   }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 42510000000,
        "Apis": [
          "P:ErrorProvider.HasErrors",
          "T:ErrorProvider"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33771,
          "Title": "Pass constants to parameters marked as [ConstantExpected]",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:42:32+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33771",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-16T00:00:00-08:00",
        "FeedbackId": "970633087",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33771#issuecomment-970633087",
        "FeedbackMarkdown": "The attribute looks good as proposed (except we changed the namespace)\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]\r\n    public sealed class ConstantExpectedAttribute : Attribute\r\n    {\r\n        public object? Min { get; set; }\r\n        public object? Max { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nFor the analyzer:\r\n* Category: Performance\r\n* The default diagnostic for passing a non-constant value: Warning\r\n* The default diagnostic for a constant that\u0027s out of range: Warning\r\n* The default diagnostic for a constant that\u0027s out of range by composition with another ConstantExpected attribute: Warning\r\n* The default diagnostic for passing min/max that make no sense (wrong type, inverted, is a reference type, etc): Error\r\n* So far we\u0027ve identified two distinct diagnostic IDs needed, one for \u0022you used the attribute wrong\u0022 (the error) and one for \u0022you\u0027re calling this method wrong\u0022 (all of the others).  They can, of course, be subsetted as needs demonstrate.",
        "TimeCode": 45950000000,
        "Apis": [
          "P:ConstantExpectedAttribute.Max",
          "P:ConstantExpectedAttribute.Min",
          "T:ConstantExpectedAttribute"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "D9g8gYdViPY",
      "StartDateTime": "2021-11-23T10:06:29-08:00",
      "EndDateTime": "2021-11-23T11:37:27-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/D9g8gYdViPY/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "winforms",
          "Id": 5405,
          "Title": "WinForm class OpenFileDialog and SaveFileDialog don\u0027t support OFN_DONTADDTORECENT flag",
          "Author": "roland5572",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-09T11:47:33+00:00",
          "Url": "https://github.com/dotnet/winforms/issues/5405",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-suggestion",
              "Color": "200dff",
              "Description": "(1) Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "api-approved",
              "Color": "23ef90",
              "Description": "(4) API was approved in API review, it can be implemented"
            },
            {
              "Name": "tenet-OS-compat",
              "Color": "c2e0c6",
              "Description": "Compatibility with OS features"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-23T00:00:00-08:00",
        "FeedbackId": "976969463",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/winforms/issues/5405#issuecomment-976969463",
        "FeedbackMarkdown": "* Makes sense\r\n* Do we/should we replicate some of these in WPF\u0027s dialog (\u0060OpenFileDialog\u0060 and \u0060SaveFileDialog\u0060)?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Windows.Forms\r\n{\r\n    public partial class FileDialog\r\n    {\r\n        [DefaultValue(true)]\r\n        public bool AddToRecent { get; set; } = true;\r\n\r\n        [DefaultValue(false)]\r\n        public bool ShowHiddenFiles { get; set; }\r\n\r\n        [DefaultValue(true)]\r\n        public bool ShowPinnedPlaces { get; set; } = true;\r\n\r\n        [DefaultValue(false)]\r\n        public bool OkRequiresInteraction { get; set; }\r\n    }\r\n    public partial class OpenFileDialog\r\n    {\r\n        [DefaultValue(false)]\r\n        public bool ShowPreview { get; set; }\r\n\r\n        [DefaultValue(false)]\r\n        public bool SelectReadOnly { get; set; }\r\n    }\r\n    public partial class SaveFileDialog\r\n    {\r\n        [DefaultValue(true)]\r\n        public bool ExpandedMode { get; set; } = true;\r\n\r\n        [DefaultValue(true)]\r\n        public bool CheckWriteAccess { get; set; } = true;\r\n    }\r\n    public partial class FolderBrowserDialog\r\n    {\r\n        [DefaultValue(true)]\r\n        public bool AddToRecent { get; set; } = true;\r\n\r\n        [DefaultValue(false)]\r\n        public bool ShowHiddenFiles { get; set; }\r\n\r\n        [DefaultValue(true)]\r\n        public bool ShowPinnedPlaces { get; set; } = true;\r\n\r\n        [DefaultValue(false)]\r\n        public bool OkRequiresInteraction { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:FileDialog.AddToRecent",
          "P:FileDialog.OkRequiresInteraction",
          "P:FileDialog.ShowHiddenFiles",
          "P:FileDialog.ShowPinnedPlaces",
          "P:FolderBrowserDialog.AddToRecent",
          "P:FolderBrowserDialog.OkRequiresInteraction",
          "P:FolderBrowserDialog.ShowHiddenFiles",
          "P:FolderBrowserDialog.ShowPinnedPlaces",
          "P:OpenFileDialog.SelectReadOnly",
          "P:OpenFileDialog.ShowPreview",
          "P:SaveFileDialog.CheckWriteAccess",
          "P:SaveFileDialog.ExpandedMode",
          "T:FileDialog",
          "T:FolderBrowserDialog",
          "T:OpenFileDialog",
          "T:SaveFileDialog"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59900,
          "Title": "System.DirectoryServices.Protocols.LdapFilter",
          "Author": "RoadTrain",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-02T19:58:28+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59900",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.DirectoryServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "needs-further-triage",
              "Color": "d2aa6d",
              "Description": "Issue has been initially triaged, but needs deeper consideration or reconsideration"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-23T00:00:00-08:00",
        "FeedbackId": "976996837",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59900#issuecomment-976996837",
        "FeedbackMarkdown": "* Do we need a new type? It seems more sensible to put it on an existing type.\r\n    - \u0060SearchRequest\u0060\r\n    - \u0060LdapConnection\u0060 / \u0060DirectoryConnection\u0060\r\n* Is this specific to filters? If not, should we remove the term \u0022Filter\u0022 from the method?\r\n* Do we need more a complex concept, such as builder-based approach?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.DirectoryServices.Protocols\r\n{\r\n    public static class LdapFilter\r\n    {\r\n        public static string EscapeFilterArgument(string filterArgument);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7960000000,
        "Apis": [
          "M:LdapFilter.EscapeFilterArgument(string)",
          "T:LdapFilter"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61135,
          "Title": "InlineArrayAttribute",
          "Author": "VSadov",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-03T00:09:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61135",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-23T00:00:00-08:00",
        "FeedbackId": "977018394",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61135#issuecomment-977018394",
        "FeedbackMarkdown": "* Makes sense as proposed\r\n* The assumptions are:\r\n    - Runtimes that don\u0027t support this layout must not expose this attribute, which is why we don\u0027t need a \u0060RuntimeFeature\u0060 field.\r\n    - The developer won\u0027t apply the attribute manually, but uses language syntax and the compiler will emit the attribute, hence \u0060System.Runtime.CompilerServices\u0060 is the appropriate home.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]\r\n    public sealed class InlineArrayAttribute : Attribute\r\n    {\r\n        public InlineArrayAttribute (int length);\r\n        public int Length { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20250000000,
        "Apis": [
          "M:InlineArrayAttribute.InlineArrayAttribute(int)",
          "P:InlineArrayAttribute.Length",
          "T:InlineArrayAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61885,
          "Title": "Update the runtime to have deterministic floating-point to integer conversions",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-21T02:15:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61885",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-23T00:00:00-08:00",
        "FeedbackId": "977069589",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61885#issuecomment-977069589",
        "FeedbackMarkdown": "* Without generic math/statics in interfaces, we\u0027d prefer a design where those methods live on a dedicated type\r\n* If we plan to expose them in generic math (and it seems we do), then it seems those need to exist on the primitive types; the only design choice we\u0027d have is to hide them there. This would mean that people using generic math will have one way to call these \u0022unsafe\u0022 methods while the people doing regular math/conversions have a different way of calling those.\r\n* We could also decide that we don\u0027t expose these \u0022unsafe\u0022 variants not on the generic interfaces and instead tell those developers to use regular type checks and invoke the corresponding methods on the dedicated type. However, for folks doing generic math this might stick out like a sore thumb.\r\n* It seems we\u0027d prefer a generic patten where we cut down the number of methods by passing in the output type:\r\n    \u0060\u0060\u0060C#\r\n    namespace System\r\n    {\r\n        public struct Double\r\n        {\r\n            public static TInteger ConvertToInteger\u003CTInteger\u003E(double value)\r\n                where TInteger: IBinaryInteger;\r\n            public static TInteger ConvertToIntegerNative\u003CTInteger\u003E(double value)\r\n                where TInteger: IBinaryInteger;\r\n        }\r\n    }\r\n    \u0060\u0060\u0060",
        "TimeCode": 30530000000,
        "Apis": [
          "M:Double.ConvertToInteger\u003CTInteger\u003E(double)",
          "M:Double.ConvertToIntegerNative\u003CTInteger\u003E(double)",
          "T:Double"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9fAW50_edfM",
      "StartDateTime": "2021-11-30T11:03:25-08:00",
      "EndDateTime": "2021-11-30T12:01:43-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9fAW50_edfM/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 60903,
          "Title": "DirectoryInfo.Copy / Directory.Copy",
          "Author": "Symbai",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-10-27T05:26:12+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/60903",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-30T00:00:00-08:00",
        "FeedbackId": "982958180",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/60903#issuecomment-982958180",
        "FeedbackMarkdown": "* We changed the 3 overloads to two with default parameters.\r\n* We added cancellation to the still-synchronous methods\r\n* We renamed some parameters\r\n* We added a boolean return value.  False indiciates that something couldn\u0027t be read (a file couldn\u0027t be read, or a directory couldn\u0027t be enumerated).  Write failures should throw.\r\n\r\n\u0060\u0060\u0060C#\r\n\r\nnamespace System.IO\r\n{\r\n    public partial class DirectoryInfo : FileSystemInfo\r\n    {\r\n        public bool CopyTo(string destinationPath, bool recursive);\r\n        public bool CopyTo(string destinationPath, bool recursive, bool skipExistingFiles=true, CancellationToken cancellationToken=default);\r\n    }\r\n    public partial class Directory\r\n    {\r\n        public static bool Copy(string sourcePath, string destinationPath, bool recursive);\r\n        public static bool Copy(string sourcePath, string destinationPath, bool recursive, bool skipExistingFiles=true, CancellationToken cancellationToken=default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Directory.Copy(string,string,bool,bool,CancellationToken)",
          "M:Directory.Copy(string,string,bool)",
          "M:DirectoryInfo.CopyTo(string,bool,bool,CancellationToken)",
          "M:DirectoryInfo.CopyTo(string,bool)",
          "T:Directory",
          "T:DirectoryInfo"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61122,
          "Title": "Analyzer: Replace occurrences of TypeInfo with Type and GetTypeInfo() with GetType()",
          "Author": "buyaa-n",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-02T21:00:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61122",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-30T00:00:00-08:00",
        "FeedbackId": "982968329",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61122#issuecomment-982968329",
        "FeedbackMarkdown": "* Generally looks good as proposed.\r\n* While a fixer may produce errors in a few edge cases, it seems generally valueable, so we should make one.\r\n* The analyzer should check the Type/TypeInfo hierarchy to not run when it\u0027s not appropriate (e.g. netstandard1.x).\r\n* It should not flag uses where any TypeInfo-specific members are used.\r\n\r\nCategory: Maintainability\r\nSeverity: Info",
        "TimeCode": 22210000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61916,
          "Title": "Port rule CA1011 - Consider passing base types as parameters",
          "Author": "Evangelink",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-22T13:30:47+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61916",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-Meta",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-11-30T00:00:00-08:00",
        "FeedbackId": "982973839",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61916#issuecomment-982973839",
        "FeedbackMarkdown": "* Generally looks good as proposed, but we changed Hidden to IdeSuggestion\r\n\r\nCategory: Design\r\nSeverity: IdeSuggestion",
        "TimeCode": 30290000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "9IzfKxXviIU",
      "StartDateTime": "2021-12-14T10:06:34-08:00",
      "EndDateTime": "2021-12-14T11:20:48-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/9IzfKxXviIU/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61675,
          "Title": "Add support for clearing ConfigurationManager sources (was possible in version 5)",
          "Author": "fredjeck",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-16T12:33:00+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61675",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-Extensions-Configuration",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993852244",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61675#issuecomment-993852244",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - Should we also expose \u0060IConfigurationBuilder.Properties\u0060? What happens if \u0060Properties\u0060 aren\u0027t cleared? Would there a benefit to add a \u0060Clear\u0060 method that clears both?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Configuration\r\n{\r\n    public partial sealed class ConfigurationManager\r\n    {\r\n        // Currently explicit:\r\n        // IList\u003CIConfigurationSource\u003E IConfigurationBuilder.Sources { get; }\r\n\r\n        // Now implicit:\r\n        public IList\u003CIConfigurationSource\u003E Sources { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "P:ConfigurationManager.Sources",
          "T:ConfigurationManager"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62505,
          "Title": "System.Diagnostics.CodeAnalysis.StringSyntaxAttribute",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-07T22:28:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62505",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993866275",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62505#issuecomment-993866275",
        "FeedbackMarkdown": "* We think we should rename \u0022language\u0022 to \u0022syntax\u0022 to avoid any connotations to localization\r\n* We should only expose the language constants as we\u0027re adding support for them\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.Parameter |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Property,\r\n                    AllowMultiple = false,\r\n                    Inherited = false)]\r\n    public sealed class StringSyntaxAttribute : Attribute\r\n    {\r\n        public StringSyntaxAttribute(string syntax);\r\n        public string Syntax { get; }\r\n\r\n        public const string Regex = \u0022regex\u0022;\r\n\r\n        // As we\u0027re adding more support we can add new languages like:\r\n        // public const string Xml = \u0022xml\u0022;\r\n        // public const string Json = \u0022json\u0022;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7080000000,
        "Apis": [
          "F:StringSyntaxAttribute.Regex",
          "M:StringSyntaxAttribute.StringSyntaxAttribute(string)",
          "P:StringSyntaxAttribute.Syntax",
          "T:StringSyntaxAttribute"
        ]
      },
      {
        "Decision": 2,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 33808,
          "Title": "Remove redundant configuration from [DllImport] declaration",
          "Author": "terrajobst",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-03-19T16:43:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/33808",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993877673",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/33808#issuecomment-993877673",
        "FeedbackMarkdown": "* We\u0027re not convinced that over-specification is a bad practice; these are expert-level APIs and many experts like being explicit instead of relying on defaults.\r\n* However, there is value in P/Invoke analyzers, which, could flag when people are calling Unicode APIs (*W) but specify ANSI encoding, for instance.\r\n* Let\u0027s close this one for now. If there are other suggestions, we can open new issues.",
        "TimeCode": 16820000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58765,
          "Title": "Add \u0060System.Reflection.Metadata.Ecma335.ControlFlowBuilder.Reset\u0060.",
          "Author": "teo-tsirpanis",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-07T19:37:46+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58765",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Reflection.Metadata",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993883006",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58765#issuecomment-993883006",
        "FeedbackMarkdown": "* Makes sense, but we\u0027d prefer the term \u0060Clear\u0060\r\n* CC @tmat \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection.Metadata.Ecma355\r\n{\r\n     public partial sealed class ControlFlowBuilder\r\n     {\r\n          public void Clear();\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25980000000,
        "Apis": [
          "M:ControlFlowBuilder.Clear()",
          "T:ControlFlowBuilder"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62057,
          "Title": "Collapse multiple \u0060Path.Combine\u0060 or \u0060Path.Join\u0060 in a row",
          "Author": "carlossanlop",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-25T17:50:59+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62057",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993892387",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62057#issuecomment-993892387",
        "FeedbackMarkdown": "* This makes sense.\r\n   - The category should be \u0022Performance\u0022\r\n   - Severity should be \u0022Info\u0022\r\n* We should special case using a single variable:\r\n    \u0060\u0060\u0060C#\r\n    string x = Path.Join(\u0022one\u0022, \u0022two\u0022);\r\n    x = Path.Join(x, \u0022three\u0022);\r\n    x = Path.Join(x, \u0022file.txt\u0022);\r\n    Console.WriteLine(x);\r\n    \u0060\u0060\u0060\r\n* Should this handle cases like this?\r\n    \u0060\u0060\u0060C#\r\n    _field = Path.Join(\u0022one\u0022, \u0022two\u0022);\r\n    _field = Path.Join(_field, \u0022three\u0022);\r\n    _field = Path.Join(_field, \u0022file.txt\u0022);\r\n    \u0060\u0060\u0060\r\n* Do we have other examples of this pattern?\r\n    - \u0060String.Concat\u0060",
        "TimeCode": 30310000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62401,
          "Title": "DrawRectangle should accept RectangleF as one of the overloads",
          "Author": "medo64",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-04T17:47:52+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62401",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Drawing",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2021-12-14T00:00:00-08:00",
        "FeedbackId": "993897880",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62401#issuecomment-993897880",
        "FeedbackMarkdown": "* Seems like a no-brainer\r\n    - Are there any other? Seems like \u0060FillPie\u0060 would be in the same category.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Drawing.Common\r\n{\r\n    public partial class Graphics\r\n    {\r\n        public void DrawRectangle(Pen pen, RectangleF rect);\r\n        public void FillPie(Brush brush, RectangleF rect, float startAngle, float sweepAngle);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 37440000000,
        "Apis": [
          "M:Graphics.DrawRectangle(Pen,RectangleF)",
          "M:Graphics.FillPie(Brush,RectangleF,float,float)",
          "T:Graphics"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "yz-tRVxVo-g",
      "StartDateTime": "2022-01-04T10:02:49-08:00",
      "EndDateTime": "2022-01-04T11:48:18-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/yz-tRVxVo-g/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63042,
          "Title": "Add public Architecture enum value for LoongArch64",
          "Author": "huoyaoyuan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-21T12:31:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63042",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005058539",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63042#issuecomment-1005058539",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We talked about adding an \u0060Unknown\u0060 member to \u0060Architecture\u0060 but decided against it; the implementation can still return a placeholder (e.g. \u0060-1\u0060).\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum Architecture\r\n    {\r\n        // Existing:\r\n        // X86\r\n        // X64\r\n        // Arm\r\n        // Arm64\r\n        // Wasm\r\n        // S390x\r\n        LoongArch64,\r\n    }\r\n}\r\nnamespace System.Reflection.PortableExecutable\r\n{\r\n    public enum Machine : ushort\r\n    {\r\n        // Existing:\r\n        // Alpha\r\n        // Alpha64\r\n        // AM33\r\n        // Amd64\r\n        // Arm\r\n        // Arm64\r\n        // ArmThumb2\r\n        // Ebc\r\n        // I386\r\n        // IA64\r\n        // M32R\r\n        // MIPS16\r\n        // MipsFpu\r\n        // MipsFpu16\r\n        // PowerPC\r\n        // PowerPCFP\r\n        // SH3\r\n        // SH3Dsp\r\n        // SH3E\r\n        // SH4\r\n        // SH5\r\n        // Thumb\r\n        // Tricore\r\n        // Unknown\r\n        // WceMipsV2\r\n        LoongArch32 = 0x6232,\r\n        LoongArch64 = 0x6264\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:Architecture.LoongArch64",
          "F:Machine.LoongArch32",
          "F:Machine.LoongArch64",
          "T:Architecture",
          "T:Machine"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63310,
          "Title": "Add architecture ARMv6 to Architecture enum",
          "Author": "directhex",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-03T20:57:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63310",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "api-suggestion",
              "Color": "1d76db",
              "Description": "Early API idea and discussion, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005060501",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63310#issuecomment-1005060501",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public enum Architecture\r\n    {\r\n        // Existing:\r\n        // X86\r\n        // X64\r\n        // Arm\r\n        // Arm64\r\n        // Wasm\r\n        // S390x\r\n        Armv6,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 8950000000,
        "Apis": [
          "F:Architecture.Armv6",
          "T:Architecture"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63331,
          "Title": "Additional cross-platform hardware intrinsic APIs for loading/storing, reordering, and extracting a per-element \u0022mask\u0022",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-04T07:01:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63331",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005073176",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63331#issuecomment-1005073176",
        "FeedbackMarkdown": "* Looks good as proposed but let\u0027s make \u0060ExtractMostSignificantBits\u0060 and \u0060StoreXxx\u0060 extension methods\r\n* We decided to keep the \u0060Shuffle\u0060 APIs as non-extensions because the two-argument shuffle would be potentially confusing and we didn\u0027t want a mix of extensions/non-extensions.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics\r\n{\r\n    public static partial class Vector64\r\n    {\r\n        public static uint ExtractMostSignificantBits\u003CT\u003E(this Vector64\u003CT\u003E vector);\r\n\r\n        public static Vector64\u003CT\u003E Load\u003CT\u003E(T* source);\r\n        public static Vector64\u003CT\u003E LoadAligned\u003CT\u003E(T* source);\r\n        public static Vector64\u003CT\u003E LoadAlignedNonTemporal\u003CT\u003E(T* source);\r\n        public static Vector64\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source);\r\n        public static Vector64\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source, nuint index);\r\n\r\n        public static void Store\u003CT\u003E(this Vector64\u003CT\u003E source, T* destination);\r\n        public static void StoreAligned\u003CT\u003E(this Vector64\u003CT\u003E source, T* destination);\r\n        public static void StoreAlignedNonTemporal\u003CT\u003E(this Vector64\u003CT\u003E source, T* destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector64\u003CT\u003E source, ref T destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector64\u003CT\u003E source, ref T destination, nuint index);\r\n\r\n        public static Vector64\u003Cbyte\u003E   Shuffle(Vector64\u003Cbyte\u003E   vector, Vector64\u003Cbyte\u003E   indices);\r\n        public static Vector64\u003Csbyte\u003E  Shuffle(Vector64\u003Csbyte\u003E  vector, Vector64\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector64\u003Cshort\u003E  Shuffle(Vector64\u003Cshort\u003E  vector, Vector64\u003Cshort\u003E  indices);\r\n        public static Vector64\u003Cushort\u003E Shuffle(Vector64\u003Cushort\u003E vector, Vector64\u003Cushort\u003E indices);\r\n\r\n        public static Vector64\u003Cint\u003E    Shuffle(Vector64\u003Cint\u003E    vector, Vector64\u003Cint\u003E    indices);\r\n        public static Vector64\u003Cuint\u003E   Shuffle(Vector64\u003Cuint\u003E   vector, Vector64\u003Cuint\u003E   indices);\r\n        public static Vector64\u003Cfloat\u003E  Shuffle(Vector64\u003Cfloat\u003E  vector, Vector64\u003Cint\u003E    indices);\r\n\r\n        public static Vector64\u003Cbyte\u003E   Shuffle(Vector64\u003Cbyte\u003E   lower, Vector64\u003Cbyte\u003E   upper, Vector64\u003Cbyte\u003E   indices);\r\n        public static Vector64\u003Csbyte\u003E  Shuffle(Vector64\u003Csbyte\u003E  lower, Vector64\u003Csbyte\u003E  upper, Vector64\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector64\u003Cshort\u003E  Shuffle(Vector64\u003Cshort\u003E  lower, Vector64\u003Cshort\u003E  upper, Vector64\u003Cshort\u003E  indices);\r\n        public static Vector64\u003Cushort\u003E Shuffle(Vector64\u003Cushort\u003E lower, Vector64\u003Cushort\u003E upper, Vector64\u003Cushort\u003E indices);\r\n\r\n        public static Vector64\u003Cint\u003E    Shuffle(Vector64\u003Cint\u003E    lower, Vector64\u003Cint\u003E    upper, Vector64\u003Cint\u003E    indices);\r\n        public static Vector64\u003Cuint\u003E   Shuffle(Vector64\u003Cuint\u003E   lower, Vector64\u003Cuint\u003E   upper, Vector64\u003Cuint\u003E   indices);\r\n        public static Vector64\u003Cfloat\u003E  Shuffle(Vector64\u003Cfloat\u003E  lower, Vector64\u003Cfloat\u003E  upper, Vector64\u003Cint\u003E    indices);\r\n    }\r\n\r\n    public static partial class Vector128\r\n    {\r\n        public static uint ExtractMostSignificantBits\u003CT\u003E(this Vector128\u003CT\u003E vector);\r\n\r\n        public static Vector128\u003CT\u003E Load\u003CT\u003E(T* source);\r\n        public static Vector128\u003CT\u003E LoadAligned\u003CT\u003E(T* source);\r\n        public static Vector128\u003CT\u003E LoadAlignedNonTemporal\u003CT\u003E(T* source);\r\n        public static Vector128\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source);\r\n        public static Vector128\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source, nuint index);\r\n\r\n        public static void Store\u003CT\u003E(this Vector128\u003CT\u003E source, T* destination);\r\n        public static void StoreAligned\u003CT\u003E(this Vector128\u003CT\u003E source, T* destination);\r\n        public static void StoreAlignedNonTemporal\u003CT\u003E(this Vector128\u003CT\u003E source, T* destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector128\u003CT\u003E source, ref T destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector128\u003CT\u003E source, ref T destination, nuint index);\r\n\r\n        public static Vector128\u003Cbyte\u003E   Shuffle(Vector128\u003Cbyte\u003E   vector, Vector128\u003Cbyte\u003E   indices);\r\n        public static Vector128\u003Csbyte\u003E  Shuffle(Vector128\u003Csbyte\u003E  vector, Vector128\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector128\u003Cshort\u003E  Shuffle(Vector128\u003Cshort\u003E  vector, Vector128\u003Cshort\u003E  indices);\r\n        public static Vector128\u003Cushort\u003E Shuffle(Vector128\u003Cushort\u003E vector, Vector128\u003Cushort\u003E indices);\r\n\r\n        public static Vector128\u003Cint\u003E    Shuffle(Vector128\u003Cint\u003E    vector, Vector128\u003Cint\u003E    indices);\r\n        public static Vector128\u003Cuint\u003E   Shuffle(Vector128\u003Cuint\u003E   vector, Vector128\u003Cuint\u003E   indices);\r\n        public static Vector128\u003Cfloat\u003E  Shuffle(Vector128\u003Cfloat\u003E  vector, Vector128\u003Cint\u003E    indices);\r\n\r\n        public static Vector128\u003Clong\u003E   Shuffle(Vector128\u003Clong\u003E   vector, Vector128\u003Clong\u003E   indices);\r\n        public static Vector128\u003Culong\u003E  Shuffle(Vector128\u003Culong\u003E  vector, Vector128\u003Culong\u003E  indices);\r\n        public static Vector128\u003Cdouble\u003E Shuffle(Vector128\u003Cdouble\u003E vector, Vector128\u003Clong\u003E   indices);\r\n\r\n        public static Vector128\u003Cbyte\u003E   Shuffle(Vector128\u003Cbyte\u003E   lower, Vector128\u003Cbyte\u003E   upper, Vector128\u003Cbyte\u003E   indices);\r\n        public static Vector128\u003Csbyte\u003E  Shuffle(Vector128\u003Csbyte\u003E  lower, Vector128\u003Csbyte\u003E  upper, Vector128\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector128\u003Cshort\u003E  Shuffle(Vector128\u003Cshort\u003E  lower, Vector128\u003Cshort\u003E  upper, Vector128\u003Cshort\u003E  indices);\r\n        public static Vector128\u003Cushort\u003E Shuffle(Vector128\u003Cushort\u003E lower, Vector128\u003Cushort\u003E upper, Vector128\u003Cushort\u003E indices);\r\n\r\n        public static Vector128\u003Cint\u003E    Shuffle(Vector128\u003Cint\u003E    lower, Vector128\u003Cint\u003E    upper, Vector128\u003Cint\u003E    indices);\r\n        public static Vector128\u003Cuint\u003E   Shuffle(Vector128\u003Cuint\u003E   lower, Vector128\u003Cuint\u003E   upper, Vector128\u003Cuint\u003E   indices);\r\n        public static Vector128\u003Cfloat\u003E  Shuffle(Vector128\u003Cfloat\u003E  lower, Vector128\u003Cfloat\u003E  upper, Vector128\u003Cint\u003E    indices);\r\n\r\n        public static Vector128\u003Clong\u003E   Shuffle(Vector128\u003Clong\u003E   lower, Vector128\u003Clong\u003E   upper, Vector128\u003Clong\u003E   indices);\r\n        public static Vector128\u003Culong\u003E  Shuffle(Vector128\u003Culong\u003E  lower, Vector128\u003Culong\u003E  upper, Vector128\u003Culong\u003E  indices);\r\n        public static Vector128\u003Cdouble\u003E Shuffle(Vector128\u003Cdouble\u003E lower, Vector128\u003Cdouble\u003E upper, Vector128\u003Clong\u003E   indices);\r\n    }\r\n\r\n    public static partial class Vector256\r\n    {\r\n        public static uint ExtractMostSignificantBits\u003CT\u003E(this Vector256\u003CT\u003E vector);\r\n\r\n        public static Vector256\u003CT\u003E Load\u003CT\u003E(T* source);\r\n        public static Vector256\u003CT\u003E LoadAligned\u003CT\u003E(T* source);\r\n        public static Vector256\u003CT\u003E LoadAlignedNonTemporal\u003CT\u003E(T* source);\r\n        public static Vector256\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source);\r\n        public static Vector256\u003CT\u003E LoadUnsafe\u003CT\u003E(ref T source, nuint index);\r\n\r\n        public static void Store\u003CT\u003E(this Vector256\u003CT\u003E source, T* destination);\r\n        public static void StoreAligned\u003CT\u003E(this Vector256\u003CT\u003E source, T* destination);\r\n        public static void StoreAlignedNonTemporal\u003CT\u003E(this Vector256\u003CT\u003E source, T* destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector256\u003CT\u003E source, ref T destination);\r\n        public static void StoreUnsafe\u003CT\u003E(this Vector256\u003CT\u003E source, ref T destination, nuint index);\r\n\r\n        public static Vector256\u003Cbyte\u003E   Shuffle(Vector256\u003Cbyte\u003E   vector, Vector256\u003Cbyte\u003E   indices);\r\n        public static Vector256\u003Csbyte\u003E  Shuffle(Vector256\u003Csbyte\u003E  vector, Vector256\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector256\u003Cshort\u003E  Shuffle(Vector256\u003Cshort\u003E  vector, Vector256\u003Cshort\u003E  indices);\r\n        public static Vector256\u003Cushort\u003E Shuffle(Vector256\u003Cushort\u003E vector, Vector256\u003Cushort\u003E indices);\r\n\r\n        public static Vector256\u003Cint\u003E    Shuffle(Vector256\u003Cint\u003E    vector, Vector256\u003Cint\u003E    indices);\r\n        public static Vector256\u003Cuint\u003E   Shuffle(Vector256\u003Cuint\u003E   vector, Vector256\u003Cuint\u003E   indices);\r\n        public static Vector256\u003Cfloat\u003E  Shuffle(Vector256\u003Cfloat\u003E  vector, Vector256\u003Cint\u003E    indices);\r\n\r\n        public static Vector256\u003Clong\u003E   Shuffle(Vector256\u003Clong\u003E   vector, Vector256\u003Clong\u003E   indices);\r\n        public static Vector256\u003Culong\u003E  Shuffle(Vector256\u003Culong\u003E  vector, Vector256\u003Culong\u003E  indices);\r\n        public static Vector256\u003Cdouble\u003E Shuffle(Vector256\u003Cdouble\u003E vector, Vector256\u003Clong\u003E   indices);\r\n\r\n        public static Vector256\u003Cbyte\u003E   Shuffle(Vector256\u003Cbyte\u003E   lower, Vector256\u003Cbyte\u003E   upper, Vector256\u003Cbyte\u003E   indices);\r\n        public static Vector256\u003Csbyte\u003E  Shuffle(Vector256\u003Csbyte\u003E  lower, Vector256\u003Csbyte\u003E  upper, Vector256\u003Csbyte\u003E  indices);\r\n\r\n        public static Vector256\u003Cshort\u003E  Shuffle(Vector256\u003Cshort\u003E  lower, Vector256\u003Cshort\u003E  upper, Vector256\u003Cshort\u003E  indices);\r\n        public static Vector256\u003Cushort\u003E Shuffle(Vector256\u003Cushort\u003E lower, Vector256\u003Cushort\u003E upper, Vector256\u003Cushort\u003E indices);\r\n\r\n        public static Vector256\u003Cint\u003E    Shuffle(Vector256\u003Cint\u003E    lower, Vector256\u003Cint\u003E    upper, Vector256\u003Cint\u003E    indices);\r\n        public static Vector256\u003Cuint\u003E   Shuffle(Vector256\u003Cuint\u003E   lower, Vector256\u003Cuint\u003E   upper, Vector256\u003Cuint\u003E   indices);\r\n        public static Vector256\u003Cfloat\u003E  Shuffle(Vector256\u003Cfloat\u003E  lower, Vector256\u003Cfloat\u003E  upper, Vector256\u003Cint\u003E    indices);\r\n\r\n        public static Vector256\u003Clong\u003E   Shuffle(Vector256\u003Clong\u003E   lower, Vector256\u003Clong\u003E   upper, Vector256\u003Clong\u003E   indices);\r\n        public static Vector256\u003Culong\u003E  Shuffle(Vector256\u003Culong\u003E  lower, Vector256\u003Culong\u003E  upper, Vector256\u003Culong\u003E  indices);\r\n        public static Vector256\u003Cdouble\u003E Shuffle(Vector256\u003Cdouble\u003E lower, Vector256\u003Cdouble\u003E upper, Vector256\u003Clong\u003E   indices);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 10480000000,
        "Apis": [
          "M:Vector128.ExtractMostSignificantBits\u003CT\u003E(this Vector128\u003CT\u003E)",
          "M:Vector128.Load\u003CT\u003E(T*)",
          "M:Vector128.LoadAligned\u003CT\u003E(T*)",
          "M:Vector128.LoadAlignedNonTemporal\u003CT\u003E(T*)",
          "M:Vector128.LoadUnsafe\u003CT\u003E(ref T,nuint)",
          "M:Vector128.LoadUnsafe\u003CT\u003E(ref T)",
          "M:Vector128.Shuffle(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cdouble\u003E,Vector128\u003Cdouble\u003E,Vector128\u003Clong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cdouble\u003E,Vector128\u003Clong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cfloat\u003E,Vector128\u003Cfloat\u003E,Vector128\u003Cint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cfloat\u003E,Vector128\u003Cint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cint\u003E,Vector128\u003Cint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Clong\u003E,Vector128\u003Clong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Csbyte\u003E,Vector128\u003Csbyte\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cshort\u003E,Vector128\u003Cshort\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cuint\u003E,Vector128\u003Cuint\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Culong\u003E,Vector128\u003Culong\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:Vector128.Shuffle(Vector128\u003Cushort\u003E,Vector128\u003Cushort\u003E)",
          "M:Vector128.Store\u003CT\u003E(this Vector128\u003CT\u003E,T*)",
          "M:Vector128.StoreAligned\u003CT\u003E(this Vector128\u003CT\u003E,T*)",
          "M:Vector128.StoreAlignedNonTemporal\u003CT\u003E(this Vector128\u003CT\u003E,T*)",
          "M:Vector128.StoreUnsafe\u003CT\u003E(this Vector128\u003CT\u003E,ref T,nuint)",
          "M:Vector128.StoreUnsafe\u003CT\u003E(this Vector128\u003CT\u003E,ref T)",
          "M:Vector256.ExtractMostSignificantBits\u003CT\u003E(this Vector256\u003CT\u003E)",
          "M:Vector256.Load\u003CT\u003E(T*)",
          "M:Vector256.LoadAligned\u003CT\u003E(T*)",
          "M:Vector256.LoadAlignedNonTemporal\u003CT\u003E(T*)",
          "M:Vector256.LoadUnsafe\u003CT\u003E(ref T,nuint)",
          "M:Vector256.LoadUnsafe\u003CT\u003E(ref T)",
          "M:Vector256.Shuffle(Vector256\u003Cbyte\u003E,Vector256\u003Cbyte\u003E,Vector256\u003Cbyte\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cbyte\u003E,Vector256\u003Cbyte\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cdouble\u003E,Vector256\u003Cdouble\u003E,Vector256\u003Clong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cdouble\u003E,Vector256\u003Clong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cfloat\u003E,Vector256\u003Cfloat\u003E,Vector256\u003Cint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cfloat\u003E,Vector256\u003Cint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cint\u003E,Vector256\u003Cint\u003E,Vector256\u003Cint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cint\u003E,Vector256\u003Cint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Clong\u003E,Vector256\u003Clong\u003E,Vector256\u003Clong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Clong\u003E,Vector256\u003Clong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Csbyte\u003E,Vector256\u003Csbyte\u003E,Vector256\u003Csbyte\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Csbyte\u003E,Vector256\u003Csbyte\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cshort\u003E,Vector256\u003Cshort\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cuint\u003E,Vector256\u003Cuint\u003E,Vector256\u003Cuint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cuint\u003E,Vector256\u003Cuint\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Culong\u003E,Vector256\u003Culong\u003E,Vector256\u003Culong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Culong\u003E,Vector256\u003Culong\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cushort\u003E,Vector256\u003Cushort\u003E,Vector256\u003Cushort\u003E)",
          "M:Vector256.Shuffle(Vector256\u003Cushort\u003E,Vector256\u003Cushort\u003E)",
          "M:Vector256.Store\u003CT\u003E(this Vector256\u003CT\u003E,T*)",
          "M:Vector256.StoreAligned\u003CT\u003E(this Vector256\u003CT\u003E,T*)",
          "M:Vector256.StoreAlignedNonTemporal\u003CT\u003E(this Vector256\u003CT\u003E,T*)",
          "M:Vector256.StoreUnsafe\u003CT\u003E(this Vector256\u003CT\u003E,ref T,nuint)",
          "M:Vector256.StoreUnsafe\u003CT\u003E(this Vector256\u003CT\u003E,ref T)",
          "M:Vector64.ExtractMostSignificantBits\u003CT\u003E(this Vector64\u003CT\u003E)",
          "M:Vector64.Load\u003CT\u003E(T*)",
          "M:Vector64.LoadAligned\u003CT\u003E(T*)",
          "M:Vector64.LoadAlignedNonTemporal\u003CT\u003E(T*)",
          "M:Vector64.LoadUnsafe\u003CT\u003E(ref T,nuint)",
          "M:Vector64.LoadUnsafe\u003CT\u003E(ref T)",
          "M:Vector64.Shuffle(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cbyte\u003E,Vector64\u003Cbyte\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cfloat\u003E,Vector64\u003Cfloat\u003E,Vector64\u003Cint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cfloat\u003E,Vector64\u003Cint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cint\u003E,Vector64\u003Cint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Csbyte\u003E,Vector64\u003Csbyte\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cshort\u003E,Vector64\u003Cshort\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cuint\u003E,Vector64\u003Cuint\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:Vector64.Shuffle(Vector64\u003Cushort\u003E,Vector64\u003Cushort\u003E)",
          "M:Vector64.Store\u003CT\u003E(this Vector64\u003CT\u003E,T*)",
          "M:Vector64.StoreAligned\u003CT\u003E(this Vector64\u003CT\u003E,T*)",
          "M:Vector64.StoreAlignedNonTemporal\u003CT\u003E(this Vector64\u003CT\u003E,T*)",
          "M:Vector64.StoreUnsafe\u003CT\u003E(this Vector64\u003CT\u003E,ref T,nuint)",
          "M:Vector64.StoreUnsafe\u003CT\u003E(this Vector64\u003CT\u003E,ref T)",
          "T:Vector128",
          "T:Vector256",
          "T:Vector64"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46626,
          "Title": "ThreadStatic on a non-static field",
          "Author": "svick",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-06T11:56:30+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46626",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Threading",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005078190",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46626#issuecomment-1005078190",
        "FeedbackMarkdown": "* Looks good as proposed by @stephentoub\r\n    - We should have a Warning level diagnostic for applying \u0060[ThreadStatic]\u0060 to instance fields. A fixer should offer to make it static, and potentially an option to switch it to be a \u0060ThreadLocal\u003CT\u003E\u0060, though that\u0027s more involved.\r\n    - We should have an Info level diagnostic for providing an initial value for a \u0060[ThreadStatic]\u0060 field.\r\n* Should be in the Reliability category",
        "TimeCode": 21320000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62489,
          "Title": "One shot hashing of \u0060Stream\u0060",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-07T16:00:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62489",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005091716",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62489#issuecomment-1005091716",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - The APIs returning \u0060byte[]\u0060 should have overloads that also accept \u0060byte[]\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Security.Cryptography\r\n{\r\n    public abstract partial class MD5\r\n    {\r\n        public static byte[] HashData(Stream source);\r\n        public static int HashData(Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class SHA1\r\n    {\r\n        public static byte[] HashData(Stream source);\r\n        public static int HashData(Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class SHA256\r\n    {\r\n        public static byte[] HashData(Stream source);\r\n        public static int HashData(Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class SHA384\r\n    {\r\n        public static byte[] HashData(Stream source);\r\n        public static int HashData(Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class SHA512\r\n    {\r\n        public static byte[] HashData(Stream source);\r\n        public static int HashData(Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class HMACMD5\r\n    {\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source);\r\n        public static byte[] HashData(byte[] key, Stream source);\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class HMACSHA1\r\n    {\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source);\r\n        public static byte[] HashData(byte[] key, Stream source);\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class HMACSHA256\r\n    {\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source);\r\n        public static byte[] HashData(byte[] key, Stream source);\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class HMACSHA384\r\n    {\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source);\r\n        public static byte[] HashData(byte[] key, Stream source);\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n    public abstract partial class HMACSHA512\r\n    {\r\n        public static byte[] HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source);\r\n        public static byte[] HashData(byte[] key, Stream source);\r\n        public static int HashData(ReadOnlySpan\u003Cbyte\u003E key, Stream source, Span\u003Cbyte\u003E destination);\r\n\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cbyte[]\u003E HashDataAsync(byte[] key, Stream source, CancellationToken cancellationToken = default);\r\n        public static ValueTask\u003Cint\u003E HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E key, Stream source, Memory\u003Cbyte\u003E destination, CancellationToken cancellationToken = default);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 25660000000,
        "Apis": [
          "M:HMACMD5.HashData(byte[],Stream)",
          "M:HMACMD5.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream,Span\u003Cbyte\u003E)",
          "M:HMACMD5.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream)",
          "M:HMACMD5.HashDataAsync(byte[],Stream,CancellationToken)",
          "M:HMACMD5.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,CancellationToken)",
          "M:HMACMD5.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:HMACSHA1.HashData(byte[],Stream)",
          "M:HMACSHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream,Span\u003Cbyte\u003E)",
          "M:HMACSHA1.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream)",
          "M:HMACSHA1.HashDataAsync(byte[],Stream,CancellationToken)",
          "M:HMACSHA1.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,CancellationToken)",
          "M:HMACSHA1.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:HMACSHA256.HashData(byte[],Stream)",
          "M:HMACSHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream,Span\u003Cbyte\u003E)",
          "M:HMACSHA256.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream)",
          "M:HMACSHA256.HashDataAsync(byte[],Stream,CancellationToken)",
          "M:HMACSHA256.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,CancellationToken)",
          "M:HMACSHA256.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:HMACSHA384.HashData(byte[],Stream)",
          "M:HMACSHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream,Span\u003Cbyte\u003E)",
          "M:HMACSHA384.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream)",
          "M:HMACSHA384.HashDataAsync(byte[],Stream,CancellationToken)",
          "M:HMACSHA384.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,CancellationToken)",
          "M:HMACSHA384.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:HMACSHA512.HashData(byte[],Stream)",
          "M:HMACSHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream,Span\u003Cbyte\u003E)",
          "M:HMACSHA512.HashData(ReadOnlySpan\u003Cbyte\u003E,Stream)",
          "M:HMACSHA512.HashDataAsync(byte[],Stream,CancellationToken)",
          "M:HMACSHA512.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,CancellationToken)",
          "M:HMACSHA512.HashDataAsync(ReadOnlyMemory\u003Cbyte\u003E,Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:MD5.HashData(Stream,Span\u003Cbyte\u003E)",
          "M:MD5.HashData(Stream)",
          "M:MD5.HashDataAsync(Stream,CancellationToken)",
          "M:MD5.HashDataAsync(Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:SHA1.HashData(Stream,Span\u003Cbyte\u003E)",
          "M:SHA1.HashData(Stream)",
          "M:SHA1.HashDataAsync(Stream,CancellationToken)",
          "M:SHA1.HashDataAsync(Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:SHA256.HashData(Stream,Span\u003Cbyte\u003E)",
          "M:SHA256.HashData(Stream)",
          "M:SHA256.HashDataAsync(Stream,CancellationToken)",
          "M:SHA256.HashDataAsync(Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:SHA384.HashData(Stream,Span\u003Cbyte\u003E)",
          "M:SHA384.HashData(Stream)",
          "M:SHA384.HashDataAsync(Stream,CancellationToken)",
          "M:SHA384.HashDataAsync(Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "M:SHA512.HashData(Stream,Span\u003Cbyte\u003E)",
          "M:SHA512.HashData(Stream)",
          "M:SHA512.HashDataAsync(Stream,CancellationToken)",
          "M:SHA512.HashDataAsync(Stream,Memory\u003Cbyte\u003E,CancellationToken)",
          "T:HMACMD5",
          "T:HMACSHA1",
          "T:HMACSHA256",
          "T:HMACSHA384",
          "T:HMACSHA512",
          "T:MD5",
          "T:SHA1",
          "T:SHA256",
          "T:SHA384",
          "T:SHA512"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62628,
          "Title": "ArgumentException.ThrowIfNullOrEmpty(string)",
          "Author": "datvm",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-10T10:22:14+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62628",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005102641",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62628#issuecomment-1005102641",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - Might be good to do a pass what \u0060ArgumentOutOfRangeException\u0060 cases we use internally. We could base it off the unique resource strings we use in corlib.\r\n* The API should\r\n    - Throw \u0060ArgumentNullException\u0060 if \u0060argument\u0060 is \u0060null\u0060, otherwise \u0060ArgumentException\u0060\r\n* We don\u0027t believe we need an overload of \u0060ThrowIfNullOrEmpty\u0060 for collections as this feels rare.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class ArgumentException\r\n    {\r\n        public static void ThrowIfNullOrEmpty([NotNull] string? argument,\r\n                                              [CallerArgumentExpression(\u0022argument\u0022)] string? paramName = null);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40720000000,
        "Apis": [
          "M:ArgumentException.ThrowIfNullOrEmpty(string?,string?)",
          "T:ArgumentException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62944,
          "Title": "RuntimeHandles should implement IEquatable",
          "Author": "MichalStrehovsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-17T05:50:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62944",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005108471",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62944#issuecomment-1005108471",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should do a pass and find all structs that provide a custom \u0060Equals\u0060 method without implementing \u0060IEquatable\u003CT\u003E\u0060\r\n* This should probably be an analyzer\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public struct RuntimeTypeHandle : IEquatable\u003CRuntimeTypeHandle\u003E\r\n    {\r\n        // bool Equals(RuntimeTypeHandle) already exists\r\n    }\r\n\r\n    public struct RuntimeMethodHandle : IEquatable\u003CRuntimeMethodHandle\u003E\r\n    {\r\n        // bool Equals(RuntimeMethodHandle) already exists\r\n    }\r\n\r\n    public struct RuntimeFieldHandle : IEquatable\u003CRuntimeFieldHandle\u003E\r\n    {\r\n        // bool Equals(RuntimeFieldHandle) already exists\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46630000000,
        "Apis": [
          "T:RuntimeFieldHandle",
          "T:RuntimeMethodHandle",
          "T:RuntimeTypeHandle"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 62949,
          "Title": "Make \u0060Lookup\u003CTKey,TElement\u003E\u0060 publicly constructable",
          "Author": "ajcvickers",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-17T11:37:37+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/62949",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "needs-author-action",
              "Color": "eb6420",
              "Description": "An issue or pull request that requires more info or actions from the author."
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-04T00:00:00-08:00",
        "FeedbackId": "1005120322",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/62949#issuecomment-1005120322",
        "FeedbackMarkdown": "* Looks good as proposed\r\n    - We want to avoid adding conflicts with RX/IX so we don\u0027t to create extension methods like \u0060ToLookupAsync()\u0060\r\n    - At the same time we don\u0027t want to make \u0060Lookup\u003CTKey, TElement\u003E\u0060 mutable\r\n    - This means we\u0027d need a single entry point that takes an \u0060IAsyncEnumerable\u003CTSource\u003E\u0060 and produces a \u0060Lookup\u003CTKey, TElement\u003E\u0060\r\n    - Easiest seems to be factory method directly on \u0060Lookup\u003CTKey, TElement\u003E\u0060\r\n* Alternatively, EF could return a custom implementation of \u0060ILookup\u003CTKey, TElement\u003E\u0060, similar to PLinq\r\n    - Sounds like we want to explore this first\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Linq\r\n{\r\n    public partial class Lookup\u003CTKey, TElement\u003E\r\n    {\r\n        public static Task\u003CLookup\u003CTKey, TElement\u003E\u003E CreateAsync\u003CTSource\u003E(\r\n            IAsyncEnumerable\u003CTSource\u003E source,\r\n            Func\u003CTSource, TKey\u003E keySelector,\r\n            Func\u003CTSource, TElement\u003E elementSelector,\r\n            IEqualityComparer\u003CTKey\u003E comparer);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 51310000000,
        "Apis": [
          "M:Lookup\u003CTKey, TElement\u003E.CreateAsync\u003CTSource\u003E(IAsyncEnumerable\u003CTSource\u003E,Func\u003CTSource, TKey\u003E,Func\u003CTSource, TElement\u003E,IEqualityComparer\u003CTKey\u003E)",
          "T:Lookup\u003CTKey, TElement\u003E"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "zBGTrbH8sAk",
      "StartDateTime": "2022-01-11T10:06:13-08:00",
      "EndDateTime": "2022-01-11T11:35:53-08:00",
      "Title": "Github Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/zBGTrbH8sAk/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 42575,
          "Title": "ActivityContext.TryParse should support IsRemote",
          "Author": "cg110",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-09-22T10:58:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/42575",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-11T00:00:00-08:00",
        "FeedbackId": "1010229716",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/42575#issuecomment-1010229716",
        "FeedbackMarkdown": "Looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public readonly partial struct ActivityContext\r\n    {\r\n        // existing\r\n        // public static bool TryParse(string? traceParent, string? traceState, out System.Diagnostics.ActivityContext context);\r\n\r\n        // new\r\n        public static bool TryParse(\r\n            string? traceParent,\r\n            string? traceState,\r\n            bool isRemote,\r\n            out System.Diagnostics.ActivityContext context);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:ActivityContext.TryParse(string?,string?,bool,out System.Diagnostics.ActivityContext)",
          "T:ActivityContext"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63353,
          "Title": "Activity.IsStopped  (functionality required to conform to OpenTelemetry specification)",
          "Author": "Oberon00",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-04T18:43:44+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63353",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-11T00:00:00-08:00",
        "FeedbackId": "1010232959",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63353#issuecomment-1010232959",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Activity\r\n    {\r\n        public bool IsStopped { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 3230000000,
        "Apis": [
          "P:Activity.IsStopped",
          "T:Activity"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 36753,
          "Title": "PathAssemblyResolver System.Reflection.MetadataLoadContext should be sealed or allow overrides",
          "Author": "DevDrake",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-05-20T11:49:49+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/36753",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-needs-work",
              "Color": "207de5",
              "Description": "API needs work before it is approved, it is NOT ready for implementation"
            },
            {
              "Name": "area-System.Reflection",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-11T00:00:00-08:00",
        "FeedbackId": "1010237884",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/36753#issuecomment-1010237884",
        "FeedbackMarkdown": "For the primary proposal: we (generally) don\u0027t expose fields as public or protected.\r\n\r\nFor the alternative proposal: we feel that simply exposing the field via a property is still too little abstraction and too limiting on the type.  Instead, determine what the use cases are for the extensibility and add protected members to provide that functionality without limiting the implementation details (for example, and add method / remove method / indexer)",
        "TimeCode": 5310000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63381,
          "Title": "Analyzer for detecting multiple Enumerations",
          "Author": "Cosifne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-05T01:11:15+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63381",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Linq",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-11T00:00:00-08:00",
        "FeedbackId": "1010272987",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63381#issuecomment-1010272987",
        "FeedbackMarkdown": "* The consensus seems to be that the analyzer has value\r\n* There was one \u0022vote\u0022 for changing the category to Reliability, but the consensus was to leave it at Performance\r\n* There\u0027s no strong opinion on servicing it into the .NET 6 SDK or merely adding it to the next version of the NuGet package\r\n* This analyzer needs a lot of comprehensive documentation, demonstrating various ways that \u0060i.ElementAt(10); i.ElementAt(100);\u0060 could be re-written (\u0060ToList()\u0060 is not always a winning move)\r\n* The initial version should use the hard-coded list plus extensibility via editorconfig\r\n  * \u0022Assume iterating\u0022 vs \u0022assume non-iterating\u0022 needs more data.",
        "TimeCode": 8760000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63130,
          "Title": "Make digest size constants public",
          "Author": "vcsjones",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-12-25T02:08:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63130",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Security",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-11T00:00:00-08:00",
        "FeedbackId": "1010279732",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63130#issuecomment-1010279732",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Security.Cryptography\r\n{\r\n     public class HMACMD5 : HMAC\r\n     {\r\n-        private const int HmacSizeBits = 128;\r\n-        private const int HmacSizeBytes = HmacSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 128;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public class HMACSHA1 : HMAC\r\n     {\r\n-        private const int HmacSizeBits = 160;\r\n-        private const int HmacSizeBytes = HmacSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 160;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public class HMACSHA256 : HMAC\r\n     {\r\n-        private const int HmacSizeBits = 256;\r\n-        private const int HmacSizeBytes = HmacSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 256;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public class HMACSHA384 : HMAC\r\n     {\r\n-        private const int HmacSizeBits = 384;\r\n-        private const int HmacSizeBytes = HmacSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 384;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public class HMACSHA512 : HMAC\r\n     {\r\n-        private const int HmacSizeBits = 512;\r\n-        private const int HmacSizeBytes = HmacSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 512;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public abstract class MD5 : HashAlgorithm\r\n     {\r\n-        private const int HashSizeBits = 128;\r\n-        private const int HashSizeBytes = HashSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 128;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public abstract class SHA1 : HashAlgorithm\r\n     {\r\n-        private const int HashSizeBits = 160;\r\n-        private const int HashSizeBytes = HashSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 160;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public abstract class SHA256 : HashAlgorithm\r\n     {\r\n-        private const int HashSizeBits = 256;\r\n-        private const int HashSizeBytes = HashSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 256;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public abstract class SHA384 : HashAlgorithm\r\n     {\r\n-        private const int HashSizeBits = 384;\r\n-        private const int HashSizeBytes = HashSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 384;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n\r\n     public abstract class SHA512 : HashAlgorithm\r\n     {\r\n-        private const int HashSizeBits = 512;\r\n-        private const int HashSizeBytes = HashSizeBits / 8;\r\n\u002B        public const int HashSizeInBits = 512;\r\n\u002B        public const int HashSizeInBytes = HashSizeInBits / 8;\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 35630000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "I9gitKnAn7c",
      "StartDateTime": "2022-01-18T10:07:23-08:00",
      "EndDateTime": "2022-01-18T11:25:23-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/I9gitKnAn7c/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 35324,
          "Title": "UnreachableException",
          "Author": "carlreinke",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-04-23T02:50:04+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/35324",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015687417",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/35324#issuecomment-1015687417",
        "FeedbackMarkdown": "We seem to have hit the most agreeable (perhaps \u0022least disagreeable\u0022) position with System.Diagnostics, on the basis that it\u0027s rather like an assert (\u0060System.Diagnostics.Debug.Assert\u0060); and based on @jkotas feedback, the exception isn\u0027t really special... so \u0060: Exception\u0060 instead of \u0060: SystemException\u0060.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public sealed class UnreachableException : Exception\r\n    {\r\n        public UnreachableException()\r\n            : base(\u0022The program executed an instruction that was thought to be unreachable.\u0022)\r\n        {\r\n        }\r\n\r\n        public UnreachableException(string? message)\r\n            : base(message)\r\n        {\r\n        }\r\n\r\n        public UnreachableException(string? message, Exception? innerException)\r\n            : base(message, innerException)\r\n        {\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:UnreachableException.UnreachableException()",
          "M:UnreachableException.UnreachableException(string?,Exception?)",
          "M:UnreachableException.UnreachableException(string?)",
          "T:UnreachableException"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63801,
          "Title": "Extend \u0060System.Runtime.InteropServices.NFloat\u0060 so it can replace the Xamarin in-box \u0060nfloat\u0060 for .NET 7",
          "Author": "tannergooding",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-14T16:36:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63801",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015702196",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63801#issuecomment-1015702196",
        "FeedbackMarkdown": "Unless there\u0027s a very strong need for IConvertable, we should leave that out.  Otherwise, looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices;\r\n\r\npublic readonly struct NFloat\r\n    : IComparable,\r\n      IComparable\u003CNFloat\u003E,\r\n      IEquatable\u003CNFloat\u003E,   // Already exposed by 13788\r\n      IFormattable\r\n{\r\n    // Xamarin exposes these as \u0060static readonly\u0060 but that is \u0022less optimizable\u0022 and not our normal convention\r\n    public static NFloat Epsilon { get; }\r\n    public static NFloat MaxValue { get; }\r\n    public static NFloat MinValue { get; }\r\n    public static NFloat NaN { get; }\r\n    public static NFloat NegativeInfinity { get; }\r\n    public static NFloat PositiveInfinity { get; }\r\n    public static NFloat Size { get; }\r\n\r\n    public static bool IsInfinity(NFloat value);\r\n    public static bool IsNaN(NFloat value);\r\n    public static bool IsNegativeInfinity(NFloat value);\r\n    public static bool IsPositiveInfinity(NFloat value);\r\n\r\n    // Parsing APIs, would match IParseable\u003CNFloat\u003E and IBinaryFloatingPoint\u003CNFloat\u003E if exposed\r\n    public static NFloat Parse(string s);\r\n    public static NFloat Parse(string s, NumberStyles style);\r\n    public static NFloat Parse(string s, IFormatProvider? provider);\r\n    public static NFloat Parse(string s, NumberStyles style, IFormatProvider? provider);\r\n    public static bool TryParse([NotNullWhen(true)] string? s, out NFloat result);\r\n    public static bool TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, out NFloat result);\r\n\r\n    // Arithmetic Operators\r\n    public static NFloat operator \u002B(NFloat left, NFloat right);\r\n    public static NFloat operator --(NFloat value);\r\n    public static NFloat operator /(NFloat left, NFloat right);\r\n    public static NFloat operator \u002B\u002B(NFloat value);\r\n    public static NFloat operator %(NFloat left, NFloat right);\r\n    public static NFloat operator *(NFloat left, NFloat right);\r\n    public static NFloat operator -(NFloat left, NFloat right);\r\n    public static NFloat operator \u002B(NFloat value);\r\n    public static NFloat operator -(NFloat value);\r\n\r\n    // Comparison Operators\r\n    public static bool operator ==(NFloat left, NFloat right);\r\n    public static bool operator \u003E(NFloat left, NFloat right);\r\n    public static bool operator \u003E=(NFloat left, NFloat right);\r\n    public static bool operator !=(NFloat left, NFloat right);\r\n    public static bool operator \u003C(NFloat left, NFloat right);\r\n    public static bool operator \u003C=(NFloat left, NFloat right);\r\n\r\n    // Explicit * to NFloat conversions\r\n    public static explicit operator NFloat(decimal value);\r\n    public static explicit operator NFloat(double value);\r\n    public static explicit operator NFloat(nint value);     // Explicit is inconsistent with int and long\r\n    public static explicit operator NFloat(nuint value);    // Explicit is inconsistent with uint and ulong, Xamarin is missing this one\r\n\r\n    // Explicit NFloat to * conversions\r\n    public static explicit operator byte(NFloat value);\r\n    public static explicit operator char(NFloat value);\r\n    public static explicit operator decimal(NFloat value);\r\n    public static explicit operator short(NFloat value);\r\n    public static explicit operator int(NFloat value);\r\n    public static explicit operator long(NFloat value);\r\n    public static explicit operator nint(NFloat value);\r\n    public static explicit operator sbyte(NFloat value);\r\n    public static explicit operator float(NFloat value);\r\n    public static explicit operator ushort(NFloat value);\r\n    public static explicit operator uint(NFloat value);\r\n    public static explicit operator ulong(NFloat value);\r\n    public static explicit operator nuint(NFloat value);   // Xamarin is missing this one\r\n\r\n    // Implicit * to NFloat conversions\r\n    public static implicit operator NFloat(byte value);\r\n    public static implicit operator NFloat(char value);\r\n    public static implicit operator NFloat(short value);\r\n    public static implicit operator NFloat(int value);\r\n    public static implicit operator NFloat(long value);\r\n    public static implicit operator NFloat(sbyte value);\r\n    public static implicit operator NFloat(float value);\r\n    public static implicit operator NFloat(ushort value);\r\n    public static implicit operator NFloat(uint value);\r\n    public static implicit operator NFloat(ulong value);\r\n\r\n    // Implicit NFloat to * conversions\r\n    public static implicit operator double(NFloat value);\r\n\r\n    // From IComparable and IComparable\u003CNFloat\u003E\r\n    public bool CompareTo(NFloat other);\r\n    public bool CompareTo(object other);\r\n\r\n    // From object and IEquatable\u003CNFloat\u003E, already exposed\r\n    public bool Equals(NFloat other);\r\n    public bool Equals(object other);\r\n\r\n    // From object and IFormattable\r\n    public string ToString();\r\n    public string ToString(IFormatProvider? provider);\r\n    public string ToString(string? format);\r\n    public string ToString(string? format, IFormatProvider? provider);\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 7810000000,
        "Apis": [
          "M:NFloat.--(NFloat)",
          "M:NFloat.-(NFloat,NFloat)",
          "M:NFloat.-(NFloat)",
          "M:NFloat.!=(NFloat,NFloat)",
          "M:NFloat.*(NFloat,NFloat)",
          "M:NFloat./(NFloat,NFloat)",
          "M:NFloat.%(NFloat,NFloat)",
          "M:NFloat.\u002B(NFloat,NFloat)",
          "M:NFloat.\u002B(NFloat)",
          "M:NFloat.\u002B\u002B(NFloat)",
          "M:NFloat.\u003C(NFloat,NFloat)",
          "M:NFloat.\u003C=(NFloat,NFloat)",
          "M:NFloat.==(NFloat,NFloat)",
          "M:NFloat.\u003E(NFloat,NFloat)",
          "M:NFloat.\u003E=(NFloat,NFloat)",
          "M:NFloat.CompareTo(NFloat)",
          "M:NFloat.CompareTo(object)",
          "M:NFloat.Equals(NFloat)",
          "M:NFloat.Equals(object)",
          "M:NFloat.explicit(decimal)",
          "M:NFloat.explicit(double)",
          "M:NFloat.explicit(NFloat)",
          "M:NFloat.explicit(nint)",
          "M:NFloat.explicit(nuint)",
          "M:NFloat.implicit(byte)",
          "M:NFloat.implicit(char)",
          "M:NFloat.implicit(float)",
          "M:NFloat.implicit(int)",
          "M:NFloat.implicit(long)",
          "M:NFloat.implicit(NFloat)",
          "M:NFloat.implicit(sbyte)",
          "M:NFloat.implicit(short)",
          "M:NFloat.implicit(uint)",
          "M:NFloat.implicit(ulong)",
          "M:NFloat.implicit(ushort)",
          "M:NFloat.IsInfinity(NFloat)",
          "M:NFloat.IsNaN(NFloat)",
          "M:NFloat.IsNegativeInfinity(NFloat)",
          "M:NFloat.IsPositiveInfinity(NFloat)",
          "M:NFloat.Parse(string,IFormatProvider?)",
          "M:NFloat.Parse(string,NumberStyles,IFormatProvider?)",
          "M:NFloat.Parse(string,NumberStyles)",
          "M:NFloat.Parse(string)",
          "M:NFloat.ToString()",
          "M:NFloat.ToString(IFormatProvider?)",
          "M:NFloat.ToString(string?,IFormatProvider?)",
          "M:NFloat.ToString(string?)",
          "M:NFloat.TryParse(string?,NumberStyles,IFormatProvider?,out NFloat)",
          "M:NFloat.TryParse(string?,out NFloat)",
          "P:NFloat.Epsilon",
          "P:NFloat.MaxValue",
          "P:NFloat.MinValue",
          "P:NFloat.NaN",
          "P:NFloat.NegativeInfinity",
          "P:NFloat.PositiveInfinity",
          "P:NFloat.Size",
          "T:NFloat"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 20824,
          "Title": "Add CancellationToken to StreamReader.Read* methods",
          "Author": "ChadNedzlek",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-03-29T21:25:25+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/20824",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015726336",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/20824#issuecomment-1015726336",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public partial class TextReader\r\n    {\r\n        public virtual ValueTask\u003Cstring?\u003E ReadLineAsync(CancellationToken cancellationToken) =\u003E throw null;\r\n        public virtual Task\u003Cstring\u003E ReadToEndAsync(CancellationToken cancellationToken) =\u003E throw null;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 18990000000,
        "Apis": [
          "M:TextReader.ReadLineAsync(CancellationToken)",
          "M:TextReader.ReadToEndAsync(CancellationToken)",
          "T:TextReader"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 58376,
          "Title": "Introduce RandomAccess.SetLength(SafeFileHandle handle) method",
          "Author": "adamsitnik",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-30T16:10:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/58376",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015728073",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/58376#issuecomment-1015728073",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public partial static class RandomAccess\r\n    {\r\n        public static void SetLength(SafeFileHandle handle, long length);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 29100000000,
        "Apis": [
          "M:RandomAccess.SetLength(SafeFileHandle,long)",
          "T:RandomAccess"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63687,
          "Title": "Add IEquatable\u003CT\u003E to public Equals-overriding value types to enable CA1066/1067",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-12T16:44:51+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63687",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015741152",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63687#issuecomment-1015741152",
        "FeedbackMarkdown": "Looks good as proposed.  (Declare on the duck-typeable ones, provide the implementation on the semantic-providing ones, fix AdjustmentRule, and suppress on the three outliers)",
        "TimeCode": 30520000000,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 256,
          "Title": "Support for Intel SHA extensions",
          "Author": "Thealexbarney",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2019-11-25T23:56:11+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/256",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "arch-x64",
              "Color": "eb6420",
              "Description": null
            },
            {
              "Name": "area-System.Runtime.Intrinsics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-18T00:00:00-08:00",
        "FeedbackId": "1015752414",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/256#issuecomment-1015752414",
        "FeedbackMarkdown": "Generally looks good as proposed.\r\n\r\nParameter names and the \u0060*Rounds\u0060 method names were aligned with the previously approved version.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.Intrinsics.X86\r\n{\r\n    public abstract class Sha : X86Base\r\n    {\r\n       public static bool IsSupported { get; }\r\n\r\n       public static class X64 : X86Base.X64 // unless it\u0027s SSE(2).\r\n       {\r\n           public static bool IsSupported { get; }\r\n       }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha1msg1_epu32 (__m128i a, __m128i b)\r\n        /// SHA1MSG1 xmm, xmm/m128\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha1MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b) =\u003E MessageSchedule1(a, b);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha1msg2_epu32 (__m128i a, __m128i b)\r\n        /// SHA1MSG2 xmm, xmm/m128\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha1MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b) =\u003E MessageSchedule2(a, b);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha1nexte_epu32 (__m128i a, __m128i b)\r\n        /// SHA1NEXTE xmm, xmm/m128\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha1NextE(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b) =\u003E NextE(a, b);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha1rnds4_epu32 (__m128i a, __m128i b, const int func)\r\n        /// SHA1RNDS4 xmm, xmm/m128, imm8\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha1FourRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, byte func) =\u003E Rounds(state1, state2, func);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha256msg1_epu32 (__m128i a, __m128i b)\r\n        /// SHA256MSG1 xmm, xmm/m128\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha256MessageSchedule1(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b) =\u003E MessageSchedule1(a, b);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha256msg2_epu32 (__m128i a, __m128i b)\r\n        /// SHA256MSG2 xmm, xmm/m128\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha256MessageSchedule2(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b) =\u003E MessageSchedule2(a, b);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// __m128i _mm_sha256rnds2_epu32 (__m128i a, __m128i b, __m128i k)\r\n        /// SHA256RNDS2 xmm, xmm/m128, \u0026lt;XMM0\u0026gt;\r\n        /// \u003C/summary\u003E\r\n        public static Vector128\u003Cbyte\u003E Sha256TwoRounds(Vector128\u003Cbyte\u003E a, Vector128\u003Cbyte\u003E b, Vector128\u003Cbyte\u003E k) =\u003E Rounds(state1, state2, message);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 40880000000,
        "Apis": [
          "M:Sha.Sha1FourRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,byte)",
          "M:Sha.Sha1MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha.Sha1MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha.Sha1NextE(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha.Sha256MessageSchedule1(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha.Sha256MessageSchedule2(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "M:Sha.Sha256TwoRounds(Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E,Vector128\u003Cbyte\u003E)",
          "P:Sha.IsSupported",
          "P:Sha.X64.IsSupported",
          "T:Sha",
          "T:Sha.X64"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "2rlbyoSZF3k",
      "StartDateTime": "2022-01-25T10:02:54-08:00",
      "EndDateTime": "2022-01-25T11:53:16-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/2rlbyoSZF3k/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 64165,
          "Title": "Add \u0060ref\u0060 field feature support to \u0060RuntimeFeature\u0060 class",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-23T15:46:07+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/64165",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021471976",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/64165#issuecomment-1021471976",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should make sure that other runtimes, such as Unity, that features listed in the \u0060RuntimeFeature\u0060 are required\r\n    - Practically, if another runtime pulls in our library code they will likely find out, given that we usually use those features\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    public static partial class RuntimeFeature\r\n    {\r\n        public const string ByRefFields = nameof(ByRefFields);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:RuntimeFeature.ByRefFields",
          "T:RuntimeFeature"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61425,
          "Title": "Regex.Count",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-10T17:31:35+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61425",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021481038",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61425#issuecomment-1021481038",
        "FeedbackMarkdown": "* Looks good as proposed\r\n* We should consider adding an analyzer the looks for code that does \u0060Regex.Count(...) \u003E 0\u0060 and suggests \u0060Regex.IsMatch(...)\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    public partial class Regex\r\n    {\r\n        public int Count(string input);\r\n        public static int Count(string input, string pattern);\r\n        public static int Count(string input, string pattern, RegexOptions options);\r\n        public static int Count(string input, string pattern, RegexOptions options, TimeSpan matchTimeout);\r\n\r\n        // And once https://github.com/dotnet/runtime/issues/59629 is approved and we support spans\r\n        public int Count(ReadOnlySpan\u003Cchar\u003E input);\r\n        public static int Count(ReadOnlySpan\u003Cchar\u003E input, string pattern);\r\n        public static int Count(ReadOnlySpan\u003Cchar\u003E input, string pattern, RegexOptions options);\r\n        public static int Count(ReadOnlySpan\u003Cchar\u003E input, string pattern, RegexOptions options, TimeSpan matchTimeout);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 6390000000,
        "Apis": [
          "M:Regex.Count(ReadOnlySpan\u003Cchar\u003E,string,RegexOptions,TimeSpan)",
          "M:Regex.Count(ReadOnlySpan\u003Cchar\u003E,string,RegexOptions)",
          "M:Regex.Count(ReadOnlySpan\u003Cchar\u003E,string)",
          "M:Regex.Count(ReadOnlySpan\u003Cchar\u003E)",
          "M:Regex.Count(string,string,RegexOptions,TimeSpan)",
          "M:Regex.Count(string,string,RegexOptions)",
          "M:Regex.Count(string,string)",
          "M:Regex.Count(string)",
          "T:Regex"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 64248,
          "Title": "RequiredMemberAttribute and NoRequiredMembersAttribute",
          "Author": "333fred",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-25T01:22:42+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/64248",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021504089",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/64248#issuecomment-1021504089",
        "FeedbackMarkdown": "* We\u0027d prefer the name \u0060SatisfiesRequiredMembersAttribute\u0060\r\n    - This gives us the extensibility by adding constructors/properties to allow specifying which members will be initialized/not initialized later, if the language wants to go there.\r\n* If we want serializers to throw an exception unless all members are specified, we should consider exposing a reflection API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.Class |\r\n                    AttributeTargets.Struct |\r\n                    AttributeTargets.Field |\r\n                    AttributeTargets.Property,\r\n                    AllowMultiple=false,\r\n                    Inherited=false)]\r\n    public sealed class RequiredMemberAttribute : Attribute\r\n    {\r\n        public RequiredMemberAttribute();\r\n    }\r\n}\r\nnamespace System.Diagnostics.CodeAnalysis\r\n{\r\n    [AttributeUsage(AttributeTargets.Constructor,\r\n                    AllowMultiple=false,\r\n                    Inherited=false)]\r\n    public sealed class SetsRequiredMembersAttribute : Attribute\r\n    {\r\n        public SetsRequiredMembersAttribute();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12890000000,
        "Apis": [
          "M:RequiredMemberAttribute.RequiredMemberAttribute()",
          "M:SetsRequiredMembersAttribute.SetsRequiredMembersAttribute()",
          "T:RequiredMemberAttribute",
          "T:SetsRequiredMembersAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63648,
          "Title": "Support Metrics UpDownCounter instrument",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-11T21:57:31+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63648",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics.Metric",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021529630",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63648#issuecomment-1021529630",
        "FeedbackMarkdown": "* We considered using generic math to constrain the \u0060T\u0060, to, for example, \u0060INumber\u0060 but the list of types are taken from the OpenTelemetry spec\r\n* \u003E \u0060UpDownCounter\u0060 and \u0060ObservableUpDownCounter\u0060 support only the following generic parameter types: \u0060Byte\u0060, \u0060Int16\u0060, \u0060Int32\u0060, \u0060Int64\u0060, \u0060Single\u0060, \u0060Double\u0060, and \u0060Decimal\u0060.\r\n    - Should we consider supporting unsigned types?\r\n    - Should we drop \u0060byte\u0060?\r\n    - We should strive for consistency with what we shipped before for \u0060Counter\u0060 (if we support \u0060byte\u0060 there, we should do it here too)\r\n    - We can consider adding support for unsigned types later too\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics.Metrics\r\n{\r\n    public sealed class UpDownCounter\u003CT\u003E : Instrument\u003CT\u003E where T : struct\r\n    {\r\n        public void Add(T delta);\r\n        public void Add(T delta, KeyValuePair\u003Cstring, object?\u003E tag);\r\n        public void Add(T delta, KeyValuePair\u003Cstring, object?\u003E tag1, KeyValuePair\u003Cstring, object?\u003E tag2);\r\n        public void Add(T delta, KeyValuePair\u003Cstring, object?\u003E tag1, KeyValuePair\u003Cstring, object?\u003E tag2, KeyValuePair\u003Cstring, object?\u003E tag3);\r\n        public void Add(T delta, ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E tags);\r\n        public void Add(T delta, params KeyValuePair\u003Cstring, object?\u003E[] tags);\r\n        public void Add(T delta, in TagList tagList);\r\n    }\r\n    public sealed class ObservableUpDownCounter\u003CT\u003E : ObservableInstrument\u003CT\u003E where T : struct\r\n    {\r\n        protected override IEnumerable\u003CMeasurement\u003CT\u003E\u003E Observe();\r\n    }\r\n    public partial class Meter : IDisposable\r\n    {\r\n        public UpDownCounter\u003CT\u003E CreateUpDownCounter\u003CT\u003E(string name, string? unit = null, string? description = null) where T : struct ;\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CT\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct;\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CMeasurement\u003CT\u003E\u003E observeValue,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct;\r\n        public ObservableUpDownCounter\u003CT\u003E CreateObservableUpDownCounter\u003CT\u003E(\r\n                            string name,\r\n                            Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E observeValues,\r\n                            string? unit = null,\r\n                            string? description = null) where T : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 30350000000,
        "Apis": [
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CIEnumerable\u003CMeasurement\u003CT\u003E\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CMeasurement\u003CT\u003E\u003E,string?,string?)",
          "M:Meter.CreateObservableUpDownCounter\u003CT\u003E(string,Func\u003CT\u003E,string?,string?)",
          "M:Meter.CreateUpDownCounter\u003CT\u003E(string,string?,string?)",
          "M:ObservableUpDownCounter\u003CT\u003E.Observe()",
          "M:UpDownCounter\u003CT\u003E.Add(T,in TagList)",
          "M:UpDownCounter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:UpDownCounter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E,KeyValuePair\u003Cstring, object?\u003E)",
          "M:UpDownCounter\u003CT\u003E.Add(T,KeyValuePair\u003Cstring, object?\u003E)",
          "M:UpDownCounter\u003CT\u003E.Add(T,params KeyValuePair\u003Cstring, object?\u003E[])",
          "M:UpDownCounter\u003CT\u003E.Add(T,ReadOnlySpan\u003CKeyValuePair\u003Cstring, object?\u003E\u003E)",
          "M:UpDownCounter\u003CT\u003E.Add(T)",
          "T:Meter",
          "T:ObservableUpDownCounter\u003CT\u003E",
          "T:UpDownCounter\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 21678,
          "Title": "Add Path.Exists -- to replace inefficient FileExists || DirectoryExists",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2017-05-12T17:36:13+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/21678",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.IO",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "tenet-performance",
              "Color": "c2e0c6",
              "Description": "Performance related issue"
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021543111",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/21678#issuecomment-1021543111",
        "FeedbackMarkdown": "* We considered returning whether it was a file or directory but\r\n    - It seems rarely useful\r\n    - It\u0027s more expensive in case of symlinks\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.IO\r\n{\r\n    public static partial class Path\r\n    {\r\n        // Implementation is logically equivalent to File.Exists(path) || Directory.Exists(path)\r\n        public static bool Exists([NotNullWhenAttribute(true)] string? path);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 48920000000,
        "Apis": [
          "M:Path.Exists(string?)",
          "T:Path"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63714,
          "Title": "Analyzer for \u0060System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute\u0060",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-13T00:22:39+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63714",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "code-analyzer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn analyzer"
            },
            {
              "Name": "code-fixer",
              "Color": "0f46ad",
              "Description": "Marks an issue that suggests a Roslyn code fixer"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-01-25T00:00:00-08:00",
        "FeedbackId": "1021551711",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63714#issuecomment-1021551711",
        "FeedbackMarkdown": "**Category**: Interoperability\r\n\r\n**Severity:**\r\n\r\n* The first half should be \u0060Warning\u0060\r\n    * \u003E \u0060SetLastError\u0060 is set to \u0060true\u0060 on a P/Invoke\r\n    * \u003E \u0060[LCIDConversionAttribute]\u0060 is used on a P/Invoke\r\n    * \u003E A type that is not a C#-unmanaged type is in a P/Invoke signature or the signature of a delegate with the \u0060[UnmanagedFunctionPointer]\u0060 attribute.\r\n    * \u003E A C#-unmanaged type that has any fields with \u0060[StructLayout(LayoutKind.Auto)]\u0060 that is in a P/Invoke signature or the signature of a delegate with the \u0060[UnmanagedFunctionPointer]\u0060 attribute.\r\n* The second half should be \u0060IDE Suggestion\u0060:\r\n    * \u003E When \u0060Marshal.SizeOf\u0060 is used on an unmanaged type. (We could also include a code-fix here to recommend switching to \u0060Unsafe.SizeOf\u0060 or the \u0060sizeof\u0060 keyword)\r\n    * \u003E When \u0060Marshal.OffsetOf\u0060 is used.\r\n    * \u003E When \u0060Marshal.StructureToPtr\u0060 or \u0060Marshal.PtrToStructure\u0060 is used. (We can include code-fixes here to use \u0022unsafe\u0022 code or other unsafe APIs).",
        "TimeCode": 58760000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "hE7KsqWPFlE",
      "StartDateTime": "2022-02-01T11:15:01-08:00",
      "EndDateTime": "2022-02-01T11:57:12-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/hE7KsqWPFlE/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 1534,
          "Title": "Nullable.RefValue, RefValueOrDefault",
          "Author": "nagya",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2020-01-09T18:31:53+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/1534",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-01T00:00:00-08:00",
        "FeedbackId": "1027214141",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/1534#issuecomment-1027214141",
        "FeedbackMarkdown": "* This API might open a pit of failure where the compiler made a copy before passing in the value, thus exposing a ref to the copy, not the original\r\n    - Example: \u0060Nullable.GetValueRefOrDefaultRef(someObj.SomeProp)\u0060\r\n    - We could add an analyzer but it might be very difficult to write an analyzer that fully understands all the places where the compiler makes a copy. However, we might be able to construct an analyzer to checks for known-safe cases, e.g. when passing in locals or fields and warns on everything else or on known unsafe cases. Either way, the analyzer could add value without having to duplicate the logic of the compiler. Another option is force the call site to specify \u0060in\u0060, which is a safe pattern. However, we don\u0027t want to add a global analyzer because that would result in us pushing for a given language use or code style and we don\u0027t believe that\u0027s our role. We could, however, have targeted analyzer for specific APIs. This is something where having a conversion with @dotnet/LDM would be a good idea.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public static partial class Nullable\r\n    {\r\n        public static ref readonly T GetValueRefOrDefaultRef\u003CT\u003E(in T? nullable) where T : struct;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12080000000,
        "Apis": [
          "M:Nullable.GetValueRefOrDefaultRef\u003CT\u003E(in T?)",
          "T:Nullable"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46822,
          "Title": "LibraryImportAttribute for p/invoke source generation",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-11T19:11:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46822",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-01T00:00:00-08:00",
        "FeedbackId": "1027242060",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46822#issuecomment-1027242060",
        "FeedbackMarkdown": "The main thing that came up in discussion is that the string encoding being an open \u0060Type\u0060 parameter is not very good ease-of-use/user-experience.  We probably want something with the convenience of the \u0060CharSet\u0060 enum, but perhaps a new one specific to this use case.  (So this would be a sibling property to the \u0060MarshalStringsUsing\u0060 property, just accelerating the common cases)",
        "TimeCode": 13060000000,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "r4wqWX0kVgA",
      "StartDateTime": "2022-02-08T10:36:54-08:00",
      "EndDateTime": "2022-02-08T12:37:55-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/r4wqWX0kVgA/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 61634,
          "Title": "Improve HostBuilder and WebApplicationBuilder Configuration integration",
          "Author": "halter73",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-11-15T22:49:40+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/61634",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "area-Extensions-Hosting",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-08T00:00:00-08:00",
        "FeedbackId": "1033038101",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/61634#issuecomment-1033038101",
        "FeedbackMarkdown": "* Consider making the constructor-based flow for \u0060HostApplicationBuilder\u0060 the \u0022canonical\u0022 way moving forward\r\n    - That doesn\u0027t mean we should not have the factory methods on \u0060Host\u0060 to aid discoverability for existing code, but it would mean that we think about the constructors not as an advanced thing, but as something that should be usable by itself; e.g. maybe we should have one that takes \u0060string[] args\u0060.\r\n* We\u0027d prefer to drop \u0060Host\u0060 from \u0060HostApplicationBuilder\u0060 but ASP.NET Core already has \u0060IApplicationBuilder\u0060 that wouldn\u0027t be implemented by this type, which would be confusing.\r\n* \u0060HostApplicationBuilder\u0060 doesn\u0027t implement \u0060IHostBuilder\u0060 which means non of the existing methods will work.\r\n    - Based on what @halter73 said, we don\u0027t believe this to be a problem and in fact wouldn\u0027t want this due to mismatches in capabilities.\r\n    - @davidfowl suggested to look at GitHub and see what \u0060UseXxx\u0060 extensions people actually have\r\n* We haven\u0027t really used the host builder pattern outside of web; MAUI has just started. We should validate that the concepts hold water outside of web.\r\n* @davidfowl has concerns that \u0060Build()\u0060 taking the factory might not work\r\n    - Suggestion was to replace that with the other existing pattern \u0060ConfigureContainer\u003CTBuilder\u003E()\u0060\r\n* It was suggested that \u0060HostApplicationBuilderSettings.Configuration\u0060 should be \u0060IConfiguration\u0060 but the idea is that \u0060HostApplicationBuilder\u0060 will be set to that instance if it\u0027s provided, hence it makes more sense to be typed as \u0060ConfigurationManager\u0060.\r\n* We need to figure out how ASP.NET Core will use \u0060HostApplicationBuilder\u0060 will it derive from it or will it wrap it? Based on that we should either make this type sealed or inheritable.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Hosting\r\n{\r\n     public static partial class Host\r\n     {\r\n        public static HostApplicationBuilder CreateApplicationBuilder();\r\n        public static HostApplicationBuilder CreateApplicationBuilder(string[] args);\r\n        public static IHostBuilder CreateDefaultBuilder();\r\n        public static IHostBuilder CreateDefaultBuilder(string[] args);\r\n    }\r\n    public sealed class HostApplicationBuilder\r\n    {\r\n        public HostApplicationBuilder();\r\n        public HostApplicationBuilder(string[] args);\r\n        public HostApplicationBuilder(HostApplicationBuilderSettings settings);\r\n        public ConfigurationManager Configuration { get; }\r\n        public IHostEnvironment Environment { get; }\r\n        public ILoggingBuilder Logging { get; }\r\n        public IServiceCollection Services { get; }\r\n        public IHost Build();\r\n        public void ConfigureContainer\u003CTBuilder\u003E(IServiceProviderFactory\u003CTBuilder\u003E factory, Action\u003CTBuilder\u003E? configure = null) where TBuilder : notnull;\r\n    }\r\n    public sealed class HostApplicationBuilderSettings\r\n    {\r\n        public HostApplicationBuilderSettings();\r\n        public string ApplicationName { get; set; }\r\n        public string[] Args { get; set; }\r\n        public string ContentRootPath { get; set; }\r\n        public bool DisableDefaults { get; set; }\r\n        public string EnvironmentName { get; set; }\r\n        public ConfigurationManager Configuration { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:Host.CreateApplicationBuilder()",
          "M:Host.CreateApplicationBuilder(string[])",
          "M:Host.CreateDefaultBuilder()",
          "M:Host.CreateDefaultBuilder(string[])",
          "M:HostApplicationBuilder.Build()",
          "M:HostApplicationBuilder.ConfigureContainer\u003CTBuilder\u003E(IServiceProviderFactory\u003CTBuilder\u003E,Action\u003CTBuilder\u003E?)",
          "M:HostApplicationBuilder.HostApplicationBuilder()",
          "M:HostApplicationBuilder.HostApplicationBuilder(HostApplicationBuilderSettings)",
          "M:HostApplicationBuilder.HostApplicationBuilder(string[])",
          "M:HostApplicationBuilderSettings.HostApplicationBuilderSettings()",
          "P:HostApplicationBuilder.Configuration",
          "P:HostApplicationBuilder.Environment",
          "P:HostApplicationBuilder.Logging",
          "P:HostApplicationBuilder.Services",
          "P:HostApplicationBuilderSettings.ApplicationName",
          "P:HostApplicationBuilderSettings.Args",
          "P:HostApplicationBuilderSettings.Configuration",
          "P:HostApplicationBuilderSettings.ContentRootPath",
          "P:HostApplicationBuilderSettings.DisableDefaults",
          "P:HostApplicationBuilderSettings.EnvironmentName",
          "T:Host",
          "T:HostApplicationBuilder",
          "T:HostApplicationBuilderSettings"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": null,
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 59629,
          "Title": "Augment Regex extensibility point for better perf and span-based matching",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-09-27T03:39:48+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/59629",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.RegularExpressions",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-15T00:00:00-08:00",
        "FeedbackId": "1040624509",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/59629#issuecomment-1040624509",
        "FeedbackMarkdown": "Looks good as proposed\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Text.RegularExpressions\r\n{\r\n    public class RegexRunner\r\n    {\r\n-        protected abstract bool FindFirstChar();\r\n-        protected abstract void Go();\r\n-        protected abstract void InitTrackCount();\r\n\u002B        protected virtual bool FindFirstChar() =\u003E throw new NotImplementedException(); //default implementation\r\n\u002B        protected virtual void Go() =\u003E throw new NotImplementedException(); //default implementation\r\n\u002B        protected virtual void InitTrackCount() =\u003E return 0; //default implementation\r\n\r\n\u002B        protected virtual void Scan(ReadOnlySpan\u003Cchar\u003E text);\r\n\r\n    }\r\n    public class Regex\r\n    {\r\n\u002B        public bool IsMatch(ReadOnlySpan\u003Cchar\u003E input);\r\n\u002B        public static bool IsMatch(ReadOnlySpan\u003Cchar\u003E input, string pattern);\r\n\u002B        public static bool IsMatch(ReadOnlySpan\u003Cchar\u003E input, string pattern, RegexOptions options);\r\n\u002B        public static bool IsMatch(ReadOnlySpan\u003Cchar\u003E input, string pattern, RegexOptions options, TimeSpan matchTimeout);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 63652,
          "Title": "Samplers should be allowed to modify tracestate",
          "Author": "tarekgh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-01-11T22:20:22+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/63652",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-15T00:00:00-08:00",
        "FeedbackId": "1040656160",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/63652#issuecomment-1040656160",
        "FeedbackMarkdown": "If the new property is declared as get\u002Binit then the C# \u0060with\u0060 syntax will allow for the easy copy-and-set, which can be written back through the ref to accomplish the current scenario.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace System.Diagnostics\r\n{\r\n    public readonly struct ActivityCreationOptions\u003CT\u003E\r\n    {\r\n\u002B        public string? TraceState { get; init; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060C#\r\n    listener.Sample = (ref ActivityCreationOptions\u003CActivityContext\u003E activityOptions) =\u003E\r\n    {\r\n        activityOptions = activityOptions with { TraceState = \u0022rojo=00f067aa0ba902b7\u0022 };\r\n        return ActivitySamplingResult.AllDataAndRecorded;\r\n    };\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": []
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46822,
          "Title": "LibraryImportAttribute for p/invoke source generation",
          "Author": "AaronRobinsonMSFT",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-11T19:11:55+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46822",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-15T00:00:00-08:00",
        "FeedbackId": "1040703073",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46822#issuecomment-1040703073",
        "FeedbackMarkdown": "We renamed the MarshalStringsUsing property to StringMarshallingCustomType, and renamed the 0 value of StringMarshalling from \u0060None\u0060 to \u0060Custom\u0060 to better describe the relationship of the two properties.  Otherwise, looks good as proposed.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Specifies how strings should be marshalled\r\n    /// \u003C/summary\u003E\r\n    public enum StringMarshalling\r\n    {\r\n        Custom = 0,\r\n        Utf8,   // UTF-8\r\n        Utf16,  // UTF-16, machine-endian\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Attribute used to indicate a Source Generator should create a function for marshaling\r\n    /// arguments instead of relying on the CLR to generate an IL Stub at runtime.\r\n    /// \u003C/summary\u003E\r\n    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]\r\n    public sealed class LibraryImportAttribute : Attribute\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Constructor.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022libraryName\u0022\u003EName of the library containing the import\u003C/param\u003E\r\n        public LibraryImportAttribute(string libraryName);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Library to load.\r\n        /// \u003C/summary\u003E\r\n        public string LibraryName { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicates the name or ordinal of the entry point to be called.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Csee cref=\u0022System.Runtime.InteropServices.DllImportAttribute.EntryPoint\u0022/\u003E\r\n        public string? EntryPoint { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicates how to marshal string parameters to the method.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If this field is specified, \u003Csee cref=\u0022StringMarshallingCustomType\u0022 /\u003E must not be specified.\r\n        /// \u003C/remarks\u003E\r\n        public StringMarshalling StringMarshalling { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicates how to marshal string parameters to the method.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If this field is specified, \u003Csee cref=\u0022StringMarshalling\u0022 /\u003E must not be specified.\r\n        /// The type should be one that conforms to usage with the attributes:\r\n        /// \u003Csee cref=\u0022System.Runtime.InteropServices.MarshalUsingAttribute\u0022/\u003E\r\n        /// \u003Csee cref=\u0022System.Runtime.InteropServices.NativeMarshallingAttribute\u0022/\u003E\r\n        /// \u003C/remarks\u003E\r\n        public Type? StringMarshallingCustomType { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicates whether the callee sents an error (SetLastError on Windows or errorno\r\n        /// on other platforms) before returning from the attributed method.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Csee cref=\u0022System.Runtime.InteropServices.DllImportAttribute.SetLastError\u0022/\u003E\r\n        public bool SetLastError { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:StringMarshalling.Custom",
          "F:StringMarshalling.Utf16",
          "F:StringMarshalling.Utf8",
          "M:LibraryImportAttribute.LibraryImportAttribute(string)",
          "P:LibraryImportAttribute.EntryPoint",
          "P:LibraryImportAttribute.LibraryName",
          "P:LibraryImportAttribute.SetLastError",
          "P:LibraryImportAttribute.StringMarshalling",
          "P:LibraryImportAttribute.StringMarshallingCustomType",
          "T:LibraryImportAttribute",
          "T:StringMarshalling"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46838,
          "Title": "Attributes and Analyzer Diagnostics to support custom struct marshalling in the DllImport Source Generator",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-11T23:22:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46838",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-02-15T00:00:00-08:00",
        "FeedbackId": "1040749264",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46838#issuecomment-1040749264",
        "FeedbackMarkdown": "We started discussing this, and ran out of time.\r\n\r\nThe main points:\r\n* Some of the behavior that\u0027s described in the shape of a Marshaller type feels like it could/should be described on an attribute applied to the Marshaller (attribute TBD).\r\n* The collection marshaller and the item marshaller seem to have gotten out of sync on some of the names (when they have the same concept), and they should align one way or the other.",
        "TimeCode": 0,
        "Apis": []
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "5PprVe5nX9U",
      "StartDateTime": "2022-03-01T10:06:03-08:00",
      "EndDateTime": "2022-03-01T12:07:56-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/5PprVe5nX9U/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 46838,
          "Title": "Attributes and Analyzer Diagnostics to support custom struct marshalling in the DllImport Source Generator",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-01-11T23:22:57+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/46838",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-01T00:00:00-08:00",
        "FeedbackId": "1055795416",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/46838#issuecomment-1055795416",
        "FeedbackMarkdown": "* We changed all of the properties in the \u0022shapes\u0022 to be methods, and made up names that made sense with that conversion.\r\n* ElementIndirectionLevel =\u003E ElementIndirectionDepth for clarity on if 0 is the collection type (yes) or the element type (no).\r\n* We dropped RequiresStackBuffer\r\n* We renamed CustomTypeMarshallerKind.SpanCollection to CustomTypeMarshallerKind.LinearCollection to avoid a misunderstanding of \u0022a collection of spans\u0022\r\n* We discussed adding a CustomTypeMarshallerDirection/CustomTypeMarshallerFeatures flags enum to help be declarative on what sub-shape is desired\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Indicates the default marshalling when the attributed type is used in source-generated interop.\r\n    /// \u003C/summary\u003E\r\n    [AttributeUsage(AttributeTargets.Struct | AttributeTargets.Class | AttributeTargets.Type | AttributeTargets.Delegate)]\r\n    public sealed class NativeMarshallingAttribute : Attribute\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022NativeMarshallingAttribute\u0022/\u003E\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022nativeType\u0022\u003EType that should be used when marshalling the attributed type. The type must not require marshalling.\u003C/param\u003E\r\n        public NativeMarshallingAttribute(Type nativeType) {}\r\n    }\r\n\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Indicates the marshalling to use in source-generated interop.\r\n    /// \u003C/summary\u003E\r\n    [AttributeUsage(AttributeTargets.Parameter | AttributeTargets.ReturnValue, AllowMultiple = true)]\r\n    public sealed class MarshalUsingAttribute : Attribute\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022MarshalUsingAttribute\u0022/\u003E\r\n        /// \u003C/summary\u003E\r\n        public MarshalUsingAttribute() {}\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Initializes a new instance of the \u003Csee cref=\u0022MarshalUsingAttribute\u0022/\u003E\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022nativeType\u0022\u003EType that should be used when marshalling the attributed parameter or field. The type must not require marshalling.\u003C/param\u003E\r\n        public MarshalUsingAttribute(Type nativeType) {}\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Type that should be used when marshalling the attributed parameter, field or, when ElementIndirectionLevel is specified, collection element on the attributed item.\r\n        /// \u003C/summary\u003E\r\n        public Type? NativeType { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Name of the parameter that contains the number of native collection elements. A value of \u003Csee cref=\u0022ReturnsCountValue\u0022/\u003E indicates the return value of the p/invoke should be used.\r\n        /// \u003C/summary\u003E\r\n        public string CountElementName { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Number of elements in the native collection.\r\n        /// \u003C/summary\u003E\r\n        public int ConstantElementCount { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The degree of indirection in a collection to which this attribute should apply.\r\n        /// \u003C/summary\u003E\r\n        public int ElementIndirectionDepth { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// When returned by \u003Csee cref=\u0022CountElementName\u0022 /\u003E, indicates the return value of the p/invoke should be used as the count.\r\n        /// \u003C/summary\u003E\r\n        public const string ReturnsCountValue = \u0022return-value\u0022;\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Indicates this type is a marshaller type to be used in source-generated interop.\r\n    /// \u003C/summary\u003E\r\n    [AttributeUsage(AttributeTargets.Struct)]\r\n    public sealed class CustomTypeMarshallerAttribute : Attribute\r\n    {\r\n        public CustomTypeMarshallerAttribute(Type managedType, CustomTypeMarshallerKind marshallerKind = CustomTypeMarshallerKind.Value)\r\n        {\r\n            ManagedType = managedType;\r\n            MarshallerKind = marshallerKind;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The managed type that the attributed type is a marshaller for.\r\n        /// \u003C/summary\u003E\r\n        public Type ManagedType { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The expected shape of this marshaller type\r\n        /// \u003C/summary\u003E\r\n        public CustomTypeMarshallerKind MarshallerKind { get; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The size of the caller-allocated buffer in scenarios where using caller-allocated buffer is support.\r\n        /// \u003C/summary\u003E\r\n        public int BufferSize { get; set; }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// This type is used as a placeholder for the first generic parameter when generic parameters cannot be used\r\n        /// to identify the managed type (i.e. when the marshaller type is generic over T and the managed type is T[])\r\n        /// \u003C/summary\u003E\r\n        public struct GenericPlaceholder\r\n        {\r\n        }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// The kind (or shape) of the custom marshaller type.\r\n    /// \u003C/summary\u003E\r\n    public enum CustomTypeMarshallerKind\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// This marshaller represents marshalling a single value.\r\n        /// \u003C/summary\u003E\r\n        Value,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// This marshaller represents marshalling a Span-like collection of values\r\n        /// \u003C/summary\u003E\r\n        LinearCollection,\r\n    }\r\n}\r\n\u0060\u0060\u0060\u0060\r\n\r\nAnd for the shapes:\r\n\r\n\u0060\u0060\u0060C#\r\n// Shape for Value kind\r\n[CustomTypeMarshaller(typeof(ManagedType))]\r\npublic struct Marshaller\r\n{\r\n    // Support for marshalling from managed to native.\r\n    // Required if ToManaged() is not defined.\r\n    // May be omitted if marshalling from managed to native is not required.\r\n    public Marshaller(ManagedType managed) {}\r\n\r\n    // Optional.\r\n    // Support for marshalling from managed to native using a caller-allocated buffer\r\n    // Requires the BufferSize field to be set on the CustomTypeMarshaller attribute.\r\n    public Marshaller(ManagedType managed, Span\u003Cbyte\u003E buffer) {}\r\n\r\n    // Support for marshalling from native to managed.\r\n    // Required if constructor taking TManaged is not defined.\r\n    // May be omitted if marshalling from native to managed is not required.\r\n    public ManagedType ToManaged() {}\r\n\r\n    // Optional.\r\n    // If defined, the return value will be passed to native instead of the Marshaller itself\r\n    // NativeType must not require marshalling\r\n    public NativeType ToNativeValue();\r\n\r\n    // Optional\r\n    // If defined, will be called when marshalling from native to managed.\r\n    // NativeType must not require marshalling, and must match ToNativeValue (if it exists)\r\n    public void FromNativeValue(NativeType nativeValue);\r\n\r\n    // Optional.\r\n    // If defined and ToNativeValue or FromNativeValue is defined, will be called before Value property getter and its return value will be pinned\r\n    public ref NativeType GetPinnableReference() {}\r\n\r\n    // Optional.\r\n    // Release native resources.\r\n    public void FreeNative() {}\r\n}\r\n\r\n[CustomTypeMarshaller(typeof(GenericCollection\u003C\u003E), CustomTypeMarshallerKind.SpanCollection)]\r\npublic struct GenericContiguousCollectionMarshallerImpl\u003CT\u003E\r\n{\r\n    // Support for marshalling from native to managed.\r\n    // May be omitted if marshalling from native to managed is not required.\r\n    public GenericContiguousCollectionMarshallerImpl(int nativeSizeOfElement);\r\n\r\n    // Support for marshalling from managed to native.\r\n    // May be omitted if marshalling from managed to native is not required.\r\n    public GenericContiguousCollectionMarshallerImpl(GenericCollection\u003CT\u003E collection, int nativeSizeOfElement);\r\n\r\n    // Optional.\r\n    // Support for marshalling from managed to native using a caller-allocated buffer\r\n    // Requires the BufferSize field to be set on the CustomTypeMarshaller attribute.\r\n    public GenericContiguousCollectionMarshallerImpl(GenericCollection\u003CT\u003E collection, Span\u003Cbyte\u003E buffer, int nativeSizeOfElement);\r\n\r\n\r\n    public Span\u003CManagedType\u003E GetManagedValuesDestination(int length);\r\n    public ReadOnlySpan\u003CManagedType\u003E GetManagedValuesSource();\r\n\r\n    public ReadOnlySpan\u003Cbyte\u003E GetNativeValuesSource(int length);\r\n    public Span\u003Cbyte\u003E GetNativeValuesDestination();\r\n\r\n    // Required.\r\n    // NativeType must not require marshalling\r\n    public NativeType ToNativeValue();\r\n\r\n    // Required.\r\n    // NativeType must not require marshalling, and must match ToNativeValue (if it exists)\r\n    public void FromNativeValue(NativeType nativeValue);\r\n\r\n    // Support for marshalling from native to managed.\r\n    // Required if constructor taking TManaged is not defined.\r\n    // May be omitted if marshalling from native to managed is not required.\r\n    public ManagedType ToManaged() {}\r\n\r\n    // Optional.\r\n    // If defined and ToNativeValue or FromNativeValue is defined, will be called before Value property getter and its return value will be pinned\r\n    public ref NativeType GetPinnableReference() {}\r\n\r\n    // Optional.\r\n    // Release native resources.\r\n    public void FreeNative() {}\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "F:CustomTypeMarshallerKind.LinearCollection",
          "F:CustomTypeMarshallerKind.Value",
          "F:MarshalUsingAttribute.ReturnsCountValue",
          "M:CustomTypeMarshallerAttribute.CustomTypeMarshallerAttribute(Type,CustomTypeMarshallerKind)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.FreeNative()",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.FromNativeValue(NativeType)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GenericContiguousCollectionMarshallerImpl(GenericCollection\u003CT\u003E,int)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GenericContiguousCollectionMarshallerImpl(GenericCollection\u003CT\u003E,Span\u003Cbyte\u003E,int)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GenericContiguousCollectionMarshallerImpl(int)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GetManagedValuesDestination(int)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GetManagedValuesSource()",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GetNativeValuesDestination()",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GetNativeValuesSource(int)",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.GetPinnableReference()",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.ToManaged()",
          "M:GenericContiguousCollectionMarshallerImpl\u003CT\u003E.ToNativeValue()",
          "M:Marshaller.FreeNative()",
          "M:Marshaller.FromNativeValue(NativeType)",
          "M:Marshaller.GetPinnableReference()",
          "M:Marshaller.Marshaller(ManagedType,Span\u003Cbyte\u003E)",
          "M:Marshaller.Marshaller(ManagedType)",
          "M:Marshaller.ToManaged()",
          "M:Marshaller.ToNativeValue()",
          "M:MarshalUsingAttribute.MarshalUsingAttribute()",
          "M:MarshalUsingAttribute.MarshalUsingAttribute(Type)",
          "M:NativeMarshallingAttribute.NativeMarshallingAttribute(Type)",
          "P:CustomTypeMarshallerAttribute.BufferSize",
          "P:CustomTypeMarshallerAttribute.ManagedType",
          "P:CustomTypeMarshallerAttribute.MarshallerKind",
          "P:MarshalUsingAttribute.ConstantElementCount",
          "P:MarshalUsingAttribute.CountElementName",
          "P:MarshalUsingAttribute.ElementIndirectionDepth",
          "P:MarshalUsingAttribute.NativeType",
          "T:CustomTypeMarshallerAttribute",
          "T:CustomTypeMarshallerAttribute.GenericPlaceholder",
          "T:CustomTypeMarshallerKind",
          "T:GenericContiguousCollectionMarshallerImpl\u003CT\u003E",
          "T:Marshaller",
          "T:MarshalUsingAttribute",
          "T:NativeMarshallingAttribute"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50406,
          "Title": "Let consumers of MemoryCache access metrics",
          "Author": "maryamariyan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-30T07:14:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50406",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-Extensions-Caching",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-01T00:00:00-08:00",
        "FeedbackId": "1055813163",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50406#issuecomment-1055813163",
        "FeedbackMarkdown": "* We changed the extension method to an instance method (not virtual at this time)\r\n* We changed MemoryCacheStatistics to readonly with get\u002Binit\r\n* We renamed the properties on MemoryCacheStatistics to reduce redundancy, and then to enhance clarity.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Caching.Memory\r\n{\r\n    public partial class MemoryCache\r\n    {\r\n        public MemoryCacheStatistics GetCurrentStatistics() { throw null; }\r\n    }\r\n\r\n    public partial readonly struct MemoryCacheStatistics\r\n    {\r\n        public long TotalRequests { get; init; } \r\n        public long TotalHits { get; init; }\r\n        public long CurrentEntryCount { get; init; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 59360000000,
        "Apis": [
          "M:MemoryCache.GetCurrentStatistics()",
          "P:MemoryCacheStatistics.CurrentEntryCount",
          "P:MemoryCacheStatistics.TotalHits",
          "P:MemoryCacheStatistics.TotalRequests",
          "T:MemoryCache",
          "T:MemoryCacheStatistics"
        ]
      }
    ]
  },
  {
    "RepositoryGroup": "",
    "Video": {
      "Id": "0nixAM-u2Fw",
      "StartDateTime": "2022-03-08T10:02:03-08:00",
      "EndDateTime": "2022-03-08T11:51:20-08:00",
      "Title": "GitHub Quick Reviews",
      "ThumbnailUrl": "https://i.ytimg.com/vi/0nixAM-u2Fw/mqdefault.jpg"
    },
    "Items": [
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 50406,
          "Title": "Let consumers of MemoryCache access metrics",
          "Author": "maryamariyan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-03-30T07:14:01+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/50406",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "feature-request",
              "Color": "c5def5",
              "Description": ""
            },
            {
              "Name": "area-Extensions-Caching",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062073606",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/50406#issuecomment-1062073606",
        "FeedbackMarkdown": "* We should wait until we have evidence that anyone needs them on the interface\r\n* If there is, then we\u0027d prefer a pattern like \u0060IMemoryCache2 : IMemoryCache\u0060 such that we always have a latest version that has all the features, rather than a permutation of all possible implementations. DIMs would be another approach.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Caching.Memory\r\n{\r\n    // interface IMemoryCacheHasStats\r\n    // {\r\n    //     MemoryCacheStatistics GetCurrentStatistics();\r\n    // }   \r\n    public partial class MemoryCache /* : IMemoryCacheHasStats */\r\n    {\r\n        public MemoryCacheStatistics GetCurrentStatistics();\r\n    }\r\n    public partial readonly struct MemoryCacheStatistics\r\n    {\r\n        public long TotalRequests { get; init; }\r\n        public long TotalHits { get; init; }\r\n        public long CurrentEntryCount { get; init; }\r\n        public long? CurrentSize { get; init; }\r\n    }    \r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 0,
        "Apis": [
          "M:MemoryCache.GetCurrentStatistics()",
          "P:MemoryCacheStatistics.CurrentEntryCount",
          "P:MemoryCacheStatistics.CurrentSize",
          "P:MemoryCacheStatistics.TotalHits",
          "P:MemoryCacheStatistics.TotalRequests",
          "T:MemoryCache",
          "T:MemoryCacheStatistics"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 66121,
          "Title": "Specify supported custom type marshalling features on CustomTypeMarshallerAttribute",
          "Author": "jkoritzinsky",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-03-02T23:41:45+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/66121",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime.InteropServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "blocking",
              "Color": "b60205",
              "Description": "Marks issues that we want to fast track in order to unblock other important work"
            },
            {
              "Name": "source-generator",
              "Color": "3988A9",
              "Description": "Indicates an issue with a source generator feature"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062084220",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/66121#issuecomment-1062084220",
        "FeedbackMarkdown": "* We should add a zero-value for \u0060CustomTypeMarshallerDirection\u0060 such that default initialized values have an associated member. We should call it \u0060None\u0060 and simply reject this as invalid for \u0060CustomTypeMarshallerAttribute.Direction\u0060. We should hide it.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    public partial class CustomTypeMarshallerAttribute : Attribute\r\n    {\r\n        public CustomTypeMarshallerDirection Direction { get; set; } = CustomTypeMarshallerDirection.Ref;\r\n        public CustomTypeMarshallerFeatures Features { get; set; }\r\n    }\r\n    [Flags]\r\n    public enum CustomTypeMarshallerDirection\r\n    {\r\n        [EditorBrowsable(EditorBrowsableState.Never)]\r\n        None = 0x0,\r\n        In = 0x1,\r\n        Out = 0x2,\r\n        Ref = CustomTypeMarshallerDirection.In | CustomTypeMarshallerDirection.Out\r\n    }\r\n    [Flags]\r\n    public enum CustomTypeMarshallerFeatures\r\n    {\r\n        None = 0x0,\r\n        UnmanagedResources = 0x1,\r\n        CallerAllocatedBuffer = 0x2,\r\n        TwoStageMarshalling = 0x4,\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 12920000000,
        "Apis": [
          "F:CustomTypeMarshallerDirection.In",
          "F:CustomTypeMarshallerDirection.None",
          "F:CustomTypeMarshallerDirection.Out",
          "F:CustomTypeMarshallerDirection.Ref",
          "F:CustomTypeMarshallerFeatures.CallerAllocatedBuffer",
          "F:CustomTypeMarshallerFeatures.None",
          "F:CustomTypeMarshallerFeatures.TwoStageMarshalling",
          "F:CustomTypeMarshallerFeatures.UnmanagedResources",
          "P:CustomTypeMarshallerAttribute.Direction",
          "P:CustomTypeMarshallerAttribute.Features",
          "T:CustomTypeMarshallerAttribute",
          "T:CustomTypeMarshallerDirection",
          "T:CustomTypeMarshallerFeatures"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 48615,
          "Title": "Add blittable Color to System.Numerics",
          "Author": "JeremyKuhne",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-02-22T19:35:29+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/48615",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Numerics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062091679",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/48615#issuecomment-1062091679",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nusing System;\r\n\r\nnamespace System.Drawing\r\n{\r\n    partial struct Color : IEquatable\u003CColor\u003E\r\n    {\r\n        public static Color FromArgb(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n        public static implicit operator Color(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n\r\n        // ToNumericsArgb? ToArgbNumerics?\r\n        public System.Numerics.Colors.Argb\u003Cbyte\u003E ToArgbValue();\r\n        public static explicit operator System.Numerics.Colors.Argb\u003Cbyte\u003E(in Color color);\r\n    }\r\n}\r\n\r\n// WPF\r\nnamespace System.Windows.Media\r\n{\r\n    public struct Color : IEquatable\u003CColor\u003E, IFormattable\r\n    {\r\n        public static Color FromArgb(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n        public static implicit operator Color(System.Numerics.Colors.Argb\u003Cbyte\u003E argb);\r\n        public static Color FromArgb(System.Numerics.Colors.Argb\u003Cfloat\u003E argb);\r\n        public static implicit operator Color(System.Numerics.Colors.Argb\u003Cfloat\u003E argb);\r\n\r\n        public System.Numerics.Colors.Argb\u003Cbyte\u003E ToArgbValue();\r\n        public static explicit operator System.Numerics.Colors.Argb\u003Cbyte\u003E(in Color color);\r\n        public System.Numerics.Colors.Argb\u003Cfloat\u003E ToArgbValue();\r\n        public static explicit operator System.Numerics.Colors.Argb\u003Cfloat\u003E(in Color color);\r\n    }\r\n}\r\n\r\nnamespace System.Numerics.Colors\r\n{\r\n    public static class Argb\r\n    {\r\n        public static Argb\u003Cbyte\u003E CreateBigEndian(uint color);\r\n        public static Argb\u003Cbyte\u003E CreateLittleEndian(uint color);\r\n        public static uint ToUInt32LittleEndian(this Argb\u003Cbyte\u003E color);\r\n        public static uint ToUInt32BigEndian(this Argb\u003Cbyte\u003E color);\r\n    }\r\n    public readonly struct Argb\u003CT\u003E : IEquatable\u003CArgb\u003CT\u003E\u003E, IFormattable, ISpanFormattable where T : struct\r\n    {\r\n        public T A { get; }\r\n        public T R { get; }\r\n        public T G { get; }\r\n        public T B { get; }\r\n\r\n        public Argb(T a, T r, T g, T b);\r\n        public Argb(ReadOnlySpan\u003CT\u003E values);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n        public bool Equals(Argb\u003CT\u003E other);\r\n        public string ToString(string format, IFormatProvider formatProvider);\r\n        // whatever ISpanFormattable says\r\n        public Rgba\u003CT\u003E ToRgba();\r\n    }\r\n    public static class Rgba\r\n    {\r\n        public static Rgba\u003Cbyte\u003E CreateLittleEndian(uint color);\r\n        public static Rgba\u003Cbyte\u003E CreateBigEndian(uint color);\r\n        public static uint ToUInt32LittleEndian(this Rgba\u003Cbyte\u003E color);\r\n        public static uint ToUInt32BigEndian(this Rgba\u003Cbyte\u003E color);\r\n    }\r\n    public readonly struct Rgba\u003CT\u003E : IEquatable\u003CRgba\u003CT\u003E\u003E, IFormattable, ISpanFormattable where T : struct\r\n    {\r\n        public T R { get; }\r\n        public T G { get; }\r\n        public T B { get; }\r\n        public T A { get; }\r\n\r\n        public Rgba(T r, T g, T b, T a);\r\n        public Rgba(ReadOnlySpan\u003CT\u003E values);\r\n        public void CopyTo(Span\u003CT\u003E destination);\r\n        public bool Equals(Rgba\u003CT\u003E other);\r\n        public string ToString(string format, IFormatProvider formatProvider);\r\n        // whatever ISpanFormattable says\r\n        public Argb\u003CT\u003E ToArgb();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 20410000000,
        "Apis": [
          "M:Argb.CreateBigEndian(uint)",
          "M:Argb.CreateLittleEndian(uint)",
          "M:Argb.ToUInt32BigEndian(this Argb\u003Cbyte\u003E)",
          "M:Argb.ToUInt32LittleEndian(this Argb\u003Cbyte\u003E)",
          "M:Argb\u003CT\u003E.Argb(ReadOnlySpan\u003CT\u003E)",
          "M:Argb\u003CT\u003E.Argb(T,T,T,T)",
          "M:Argb\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:Argb\u003CT\u003E.Equals(Argb\u003CT\u003E)",
          "M:Argb\u003CT\u003E.ToRgba()",
          "M:Argb\u003CT\u003E.ToString(string,IFormatProvider)",
          "M:Color.explicit(in Color)",
          "M:Color.FromArgb(System.Numerics.Colors.Argb\u003Cbyte\u003E)",
          "M:Color.FromArgb(System.Numerics.Colors.Argb\u003Cfloat\u003E)",
          "M:Color.implicit(System.Numerics.Colors.Argb\u003Cbyte\u003E)",
          "M:Color.implicit(System.Numerics.Colors.Argb\u003Cfloat\u003E)",
          "M:Color.ToArgbValue()",
          "M:Rgba.CreateBigEndian(uint)",
          "M:Rgba.CreateLittleEndian(uint)",
          "M:Rgba.ToUInt32BigEndian(this Rgba\u003Cbyte\u003E)",
          "M:Rgba.ToUInt32LittleEndian(this Rgba\u003Cbyte\u003E)",
          "M:Rgba\u003CT\u003E.CopyTo(Span\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Equals(Rgba\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Rgba(ReadOnlySpan\u003CT\u003E)",
          "M:Rgba\u003CT\u003E.Rgba(T,T,T,T)",
          "M:Rgba\u003CT\u003E.ToArgb()",
          "M:Rgba\u003CT\u003E.ToString(string,IFormatProvider)",
          "P:Argb\u003CT\u003E.A",
          "P:Argb\u003CT\u003E.B",
          "P:Argb\u003CT\u003E.G",
          "P:Argb\u003CT\u003E.R",
          "P:Rgba\u003CT\u003E.A",
          "P:Rgba\u003CT\u003E.B",
          "P:Rgba\u003CT\u003E.G",
          "P:Rgba\u003CT\u003E.R",
          "T:Argb",
          "T:Argb\u003CT\u003E",
          "T:Color",
          "T:Rgba",
          "T:Rgba\u003CT\u003E"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 56592,
          "Title": "Additional JsonNode functionality",
          "Author": "steveharter",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-07-29T23:46:58+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/56592",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Text.Json",
              "Color": "d4c5f9",
              "Description": ""
            },
            {
              "Name": "User Story",
              "Color": "0e8a16",
              "Description": "A single user-facing feature. Can be grouped under an epic."
            },
            {
              "Name": "Priority:2",
              "Color": "e99695",
              "Description": "Work that is important, but not critical for the release"
            },
            {
              "Name": "Cost:M",
              "Color": "00AA00",
              "Description": "Work that requires one engineer up to 2 weeks"
            },
            {
              "Name": "Team:Libraries",
              "Color": "e5a0d3",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062114464",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/56592#issuecomment-1062114464",
        "FeedbackMarkdown": "* \u0060XDocument\u0060 uses a copy constructor on \u0060XElement\u0060 instead, but \u0060DeepClone\u0060 seems more discoverable.\r\n* \u0060IsRoot\u0060 doesn\u0027t seem that value, as the canonical way would be to check \u0060node.Parent is null\u0060.\r\n* \u0060GetValueKind()\u0060 should try to return a better value than \u0060Undefined\u0060 such that modifications of primitives doesn\u0027t result in unexpected changes from, say, \u0060Number\u0060 to \u0060Undefined\u0060.\r\n    - Do we need the options? We might need it for settings such as the one that serializes numbers as strings\r\n* In \u0060XDocument\u0060 the \u0060Replace\u0060 method is called \u0060ReplaceWith\u0060, which makes it a bit more clear that it\u0027s in-place semantics\r\n* We need to define what \u0060JsonArray.GetValues\u003Cobject\u003E\u0060 will do. Return the \u0060JsonNode\u0060 seems the most viable, because boxing the underlying primitives wouldn\u0027t be well-defined.\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Text.Json.Nodes\r\n{\r\n     public partial class JsonNode\r\n     {\r\n        public JsonNode DeepClone();\r\n        public static bool DeepEquals(JsonNode? node1, JsonNode? node2);\r\n        public JsonValueKind GetValueKind(JsonSerializerOptions options = null);\r\n        public string GetPropertyName();\r\n        public int GetElementIndex();\r\n        public void ReplaceWith\u003CT\u003E(T value);\r\n    }\r\n    public partial class JsonArray\r\n    {\r\n        public IEnumerable\u003CT\u003E GetValues\u003CT\u003E();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 26190000000,
        "Apis": [
          "M:JsonArray.GetValues\u003CT\u003E()",
          "M:JsonNode.DeepClone()",
          "M:JsonNode.DeepEquals(JsonNode?,JsonNode?)",
          "M:JsonNode.GetElementIndex()",
          "M:JsonNode.GetPropertyName()",
          "M:JsonNode.GetValueKind(JsonSerializerOptions)",
          "M:JsonNode.ReplaceWith\u003CT\u003E(T)",
          "T:JsonArray",
          "T:JsonNode"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 65858,
          "Title": "Stopwatch.GetElapsedTime",
          "Author": "stephentoub",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-02-24T19:06:17+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/65858",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "enhancement",
              "Color": "200dff",
              "Description": "Product code improvement that does NOT require public API changes/additions"
            },
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Diagnostics",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062118260",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/65858#issuecomment-1062118260",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Stopwatch\r\n    {\r\n        public static TimeSpan GetElapsedTime(long startingTimestamp);\r\n        public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 43490000000,
        "Apis": [
          "M:Stopwatch.GetElapsedTime(long,long)",
          "M:Stopwatch.GetElapsedTime(long)",
          "T:Stopwatch"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 65660,
          "Title": "Activity.HasRemoteParent (and problematic docs for Activity.Parent)",
          "Author": "Oberon00",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-02-21T11:08:19+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/65660",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "in-pr",
              "Color": "4da6bc",
              "Description": "there is an active PR which will close this issue when it is merged"
            },
            {
              "Name": "area-System.Diagnostics.Activity",
              "Color": "d4c5f9",
              "Description": ""
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062124497",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/65660#issuecomment-1062124497",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Diagnostics\r\n{\r\n    public partial class Activity\r\n    {\r\n        public bool HasRemoteParent { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 46370000000,
        "Apis": [
          "P:Activity.HasRemoteParent",
          "T:Activity"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 57881,
          "Title": "Add method TryFormat for Enum",
          "Author": "leandromoh",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2021-08-21T16:38:21+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/57881",
          "Milestone": "Future",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062129899",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/57881#issuecomment-1062129899",
        "FeedbackMarkdown": "* Makes sense\r\n* It seems also desirable to also implement \u0060ISpanFormattable\u0060, this would be useful, for example, for interpolated strings\r\n    - This would require work in the JIT to avoid the boxing overhead\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial class Enum : ISpanFormattable\r\n    {\r\n        public bool TryFormat(Span\u003Cchar\u003E destination, out int charsWritten, ReadOnlySpan\u003Cchar\u003E format, IFormatProvider? provider);\r\n\r\n        public static bool TryFormat\u003CTEnum\u003E(TEnum value, Span\u003Cchar\u003E destination, out int charsWritten) \r\n             where TEnum : struct, Enum;\r\n     }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 50880000000,
        "Apis": [
          "M:Enum.TryFormat(Span\u003Cchar\u003E,out int,ReadOnlySpan\u003Cchar\u003E,IFormatProvider?)",
          "M:Enum.TryFormat\u003CTEnum\u003E(TEnum,Span\u003Cchar\u003E,out int)",
          "T:Enum"
        ]
      },
      {
        "Decision": 0,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 65074,
          "Title": "Scale property for the decimal datatype",
          "Author": "vanillajonathan",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-02-09T13:26:33+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/65074",
          "Milestone": "(None)",
          "Labels": [
            {
              "Name": "api-approved",
              "Color": "159818",
              "Description": "API was approved in API review, it can be implemented"
            },
            {
              "Name": "area-System.Runtime",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "up-for-grabs",
              "Color": "23ef90",
              "Description": "Good issue for external contributors"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062132366",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/65074#issuecomment-1062132366",
        "FeedbackMarkdown": "* Looks good as proposed\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System\r\n{\r\n    public partial struct Decimal\r\n    {\r\n        public byte Scale { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 54750000000,
        "Apis": [
          "P:Decimal.Scale",
          "T:Decimal"
        ]
      },
      {
        "Decision": 1,
        "Issue": {
          "Owner": "dotnet",
          "Repo": "runtime",
          "Id": 66167,
          "Title": "System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute",
          "Author": "333fred",
          "Assignees": [],
          "MarkedReadyForReviewBy": null,
          "AreaOwners": [],
          "CreatedAt": "2022-03-03T22:40:20+00:00",
          "Url": "https://github.com/dotnet/runtime/issues/66167",
          "Milestone": "7.0.0",
          "Labels": [
            {
              "Name": "area-System.Runtime.CompilerServices",
              "Color": "d4c5f9",
              "Description": null
            },
            {
              "Name": "api-ready-for-review",
              "Color": "5319e7",
              "Description": "API is ready for review, it is NOT ready for implementation"
            }
          ],
          "Reviewers": []
        },
        "FeedbackDateTime": "2022-03-08T00:00:00-08:00",
        "FeedbackId": "1062143475",
        "FeedbackAuthor": "terrajobst",
        "FeedbackUrl": "https://github.com/dotnet/runtime/issues/66167#issuecomment-1062143475",
        "FeedbackMarkdown": "* Makes sense\r\n* It\u0027s not clear why the \u0060Language\u0060 property exists; it seems it\u0027s geared towards expressing optionality. But if other languages later also support the feature, would they emit the attribute using their language or would the emit with the name of the first language?\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    [AttributeUsage(AttributeTargets.All, AllowMultiple = true, Inherited = false)]\r\n    public sealed class CompilerFeatureRequiredAttribute : Attribute\r\n    {\r\n        public CompilerFeatureRequiredAttribute(string featureName)\r\n        {\r\n            FeatureName = featureName;\r\n        }\r\n        public string FeatureName { get; }\r\n        public string? Language { get; init; }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "TimeCode": 57140000000,
        "Apis": [
          "M:CompilerFeatureRequiredAttribute.CompilerFeatureRequiredAttribute(string)",
          "P:CompilerFeatureRequiredAttribute.FeatureName",
          "P:CompilerFeatureRequiredAttribute.Language",
          "T:CompilerFeatureRequiredAttribute"
        ]
      }
    ]
  }
]